# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod dashcore { use crate as example_nested ; pub mod internal_macros { use crate as example_nested ; } # [cfg (feature = "serde")] pub mod serde_utils { use crate as example_nested ; } pub mod network { use crate as example_nested ; pub mod constants { use crate as example_nested ; } # [cfg (feature = "std")] pub mod address { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_blockdata { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_headers2 { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_network { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_qrinfo { use crate as example_nested ; # [doc = "FFI-representation of the [`QuorumSnapshot`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_network_message_qrinfo_QuorumSnapshot { pub skip_list_mode : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode , pub active_quorum_members : * mut crate :: fermented :: generics :: Vec_bool , pub skip_list : * mut crate :: fermented :: generics :: Vec_i32 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> dashcore :: network :: message_qrinfo :: QuorumSnapshot { let ffi_ref = & * ffi ; dashcore :: network :: message_qrinfo :: QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_from (ffi_ref . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionFrom < Vec < i32 > >> :: ffi_from (ffi_ref . skip_list) } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: QuorumSnapshot) -> * const dashcore_network_message_qrinfo_QuorumSnapshot { ferment :: boxed (dashcore_network_message_qrinfo_QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_to (obj . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionTo < Vec < i32 > >> :: ffi_to (obj . skip_list) }) } } impl Drop for dashcore_network_message_qrinfo_QuorumSnapshot { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . skip_list_mode) ; ferment :: unbox_any (ffi_ref . active_quorum_members) ; ferment :: unbox_any (ffi_ref . skip_list) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_ctor (skip_list_mode : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode , active_quorum_members : * mut crate :: fermented :: generics :: Vec_bool , skip_list : * mut crate :: fermented :: generics :: Vec_i32) -> * mut dashcore_network_message_qrinfo_QuorumSnapshot { ferment :: boxed (dashcore_network_message_qrinfo_QuorumSnapshot { skip_list_mode , active_quorum_members , skip_list }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_destroy (ffi : * mut dashcore_network_message_qrinfo_QuorumSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_skip_list_mode (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_active_quorum_members (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . active_quorum_members } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_skip_list (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_i32 { (* obj) . skip_list } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_skip_list_mode (obj : * mut dashcore_network_message_qrinfo_QuorumSnapshot , value : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode) { (* obj) . skip_list_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_active_quorum_members (obj : * mut dashcore_network_message_qrinfo_QuorumSnapshot , value : * mut crate :: fermented :: generics :: Vec_bool) { (* obj) . active_quorum_members = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_skip_list (obj : * mut dashcore_network_message_qrinfo_QuorumSnapshot , value : * mut crate :: fermented :: generics :: Vec_i32) { (* obj) . skip_list = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MNSkipListMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_network_message_qrinfo_MNSkipListMode { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_MNSkipListMode) -> dashcore :: network :: message_qrinfo :: MNSkipListMode { let ffi_ref = & * ffi ; match ffi_ref { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: MNSkipListMode) -> * const dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (match obj { dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping => dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst => dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept => dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll => dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_network_message_qrinfo_MNSkipListMode { fn drop (& mut self) { unsafe { match self { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_NoSkipping_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipFirst_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipExcept_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipAll_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_destroy (ffi : * mut dashcore_network_message_qrinfo_MNSkipListMode) { ferment :: unbox_any (ffi) ; } } # [cfg (feature = "std")] pub mod message_sml { use crate as example_nested ; } } pub mod address { use crate as example_nested ; } pub mod amount { use crate as example_nested ; # [cfg (feature = "serde")] pub mod serde { use crate as example_nested ; pub mod as_sat { use crate as example_nested ; } pub mod as_btc { use crate as example_nested ; } } } pub mod base58 { use crate as example_nested ; } pub mod bip152 { use crate as example_nested ; } pub mod bip158 { use crate as example_nested ; } pub mod blockdata { use crate as example_nested ; pub mod block { use crate as example_nested ; } pub mod constants { use crate as example_nested ; } pub mod fee_rate { use crate as example_nested ; } pub mod locktime { use crate as example_nested ; pub mod absolute { use crate as example_nested ; } pub mod relative { use crate as example_nested ; } } pub mod opcodes { use crate as example_nested ; } pub mod script { use crate as example_nested ; pub mod owned { use crate as example_nested ; # [doc = "FFI-representation of the [`ScriptBuf`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_script_owned_ScriptBuf (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_script_owned_ScriptBuf) -> dashcore :: blockdata :: script :: owned :: ScriptBuf { let ffi_ref = & * ffi ; dashcore :: blockdata :: script :: owned :: ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: script :: owned :: ScriptBuf) -> * const dashcore_blockdata_script_owned_ScriptBuf { ferment :: boxed (dashcore_blockdata_script_owned_ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_blockdata_script_owned_ScriptBuf { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dashcore_blockdata_script_owned_ScriptBuf { ferment :: boxed (dashcore_blockdata_script_owned_ScriptBuf (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_destroy (ffi : * mut dashcore_blockdata_script_owned_ScriptBuf) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_get_0 (obj : * const dashcore_blockdata_script_owned_ScriptBuf) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_set_0 (obj : * mut dashcore_blockdata_script_owned_ScriptBuf , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . 0 = value ; } } pub mod push_bytes { use crate as example_nested ; } } pub mod transaction { use crate as example_nested ; pub mod outpoint { use crate as example_nested ; # [doc = "FFI-representation of the [`OutPoint`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_outpoint_OutPoint { pub txid : * mut Txid , pub vout : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> dashcore :: blockdata :: transaction :: outpoint :: OutPoint { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: outpoint :: OutPoint { txid : std :: ptr :: read (ffi_ref . txid) , vout : ffi_ref . vout } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: outpoint :: OutPoint) -> * const dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (dashcore_blockdata_transaction_outpoint_OutPoint { txid : ferment :: boxed (obj . txid) , vout : obj . vout }) } } impl Drop for dashcore_blockdata_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . txid) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_ctor (txid : * mut Txid , vout : u32) -> * mut dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (dashcore_blockdata_transaction_outpoint_OutPoint { txid , vout }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_destroy (ffi : * mut dashcore_blockdata_transaction_outpoint_OutPoint) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_get_txid (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> * mut Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_get_vout (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> u32 { (* obj) . vout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_set_txid (obj : * mut dashcore_blockdata_transaction_outpoint_OutPoint , value : * mut Txid) { (* obj) . txid = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_set_vout (obj : * mut dashcore_blockdata_transaction_outpoint_OutPoint , value : u32) { (* obj) . vout = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::new`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_new (txid : * mut Txid , vout : u32) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: new (std :: ptr :: read (txid) , vout) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::null`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_null () -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: null () ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::outpoint::OutPoint::is_null`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_is_null (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint) -> bool { let obj = dashcore :: blockdata :: transaction :: outpoint :: OutPoint :: is_null (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (self_)))) ; obj } } pub mod special_transaction { use crate as example_nested ; pub mod asset_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { pub version : u8 , pub credit_outputs : * mut crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { version : ffi_ref . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . credit_outputs) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { version : obj . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: transaction :: txout :: TxOut > >> :: ffi_to (obj . credit_outputs) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . credit_outputs) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_ctor (version : u8 , credit_outputs : * mut crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut) -> * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { version , credit_outputs }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_get_credit_outputs (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> * mut crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut { (* obj) . credit_outputs } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload , value : u8) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_set_credit_outputs (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload , value : * mut crate :: fermented :: generics :: Vec_dashcore_transaction_txout_TxOut) { (* obj) . credit_outputs = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::asset_lock::AssetLockPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_from (self_)))) ; obj } } pub mod asset_unlock { use crate as example_nested ; pub mod qualified_asset_unlock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { pub base : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , pub request_info : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , pub quorum_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_from (ffi_ref . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_from (ffi_ref . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . quorum_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_to (obj . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_to (obj . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . quorum_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . request_info) ; ferment :: unbox_any (ffi_ref . quorum_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_ctor (base : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , request_info : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , quorum_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { base , request_info , quorum_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_base (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_request_info (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { (* obj) . request_info } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_quorum_sig (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . quorum_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_base (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_request_info (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) { (* obj) . request_info = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_quorum_sig (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . quorum_sig = value ; } } pub mod request_info { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockRequestInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { pub request_height : u32 , pub quorum_hash : * mut QuorumHash } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { request_height : ffi_ref . request_height , quorum_hash : std :: ptr :: read (ffi_ref . quorum_hash) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { request_height : obj . request_height , quorum_hash : ferment :: boxed (obj . quorum_hash) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . quorum_hash) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_ctor (request_height : u32 , quorum_hash : * mut QuorumHash) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { request_height , quorum_hash }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_get_request_height (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> u32 { (* obj) . request_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_get_quorum_hash (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> * mut QuorumHash { (* obj) . quorum_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_set_request_height (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , value : u32) { (* obj) . request_height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_set_quorum_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , value : * mut QuorumHash) { (* obj) . quorum_hash = value ; } } pub mod unqualified_asset_unlock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockBasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { pub version : u8 , pub index : u64 , pub fee : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { version : ffi_ref . version , index : ffi_ref . index , fee : ffi_ref . fee } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { version : obj . version , index : obj . index , fee : obj . fee }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_ctor (version : u8 , index : u64 , fee : u32) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { version , index , fee }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_index (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u64 { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_fee (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u32 { (* obj) . fee } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , value : u8) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_index (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , value : u64) { (* obj) . index = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_fee (obj : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , value : u32) { (* obj) . fee = value ; } } } pub mod coinbase { use crate as example_nested ; # [doc = "FFI-representation of the [`CoinbasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { pub version : u16 , pub height : u32 , pub merkle_root_masternode_list : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , pub merkle_root_quorums : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , pub best_cl_height : * mut u32 , pub best_cl_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub asset_locked_amount : * mut u64 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { version : ffi_ref . version , height : ffi_ref . height , merkle_root_masternode_list : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_from (ffi_ref . merkle_root_masternode_list) , merkle_root_quorums : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_from (ffi_ref . merkle_root_quorums) , best_cl_height : ferment :: from_opt_primitive (ffi_ref . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from_opt (ffi_ref . best_cl_signature) , asset_locked_amount : ferment :: from_opt_primitive (ffi_ref . asset_locked_amount) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload) -> * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { version : obj . version , height : obj . height , merkle_root_masternode_list : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_to (obj . merkle_root_masternode_list) , merkle_root_quorums : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_to (obj . merkle_root_quorums) , best_cl_height : ferment :: to_opt_primitive (obj . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to_opt (obj . best_cl_signature) , asset_locked_amount : ferment :: to_opt_primitive (obj . asset_locked_amount) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . merkle_root_masternode_list) ; ferment :: unbox_any (ffi_ref . merkle_root_quorums) ; ferment :: unbox_any_opt (ffi_ref . best_cl_height) ; ferment :: unbox_any_opt (ffi_ref . best_cl_signature) ; ferment :: unbox_any_opt (ffi_ref . asset_locked_amount) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_ctor (version : u16 , height : u32 , merkle_root_masternode_list : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , merkle_root_quorums : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , best_cl_height : * mut u32 , best_cl_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , asset_locked_amount : * mut u64) -> * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { version , height , merkle_root_masternode_list , merkle_root_quorums , best_cl_height , best_cl_signature , asset_locked_amount }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_height (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_merkle_root_masternode_list (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . merkle_root_masternode_list } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_merkle_root_quorums (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . merkle_root_quorums } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_best_cl_height (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u32 { (* obj) . best_cl_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_best_cl_signature (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . best_cl_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_asset_locked_amount (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u64 { (* obj) . asset_locked_amount } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_height (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : u32) { (* obj) . height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_merkle_root_masternode_list (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList) { (* obj) . merkle_root_masternode_list = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_merkle_root_quorums (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums) { (* obj) . merkle_root_quorums = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_best_cl_height (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : * mut u32) { (* obj) . best_cl_height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_best_cl_signature (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . best_cl_signature = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_asset_locked_amount (obj : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload , value : * mut u64) { (* obj) . asset_locked_amount = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::coinbase::CoinbasePayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_from (self_)))) ; obj } } pub mod mnhf_signal { use crate as example_nested ; } pub mod provider_registration { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProviderMasternodeType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { Regular = 0 , HighPerformance = 1 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular => dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: Regular , dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance => dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: HighPerformance } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType) -> * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: Regular => dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular , dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType :: HighPerformance => dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular => { } , dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType_Regular_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: Regular { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType_HighPerformance_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType :: HighPerformance { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`ProviderRegistrationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { pub version : u16 , pub masternode_type : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType , pub masternode_mode : u16 , pub collateral_outpoint : * mut dashcore :: transaction :: outpoint :: OutPoint , pub service_address : * mut std :: net :: SocketAddr , pub owner_key_hash : * mut PubkeyHash , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut PubkeyHash , pub operator_reward : u16 , pub script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub signature : * mut crate :: fermented :: generics :: Vec_u8 , pub platform_node_id : * mut PubkeyHash , pub platform_p2p_port : * mut u16 , pub platform_http_port : * mut u16 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { version : ffi_ref . version , masternode_type : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType >> :: ffi_from (ffi_ref . masternode_type) , masternode_mode : ffi_ref . masternode_mode , collateral_outpoint : std :: ptr :: read (ffi_ref . collateral_outpoint) , service_address : std :: ptr :: read (ffi_ref . service_address) , owner_key_hash : std :: ptr :: read (ffi_ref . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : std :: ptr :: read (ffi_ref . voting_key_hash) , operator_reward : ffi_ref . operator_reward , script_payout : std :: ptr :: read (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . signature) , platform_node_id : ferment :: from_opt_opaque (ffi_ref . platform_node_id) , platform_p2p_port : ferment :: from_opt_primitive (ffi_ref . platform_p2p_port) , platform_http_port : ferment :: from_opt_primitive (ffi_ref . platform_http_port) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { version : obj . version , masternode_type : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType >> :: ffi_to (obj . masternode_type) , masternode_mode : obj . masternode_mode , collateral_outpoint : ferment :: boxed (obj . collateral_outpoint) , service_address : ferment :: boxed (obj . service_address) , owner_key_hash : ferment :: boxed (obj . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : ferment :: boxed (obj . voting_key_hash) , operator_reward : obj . operator_reward , script_payout : ferment :: boxed (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . signature) , platform_node_id : ferment :: to_opt_primitive (obj . platform_node_id) , platform_p2p_port : ferment :: to_opt_primitive (obj . platform_p2p_port) , platform_http_port : ferment :: to_opt_primitive (obj . platform_http_port) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . masternode_type) ; ; ferment :: unbox_any (ffi_ref . collateral_outpoint) ; ferment :: unbox_any (ffi_ref . service_address) ; ferment :: unbox_any (ffi_ref . owner_key_hash) ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any_opt (ffi_ref . platform_node_id) ; ferment :: unbox_any_opt (ffi_ref . platform_p2p_port) ; ferment :: unbox_any_opt (ffi_ref . platform_http_port) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_ctor (version : u16 , masternode_type : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType , masternode_mode : u16 , collateral_outpoint : * mut dashcore :: transaction :: outpoint :: OutPoint , service_address : * mut std :: net :: SocketAddr , owner_key_hash : * mut PubkeyHash , operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , voting_key_hash : * mut PubkeyHash , operator_reward : u16 , script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , signature : * mut crate :: fermented :: generics :: Vec_u8 , platform_node_id : * mut PubkeyHash , platform_p2p_port : * mut u16 , platform_http_port : * mut u16) -> * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { version , masternode_type , masternode_mode , collateral_outpoint , service_address , owner_key_hash , operator_public_key , voting_key_hash , operator_reward , script_payout , inputs_hash , signature , platform_node_id , platform_p2p_port , platform_http_port }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_masternode_type (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType { (* obj) . masternode_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_masternode_mode (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . masternode_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_collateral_outpoint (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut dashcore :: transaction :: outpoint :: OutPoint { (* obj) . collateral_outpoint } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_service_address (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut std :: net :: SocketAddr { (* obj) . service_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_owner_key_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut PubkeyHash { (* obj) . owner_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_operator_public_key (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_voting_key_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_operator_reward (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . operator_reward } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_script_payout (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_inputs_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_signature (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_node_id (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut PubkeyHash { (* obj) . platform_node_id } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_p2p_port (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_p2p_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_http_port (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_http_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_masternode_type (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderMasternodeType) { (* obj) . masternode_type = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_masternode_mode (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : u16) { (* obj) . masternode_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_collateral_outpoint (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut dashcore :: transaction :: outpoint :: OutPoint) { (* obj) . collateral_outpoint = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_service_address (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut std :: net :: SocketAddr) { (* obj) . service_address = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_owner_key_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut PubkeyHash) { (* obj) . owner_key_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_operator_public_key (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey) { (* obj) . operator_public_key = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_voting_key_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut PubkeyHash) { (* obj) . voting_key_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_operator_reward (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : u16) { (* obj) . operator_reward = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_script_payout (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . script_payout = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_inputs_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash) { (* obj) . inputs_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_signature (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . signature = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_node_id (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut PubkeyHash) { (* obj) . platform_node_id = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_p2p_port (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut u16) { (* obj) . platform_p2p_port = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_http_port (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload , value : * mut u16) { (* obj) . platform_http_port = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_registration::ProviderRegistrationPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_registrar { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateRegistrarPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { pub version : u16 , pub pro_tx_hash : * mut Txid , pub provider_mode : u16 , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut PubkeyHash , pub script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub payload_sig : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { version : ffi_ref . version , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , provider_mode : ffi_ref . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : std :: ptr :: read (ffi_ref . voting_key_hash) , script_payout : std :: ptr :: read (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { version : obj . version , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , provider_mode : obj . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : ferment :: boxed (obj . voting_key_hash) , script_payout : ferment :: boxed (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_ctor (version : u16 , pro_tx_hash : * mut Txid , provider_mode : u16 , operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , voting_key_hash : * mut PubkeyHash , script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , payload_sig : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { version , pro_tx_hash , provider_mode , operator_public_key , voting_key_hash , script_payout , inputs_hash , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_pro_tx_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_provider_mode (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . provider_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_operator_public_key (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_voting_key_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_script_payout (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_inputs_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_payload_sig (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_pro_tx_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut Txid) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_provider_mode (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : u16) { (* obj) . provider_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_operator_public_key (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey) { (* obj) . operator_public_key = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_voting_key_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut PubkeyHash) { (* obj) . voting_key_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_script_payout (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . script_payout = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_inputs_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash) { (* obj) . inputs_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_payload_sig (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . payload_sig = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_registrar::ProviderUpdateRegistrarPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_revocation { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateRevocationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { pub version : u16 , pub pro_tx_hash : * mut Txid , pub reason : u16 , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { version : ffi_ref . version , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , reason : ffi_ref . reason , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { version : obj . version , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , reason : obj . reason , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_ctor (version : u16 , pro_tx_hash : * mut Txid , reason : u16 , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { version , pro_tx_hash , reason , inputs_hash , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_pro_tx_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_reason (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . reason } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_inputs_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_payload_sig (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_pro_tx_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload , value : * mut Txid) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_reason (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload , value : u16) { (* obj) . reason = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_inputs_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash) { (* obj) . inputs_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_payload_sig (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . payload_sig = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_revocation::ProviderUpdateRevocationPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_from (self_)))) ; obj } } pub mod provider_update_service { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateServicePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { pub version : u16 , pub mn_type : * mut u16 , pub pro_tx_hash : * mut Txid , pub ip_address : * mut [u8 ; 16] , pub port : u16 , pub script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub platform_node_id : * mut crate :: fermented :: generics :: Arr_u8_20 , pub platform_p2p_port : * mut u16 , pub platform_http_port : * mut u16 , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { version : ffi_ref . version , mn_type : ferment :: from_opt_primitive (ffi_ref . mn_type) , pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (ffi_ref . ip_address) , port : ffi_ref . port , script_payout : std :: ptr :: read (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , platform_node_id : < crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from_opt (ffi_ref . platform_node_id) , platform_p2p_port : ferment :: from_opt_primitive (ffi_ref . platform_p2p_port) , platform_http_port : ferment :: from_opt_primitive (ffi_ref . platform_http_port) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { version : obj . version , mn_type : ferment :: to_opt_primitive (obj . mn_type) , pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (obj . ip_address) , port : obj . port , script_payout : ferment :: boxed (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , platform_node_id : < crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to_opt (obj . platform_node_id) , platform_p2p_port : ferment :: to_opt_primitive (obj . platform_p2p_port) , platform_http_port : ferment :: to_opt_primitive (obj . platform_http_port) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any_opt (ffi_ref . mn_type) ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any_opt (ffi_ref . ip_address) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any_opt (ffi_ref . platform_node_id) ; ferment :: unbox_any_opt (ffi_ref . platform_p2p_port) ; ferment :: unbox_any_opt (ffi_ref . platform_http_port) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_ctor (version : u16 , mn_type : * mut u16 , pro_tx_hash : * mut Txid , ip_address : * mut [u8 ; 16] , port : u16 , script_payout : * mut dashcore :: blockdata :: script :: ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , platform_node_id : * mut crate :: fermented :: generics :: Arr_u8_20 , platform_p2p_port : * mut u16 , platform_http_port : * mut u16 , payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { version , mn_type , pro_tx_hash , ip_address , port , script_payout , inputs_hash , platform_node_id , platform_p2p_port , platform_http_port , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_mn_type (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut u16 { (* obj) . mn_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_pro_tx_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_ip_address (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut [u8 ; 16] { (* obj) . ip_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_port (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_script_payout (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_inputs_hash (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_platform_node_id (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: generics :: Arr_u8_20 { (* obj) . platform_node_id } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_platform_p2p_port (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut u16 { (* obj) . platform_p2p_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_platform_http_port (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut u16 { (* obj) . platform_http_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_payload_sig (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_mn_type (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut u16) { (* obj) . mn_type = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_pro_tx_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut Txid) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_ip_address (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut [u8 ; 16]) { (* obj) . ip_address = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_port (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : u16) { (* obj) . port = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_script_payout (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . script_payout = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_inputs_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash) { (* obj) . inputs_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_platform_node_id (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut crate :: fermented :: generics :: Arr_u8_20) { (* obj) . platform_node_id = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_platform_p2p_port (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut u16) { (* obj) . platform_p2p_port = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_platform_http_port (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut u16) { (* obj) . platform_http_port = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_payload_sig (obj : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . payload_sig = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::provider_update_service::ProviderUpdateServicePayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_from (self_)))) ; obj } } pub mod quorum_commitment { use crate as example_nested ; # [doc = "FFI-representation of the [`QuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { pub version : u16 , pub llmq_type : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub quorum_hash : * mut QuorumHash , pub quorum_index : * mut i16 , pub signers : * mut crate :: fermented :: generics :: Vec_bool , pub valid_members : * mut crate :: fermented :: generics :: Vec_bool , pub quorum_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub quorum_vvec_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash , pub threshold_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub all_commitment_aggregated_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { version : ffi_ref . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (ffi_ref . llmq_type) , quorum_hash : std :: ptr :: read (ffi_ref . quorum_hash) , quorum_index : ferment :: from_opt_primitive (ffi_ref . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . quorum_public_key) , quorum_vvec_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumVVecHash >> :: ffi_from (ffi_ref . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . all_commitment_aggregated_signature) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { version : obj . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj . llmq_type) , quorum_hash : ferment :: boxed (obj . quorum_hash) , quorum_index : ferment :: to_opt_primitive (obj . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . quorum_public_key) , quorum_vvec_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumVVecHash >> :: ffi_to (obj . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . all_commitment_aggregated_signature) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . llmq_type) ; ferment :: unbox_any (ffi_ref . quorum_hash) ; ferment :: unbox_any_opt (ffi_ref . quorum_index) ; ferment :: unbox_any (ffi_ref . signers) ; ferment :: unbox_any (ffi_ref . valid_members) ; ferment :: unbox_any (ffi_ref . quorum_public_key) ; ferment :: unbox_any (ffi_ref . quorum_vvec_hash) ; ferment :: unbox_any (ffi_ref . threshold_sig) ; ferment :: unbox_any (ffi_ref . all_commitment_aggregated_signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_ctor (version : u16 , llmq_type : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , quorum_hash : * mut QuorumHash , quorum_index : * mut i16 , signers : * mut crate :: fermented :: generics :: Vec_bool , valid_members : * mut crate :: fermented :: generics :: Vec_bool , quorum_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , quorum_vvec_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash , threshold_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , all_commitment_aggregated_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { version , llmq_type , quorum_hash , quorum_index , signers , valid_members , quorum_public_key , quorum_vvec_hash , threshold_sig , all_commitment_aggregated_signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_llmq_type (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { (* obj) . llmq_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_hash (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut QuorumHash { (* obj) . quorum_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_index (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut i16 { (* obj) . quorum_index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_signers (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . signers } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_valid_members (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . valid_members } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_public_key (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . quorum_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_vvec_hash (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash { (* obj) . quorum_vvec_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_threshold_sig (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . threshold_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_all_commitment_aggregated_signature (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . all_commitment_aggregated_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_llmq_type (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) { (* obj) . llmq_type = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut QuorumHash) { (* obj) . quorum_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_index (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut i16) { (* obj) . quorum_index = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_signers (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: generics :: Vec_bool) { (* obj) . signers = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_valid_members (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: generics :: Vec_bool) { (* obj) . valid_members = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_public_key (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey) { (* obj) . quorum_public_key = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_vvec_hash (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash) { (* obj) . quorum_vvec_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_threshold_sig (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . threshold_sig = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_all_commitment_aggregated_signature (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . all_commitment_aggregated_signature = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::quorum_commitment::QuorumEntry::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`QuorumCommitmentPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { pub version : u16 , pub height : u32 , pub finalization_commitment : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { version : ffi_ref . version , height : ffi_ref . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (ffi_ref . finalization_commitment) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { version : obj . version , height : obj . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_to (obj . finalization_commitment) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . finalization_commitment) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_ctor (version : u16 , height : u32 , finalization_commitment : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { version , height , finalization_commitment }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_version (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_height (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_finalization_commitment (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { (* obj) . finalization_commitment } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_version (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_height (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload , value : u32) { (* obj) . height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_finalization_commitment (obj : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) { (* obj) . finalization_commitment = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::quorum_commitment::QuorumCommitmentPayload::size`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_size (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload :: size (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_from (self_)))) ; obj } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TransactionPayload`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_TransactionPayload { ProviderRegistrationPayloadType (* mut dashcore :: prelude :: special_transaction) , ProviderUpdateServicePayloadType (* mut dashcore :: prelude :: special_transaction) , ProviderUpdateRegistrarPayloadType (* mut dashcore :: prelude :: special_transaction) , ProviderUpdateRevocationPayloadType (* mut dashcore :: prelude :: special_transaction) , CoinbasePayloadType (* mut dashcore :: prelude :: special_transaction) , QuorumCommitmentPayloadType (* mut dashcore :: prelude :: special_transaction) , MnhfSignalPayloadType (* mut dashcore :: prelude :: special_transaction) , AssetLockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) , AssetUnlockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: MnhfSignalPayloadType (std :: ptr :: read (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload) -> * const dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: MnhfSignalPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (ferment :: boxed (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_TransactionPayload { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderRegistrationPayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateServicePayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateRegistrarPayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateRevocationPayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_CoinbasePayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_QuorumCommitmentPayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_MnhfSignalPayloadType_ctor (o_o_0 : * mut dashcore :: prelude :: special_transaction) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: MnhfSignalPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_AssetLockPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_AssetUnlockPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::TransactionPayload::get_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_get_type (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType { let obj = dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: get_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from (self_)))) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::special_transaction::TransactionPayload::len`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_len (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> usize { let obj = dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: len (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TransactionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_TransactionType { Classic = 0 , ProviderRegistration = 1 , ProviderUpdateService = 2 , ProviderUpdateRegistrar = 3 , ProviderUpdateRevocation = 4 , Coinbase = 5 , QuorumCommitment = 6 , MnhfSignal = 7 , AssetLock = 8 , AssetUnlock = 9 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType > for dashcore_blockdata_transaction_special_transaction_TransactionType { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_TransactionType) -> dashcore :: blockdata :: transaction :: special_transaction :: TransactionType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Classic , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderRegistration , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateService , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRegistrar , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRevocation , dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Coinbase , dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: QuorumCommitment , dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: MnhfSignal , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetLock , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock => dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetUnlock } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType > for dashcore_blockdata_transaction_special_transaction_TransactionType { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: TransactionType) -> * const dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Classic => dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderRegistration => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateService => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRegistrar => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: ProviderUpdateRevocation => dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: Coinbase => dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: QuorumCommitment => dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: MnhfSignal => dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetLock => dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock , dashcore :: blockdata :: transaction :: special_transaction :: TransactionType :: AssetUnlock => dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_TransactionType { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock => { } , dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_Classic_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: Classic { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_ProviderRegistration_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderRegistration { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_ProviderUpdateService_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateService { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_ProviderUpdateRegistrar_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRegistrar { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_ProviderUpdateRevocation_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: ProviderUpdateRevocation { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_Coinbase_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: Coinbase { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_QuorumCommitment_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: QuorumCommitment { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_MnhfSignal_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: MnhfSignal { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_AssetLock_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetLock { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_AssetUnlock_ctor () -> * mut dashcore_blockdata_transaction_special_transaction_TransactionType { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionType :: AssetUnlock { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionType_destroy (ffi : * mut dashcore_blockdata_transaction_special_transaction_TransactionType) { ferment :: unbox_any (ffi) ; } } pub mod txin { use crate as example_nested ; # [doc = "FFI-representation of the [`TxIn`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txin_TxIn { pub previous_output : * mut dashcore :: transaction :: outpoint :: OutPoint , pub script_sig : * mut dashcore :: blockdata :: script :: ScriptBuf , pub sequence : u32 , pub witness : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txin_TxIn) -> dashcore :: blockdata :: transaction :: txin :: TxIn { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txin :: TxIn { previous_output : std :: ptr :: read (ffi_ref . previous_output) , script_sig : std :: ptr :: read (ffi_ref . script_sig) , sequence : ffi_ref . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness >> :: ffi_from (ffi_ref . witness) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txin :: TxIn) -> * const dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (dashcore_blockdata_transaction_txin_TxIn { previous_output : ferment :: boxed (obj . previous_output) , script_sig : ferment :: boxed (obj . script_sig) , sequence : obj . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness >> :: ffi_to (obj . witness) }) } } impl Drop for dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . previous_output) ; ferment :: unbox_any (ffi_ref . script_sig) ; ; ferment :: unbox_any (ffi_ref . witness) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_ctor (previous_output : * mut dashcore :: transaction :: outpoint :: OutPoint , script_sig : * mut dashcore :: blockdata :: script :: ScriptBuf , sequence : u32 , witness : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness) -> * mut dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (dashcore_blockdata_transaction_txin_TxIn { previous_output , script_sig , sequence , witness }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_destroy (ffi : * mut dashcore_blockdata_transaction_txin_TxIn) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_previous_output (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut dashcore :: transaction :: outpoint :: OutPoint { (* obj) . previous_output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_script_sig (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . script_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_sequence (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> u32 { (* obj) . sequence } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_witness (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness { (* obj) . witness } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_previous_output (obj : * mut dashcore_blockdata_transaction_txin_TxIn , value : * mut dashcore :: transaction :: outpoint :: OutPoint) { (* obj) . previous_output = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_script_sig (obj : * mut dashcore_blockdata_transaction_txin_TxIn , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . script_sig = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_sequence (obj : * mut dashcore_blockdata_transaction_txin_TxIn , value : u32) { (* obj) . sequence = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_witness (obj : * mut dashcore_blockdata_transaction_txin_TxIn , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness) { (* obj) . witness = value ; } } pub mod txout { use crate as example_nested ; # [doc = "FFI-representation of the [`TxOut`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txout_TxOut { pub value : u64 , pub script_pubkey : * mut dashcore :: blockdata :: script :: ScriptBuf } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txout_TxOut) -> dashcore :: blockdata :: transaction :: txout :: TxOut { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txout :: TxOut { value : ffi_ref . value , script_pubkey : std :: ptr :: read (ffi_ref . script_pubkey) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txout :: TxOut) -> * const dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (dashcore_blockdata_transaction_txout_TxOut { value : obj . value , script_pubkey : ferment :: boxed (obj . script_pubkey) }) } } impl Drop for dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . script_pubkey) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_ctor (value : u64 , script_pubkey : * mut dashcore :: blockdata :: script :: ScriptBuf) -> * mut dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (dashcore_blockdata_transaction_txout_TxOut { value , script_pubkey }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_destroy (ffi : * mut dashcore_blockdata_transaction_txout_TxOut) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_get_value (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> u64 { (* obj) . value } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_get_script_pubkey (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . script_pubkey } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_set_value (obj : * mut dashcore_blockdata_transaction_txout_TxOut , value : u64) { (* obj) . value = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_set_script_pubkey (obj : * mut dashcore_blockdata_transaction_txout_TxOut , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . script_pubkey = value ; } } # [doc = "FFI-representation of the [`Transaction`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_Transaction { pub version : u16 , pub lock_time : u32 , pub input : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn , pub output : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut , pub special_transaction_payload : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_Transaction) -> dashcore :: blockdata :: transaction :: Transaction { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: Transaction { version : ffi_ref . version , lock_time : ffi_ref . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_from (ffi_ref . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from_opt (ffi_ref . special_transaction_payload) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: Transaction) -> * const dashcore_blockdata_transaction_Transaction { ferment :: boxed (dashcore_blockdata_transaction_Transaction { version : obj . version , lock_time : obj . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_to (obj . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_to (obj . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_to_opt (obj . special_transaction_payload) }) } } impl Drop for dashcore_blockdata_transaction_Transaction { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . input) ; ferment :: unbox_any (ffi_ref . output) ; ferment :: unbox_any_opt (ffi_ref . special_transaction_payload) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_ctor (version : u16 , lock_time : u32 , input : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn , output : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut , special_transaction_payload : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> * mut dashcore_blockdata_transaction_Transaction { ferment :: boxed (dashcore_blockdata_transaction_Transaction { version , lock_time , input , output , special_transaction_payload }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_destroy (ffi : * mut dashcore_blockdata_transaction_Transaction) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_version (obj : * const dashcore_blockdata_transaction_Transaction) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_lock_time (obj : * const dashcore_blockdata_transaction_Transaction) -> u32 { (* obj) . lock_time } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_input (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn { (* obj) . input } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_output (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut { (* obj) . output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_special_transaction_payload (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload { (* obj) . special_transaction_payload } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_version (obj : * mut dashcore_blockdata_transaction_Transaction , value : u16) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_lock_time (obj : * mut dashcore_blockdata_transaction_Transaction , value : u32) { (* obj) . lock_time = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_input (obj : * mut dashcore_blockdata_transaction_Transaction , value : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn) { (* obj) . input = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_output (obj : * mut dashcore_blockdata_transaction_Transaction , value : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut) { (* obj) . output = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_special_transaction_payload (obj : * mut dashcore_blockdata_transaction_Transaction , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) { (* obj) . special_transaction_payload = value ; } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::txid`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_txid (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> * mut Txid { let obj = dashcore :: blockdata :: transaction :: Transaction :: txid (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::tx_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_tx_type (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType { let obj = dashcore :: blockdata :: transaction :: Transaction :: tx_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionType as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::blockdata::transaction::Transaction::is_coin_base`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_is_coin_base (self_ : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) -> bool { let obj = dashcore :: blockdata :: transaction :: Transaction :: is_coin_base (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (self_)))) ; obj } } pub mod weight { use crate as example_nested ; } pub mod witness { use crate as example_nested ; # [doc = "FFI-representation of the [`Witness`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_witness_Witness { pub content : * mut crate :: fermented :: generics :: Vec_u8 , pub witness_elements : usize , pub indices_start : usize } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_witness_Witness) -> dashcore :: blockdata :: witness :: Witness { let ffi_ref = & * ffi ; dashcore :: blockdata :: witness :: Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . content) , witness_elements : ffi_ref . witness_elements , indices_start : ffi_ref . indices_start } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: witness :: Witness) -> * const dashcore_blockdata_witness_Witness { ferment :: boxed (dashcore_blockdata_witness_Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . content) , witness_elements : obj . witness_elements , indices_start : obj . indices_start }) } } impl Drop for dashcore_blockdata_witness_Witness { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . content) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_ctor (content : * mut crate :: fermented :: generics :: Vec_u8 , witness_elements : usize , indices_start : usize) -> * mut dashcore_blockdata_witness_Witness { ferment :: boxed (dashcore_blockdata_witness_Witness { content , witness_elements , indices_start }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_destroy (ffi : * mut dashcore_blockdata_witness_Witness) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_content (obj : * const dashcore_blockdata_witness_Witness) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . content } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_witness_elements (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . witness_elements } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_indices_start (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . indices_start } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_content (obj : * mut dashcore_blockdata_witness_Witness , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . content = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_witness_elements (obj : * mut dashcore_blockdata_witness_Witness , value : usize) { (* obj) . witness_elements = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_indices_start (obj : * mut dashcore_blockdata_witness_Witness , value : usize) { (* obj) . indices_start = value ; } } } pub mod bloom { use crate as example_nested ; pub mod filter { use crate as example_nested ; } pub mod hash { use crate as example_nested ; } } pub mod consensus { use crate as example_nested ; pub mod encode { use crate as example_nested ; } # [cfg (feature = "serde")] pub mod serde { use crate as example_nested ; pub mod hex { use crate as example_nested ; } } } pub mod bls_sig_utils { use crate as example_nested ; # [doc = "FFI-representation of the [`BLSPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSPublicKey (* mut crate :: fermented :: generics :: Arr_u8_48) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSPublicKey) -> dashcore :: bls_sig_utils :: BLSPublicKey { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionFrom < [u8 ; 48] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSPublicKey) -> * const dashcore_bls_sig_utils_BLSPublicKey { ferment :: boxed (dashcore_bls_sig_utils_BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionTo < [u8 ; 48] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_48) -> * mut dashcore_bls_sig_utils_BLSPublicKey { ferment :: boxed (dashcore_bls_sig_utils_BLSPublicKey (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_destroy (ffi : * mut dashcore_bls_sig_utils_BLSPublicKey) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_get_0 (obj : * const dashcore_bls_sig_utils_BLSPublicKey) -> * mut crate :: fermented :: generics :: Arr_u8_48 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_set_0 (obj : * mut dashcore_bls_sig_utils_BLSPublicKey , value : * mut crate :: fermented :: generics :: Arr_u8_48) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`BLSSignature`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSSignature (* mut crate :: fermented :: generics :: Arr_u8_96) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSSignature) -> dashcore :: bls_sig_utils :: BLSSignature { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionFrom < [u8 ; 96] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSSignature) -> * const dashcore_bls_sig_utils_BLSSignature { ferment :: boxed (dashcore_bls_sig_utils_BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionTo < [u8 ; 96] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSSignature { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_96) -> * mut dashcore_bls_sig_utils_BLSSignature { ferment :: boxed (dashcore_bls_sig_utils_BLSSignature (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_destroy (ffi : * mut dashcore_bls_sig_utils_BLSSignature) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_get_0 (obj : * const dashcore_bls_sig_utils_BLSSignature) -> * mut crate :: fermented :: generics :: Arr_u8_96 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_set_0 (obj : * mut dashcore_bls_sig_utils_BLSSignature , value : * mut crate :: fermented :: generics :: Arr_u8_96) { (* obj) . 0 = value ; } } pub mod crypto { use crate as example_nested ; pub mod key { use crate as example_nested ; } pub mod sighash { use crate as example_nested ; } } pub mod ephemerealdata { use crate as example_nested ; pub mod chain_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`ChainLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_chain_lock_ChainLock { pub block_height : u32 , pub block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> dashcore :: ephemerealdata :: chain_lock :: ChainLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: chain_lock :: ChainLock { block_height : ffi_ref . block_height , block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (ffi_ref . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: chain_lock :: ChainLock) -> * const dashcore_ephemerealdata_chain_lock_ChainLock { ferment :: boxed (dashcore_ephemerealdata_chain_lock_ChainLock { block_height : obj . block_height , block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (obj . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_chain_lock_ChainLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . block_hash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_ctor (block_height : u32 , block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_ephemerealdata_chain_lock_ChainLock { ferment :: boxed (dashcore_ephemerealdata_chain_lock_ChainLock { block_height , block_hash , signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_destroy (ffi : * mut dashcore_ephemerealdata_chain_lock_ChainLock) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_block_height (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> u32 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_block_hash (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_signature (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_block_height (obj : * mut dashcore_ephemerealdata_chain_lock_ChainLock , value : u32) { (* obj) . block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_block_hash (obj : * mut dashcore_ephemerealdata_chain_lock_ChainLock , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) { (* obj) . block_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_signature (obj : * mut dashcore_ephemerealdata_chain_lock_ChainLock , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . signature = value ; } } pub mod instant_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`InstantLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_instant_lock_InstantLock { pub version : u8 , pub inputs : * mut crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint , pub txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub cyclehash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> dashcore :: ephemerealdata :: instant_lock :: InstantLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: instant_lock :: InstantLock { version : ffi_ref . version , inputs : < crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint > >> :: ffi_from (ffi_ref . inputs) , txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . txid) , cyclehash : < example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: CycleHash >> :: ffi_from (ffi_ref . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: instant_lock :: InstantLock) -> * const dashcore_ephemerealdata_instant_lock_InstantLock { ferment :: boxed (dashcore_ephemerealdata_instant_lock_InstantLock { version : obj . version , inputs : < crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint > >> :: ffi_to (obj . inputs) , txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . txid) , cyclehash : < example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash as ferment :: FFIConversionTo < dashcore :: hash_types :: CycleHash >> :: ffi_to (obj . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_instant_lock_InstantLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . inputs) ; ferment :: unbox_any (ffi_ref . txid) ; ferment :: unbox_any (ffi_ref . cyclehash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_ctor (version : u8 , inputs : * mut crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint , txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , cyclehash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash , signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_ephemerealdata_instant_lock_InstantLock { ferment :: boxed (dashcore_ephemerealdata_instant_lock_InstantLock { version , inputs , txid , cyclehash , signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_destroy (ffi : * mut dashcore_ephemerealdata_instant_lock_InstantLock) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_version (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_inputs (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint { (* obj) . inputs } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_txid (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_cyclehash (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash { (* obj) . cyclehash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_signature (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_version (obj : * mut dashcore_ephemerealdata_instant_lock_InstantLock , value : u8) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_inputs (obj : * mut dashcore_ephemerealdata_instant_lock_InstantLock , value : * mut crate :: fermented :: generics :: std_vec_Vec_dashcore_transaction_outpoint_OutPoint) { (* obj) . inputs = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_txid (obj : * mut dashcore_ephemerealdata_instant_lock_InstantLock , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . txid = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_cyclehash (obj : * mut dashcore_ephemerealdata_instant_lock_InstantLock , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash) { (* obj) . cyclehash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_signature (obj : * mut dashcore_ephemerealdata_instant_lock_InstantLock , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { (* obj) . signature = value ; } } } pub mod hash_types { use crate as example_nested ; } pub mod merkle_tree { use crate as example_nested ; pub mod block { use crate as example_nested ; } } pub mod pow { use crate as example_nested ; } pub mod sign_message { use crate as example_nested ; } pub mod signer { use crate as example_nested ; } pub mod sml { use crate as example_nested ; pub mod address { use crate as example_nested ; } pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SmlError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_error_SmlError { BaseBlockNotGenesis (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , BlockHashLookupFailed (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , IncompleteMnListDiff , MissingStartMasternodeList (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , BaseBlockHashMismatch { expected : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , found : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash } , UnknownError , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) , InvalidIndexInSignatureSet (u16) , IncompleteSignatureSet } impl ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_error_SmlError) -> dashcore :: sml :: error :: SmlError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: IncompleteMnListDiff => dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* expected) , found : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* found) } , dashcore_sml_error_SmlError :: UnknownError => dashcore :: sml :: error :: SmlError :: UnknownError , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (* o_0) , dashcore_sml_error_SmlError :: IncompleteSignatureSet => dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet } } } impl ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_to_const (obj : dashcore :: sml :: error :: SmlError) -> * const dashcore_sml_error_SmlError { ferment :: boxed (match obj { dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (o_0) => dashcore_sml_error_SmlError :: BaseBlockNotGenesis (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (o_0) => dashcore_sml_error_SmlError :: BlockHashLookupFailed (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff => dashcore_sml_error_SmlError :: IncompleteMnListDiff , dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (o_0) => dashcore_sml_error_SmlError :: MissingStartMasternodeList (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected , found } => dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (expected) , found : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (found) } , dashcore :: sml :: error :: SmlError :: UnknownError => dashcore_sml_error_SmlError :: UnknownError , dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (o_0) => dashcore_sml_error_SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (o_0) => dashcore_sml_error_SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) , dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet => dashcore_sml_error_SmlError :: IncompleteSignatureSet , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_error_SmlError { fn drop (& mut self) { unsafe { match self { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: IncompleteMnListDiff => { } , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => { ferment :: unbox_any (* expected) ; ; ferment :: unbox_any (* found) ; } , dashcore_sml_error_SmlError :: UnknownError => { } , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => { ; } , dashcore_sml_error_SmlError :: IncompleteSignatureSet => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BaseBlockNotGenesis_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BlockHashLookupFailed_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_IncompleteMnListDiff_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: IncompleteMnListDiff { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_MissingStartMasternodeList_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BaseBlockHashMismatch_ctor (expected : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , found : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_UnknownError_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: UnknownError { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_FeatureNotTurnedOn_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_InvalidIndexInSignatureSet_ctor (o_o_0 : u16) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_IncompleteSignatureSet_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: IncompleteSignatureSet { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_destroy (ffi : * mut dashcore_sml_error_SmlError) { ferment :: unbox_any (ffi) ; } } pub mod llmq_entry_verification { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQEntryVerificationStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { Unknown , Verified , Skipped (* mut dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus) , Invalid (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError) } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) -> dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped (std :: ptr :: read (* o_0)) , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus) -> * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (match obj { dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (ferment :: boxed (o_0)) , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Unknown_ctor () -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Verified_ctor () -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Skipped_ctor (o_o_0 : * mut dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus) -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Invalid_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError) -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_destroy (ffi : * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) { ferment :: unbox_any (ffi) ; } } pub mod llmq_type { use crate as example_nested ; pub mod network { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_type_LLMQType { LlmqtypeUnknown = 0 , Llmqtype50_60 = 1 , Llmqtype400_60 = 2 , Llmqtype400_85 = 3 , Llmqtype100_67 = 4 , Llmqtype60_75 = 5 , Llmqtype25_67 = 6 , LlmqtypeTest = 100 , LlmqtypeDevnet = 101 , LlmqtypeTestV17 = 102 , LlmqtypeTestDIP0024 = 103 , LlmqtypeTestInstantSend = 104 , LlmqtypeDevnetDIP0024 = 105 , LlmqtypeTestnetPlatform = 106 , LlmqtypeDevnetPlatform = 107 } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_type_LLMQType) -> dashcore :: sml :: llmq_type :: LLMQType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_type :: LLMQType) -> * const dashcore_sml_llmq_type_LLMQType { ferment :: boxed (match obj { dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown => dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 => dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_type_LLMQType { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeUnknown_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype50_60_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype400_60_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype400_85_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype100_67_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype60_75_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype25_67_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTest_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnet_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestV17_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestDIP0024_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestInstantSend_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnetDIP0024_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestnetPlatform_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnetPlatform_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_destroy (ffi : * mut dashcore_sml_llmq_type_LLMQType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::index`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_index (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> u8 { let obj = dashcore :: sml :: llmq_type :: LLMQType :: index (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u16`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u16 (index : u16) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u16 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u8`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u8 (index : u8) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u8 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::is_rotating_quorum_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_is_rotating_quorum_type (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> bool { let obj = dashcore :: sml :: llmq_type :: LLMQType :: is_rotating_quorum_type (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_)))) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_cycle_base_height`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_cycle_base_height (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , height : u32) -> u32 { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_cycle_base_height (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , height) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_dkg_window_for_height`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_dkg_window_for_height (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , height : u32) -> * mut dashcore :: sml :: llmq_type :: DKGWindow { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_dkg_window_for_height (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , height) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::get_dkg_windows_in_range`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_get_dkg_windows_in_range (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , start : u32 , end : u32) -> * mut crate :: fermented :: generics :: Vec_dashcore_sml_llmq_type_DKGWindow { let obj = dashcore :: sml :: llmq_type :: LLMQType :: get_dkg_windows_in_range (Box :: leak (Box :: new (< crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (self_))) , start , end) ; < crate :: fermented :: generics :: Vec_dashcore_sml_llmq_type_DKGWindow as ferment :: FFIConversionTo < Vec < dashcore :: sml :: llmq_type :: DKGWindow > >> :: ffi_to (obj) } } pub mod masternode_list { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeList`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_MasternodeList { pub block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , pub known_height : u32 , pub masternode_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , pub llmq_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , pub masternodes : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , pub quorums : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_MasternodeList) -> dashcore :: sml :: masternode_list :: MasternodeList { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list :: MasternodeList { block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (ffi_ref . block_hash) , known_height : ffi_ref . known_height , masternode_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_from_opt (ffi_ref . masternode_merkle_root) , llmq_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_from_opt (ffi_ref . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_from (ffi_ref . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_from (ffi_ref . quorums) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list :: MasternodeList) -> * const dashcore_sml_masternode_list_MasternodeList { ferment :: boxed (dashcore_sml_masternode_list_MasternodeList { block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (obj . block_hash) , known_height : obj . known_height , masternode_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_to_opt (obj . masternode_merkle_root) , llmq_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_to_opt (obj . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_to (obj . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_to (obj . quorums) }) } } impl Drop for dashcore_sml_masternode_list_MasternodeList { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . block_hash) ; ; ferment :: unbox_any_opt (ffi_ref . masternode_merkle_root) ; ferment :: unbox_any_opt (ffi_ref . llmq_merkle_root) ; ferment :: unbox_any (ffi_ref . masternodes) ; ferment :: unbox_any (ffi_ref . quorums) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_ctor (block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , known_height : u32 , masternode_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , llmq_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , masternodes : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , quorums : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut dashcore_sml_masternode_list_MasternodeList { ferment :: boxed (dashcore_sml_masternode_list_MasternodeList { block_hash , known_height , masternode_merkle_root , llmq_merkle_root , masternodes , quorums }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_destroy (ffi : * mut dashcore_sml_masternode_list_MasternodeList) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_block_hash (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_known_height (obj : * const dashcore_sml_masternode_list_MasternodeList) -> u32 { (* obj) . known_height } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_masternode_merkle_root (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . masternode_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_llmq_merkle_root (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . llmq_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_masternodes (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { (* obj) . masternodes } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_quorums (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { (* obj) . quorums } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_block_hash (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) { (* obj) . block_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_known_height (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : u32) { (* obj) . known_height = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_masternode_merkle_root (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList) { (* obj) . masternode_merkle_root = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_llmq_merkle_root (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums) { (* obj) . llmq_merkle_root = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_masternodes (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { (* obj) . masternodes = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_quorums (obj : * mut dashcore_sml_masternode_list_MasternodeList , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { (* obj) . quorums = value ; } } pub mod masternode_list_engine { use crate as example_nested ; # [cfg (feature = "message_verification")] pub mod message_request_verification { use crate as example_nested ; } } pub mod masternode_list_entry { use crate as example_nested ; pub mod qualified_masternode_list_entry { use crate as example_nested ; # [doc = "FFI-representation of the [`QualifiedMasternodeListEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub masternode_list_entry : * mut dashcore :: sml :: masternode_list_entry :: MasternodeListEntry , pub entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash , pub confirmed_hash_hashed_with_pro_reg_tx : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { masternode_list_entry : std :: ptr :: read (ffi_ref . masternode_list_entry) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: Sha256dHash >> :: ffi_from (ffi_ref . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx as ferment :: FFIConversionFrom < dashcore :: hash_types :: ConfirmedHashHashedWithProRegTx >> :: ffi_from_opt (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry) -> * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { masternode_list_entry : ferment :: boxed (obj . masternode_list_entry) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash as ferment :: FFIConversionTo < dashcore :: hash_types :: Sha256dHash >> :: ffi_to (obj . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx as ferment :: FFIConversionTo < dashcore :: hash_types :: ConfirmedHashHashedWithProRegTx >> :: ffi_to_opt (obj . confirmed_hash_hashed_with_pro_reg_tx) }) } } impl Drop for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . masternode_list_entry) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_ctor (masternode_list_entry : * mut dashcore :: sml :: masternode_list_entry :: MasternodeListEntry , entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash , confirmed_hash_hashed_with_pro_reg_tx : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx) -> * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { masternode_list_entry , entry_hash , confirmed_hash_hashed_with_pro_reg_tx }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_destroy (ffi : * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_masternode_list_entry (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut dashcore :: sml :: masternode_list_entry :: MasternodeListEntry { (* obj) . masternode_list_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_entry_hash (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_confirmed_hash_hashed_with_pro_reg_tx (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx { (* obj) . confirmed_hash_hashed_with_pro_reg_tx } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_masternode_list_entry (obj : * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , value : * mut dashcore :: sml :: masternode_list_entry :: MasternodeListEntry) { (* obj) . masternode_list_entry = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_entry_hash (obj : * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash) { (* obj) . entry_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_confirmed_hash_hashed_with_pro_reg_tx (obj : * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx) { (* obj) . confirmed_hash_hashed_with_pro_reg_tx = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`EntryMasternodeType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_masternode_list_entry_EntryMasternodeType { Regular , HighPerformance { platform_http_port : u16 , platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash } } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_EntryMasternodeType) -> dashcore :: sml :: masternode_list_entry :: EntryMasternodeType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port : * platform_http_port , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (* platform_node_id) } } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: EntryMasternodeType) -> * const dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (match obj { dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular => dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular , dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port : platform_http_port , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (platform_node_id) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_masternode_list_entry_EntryMasternodeType { fn drop (& mut self) { unsafe { match self { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => { } , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => { ; ; ferment :: unbox_any (* platform_node_id) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_Regular_ctor () -> * mut dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_HighPerformance_ctor (platform_http_port : u16 , platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash) -> * mut dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_destroy (ffi : * mut dashcore_sml_masternode_list_entry_EntryMasternodeType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`OperatorPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_OperatorPublicKey { pub data : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub version : u16 } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . data) , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: OperatorPublicKey) -> * const dashcore_sml_masternode_list_entry_OperatorPublicKey { ferment :: boxed (dashcore_sml_masternode_list_entry_OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . data) , version : obj . version }) } } impl Drop for dashcore_sml_masternode_list_entry_OperatorPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_ctor (data : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , version : u16) -> * mut dashcore_sml_masternode_list_entry_OperatorPublicKey { ferment :: boxed (dashcore_sml_masternode_list_entry_OperatorPublicKey { data , version }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_destroy (ffi : * mut dashcore_sml_masternode_list_entry_OperatorPublicKey) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_get_data (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_get_version (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_set_data (obj : * mut dashcore_sml_masternode_list_entry_OperatorPublicKey , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey) { (* obj) . data = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_set_version (obj : * mut dashcore_sml_masternode_list_entry_OperatorPublicKey , value : u16) { (* obj) . version = value ; } } pub mod quorum_entry { use crate as example_nested ; pub mod qualified_quorum_entry { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VerifyingChainLockSignaturesType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { Rotating (* mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) , NonRotating (* mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_from (* o_0)) , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (match obj { dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_Rotating_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_NonRotating_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_destroy (ffi : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`QualifiedQuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub quorum_entry : * mut dashcore :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry , pub verified : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus , pub commitment_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash , pub entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash , pub verifying_chain_lock_signature : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { let ffi_ref = & * ffi ; dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { quorum_entry : std :: ptr :: read (ffi_ref . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_from (ffi_ref . verified) , commitment_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumCommitmentHash >> :: ffi_from (ffi_ref . commitment_hash) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumEntryHash >> :: ffi_from (ffi_ref . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_from_opt (ffi_ref . verifying_chain_lock_signature) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { quorum_entry : ferment :: boxed (obj . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_to (obj . verified) , commitment_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumCommitmentHash >> :: ffi_to (obj . commitment_hash) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumEntryHash >> :: ffi_to (obj . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_to_opt (obj . verifying_chain_lock_signature) }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . quorum_entry) ; ferment :: unbox_any (ffi_ref . verified) ; ferment :: unbox_any (ffi_ref . commitment_hash) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . verifying_chain_lock_signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor (quorum_entry : * mut dashcore :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry , verified : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus , commitment_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash , entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash , verifying_chain_lock_signature : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { quorum_entry , verified , commitment_hash , entry_hash , verifying_chain_lock_signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy (ffi : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_quorum_entry (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut dashcore :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { (* obj) . quorum_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_verified (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { (* obj) . verified } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_commitment_hash (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash { (* obj) . commitment_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_entry_hash (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_verifying_chain_lock_signature (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { (* obj) . verifying_chain_lock_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_quorum_entry (obj : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , value : * mut dashcore :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry) { (* obj) . quorum_entry = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_verified (obj : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) { (* obj) . verified = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_commitment_hash (obj : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash) { (* obj) . commitment_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_entry_hash (obj : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash) { (* obj) . entry_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_verifying_chain_lock_signature (obj : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , value : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) { (* obj) . verifying_chain_lock_signature = value ; } } # [cfg (feature = "quorum_validation")] pub mod validation { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } pub mod quorum_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ClientDataRetrievalError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_ClientDataRetrievalError { RequiredBlockNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , CoinbaseNotFoundOnBlock (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError) -> dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError) -> * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_RequiredBlockNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_CoinbaseNotFoundOnBlock_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_destroy (ffi : * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`QuorumValidationError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_QuorumValidationError { RequiredBlockNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , * mut std :: os :: raw :: c_char) , RequiredBlockHeightNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , VerifyingMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredChainLockNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight , * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , RequiredRotatedChainLockSigNotPresent (u8 , * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , RequiredRotatedChainLockSigsNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , InsufficientSigners { required : u64 , found : u64 } , InsufficientValidMembers { required : u64 , found : u64 } , MismatchedBitsetLengths { signers_len : usize , valid_members_len : usize } , InvalidQuorumPublicKey , InvalidBLSPublicKey (* mut std :: os :: raw :: c_char) , InvalidBLSSignature (* mut std :: os :: raw :: c_char) , InvalidQuorumSignature , InvalidFinalSignature , AllCommitmentAggregatedSignatureNotValid (* mut std :: os :: raw :: c_char) , ThresholdSignatureNotValid (* mut std :: os :: raw :: c_char) , CommitmentHashNotPresent , RequiredSnapshotNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , SMLError (* mut crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError) , RequiredQuorumIndexNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , ExpectedOnlyRotatedQuorums (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) , ClientDataRetrievalError (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_QuorumValidationError) -> dashcore :: sml :: quorum_validation_error :: QuorumValidationError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0) , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0) , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (* o_0 , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len : * signers_len , valid_members_len : * valid_members_len } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: QuorumValidationError) -> * const dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0) , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0) , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len : signers_len , valid_members_len : valid_members_len } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent => dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_QuorumValidationError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_string (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => { ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredBlockNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , o_o_1 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredBlockHeightNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_VerifyingMasternodeListNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredMasternodeListNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredChainLockNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight , o_o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredRotatedChainLockSigNotPresent_ctor (o_o_0 : u8 , o_o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredRotatedChainLockSigsNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InsufficientSigners_ctor (required : u64 , found : u64) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InsufficientValidMembers_ctor (required : u64 , found : u64) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_MismatchedBitsetLengths_ctor (signers_len : usize , valid_members_len : usize) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidQuorumPublicKey_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidBLSPublicKey_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidBLSSignature_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidQuorumSignature_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidFinalSignature_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_AllCommitmentAggregatedSignatureNotValid_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ThresholdSignatureNotValid_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_CommitmentHashNotPresent_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredSnapshotNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_SMLError_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredQuorumIndexNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ExpectedOnlyRotatedQuorums_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , o_o_1 : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ClientDataRetrievalError_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_FeatureNotTurnedOn_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_destroy (ffi : * mut dashcore_sml_quorum_validation_error_QuorumValidationError) { ferment :: unbox_any (ffi) ; } } } pub mod taproot { use crate as example_nested ; } pub mod util { use crate as example_nested ; } pub mod prelude { use crate as example_nested ; # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dashcore_prelude_CoreBlockHeight) -> dashcore :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dashcore :: prelude :: CoreBlockHeight) -> * const dashcore_prelude_CoreBlockHeight { ferment :: boxed (dashcore_prelude_CoreBlockHeight (obj)) } } impl Drop for dashcore_prelude_CoreBlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_ctor (o_0 : u32) -> * mut dashcore_prelude_CoreBlockHeight { ferment :: boxed (dashcore_prelude_CoreBlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_destroy (ffi : * mut dashcore_prelude_CoreBlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_get_0 (obj : * const dashcore_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_set_0 (obj : * mut dashcore_prelude_CoreBlockHeight , value : u32) { (* obj) . 0 = value ; } } } pub mod platform_value { use crate as example_nested ; pub mod btreemap_extensions { use crate as example_nested ; } pub mod converter { use crate as example_nested ; # [cfg (feature = "json")] pub mod serde_json { use crate as example_nested ; } } pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Error`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_error_Error { Unsupported (* mut std :: os :: raw :: c_char) , StructureError (* mut std :: os :: raw :: c_char) , PathError (* mut std :: os :: raw :: c_char) , IntegerSizeError , IntegerParsingError , StringDecodingError (* mut std :: os :: raw :: c_char) , KeyMustBeAString , ByteLengthNot20BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot32BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot36BytesError (* mut std :: os :: raw :: c_char) , SerdeSerializationError (* mut std :: os :: raw :: c_char) , SerdeDeserializationError (* mut std :: os :: raw :: c_char) , CborSerializationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_from_const (ffi : * const platform_value_error_Error) -> platform_value :: error :: Error { let ffi_ref = & * ffi ; match ffi_ref { platform_value_error_Error :: Unsupported (o_0) => platform_value :: error :: Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: StructureError (o_0) => platform_value :: error :: Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: PathError (o_0) => platform_value :: error :: Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: IntegerSizeError => platform_value :: error :: Error :: IntegerSizeError , platform_value_error_Error :: IntegerParsingError => platform_value :: error :: Error :: IntegerParsingError , platform_value_error_Error :: StringDecodingError (o_0) => platform_value :: error :: Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: KeyMustBeAString => platform_value :: error :: Error :: KeyMustBeAString , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeSerializationError (o_0) => platform_value :: error :: Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeDeserializationError (o_0) => platform_value :: error :: Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: CborSerializationError (o_0) => platform_value :: error :: Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_to_const (obj : platform_value :: error :: Error) -> * const platform_value_error_Error { ferment :: boxed (match obj { platform_value :: error :: Error :: Unsupported (o_0) => platform_value_error_Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: StructureError (o_0) => platform_value_error_Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: PathError (o_0) => platform_value_error_Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: IntegerSizeError => platform_value_error_Error :: IntegerSizeError , platform_value :: error :: Error :: IntegerParsingError => platform_value_error_Error :: IntegerParsingError , platform_value :: error :: Error :: StringDecodingError (o_0) => platform_value_error_Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: KeyMustBeAString => platform_value_error_Error :: KeyMustBeAString , platform_value :: error :: Error :: ByteLengthNot20BytesError (o_0) => platform_value_error_Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot32BytesError (o_0) => platform_value_error_Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot36BytesError (o_0) => platform_value_error_Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeSerializationError (o_0) => platform_value_error_Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeDeserializationError (o_0) => platform_value_error_Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: CborSerializationError (o_0) => platform_value_error_Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_error_Error { fn drop (& mut self) { unsafe { match self { platform_value_error_Error :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: StructureError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: PathError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: IntegerSizeError => { } , platform_value_error_Error :: IntegerParsingError => { } , platform_value_error_Error :: StringDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: KeyMustBeAString => { } , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: CborSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_Unsupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: Unsupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_StructureError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: StructureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_PathError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: PathError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_IntegerSizeError_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: IntegerSizeError { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_IntegerParsingError_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: IntegerParsingError { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_StringDecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: StringDecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_KeyMustBeAString_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: KeyMustBeAString { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot20BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot20BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot32BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot32BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot36BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot36BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_SerdeSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: SerdeSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_SerdeDeserializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: SerdeDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_CborSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: CborSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_destroy (ffi : * mut platform_value_error_Error) { ferment :: unbox_any (ffi) ; } } pub mod index { use crate as example_nested ; } pub mod inner_value_at_path { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod macros { use crate as example_nested ; } pub mod patch { use crate as example_nested ; pub mod diff { use crate as example_nested ; } } pub mod types { use crate as example_nested ; pub mod binary_data { use crate as example_nested ; # [doc = "FFI-representation of the [`BinaryData`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_binary_data_BinaryData (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_from_const (ffi : * const platform_value_types_binary_data_BinaryData) -> platform_value :: types :: binary_data :: BinaryData { let ffi_ref = & * ffi ; platform_value :: types :: binary_data :: BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_to_const (obj : platform_value :: types :: binary_data :: BinaryData) -> * const platform_value_types_binary_data_BinaryData { ferment :: boxed (platform_value_types_binary_data_BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_binary_data_BinaryData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_types_binary_data_BinaryData { ferment :: boxed (platform_value_types_binary_data_BinaryData (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_destroy (ffi : * mut platform_value_types_binary_data_BinaryData) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_get_0 (obj : * const platform_value_types_binary_data_BinaryData) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_set_0 (obj : * mut platform_value_types_binary_data_BinaryData , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . 0 = value ; } } pub mod bytes_20 { use crate as example_nested ; # [doc = "FFI-representation of the [`Bytes20`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_20_Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_20_Bytes20) -> platform_value :: types :: bytes_20 :: Bytes20 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_20 :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_20 :: Bytes20) -> * const platform_value_types_bytes_20_Bytes20 { ferment :: boxed (platform_value_types_bytes_20_Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_20_Bytes20 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_20) -> * mut platform_value_types_bytes_20_Bytes20 { ferment :: boxed (platform_value_types_bytes_20_Bytes20 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_destroy (ffi : * mut platform_value_types_bytes_20_Bytes20) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_get_0 (obj : * const platform_value_types_bytes_20_Bytes20) -> * mut crate :: fermented :: generics :: Arr_u8_20 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_set_0 (obj : * mut platform_value_types_bytes_20_Bytes20 , value : * mut crate :: fermented :: generics :: Arr_u8_20) { (* obj) . 0 = value ; } } pub mod bytes_32 { use crate as example_nested ; # [doc = "FFI-representation of the [`Bytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_32_Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_32_Bytes32) -> platform_value :: types :: bytes_32 :: Bytes32 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_32 :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_32 :: Bytes32) -> * const platform_value_types_bytes_32_Bytes32 { ferment :: boxed (platform_value_types_bytes_32_Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_32_Bytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_types_bytes_32_Bytes32 { ferment :: boxed (platform_value_types_bytes_32_Bytes32 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_destroy (ffi : * mut platform_value_types_bytes_32_Bytes32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_get_0 (obj : * const platform_value_types_bytes_32_Bytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_set_0 (obj : * mut platform_value_types_bytes_32_Bytes32 , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . 0 = value ; } } pub mod identifier { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentifierBytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_IdentifierBytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_IdentifierBytes32) -> platform_value :: types :: identifier :: IdentifierBytes32 { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: IdentifierBytes32) -> * const platform_value_types_identifier_IdentifierBytes32 { ferment :: boxed (platform_value_types_identifier_IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_IdentifierBytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_types_identifier_IdentifierBytes32 { ferment :: boxed (platform_value_types_identifier_IdentifierBytes32 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_destroy (ffi : * mut platform_value_types_identifier_IdentifierBytes32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_get_0 (obj : * const platform_value_types_identifier_IdentifierBytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_set_0 (obj : * mut platform_value_types_identifier_IdentifierBytes32 , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`Identifier`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_Identifier (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_Identifier) -> platform_value :: types :: identifier :: Identifier { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: Identifier) -> * const platform_value_types_identifier_Identifier { ferment :: boxed (platform_value_types_identifier_Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_Identifier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_ctor (o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) -> * mut platform_value_types_identifier_Identifier { ferment :: boxed (platform_value_types_identifier_Identifier (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_destroy (ffi : * mut platform_value_types_identifier_Identifier) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_get_0 (obj : * const platform_value_types_identifier_Identifier) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_set_0 (obj : * mut platform_value_types_identifier_Identifier , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) { (* obj) . 0 = value ; } } } pub mod value_map { use crate as example_nested ; # [doc = "FFI-representation of the [`ValueMap`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_value_map_ValueMap (* mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) ; impl ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_from_const (ffi : * const platform_value_value_map_ValueMap) -> platform_value :: value_map :: ValueMap { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_to_const (obj : platform_value :: value_map :: ValueMap) -> * const platform_value_value_map_ValueMap { ferment :: boxed (platform_value_value_map_ValueMap (< crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_to (obj))) } } impl Drop for platform_value_value_map_ValueMap { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_ctor (o_0 : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) -> * mut platform_value_value_map_ValueMap { ferment :: boxed (platform_value_value_map_ValueMap (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_destroy (ffi : * mut platform_value_value_map_ValueMap) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_get_0 (obj : * const platform_value_value_map_ValueMap) -> * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_set_0 (obj : * mut platform_value_value_map_ValueMap , value : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) { (* obj) . 0 = value ; } } pub mod value_serialization { use crate as example_nested ; } # [doc = "FFI-representation of the [`Hash256`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_Hash256 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_from_const (ffi : * const platform_value_Hash256) -> platform_value :: Hash256 { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_to_const (obj : platform_value :: Hash256) -> * const platform_value_Hash256 { ferment :: boxed (platform_value_Hash256 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj))) } } impl Drop for platform_value_Hash256 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_Hash256 { ferment :: boxed (platform_value_Hash256 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_destroy (ffi : * mut platform_value_Hash256) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_get_0 (obj : * const platform_value_Hash256) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_set_0 (obj : * mut platform_value_Hash256 , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Value`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_Value { U128 (* mut [u8 ; 16]) , I128 (* mut [u8 ; 16]) , U64 (u64) , I64 (i64) , U32 (u32) , I32 (i32) , U16 (u16) , I16 (i16) , U8 (u8) , I8 (i8) , Bytes (* mut crate :: fermented :: generics :: Vec_u8) , Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) , Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) , Bytes36 (* mut crate :: fermented :: generics :: Arr_u8_36) , EnumU8 (* mut crate :: fermented :: generics :: Vec_u8) , EnumString (* mut crate :: fermented :: generics :: Vec_String) , Identifier (* mut crate :: fermented :: types :: platform_value :: platform_value_Hash256) , Float (f64) , Text (* mut std :: os :: raw :: c_char) , Bool (bool) , Null , Array (* mut crate :: fermented :: generics :: Vec_platform_value_Value) , Map (* mut crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap) } impl ferment :: FFIConversionFrom < platform_value :: Value > for platform_value_Value { unsafe fn ffi_from_const (ffi : * const platform_value_Value) -> platform_value :: Value { let ffi_ref = & * ffi ; match ffi_ref { platform_value_Value :: U128 (o_0) => platform_value :: Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) , platform_value_Value :: I128 (o_0) => platform_value :: Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (* o_0)) , platform_value_Value :: U64 (o_0) => platform_value :: Value :: U64 (* o_0) , platform_value_Value :: I64 (o_0) => platform_value :: Value :: I64 (* o_0) , platform_value_Value :: U32 (o_0) => platform_value :: Value :: U32 (* o_0) , platform_value_Value :: I32 (o_0) => platform_value :: Value :: I32 (* o_0) , platform_value_Value :: U16 (o_0) => platform_value :: Value :: U16 (* o_0) , platform_value_Value :: I16 (o_0) => platform_value :: Value :: I16 (* o_0) , platform_value_Value :: U8 (o_0) => platform_value :: Value :: U8 (* o_0) , platform_value_Value :: I8 (o_0) => platform_value :: Value :: I8 (* o_0) , platform_value_Value :: Bytes (o_0) => platform_value :: Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes20 (o_0) => platform_value :: Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes32 (o_0) => platform_value :: Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes36 (o_0) => platform_value :: Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionFrom < [u8 ; 36] >> :: ffi_from (* o_0)) , platform_value_Value :: EnumU8 (o_0) => platform_value :: Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: EnumString (o_0) => platform_value :: Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* o_0)) , platform_value_Value :: Identifier (o_0) => platform_value :: Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionFrom < platform_value :: Hash256 >> :: ffi_from (* o_0)) , platform_value_Value :: Float (o_0) => platform_value :: Value :: Float (* o_0) , platform_value_Value :: Text (o_0) => platform_value :: Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_Value :: Bool (o_0) => platform_value :: Value :: Bool (* o_0) , platform_value_Value :: Null => platform_value :: Value :: Null , platform_value_Value :: Array (o_0) => platform_value :: Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (* o_0)) , platform_value_Value :: Map (o_0) => platform_value :: Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: Value > for platform_value_Value { unsafe fn ffi_to_const (obj : platform_value :: Value) -> * const platform_value_Value { ferment :: boxed (match obj { platform_value :: Value :: U128 (o_0) => platform_value_Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , platform_value :: Value :: I128 (o_0) => platform_value_Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (o_0)) , platform_value :: Value :: U64 (o_0) => platform_value_Value :: U64 (o_0) , platform_value :: Value :: I64 (o_0) => platform_value_Value :: I64 (o_0) , platform_value :: Value :: U32 (o_0) => platform_value_Value :: U32 (o_0) , platform_value :: Value :: I32 (o_0) => platform_value_Value :: I32 (o_0) , platform_value :: Value :: U16 (o_0) => platform_value_Value :: U16 (o_0) , platform_value :: Value :: I16 (o_0) => platform_value_Value :: I16 (o_0) , platform_value :: Value :: U8 (o_0) => platform_value_Value :: U8 (o_0) , platform_value :: Value :: I8 (o_0) => platform_value_Value :: I8 (o_0) , platform_value :: Value :: Bytes (o_0) => platform_value_Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes20 (o_0) => platform_value_Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes32 (o_0) => platform_value_Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes36 (o_0) => platform_value_Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionTo < [u8 ; 36] >> :: ffi_to (o_0)) , platform_value :: Value :: EnumU8 (o_0) => platform_value_Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: EnumString (o_0) => platform_value_Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (o_0)) , platform_value :: Value :: Identifier (o_0) => platform_value_Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionTo < platform_value :: Hash256 >> :: ffi_to (o_0)) , platform_value :: Value :: Float (o_0) => platform_value_Value :: Float (o_0) , platform_value :: Value :: Text (o_0) => platform_value_Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: Value :: Bool (o_0) => platform_value_Value :: Bool (o_0) , platform_value :: Value :: Null => platform_value_Value :: Null , platform_value :: Value :: Array (o_0) => platform_value_Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (o_0)) , platform_value :: Value :: Map (o_0) => platform_value_Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_Value { fn drop (& mut self) { unsafe { match self { platform_value_Value :: U128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: I128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: U64 (o_0) => { ; } , platform_value_Value :: I64 (o_0) => { ; } , platform_value_Value :: U32 (o_0) => { ; } , platform_value_Value :: I32 (o_0) => { ; } , platform_value_Value :: U16 (o_0) => { ; } , platform_value_Value :: I16 (o_0) => { ; } , platform_value_Value :: U8 (o_0) => { ; } , platform_value_Value :: I8 (o_0) => { ; } , platform_value_Value :: Bytes (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes20 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes32 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes36 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumU8 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumString (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Identifier (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Float (o_0) => { ; } , platform_value_Value :: Text (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_Value :: Bool (o_0) => { ; } , platform_value_Value :: Null => { } , platform_value_Value :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Map (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U128_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U128 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I128_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I128 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U64_ctor (o_o_0 : u64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I64_ctor (o_o_0 : i64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U32_ctor (o_o_0 : u32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I32_ctor (o_o_0 : i32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U16_ctor (o_o_0 : u16) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U16 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I16_ctor (o_o_0 : i16) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I16 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U8_ctor (o_o_0 : u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I8_ctor (o_o_0 : i8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes20_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_20) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes20 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes32_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes36_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_36) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes36 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_EnumU8_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: EnumU8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_EnumString_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_String) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: EnumString (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Identifier_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Hash256) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Identifier (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Float_ctor (o_o_0 : f64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Float (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Text_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Text (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bool_ctor (o_o_0 : bool) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bool (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Null_ctor () -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Null { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Array_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_platform_value_Value) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Array (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Map_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Map (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_destroy (ffi : * mut platform_value_Value) { ferment :: unbox_any (ffi) ; } } pub mod platform_version { use crate as example_nested ; pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`PlatformVersionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_version_error_PlatformVersionError { UnknownVersionError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_from_const (ffi : * const platform_version_error_PlatformVersionError) -> platform_version :: error :: PlatformVersionError { let ffi_ref = & * ffi ; match ffi_ref { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => platform_version :: error :: PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_to_const (obj : platform_version :: error :: PlatformVersionError) -> * const platform_version_error_PlatformVersionError { ferment :: boxed (match obj { platform_version :: error :: PlatformVersionError :: UnknownVersionError (o_0) => platform_version_error_PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_version_error_PlatformVersionError { fn drop (& mut self) { unsafe { match self { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_error_PlatformVersionError_UnknownVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_version_error_PlatformVersionError { ferment :: boxed (platform_version_error_PlatformVersionError :: UnknownVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_version_error_PlatformVersionError_destroy (ffi : * mut platform_version_error_PlatformVersionError) { ferment :: unbox_any (ffi) ; } } pub mod version { use crate as example_nested ; pub mod dpp_versions { use crate as example_nested ; pub mod dpp_asset_lock_versions { use crate as example_nested ; } pub mod dpp_contract_versions { use crate as example_nested ; } pub mod dpp_costs_versions { use crate as example_nested ; } pub mod dpp_document_versions { use crate as example_nested ; } pub mod dpp_factory_versions { use crate as example_nested ; } pub mod dpp_identity_versions { use crate as example_nested ; } pub mod dpp_method_versions { use crate as example_nested ; } pub mod dpp_state_transition_conversion_versions { use crate as example_nested ; } pub mod dpp_state_transition_method_versions { use crate as example_nested ; } pub mod dpp_state_transition_serialization_versions { use crate as example_nested ; } pub mod dpp_state_transition_versions { use crate as example_nested ; } pub mod dpp_token_versions { use crate as example_nested ; } pub mod dpp_validation_versions { use crate as example_nested ; } pub mod dpp_voting_versions { use crate as example_nested ; } } pub mod drive_abci_versions { use crate as example_nested ; pub mod drive_abci_method_versions { use crate as example_nested ; } pub mod drive_abci_query_versions { use crate as example_nested ; } pub mod drive_abci_structure_versions { use crate as example_nested ; } pub mod drive_abci_validation_versions { use crate as example_nested ; } pub mod drive_abci_withdrawal_constants { use crate as example_nested ; } } pub mod drive_versions { use crate as example_nested ; pub mod drive_contract_method_versions { use crate as example_nested ; } pub mod drive_credit_pool_method_versions { use crate as example_nested ; } pub mod drive_document_method_versions { use crate as example_nested ; } pub mod drive_group_method_versions { use crate as example_nested ; } pub mod drive_grove_method_versions { use crate as example_nested ; } pub mod drive_identity_method_versions { use crate as example_nested ; } pub mod drive_state_transition_method_versions { use crate as example_nested ; } pub mod drive_structure_version { use crate as example_nested ; } pub mod drive_token_method_versions { use crate as example_nested ; } pub mod drive_verify_method_versions { use crate as example_nested ; } pub mod drive_vote_method_versions { use crate as example_nested ; } } pub mod fee { use crate as example_nested ; pub mod data_contract_registration { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeDataContractRegistrationVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { pub base_contract_registration_fee : u64 , pub document_type_registration_fee : u64 , pub document_type_base_non_unique_index_registration_fee : u64 , pub document_type_base_unique_index_registration_fee : u64 , pub document_type_base_contested_index_registration_fee : u64 , pub token_registration_fee : u64 , pub token_uses_perpetual_distribution_fee : u64 , pub token_uses_pre_programmed_distribution_fee : u64 , pub search_keyword_fee : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion > for platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion { base_contract_registration_fee : ffi_ref . base_contract_registration_fee , document_type_registration_fee : ffi_ref . document_type_registration_fee , document_type_base_non_unique_index_registration_fee : ffi_ref . document_type_base_non_unique_index_registration_fee , document_type_base_unique_index_registration_fee : ffi_ref . document_type_base_unique_index_registration_fee , document_type_base_contested_index_registration_fee : ffi_ref . document_type_base_contested_index_registration_fee , token_registration_fee : ffi_ref . token_registration_fee , token_uses_perpetual_distribution_fee : ffi_ref . token_uses_perpetual_distribution_fee , token_uses_pre_programmed_distribution_fee : ffi_ref . token_uses_pre_programmed_distribution_fee , search_keyword_fee : ffi_ref . search_keyword_fee } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion > for platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion) -> * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { ferment :: boxed (platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { base_contract_registration_fee : obj . base_contract_registration_fee , document_type_registration_fee : obj . document_type_registration_fee , document_type_base_non_unique_index_registration_fee : obj . document_type_base_non_unique_index_registration_fee , document_type_base_unique_index_registration_fee : obj . document_type_base_unique_index_registration_fee , document_type_base_contested_index_registration_fee : obj . document_type_base_contested_index_registration_fee , token_registration_fee : obj . token_registration_fee , token_uses_perpetual_distribution_fee : obj . token_uses_perpetual_distribution_fee , token_uses_pre_programmed_distribution_fee : obj . token_uses_pre_programmed_distribution_fee , search_keyword_fee : obj . search_keyword_fee }) } } impl Drop for platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_ctor (base_contract_registration_fee : u64 , document_type_registration_fee : u64 , document_type_base_non_unique_index_registration_fee : u64 , document_type_base_unique_index_registration_fee : u64 , document_type_base_contested_index_registration_fee : u64 , token_registration_fee : u64 , token_uses_perpetual_distribution_fee : u64 , token_uses_pre_programmed_distribution_fee : u64 , search_keyword_fee : u64) -> * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { ferment :: boxed (platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { base_contract_registration_fee , document_type_registration_fee , document_type_base_non_unique_index_registration_fee , document_type_base_unique_index_registration_fee , document_type_base_contested_index_registration_fee , token_registration_fee , token_uses_perpetual_distribution_fee , token_uses_pre_programmed_distribution_fee , search_keyword_fee }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_destroy (ffi : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_base_contract_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . base_contract_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_document_type_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . document_type_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_document_type_base_non_unique_index_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . document_type_base_non_unique_index_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_document_type_base_unique_index_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . document_type_base_unique_index_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_document_type_base_contested_index_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . document_type_base_contested_index_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_token_registration_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . token_registration_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_token_uses_perpetual_distribution_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . token_uses_perpetual_distribution_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_token_uses_pre_programmed_distribution_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . token_uses_pre_programmed_distribution_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_get_search_keyword_fee (obj : * const platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) -> u64 { (* obj) . search_keyword_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_base_contract_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . base_contract_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_document_type_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . document_type_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_document_type_base_non_unique_index_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . document_type_base_non_unique_index_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_document_type_base_unique_index_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . document_type_base_unique_index_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_document_type_base_contested_index_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . document_type_base_contested_index_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_token_registration_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . token_registration_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_token_uses_perpetual_distribution_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . token_uses_perpetual_distribution_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_token_uses_pre_programmed_distribution_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . token_uses_pre_programmed_distribution_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion_set_search_keyword_fee (obj : * mut platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , value : u64) { (* obj) . search_keyword_fee = value ; } } pub mod data_contract_validation { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeDataContractValidationVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { pub document_type_base_fee : u64 , pub document_type_schema_size_fee : u64 , pub document_type_per_property_fee : u64 , pub document_type_base_non_unique_index_fee : u64 , pub document_type_non_unique_index_per_property_fee : u64 , pub document_type_base_unique_index_fee : u64 , pub document_type_unique_index_per_property_fee : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion { document_type_base_fee : ffi_ref . document_type_base_fee , document_type_schema_size_fee : ffi_ref . document_type_schema_size_fee , document_type_per_property_fee : ffi_ref . document_type_per_property_fee , document_type_base_non_unique_index_fee : ffi_ref . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : ffi_ref . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : ffi_ref . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : ffi_ref . document_type_unique_index_per_property_fee } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion) -> * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { ferment :: boxed (platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { document_type_base_fee : obj . document_type_base_fee , document_type_schema_size_fee : obj . document_type_schema_size_fee , document_type_per_property_fee : obj . document_type_per_property_fee , document_type_base_non_unique_index_fee : obj . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : obj . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : obj . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : obj . document_type_unique_index_per_property_fee }) } } impl Drop for platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_ctor (document_type_base_fee : u64 , document_type_schema_size_fee : u64 , document_type_per_property_fee : u64 , document_type_base_non_unique_index_fee : u64 , document_type_non_unique_index_per_property_fee : u64 , document_type_base_unique_index_fee : u64 , document_type_unique_index_per_property_fee : u64) -> * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { ferment :: boxed (platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { document_type_base_fee , document_type_schema_size_fee , document_type_per_property_fee , document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee , document_type_unique_index_per_property_fee }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_destroy (ffi : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_base_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_schema_size_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_schema_size_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_per_property_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_base_non_unique_index_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_non_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_non_unique_index_per_property_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_non_unique_index_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_base_unique_index_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_get_document_type_unique_index_per_property_fee (obj : * const platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_unique_index_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_base_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_base_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_schema_size_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_schema_size_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_per_property_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_per_property_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_base_non_unique_index_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_base_non_unique_index_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_non_unique_index_per_property_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_non_unique_index_per_property_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_base_unique_index_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_base_unique_index_fee = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion_set_document_type_unique_index_per_property_fee (obj : * mut platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , value : u64) { (* obj) . document_type_unique_index_per_property_fee = value ; } } pub mod hashing { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeHashingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_hashing_FeeHashingVersion { pub blake3_base : u64 , pub blake3_per_block : u64 , pub sha256_per_block : u64 , pub sha256_ripe_md160_base : u64 , pub single_sha256_base : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_hashing_FeeHashingVersion) -> platform_version :: version :: fee :: hashing :: FeeHashingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: hashing :: FeeHashingVersion { blake3_base : ffi_ref . blake3_base , blake3_per_block : ffi_ref . blake3_per_block , sha256_per_block : ffi_ref . sha256_per_block , sha256_ripe_md160_base : ffi_ref . sha256_ripe_md160_base , single_sha256_base : ffi_ref . single_sha256_base } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: hashing :: FeeHashingVersion) -> * const platform_version_version_fee_hashing_FeeHashingVersion { ferment :: boxed (platform_version_version_fee_hashing_FeeHashingVersion { blake3_base : obj . blake3_base , blake3_per_block : obj . blake3_per_block , sha256_per_block : obj . sha256_per_block , sha256_ripe_md160_base : obj . sha256_ripe_md160_base , single_sha256_base : obj . single_sha256_base }) } } impl Drop for platform_version_version_fee_hashing_FeeHashingVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_ctor (blake3_base : u64 , blake3_per_block : u64 , sha256_per_block : u64 , sha256_ripe_md160_base : u64 , single_sha256_base : u64) -> * mut platform_version_version_fee_hashing_FeeHashingVersion { ferment :: boxed (platform_version_version_fee_hashing_FeeHashingVersion { blake3_base , blake3_per_block , sha256_per_block , sha256_ripe_md160_base , single_sha256_base }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_destroy (ffi : * mut platform_version_version_fee_hashing_FeeHashingVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_blake3_base (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_blake3_per_block (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_sha256_per_block (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_sha256_ripe_md160_base (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_ripe_md160_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_single_sha256_base (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . single_sha256_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_blake3_base (obj : * mut platform_version_version_fee_hashing_FeeHashingVersion , value : u64) { (* obj) . blake3_base = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_blake3_per_block (obj : * mut platform_version_version_fee_hashing_FeeHashingVersion , value : u64) { (* obj) . blake3_per_block = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_sha256_per_block (obj : * mut platform_version_version_fee_hashing_FeeHashingVersion , value : u64) { (* obj) . sha256_per_block = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_sha256_ripe_md160_base (obj : * mut platform_version_version_fee_hashing_FeeHashingVersion , value : u64) { (* obj) . sha256_ripe_md160_base = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_single_sha256_base (obj : * mut platform_version_version_fee_hashing_FeeHashingVersion , value : u64) { (* obj) . single_sha256_base = value ; } } pub mod processing { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeProcessingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_processing_FeeProcessingVersion { pub fetch_identity_balance_processing_cost : u64 , pub fetch_identity_revision_processing_cost : u64 , pub fetch_identity_balance_and_revision_processing_cost : u64 , pub fetch_identity_cost_per_look_up_key_by_id : u64 , pub fetch_identity_token_balance_processing_cost : u64 , pub fetch_prefunded_specialized_balance_processing_cost : u64 , pub fetch_single_identity_key_processing_cost : u64 , pub validate_key_structure : u64 , pub perform_network_threshold_signing : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_processing_FeeProcessingVersion) -> platform_version :: version :: fee :: processing :: FeeProcessingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: processing :: FeeProcessingVersion { fetch_identity_balance_processing_cost : ffi_ref . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : ffi_ref . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : ffi_ref . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : ffi_ref . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : ffi_ref . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : ffi_ref . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : ffi_ref . fetch_single_identity_key_processing_cost , validate_key_structure : ffi_ref . validate_key_structure , perform_network_threshold_signing : ffi_ref . perform_network_threshold_signing } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: processing :: FeeProcessingVersion) -> * const platform_version_version_fee_processing_FeeProcessingVersion { ferment :: boxed (platform_version_version_fee_processing_FeeProcessingVersion { fetch_identity_balance_processing_cost : obj . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : obj . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : obj . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : obj . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : obj . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : obj . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : obj . fetch_single_identity_key_processing_cost , validate_key_structure : obj . validate_key_structure , perform_network_threshold_signing : obj . perform_network_threshold_signing }) } } impl Drop for platform_version_version_fee_processing_FeeProcessingVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_ctor (fetch_identity_balance_processing_cost : u64 , fetch_identity_revision_processing_cost : u64 , fetch_identity_balance_and_revision_processing_cost : u64 , fetch_identity_cost_per_look_up_key_by_id : u64 , fetch_identity_token_balance_processing_cost : u64 , fetch_prefunded_specialized_balance_processing_cost : u64 , fetch_single_identity_key_processing_cost : u64 , validate_key_structure : u64 , perform_network_threshold_signing : u64) -> * mut platform_version_version_fee_processing_FeeProcessingVersion { ferment :: boxed (platform_version_version_fee_processing_FeeProcessingVersion { fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost , validate_key_structure , perform_network_threshold_signing }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_destroy (ffi : * mut platform_version_version_fee_processing_FeeProcessingVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_balance_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_revision_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_balance_and_revision_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_and_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_cost_per_look_up_key_by_id (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_cost_per_look_up_key_by_id } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_token_balance_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_token_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_prefunded_specialized_balance_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_prefunded_specialized_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_single_identity_key_processing_cost (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_single_identity_key_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_validate_key_structure (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . validate_key_structure } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_perform_network_threshold_signing (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . perform_network_threshold_signing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_balance_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_identity_balance_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_revision_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_identity_revision_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_balance_and_revision_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_identity_balance_and_revision_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_cost_per_look_up_key_by_id (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_identity_cost_per_look_up_key_by_id = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_token_balance_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_identity_token_balance_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_prefunded_specialized_balance_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_prefunded_specialized_balance_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_single_identity_key_processing_cost (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . fetch_single_identity_key_processing_cost = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_validate_key_structure (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . validate_key_structure = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_perform_network_threshold_signing (obj : * mut platform_version_version_fee_processing_FeeProcessingVersion , value : u64) { (* obj) . perform_network_threshold_signing = value ; } } pub mod signature { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeSignatureVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_signature_FeeSignatureVersion { pub verify_signature_ecdsa_secp256k1 : u64 , pub verify_signature_bls12_381 : u64 , pub verify_signature_ecdsa_hash160 : u64 , pub verify_signature_bip13_script_hash : u64 , pub verify_signature_eddsa25519_hash160 : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_signature_FeeSignatureVersion) -> platform_version :: version :: fee :: signature :: FeeSignatureVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: signature :: FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : ffi_ref . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : ffi_ref . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : ffi_ref . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : ffi_ref . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : ffi_ref . verify_signature_eddsa25519_hash160 } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: signature :: FeeSignatureVersion) -> * const platform_version_version_fee_signature_FeeSignatureVersion { ferment :: boxed (platform_version_version_fee_signature_FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : obj . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : obj . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : obj . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : obj . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : obj . verify_signature_eddsa25519_hash160 }) } } impl Drop for platform_version_version_fee_signature_FeeSignatureVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_ctor (verify_signature_ecdsa_secp256k1 : u64 , verify_signature_bls12_381 : u64 , verify_signature_ecdsa_hash160 : u64 , verify_signature_bip13_script_hash : u64 , verify_signature_eddsa25519_hash160 : u64) -> * mut platform_version_version_fee_signature_FeeSignatureVersion { ferment :: boxed (platform_version_version_fee_signature_FeeSignatureVersion { verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 , verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_destroy (ffi : * mut platform_version_version_fee_signature_FeeSignatureVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_ecdsa_secp256k1 (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_secp256k1 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_bls12_381 (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bls12_381 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_ecdsa_hash160 (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_hash160 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_bip13_script_hash (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bip13_script_hash } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_eddsa25519_hash160 (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_eddsa25519_hash160 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_ecdsa_secp256k1 (obj : * mut platform_version_version_fee_signature_FeeSignatureVersion , value : u64) { (* obj) . verify_signature_ecdsa_secp256k1 = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_bls12_381 (obj : * mut platform_version_version_fee_signature_FeeSignatureVersion , value : u64) { (* obj) . verify_signature_bls12_381 = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_ecdsa_hash160 (obj : * mut platform_version_version_fee_signature_FeeSignatureVersion , value : u64) { (* obj) . verify_signature_ecdsa_hash160 = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_bip13_script_hash (obj : * mut platform_version_version_fee_signature_FeeSignatureVersion , value : u64) { (* obj) . verify_signature_bip13_script_hash = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_eddsa25519_hash160 (obj : * mut platform_version_version_fee_signature_FeeSignatureVersion , value : u64) { (* obj) . verify_signature_eddsa25519_hash160 = value ; } } pub mod state_transition_min_fees { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionMinFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { pub credit_transfer : u64 , pub credit_withdrawal : u64 , pub identity_update : u64 , pub document_batch_sub_transition : u64 , pub contract_create : u64 , pub contract_update : u64 , pub masternode_vote : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { credit_transfer : ffi_ref . credit_transfer , credit_withdrawal : ffi_ref . credit_withdrawal , identity_update : ffi_ref . identity_update , document_batch_sub_transition : ffi_ref . document_batch_sub_transition , contract_create : ffi_ref . contract_create , contract_update : ffi_ref . contract_update , masternode_vote : ffi_ref . masternode_vote } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees) -> * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { ferment :: boxed (platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { credit_transfer : obj . credit_transfer , credit_withdrawal : obj . credit_withdrawal , identity_update : obj . identity_update , document_batch_sub_transition : obj . document_batch_sub_transition , contract_create : obj . contract_create , contract_update : obj . contract_update , masternode_vote : obj . masternode_vote }) } } impl Drop for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_ctor (credit_transfer : u64 , credit_withdrawal : u64 , identity_update : u64 , document_batch_sub_transition : u64 , contract_create : u64 , contract_update : u64 , masternode_vote : u64) -> * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { ferment :: boxed (platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { credit_transfer , credit_withdrawal , identity_update , document_batch_sub_transition , contract_create , contract_update , masternode_vote }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_destroy (ffi : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_credit_transfer (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_transfer } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_credit_withdrawal (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_withdrawal } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_identity_update (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . identity_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_document_batch_sub_transition (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . document_batch_sub_transition } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_contract_create (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_create } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_contract_update (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_masternode_vote (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . masternode_vote } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_credit_transfer (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . credit_transfer = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_credit_withdrawal (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . credit_withdrawal = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_identity_update (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . identity_update = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_document_batch_sub_transition (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . document_batch_sub_transition = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_contract_create (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . contract_create = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_contract_update (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . contract_update = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_masternode_vote (obj : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , value : u64) { (* obj) . masternode_vote = value ; } } pub mod storage { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeStorageVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_storage_FeeStorageVersion { pub storage_disk_usage_credit_per_byte : u64 , pub storage_processing_credit_per_byte : u64 , pub storage_load_credit_per_byte : u64 , pub non_storage_load_credit_per_byte : u64 , pub storage_seek_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_storage_FeeStorageVersion) -> platform_version :: version :: fee :: storage :: FeeStorageVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: storage :: FeeStorageVersion { storage_disk_usage_credit_per_byte : ffi_ref . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : ffi_ref . storage_processing_credit_per_byte , storage_load_credit_per_byte : ffi_ref . storage_load_credit_per_byte , non_storage_load_credit_per_byte : ffi_ref . non_storage_load_credit_per_byte , storage_seek_cost : ffi_ref . storage_seek_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: storage :: FeeStorageVersion) -> * const platform_version_version_fee_storage_FeeStorageVersion { ferment :: boxed (platform_version_version_fee_storage_FeeStorageVersion { storage_disk_usage_credit_per_byte : obj . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : obj . storage_processing_credit_per_byte , storage_load_credit_per_byte : obj . storage_load_credit_per_byte , non_storage_load_credit_per_byte : obj . non_storage_load_credit_per_byte , storage_seek_cost : obj . storage_seek_cost }) } } impl Drop for platform_version_version_fee_storage_FeeStorageVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_ctor (storage_disk_usage_credit_per_byte : u64 , storage_processing_credit_per_byte : u64 , storage_load_credit_per_byte : u64 , non_storage_load_credit_per_byte : u64 , storage_seek_cost : u64) -> * mut platform_version_version_fee_storage_FeeStorageVersion { ferment :: boxed (platform_version_version_fee_storage_FeeStorageVersion { storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte , storage_load_credit_per_byte , non_storage_load_credit_per_byte , storage_seek_cost }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_destroy (ffi : * mut platform_version_version_fee_storage_FeeStorageVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_disk_usage_credit_per_byte (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_disk_usage_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_processing_credit_per_byte (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_processing_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_load_credit_per_byte (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_non_storage_load_credit_per_byte (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . non_storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_seek_cost (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_seek_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_disk_usage_credit_per_byte (obj : * mut platform_version_version_fee_storage_FeeStorageVersion , value : u64) { (* obj) . storage_disk_usage_credit_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_processing_credit_per_byte (obj : * mut platform_version_version_fee_storage_FeeStorageVersion , value : u64) { (* obj) . storage_processing_credit_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_load_credit_per_byte (obj : * mut platform_version_version_fee_storage_FeeStorageVersion , value : u64) { (* obj) . storage_load_credit_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_non_storage_load_credit_per_byte (obj : * mut platform_version_version_fee_storage_FeeStorageVersion , value : u64) { (* obj) . non_storage_load_credit_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_seek_cost (obj : * mut platform_version_version_fee_storage_FeeStorageVersion , value : u64) { (* obj) . storage_seek_cost = value ; } } pub mod vote_resolution_fund_fees { use crate as example_nested ; # [doc = "FFI-representation of the [`VoteResolutionFundFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { pub contested_document_vote_resolution_fund_required_amount : u64 , pub contested_document_vote_resolution_unlock_fund_required_amount : u64 , pub contested_document_single_vote_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : ffi_ref . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : ffi_ref . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : ffi_ref . contested_document_single_vote_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees) -> * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { ferment :: boxed (platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : obj . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : obj . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : obj . contested_document_single_vote_cost }) } } impl Drop for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_ctor (contested_document_vote_resolution_fund_required_amount : u64 , contested_document_vote_resolution_unlock_fund_required_amount : u64 , contested_document_single_vote_cost : u64) -> * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { ferment :: boxed (platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_destroy (ffi : * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_vote_resolution_fund_required_amount (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_vote_resolution_unlock_fund_required_amount (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_unlock_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_single_vote_cost (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_single_vote_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_vote_resolution_fund_required_amount (obj : * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees , value : u64) { (* obj) . contested_document_vote_resolution_fund_required_amount = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_vote_resolution_unlock_fund_required_amount (obj : * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees , value : u64) { (* obj) . contested_document_vote_resolution_unlock_fund_required_amount = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_single_vote_cost (obj : * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees , value : u64) { (* obj) . contested_document_single_vote_cost = value ; } } # [doc = "FFI-representation of the [`FeeVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_FeeVersion { pub fee_version_number : * mut platform_version :: version :: fee :: FeeVersionNumber , pub uses_version_fee_multiplier_permille : * mut u64 , pub storage : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion , pub signature : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion , pub hashing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion , pub processing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion , pub data_contract_validation : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , pub data_contract_registration : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , pub state_transition_min_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , pub vote_resolution_fund_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_FeeVersion) -> platform_version :: version :: fee :: FeeVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: FeeVersion { fee_version_number : std :: ptr :: read (ffi_ref . fee_version_number) , uses_version_fee_multiplier_permille : ferment :: from_opt_primitive (ffi_ref . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_from (ffi_ref . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_from (ffi_ref . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_from (ffi_ref . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_from (ffi_ref . processing) , data_contract_validation : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion >> :: ffi_from (ffi_ref . data_contract_validation) , data_contract_registration : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion >> :: ffi_from (ffi_ref . data_contract_registration) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_from (ffi_ref . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_from (ffi_ref . vote_resolution_fund_fees) } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: FeeVersion) -> * const platform_version_version_fee_FeeVersion { ferment :: boxed (platform_version_version_fee_FeeVersion { fee_version_number : ferment :: boxed (obj . fee_version_number) , uses_version_fee_multiplier_permille : ferment :: to_opt_primitive (obj . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_to (obj . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_to (obj . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_to (obj . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_to (obj . processing) , data_contract_validation : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_validation :: FeeDataContractValidationVersion >> :: ffi_to (obj . data_contract_validation) , data_contract_registration : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract_registration :: FeeDataContractRegistrationVersion >> :: ffi_to (obj . data_contract_registration) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_to (obj . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_to (obj . vote_resolution_fund_fees) }) } } impl Drop for platform_version_version_fee_FeeVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . fee_version_number) ; ferment :: unbox_any_opt (ffi_ref . uses_version_fee_multiplier_permille) ; ferment :: unbox_any (ffi_ref . storage) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . hashing) ; ferment :: unbox_any (ffi_ref . processing) ; ferment :: unbox_any (ffi_ref . data_contract_validation) ; ferment :: unbox_any (ffi_ref . data_contract_registration) ; ferment :: unbox_any (ffi_ref . state_transition_min_fees) ; ferment :: unbox_any (ffi_ref . vote_resolution_fund_fees) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_ctor (fee_version_number : * mut platform_version :: version :: fee :: FeeVersionNumber , uses_version_fee_multiplier_permille : * mut u64 , storage : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion , signature : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion , hashing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion , processing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion , data_contract_validation : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion , data_contract_registration : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion , state_transition_min_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , vote_resolution_fund_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> * mut platform_version_version_fee_FeeVersion { ferment :: boxed (platform_version_version_fee_FeeVersion { fee_version_number , uses_version_fee_multiplier_permille , storage , signature , hashing , processing , data_contract_validation , data_contract_registration , state_transition_min_fees , vote_resolution_fund_fees }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_destroy (ffi : * mut platform_version_version_fee_FeeVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_fee_version_number (obj : * const platform_version_version_fee_FeeVersion) -> * mut platform_version :: version :: fee :: FeeVersionNumber { (* obj) . fee_version_number } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_uses_version_fee_multiplier_permille (obj : * const platform_version_version_fee_FeeVersion) -> * mut u64 { (* obj) . uses_version_fee_multiplier_permille } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_storage (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion { (* obj) . storage } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_signature (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_hashing (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion { (* obj) . hashing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_processing (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion { (* obj) . processing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_data_contract_validation (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion { (* obj) . data_contract_validation } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_data_contract_registration (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion { (* obj) . data_contract_registration } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_state_transition_min_fees (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { (* obj) . state_transition_min_fees } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_vote_resolution_fund_fees (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { (* obj) . vote_resolution_fund_fees } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_fee_version_number (obj : * mut platform_version_version_fee_FeeVersion , value : * mut platform_version :: version :: fee :: FeeVersionNumber) { (* obj) . fee_version_number = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_uses_version_fee_multiplier_permille (obj : * mut platform_version_version_fee_FeeVersion , value : * mut u64) { (* obj) . uses_version_fee_multiplier_permille = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_storage (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion) { (* obj) . storage = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_signature (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion) { (* obj) . signature = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_hashing (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion) { (* obj) . hashing = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_processing (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion) { (* obj) . processing = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_data_contract_validation (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_validation :: platform_version_version_fee_data_contract_validation_FeeDataContractValidationVersion) { (* obj) . data_contract_validation = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_data_contract_registration (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract_registration :: platform_version_version_fee_data_contract_registration_FeeDataContractRegistrationVersion) { (* obj) . data_contract_registration = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_state_transition_min_fees (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) { (* obj) . state_transition_min_fees = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_vote_resolution_fund_fees (obj : * mut platform_version_version_fee_FeeVersion , value : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) { (* obj) . vote_resolution_fund_fees = value ; } } # [cfg (feature = "mock-versions")] pub mod mocks { use crate as example_nested ; } pub mod system_data_contract_versions { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemDataContractVersions`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_data_contract_versions_SystemDataContractVersions { pub withdrawals : * mut platform_version :: version :: FeatureVersion , pub dpns : * mut platform_version :: version :: FeatureVersion , pub dashpay : * mut platform_version :: version :: FeatureVersion , pub masternode_reward_shares : * mut platform_version :: version :: FeatureVersion , pub feature_flags : * mut platform_version :: version :: FeatureVersion , pub wallet : * mut platform_version :: version :: FeatureVersion , pub token_history : * mut platform_version :: version :: FeatureVersion , pub keyword_search : * mut platform_version :: version :: FeatureVersion } impl ferment :: FFIConversionFrom < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { let ffi_ref = & * ffi ; platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { withdrawals : std :: ptr :: read (ffi_ref . withdrawals) , dpns : std :: ptr :: read (ffi_ref . dpns) , dashpay : std :: ptr :: read (ffi_ref . dashpay) , masternode_reward_shares : std :: ptr :: read (ffi_ref . masternode_reward_shares) , feature_flags : std :: ptr :: read (ffi_ref . feature_flags) , wallet : std :: ptr :: read (ffi_ref . wallet) , token_history : std :: ptr :: read (ffi_ref . token_history) , keyword_search : std :: ptr :: read (ffi_ref . keyword_search) } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_to_const (obj : platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions) -> * const platform_version_version_system_data_contract_versions_SystemDataContractVersions { ferment :: boxed (platform_version_version_system_data_contract_versions_SystemDataContractVersions { withdrawals : ferment :: boxed (obj . withdrawals) , dpns : ferment :: boxed (obj . dpns) , dashpay : ferment :: boxed (obj . dashpay) , masternode_reward_shares : ferment :: boxed (obj . masternode_reward_shares) , feature_flags : ferment :: boxed (obj . feature_flags) , wallet : ferment :: boxed (obj . wallet) , token_history : ferment :: boxed (obj . token_history) , keyword_search : ferment :: boxed (obj . keyword_search) }) } } impl Drop for platform_version_version_system_data_contract_versions_SystemDataContractVersions { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . withdrawals) ; ferment :: unbox_any (ffi_ref . dpns) ; ferment :: unbox_any (ffi_ref . dashpay) ; ferment :: unbox_any (ffi_ref . masternode_reward_shares) ; ferment :: unbox_any (ffi_ref . feature_flags) ; ferment :: unbox_any (ffi_ref . wallet) ; ferment :: unbox_any (ffi_ref . token_history) ; ferment :: unbox_any (ffi_ref . keyword_search) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_ctor (withdrawals : * mut platform_version :: version :: FeatureVersion , dpns : * mut platform_version :: version :: FeatureVersion , dashpay : * mut platform_version :: version :: FeatureVersion , masternode_reward_shares : * mut platform_version :: version :: FeatureVersion , feature_flags : * mut platform_version :: version :: FeatureVersion , wallet : * mut platform_version :: version :: FeatureVersion , token_history : * mut platform_version :: version :: FeatureVersion , keyword_search : * mut platform_version :: version :: FeatureVersion) -> * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions { ferment :: boxed (platform_version_version_system_data_contract_versions_SystemDataContractVersions { withdrawals , dpns , dashpay , masternode_reward_shares , feature_flags , wallet , token_history , keyword_search }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_destroy (ffi : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_withdrawals (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . withdrawals } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_dpns (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . dpns } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_dashpay (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . dashpay } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_masternode_reward_shares (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . masternode_reward_shares } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_feature_flags (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . feature_flags } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_wallet (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . wallet } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_token_history (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . token_history } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_keyword_search (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut platform_version :: version :: FeatureVersion { (* obj) . keyword_search } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_withdrawals (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . withdrawals = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_dpns (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . dpns = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_dashpay (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . dashpay = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_masternode_reward_shares (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . masternode_reward_shares = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_feature_flags (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . feature_flags = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_wallet (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . wallet = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_token_history (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . token_history = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_keyword_search (obj : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions , value : * mut platform_version :: version :: FeatureVersion) { (* obj) . keyword_search = value ; } } pub mod system_limits { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemLimits`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_limits_SystemLimits { pub estimated_contract_max_serialized_size : u16 , pub max_field_value_size : u32 , pub max_state_transition_size : u64 , pub max_transitions_in_documents_batch : u16 , pub withdrawal_transactions_per_block_limit : u16 , pub retry_signing_expired_withdrawal_documents_per_block_limit : u16 , pub max_withdrawal_amount : u64 , pub max_contract_group_size : u16 , pub max_token_redemption_cycles : u32 } impl ferment :: FFIConversionFrom < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_limits_SystemLimits) -> platform_version :: version :: system_limits :: SystemLimits { let ffi_ref = & * ffi ; platform_version :: version :: system_limits :: SystemLimits { estimated_contract_max_serialized_size : ffi_ref . estimated_contract_max_serialized_size , max_field_value_size : ffi_ref . max_field_value_size , max_state_transition_size : ffi_ref . max_state_transition_size , max_transitions_in_documents_batch : ffi_ref . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : ffi_ref . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : ffi_ref . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : ffi_ref . max_withdrawal_amount , max_contract_group_size : ffi_ref . max_contract_group_size , max_token_redemption_cycles : ffi_ref . max_token_redemption_cycles } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_to_const (obj : platform_version :: version :: system_limits :: SystemLimits) -> * const platform_version_version_system_limits_SystemLimits { ferment :: boxed (platform_version_version_system_limits_SystemLimits { estimated_contract_max_serialized_size : obj . estimated_contract_max_serialized_size , max_field_value_size : obj . max_field_value_size , max_state_transition_size : obj . max_state_transition_size , max_transitions_in_documents_batch : obj . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : obj . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : obj . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : obj . max_withdrawal_amount , max_contract_group_size : obj . max_contract_group_size , max_token_redemption_cycles : obj . max_token_redemption_cycles }) } } impl Drop for platform_version_version_system_limits_SystemLimits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_ctor (estimated_contract_max_serialized_size : u16 , max_field_value_size : u32 , max_state_transition_size : u64 , max_transitions_in_documents_batch : u16 , withdrawal_transactions_per_block_limit : u16 , retry_signing_expired_withdrawal_documents_per_block_limit : u16 , max_withdrawal_amount : u64 , max_contract_group_size : u16 , max_token_redemption_cycles : u32) -> * mut platform_version_version_system_limits_SystemLimits { ferment :: boxed (platform_version_version_system_limits_SystemLimits { estimated_contract_max_serialized_size , max_field_value_size , max_state_transition_size , max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount , max_contract_group_size , max_token_redemption_cycles }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_destroy (ffi : * mut platform_version_version_system_limits_SystemLimits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_estimated_contract_max_serialized_size (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . estimated_contract_max_serialized_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_field_value_size (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_field_value_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_state_transition_size (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_state_transition_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_transitions_in_documents_batch (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . max_transitions_in_documents_batch } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_withdrawal_transactions_per_block_limit (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . withdrawal_transactions_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_retry_signing_expired_withdrawal_documents_per_block_limit (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . retry_signing_expired_withdrawal_documents_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_withdrawal_amount (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_withdrawal_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_contract_group_size (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . max_contract_group_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_token_redemption_cycles (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_token_redemption_cycles } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_estimated_contract_max_serialized_size (obj : * mut platform_version_version_system_limits_SystemLimits , value : u16) { (* obj) . estimated_contract_max_serialized_size = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_field_value_size (obj : * mut platform_version_version_system_limits_SystemLimits , value : u32) { (* obj) . max_field_value_size = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_state_transition_size (obj : * mut platform_version_version_system_limits_SystemLimits , value : u64) { (* obj) . max_state_transition_size = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_transitions_in_documents_batch (obj : * mut platform_version_version_system_limits_SystemLimits , value : u16) { (* obj) . max_transitions_in_documents_batch = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_withdrawal_transactions_per_block_limit (obj : * mut platform_version_version_system_limits_SystemLimits , value : u16) { (* obj) . withdrawal_transactions_per_block_limit = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_retry_signing_expired_withdrawal_documents_per_block_limit (obj : * mut platform_version_version_system_limits_SystemLimits , value : u16) { (* obj) . retry_signing_expired_withdrawal_documents_per_block_limit = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_withdrawal_amount (obj : * mut platform_version_version_system_limits_SystemLimits , value : u64) { (* obj) . max_withdrawal_amount = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_contract_group_size (obj : * mut platform_version_version_system_limits_SystemLimits , value : u16) { (* obj) . max_contract_group_size = value ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_token_redemption_cycles (obj : * mut platform_version_version_system_limits_SystemLimits , value : u32) { (* obj) . max_token_redemption_cycles = value ; } } } } pub mod example_simple { use crate as example_nested ; pub mod example { use crate as example_nested ; pub mod address { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::example::address::address_with_script_pubkey`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_example_address_address_with_script_pubkey (script : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std :: os :: raw :: c_char { let obj = example_simple :: example :: address :: address_with_script_pubkey (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (script)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj) } # [doc = "FFI-representation of the [`example_simple::example::address::address_simple_result`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_example_address_address_simple_result (script : * mut crate :: fermented :: generics :: Vec_u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_simple :: example :: address :: address_simple_result (< crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from (script)) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } } pub mod custom_conversion { use crate as example_nested ; # [doc = "FFI-representation of the [`StructUsesDurationTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_example_custom_conversion_StructUsesDurationTuple { pub time : * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration } impl ferment :: FFIConversionFrom < example_simple :: example :: custom_conversion :: StructUsesDurationTuple > for example_simple_example_custom_conversion_StructUsesDurationTuple { unsafe fn ffi_from_const (ffi : * const example_simple_example_custom_conversion_StructUsesDurationTuple) -> example_simple :: example :: custom_conversion :: StructUsesDurationTuple { let ffi_ref = & * ffi ; example_simple :: example :: custom_conversion :: StructUsesDurationTuple { time : < crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration as ferment :: FFIConversionFrom < (std :: time :: Duration , std :: time :: Duration) >> :: ffi_from (ffi_ref . time) } } } impl ferment :: FFIConversionTo < example_simple :: example :: custom_conversion :: StructUsesDurationTuple > for example_simple_example_custom_conversion_StructUsesDurationTuple { unsafe fn ffi_to_const (obj : example_simple :: example :: custom_conversion :: StructUsesDurationTuple) -> * const example_simple_example_custom_conversion_StructUsesDurationTuple { ferment :: boxed (example_simple_example_custom_conversion_StructUsesDurationTuple { time : < crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration as ferment :: FFIConversionTo < (std :: time :: Duration , std :: time :: Duration) >> :: ffi_to (obj . time) }) } } impl Drop for example_simple_example_custom_conversion_StructUsesDurationTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_ctor (time : * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration) -> * mut example_simple_example_custom_conversion_StructUsesDurationTuple { ferment :: boxed (example_simple_example_custom_conversion_StructUsesDurationTuple { time }) } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_destroy (ffi : * mut example_simple_example_custom_conversion_StructUsesDurationTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_get_time (obj : * const example_simple_example_custom_conversion_StructUsesDurationTuple) -> * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration { (* obj) . time } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_set_time (obj : * mut example_simple_example_custom_conversion_StructUsesDurationTuple , value : * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration) { (* obj) . time = value ; } # [doc = "FFI-representation of the [`StructUsesGenericWithCustom`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_example_custom_conversion_StructUsesGenericWithCustom { pub time : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration } impl ferment :: FFIConversionFrom < example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom > for example_simple_example_custom_conversion_StructUsesGenericWithCustom { unsafe fn ffi_from_const (ffi : * const example_simple_example_custom_conversion_StructUsesGenericWithCustom) -> example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom { let ffi_ref = & * ffi ; example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom { time : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , std :: time :: Duration > >> :: ffi_from (ffi_ref . time) } } } impl ferment :: FFIConversionTo < example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom > for example_simple_example_custom_conversion_StructUsesGenericWithCustom { unsafe fn ffi_to_const (obj : example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom) -> * const example_simple_example_custom_conversion_StructUsesGenericWithCustom { ferment :: boxed (example_simple_example_custom_conversion_StructUsesGenericWithCustom { time : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , std :: time :: Duration > >> :: ffi_to (obj . time) }) } } impl Drop for example_simple_example_custom_conversion_StructUsesGenericWithCustom { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_ctor (time : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration) -> * mut example_simple_example_custom_conversion_StructUsesGenericWithCustom { ferment :: boxed (example_simple_example_custom_conversion_StructUsesGenericWithCustom { time }) } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_destroy (ffi : * mut example_simple_example_custom_conversion_StructUsesGenericWithCustom) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_get_time (obj : * const example_simple_example_custom_conversion_StructUsesGenericWithCustom) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration { (* obj) . time } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_set_time (obj : * mut example_simple_example_custom_conversion_StructUsesGenericWithCustom , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration) { (* obj) . time = value ; } } } pub mod data_contract { use crate as example_nested ; pub mod v0 { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_v0_data_contract_DataContractV0 { } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 > for example_simple_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_v0_data_contract_DataContractV0) -> example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 { let ffi_ref = & * ffi ; example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 { } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 > for example_simple_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: v0 :: data_contract :: DataContractV0) -> * const example_simple_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (example_simple_data_contract_v0_data_contract_DataContractV0 { }) } } impl Drop for example_simple_data_contract_v0_data_contract_DataContractV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v0_data_contract_DataContractV0_ctor () -> * mut example_simple_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (example_simple_data_contract_v0_data_contract_DataContractV0 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v0_data_contract_DataContractV0_destroy (ffi : * mut example_simple_data_contract_v0_data_contract_DataContractV0) { ferment :: unbox_any (ffi) ; } } } pub mod v1 { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV1`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_v1_data_contract_DataContractV1 { } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 > for example_simple_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_v1_data_contract_DataContractV1) -> example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 { let ffi_ref = & * ffi ; example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 { } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 > for example_simple_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: v1 :: data_contract :: DataContractV1) -> * const example_simple_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (example_simple_data_contract_v1_data_contract_DataContractV1 { }) } } impl Drop for example_simple_data_contract_v1_data_contract_DataContractV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v1_data_contract_DataContractV1_ctor () -> * mut example_simple_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (example_simple_data_contract_v1_data_contract_DataContractV1 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v1_data_contract_DataContractV1_destroy (ffi : * mut example_simple_data_contract_v1_data_contract_DataContractV1) { ferment :: unbox_any (ffi) ; } } } pub mod document_type { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_document_type_v0_DocumentTypeV0 { pub name : * mut std :: os :: raw :: c_char , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for example_simple_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 { let ffi_ref = & * ffi ; example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for example_simple_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0) -> * const example_simple_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (example_simple_data_contract_document_type_v0_DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) }) } } impl Drop for example_simple_data_contract_document_type_v0_DocumentTypeV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . binary_paths) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_ctor (name : * mut std :: os :: raw :: c_char , binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) -> * mut example_simple_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (example_simple_data_contract_document_type_v0_DocumentTypeV0 { name , binary_paths }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_destroy (ffi : * mut example_simple_data_contract_document_type_v0_DocumentTypeV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_get_name (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_get_binary_paths (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_set_name (obj : * mut example_simple_data_contract_document_type_v0_DocumentTypeV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_set_binary_paths (obj : * mut example_simple_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . binary_paths = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_data_contract_document_type_DocumentType { V0 (* mut crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0) } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: DocumentType > for example_simple_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_document_type_DocumentType) -> example_simple :: data_contract :: document_type :: DocumentType { let ffi_ref = & * ffi ; match ffi_ref { example_simple_data_contract_document_type_DocumentType :: V0 (o_0) => example_simple :: data_contract :: document_type :: DocumentType :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: DocumentType > for example_simple_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: document_type :: DocumentType) -> * const example_simple_data_contract_document_type_DocumentType { ferment :: boxed (match obj { example_simple :: data_contract :: document_type :: DocumentType :: V0 (o_0) => example_simple_data_contract_document_type_DocumentType :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { match self { example_simple_data_contract_document_type_DocumentType :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_DocumentType_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut example_simple_data_contract_document_type_DocumentType { ferment :: boxed (example_simple_data_contract_document_type_DocumentType :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_DocumentType_destroy (ffi : * mut example_simple_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContract`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_data_contract_DataContract { V0 (* mut crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0) , V1 (* mut v1 :: DataContractV1) , # [cfg (test)] Test } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: DataContract > for example_simple_data_contract_DataContract { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_DataContract) -> example_simple :: data_contract :: DataContract { let ffi_ref = & * ffi ; match ffi_ref { example_simple_data_contract_DataContract :: V0 (o_0) => example_simple :: data_contract :: DataContract :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionFrom < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_from (* o_0)) , example_simple_data_contract_DataContract :: V1 (o_0) => example_simple :: data_contract :: DataContract :: V1 (std :: ptr :: read (* o_0)) , # [cfg (test)] example_simple_data_contract_DataContract :: Test => example_simple :: data_contract :: DataContract :: Test } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: DataContract > for example_simple_data_contract_DataContract { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: DataContract) -> * const example_simple_data_contract_DataContract { ferment :: boxed (match obj { example_simple :: data_contract :: DataContract :: V0 (o_0) => example_simple_data_contract_DataContract :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionTo < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_to (o_0)) , example_simple :: data_contract :: DataContract :: V1 (o_0) => example_simple_data_contract_DataContract :: V1 (ferment :: boxed (o_0)) , # [cfg (test)] example_simple :: data_contract :: DataContract :: Test => example_simple_data_contract_DataContract :: Test , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_data_contract_DataContract { fn drop (& mut self) { unsafe { match self { example_simple_data_contract_DataContract :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , example_simple_data_contract_DataContract :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (test)] example_simple_data_contract_DataContract :: Test => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0) -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_V1_ctor (o_o_0 : * mut v1 :: DataContractV1) -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: V1 (o_o_0)) } # [cfg (test)] # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_Test_ctor () -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: Test { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_destroy (ffi : * mut example_simple_data_contract_DataContract) { ferment :: unbox_any (ffi) ; } } pub mod state_transition { use crate as example_nested ; pub mod errors { use crate as example_nested ; pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . public_key_type) }) } } impl Drop for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor (public_key_type : * mut std :: os :: raw :: c_char) -> * mut example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy (ffi : * mut example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type (obj : * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type (obj : * mut example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . public_key_type = value ; } } } } pub mod errors { use crate as example_nested ; pub mod protocol_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProtocolError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_errors_protocol_error_ProtocolError { InvalidPKT (* mut crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) } impl ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError > for example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const example_simple_errors_protocol_error_ProtocolError) -> example_simple :: errors :: protocol_error :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_0) => example_simple :: errors :: protocol_error :: ProtocolError :: InvalidPKT (< crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError > for example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : example_simple :: errors :: protocol_error :: ProtocolError) -> * const example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (match obj { example_simple :: errors :: protocol_error :: ProtocolError :: InvalidPKT (o_0) => example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (< crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { match self { example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_protocol_error_ProtocolError_InvalidPKT_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } } pub mod context { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContextProviderError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_errors_context_ContextProviderError { Generic (* mut std :: os :: raw :: c_char) , Config (* mut std :: os :: raw :: c_char) , InvalidDataContract (* mut std :: os :: raw :: c_char) , InvalidQuorum (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < example_simple :: errors :: context :: ContextProviderError > for example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const example_simple_errors_context_ContextProviderError) -> example_simple :: errors :: context :: ContextProviderError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_errors_context_ContextProviderError :: Generic (o_0) => example_simple :: errors :: context :: ContextProviderError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: Config (o_0) => example_simple :: errors :: context :: ContextProviderError :: Config (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_0) => example_simple :: errors :: context :: ContextProviderError :: InvalidDataContract (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_0) => example_simple :: errors :: context :: ContextProviderError :: InvalidQuorum (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: errors :: context :: ContextProviderError > for example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : example_simple :: errors :: context :: ContextProviderError) -> * const example_simple_errors_context_ContextProviderError { ferment :: boxed (match obj { example_simple :: errors :: context :: ContextProviderError :: Generic (o_0) => example_simple_errors_context_ContextProviderError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: Config (o_0) => example_simple_errors_context_ContextProviderError :: Config (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: InvalidDataContract (o_0) => example_simple_errors_context_ContextProviderError :: InvalidDataContract (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: InvalidQuorum (o_0) => example_simple_errors_context_ContextProviderError :: InvalidQuorum (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { match self { example_simple_errors_context_ContextProviderError :: Generic (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: Config (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_Generic_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: Generic (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_Config_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: Config (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_InvalidDataContract_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_InvalidQuorum_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_destroy (ffi : * mut example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } } } pub mod document { use crate as example_nested ; pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_document_errors_DocumentError { InvalidActionError (u8) , InvalidInitialRevisionError { document : * mut crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document } } impl ferment :: FFIConversionFrom < example_simple :: document :: errors :: DocumentError > for example_simple_document_errors_DocumentError { unsafe fn ffi_from_const (ffi : * const example_simple_document_errors_DocumentError) -> example_simple :: document :: errors :: DocumentError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_document_errors_DocumentError :: InvalidActionError (o_0) => example_simple :: document :: errors :: DocumentError :: InvalidActionError (* o_0) , example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document } => example_simple :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document : Box :: new (< crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document as ferment :: FFIConversionFrom < example_simple :: document :: Document >> :: ffi_from (* document)) } } } } impl ferment :: FFIConversionTo < example_simple :: document :: errors :: DocumentError > for example_simple_document_errors_DocumentError { unsafe fn ffi_to_const (obj : example_simple :: document :: errors :: DocumentError) -> * const example_simple_document_errors_DocumentError { ferment :: boxed (match obj { example_simple :: document :: errors :: DocumentError :: InvalidActionError (o_0) => example_simple_document_errors_DocumentError :: InvalidActionError (o_0) , example_simple :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document } => example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document : < crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document as ferment :: FFIConversionTo < example_simple :: document :: Document >> :: ffi_to (* document) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_document_errors_DocumentError { fn drop (& mut self) { unsafe { match self { example_simple_document_errors_DocumentError :: InvalidActionError (o_0) => { ; } , example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document } => { ferment :: unbox_any (* document) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_InvalidActionError_ctor (o_o_0 : u8) -> * mut example_simple_document_errors_DocumentError { ferment :: boxed (example_simple_document_errors_DocumentError :: InvalidActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_InvalidInitialRevisionError_ctor (document : * mut crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document) -> * mut example_simple_document_errors_DocumentError { ferment :: boxed (example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_destroy (ffi : * mut example_simple_document_errors_DocumentError) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Document`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_document_Document { V0 } impl ferment :: FFIConversionFrom < example_simple :: document :: Document > for example_simple_document_Document { unsafe fn ffi_from_const (ffi : * const example_simple_document_Document) -> example_simple :: document :: Document { let ffi_ref = & * ffi ; match ffi_ref { example_simple_document_Document :: V0 => example_simple :: document :: Document :: V0 } } } impl ferment :: FFIConversionTo < example_simple :: document :: Document > for example_simple_document_Document { unsafe fn ffi_to_const (obj : example_simple :: document :: Document) -> * const example_simple_document_Document { ferment :: boxed (match obj { example_simple :: document :: Document :: V0 => example_simple_document_Document :: V0 , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_document_Document { fn drop (& mut self) { unsafe { match self { example_simple_document_Document :: V0 => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_document_Document_V0_ctor () -> * mut example_simple_document_Document { ferment :: boxed (example_simple_document_Document :: V0 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_Document_destroy (ffi : * mut example_simple_document_Document) { ferment :: unbox_any (ffi) ; } } pub mod types { use crate as example_nested ; pub mod tuple_in_functions { use crate as example_nested ; # [doc = "FFI-representation of the [`StructWithTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_types_tuple_in_functions_StructWithTuple { pub tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID , pub tuple2 : * mut crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID , pub tuple3 : * mut crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < example_simple :: types :: tuple_in_functions :: StructWithTuple > for example_simple_types_tuple_in_functions_StructWithTuple { unsafe fn ffi_from_const (ffi : * const example_simple_types_tuple_in_functions_StructWithTuple) -> example_simple :: types :: tuple_in_functions :: StructWithTuple { let ffi_ref = & * ffi ; example_simple :: types :: tuple_in_functions :: StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (ffi_ref . tuple) , tuple2 : < crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (Option < u32 > , example_simple :: nested :: HashID) >> :: ffi_from (ffi_ref . tuple2) , tuple3 : < crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID as ferment :: FFIConversionFrom < (Option < u32 > , Vec < example_simple :: nested :: HashID >) >> :: ffi_from (ffi_ref . tuple3) } } } impl ferment :: FFIConversionTo < example_simple :: types :: tuple_in_functions :: StructWithTuple > for example_simple_types_tuple_in_functions_StructWithTuple { unsafe fn ffi_to_const (obj : example_simple :: types :: tuple_in_functions :: StructWithTuple) -> * const example_simple_types_tuple_in_functions_StructWithTuple { ferment :: boxed (example_simple_types_tuple_in_functions_StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj . tuple) , tuple2 : < crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (Option < u32 > , example_simple :: nested :: HashID) >> :: ffi_to (obj . tuple2) , tuple3 : < crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID as ferment :: FFIConversionTo < (Option < u32 > , Vec < example_simple :: nested :: HashID >) >> :: ffi_to (obj . tuple3) }) } } impl Drop for example_simple_types_tuple_in_functions_StructWithTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple) ; ferment :: unbox_any (ffi_ref . tuple2) ; ferment :: unbox_any (ffi_ref . tuple3) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_ctor (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID , tuple2 : * mut crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID , tuple3 : * mut crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID) -> * mut example_simple_types_tuple_in_functions_StructWithTuple { ferment :: boxed (example_simple_types_tuple_in_functions_StructWithTuple { tuple , tuple2 , tuple3 }) } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_destroy (ffi : * mut example_simple_types_tuple_in_functions_StructWithTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_get_tuple (obj : * const example_simple_types_tuple_in_functions_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { (* obj) . tuple } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_get_tuple2 (obj : * const example_simple_types_tuple_in_functions_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID { (* obj) . tuple2 } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_get_tuple3 (obj : * const example_simple_types_tuple_in_functions_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID { (* obj) . tuple3 } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_set_tuple (obj : * mut example_simple_types_tuple_in_functions_StructWithTuple , value : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) { (* obj) . tuple = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_set_tuple2 (obj : * mut example_simple_types_tuple_in_functions_StructWithTuple , value : * mut crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID) { (* obj) . tuple2 = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_StructWithTuple_set_tuple3 (obj : * mut example_simple_types_tuple_in_functions_StructWithTuple , value : * mut crate :: fermented :: generics :: Tuple_Option_u32_Vec_example_simple_nested_HashID) { (* obj) . tuple3 = value ; } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::get_tuple_simple`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_get_tuple_simple () -> * mut crate :: fermented :: generics :: Tuple_u32_u32 { let obj = example_simple :: types :: tuple_in_functions :: get_tuple_simple () ; < crate :: fermented :: generics :: Tuple_u32_u32 as ferment :: FFIConversionTo < (u32 , u32) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::get_tuple_simple_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_get_tuple_simple_complex () -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { let obj = example_simple :: types :: tuple_in_functions :: get_tuple_simple_complex () ; < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::get_tuple_opt_primitive`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_get_tuple_opt_primitive () -> * mut crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID { let obj = example_simple :: types :: tuple_in_functions :: get_tuple_opt_primitive () ; < crate :: fermented :: generics :: Tuple_Option_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (Option < u32 > , example_simple :: nested :: HashID) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::get_tuple_complex_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_get_tuple_complex_complex (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) -> u32 { let obj = example_simple :: types :: tuple_in_functions :: get_tuple_complex_complex (< crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (tuple)) ; obj } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::get_vec_of_tuples`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_get_vec_of_tuples () -> * mut crate :: fermented :: generics :: Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { let obj = example_simple :: types :: tuple_in_functions :: get_vec_of_tuples () ; < crate :: fermented :: generics :: Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionTo < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::set_vec_of_tuples`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_set_vec_of_tuples (vec : * mut crate :: fermented :: generics :: Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { let obj = example_simple :: types :: tuple_in_functions :: set_vec_of_tuples (< crate :: fermented :: generics :: Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionFrom < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > >> :: ffi_from (vec)) ; ; } # [doc = "FFI-representation of the [`example_simple::types::tuple_in_functions::set_slice_of_tuples`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_tuple_in_functions_set_slice_of_tuples (arr : * mut crate :: fermented :: generics :: Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { let obj = example_simple :: types :: tuple_in_functions :: set_slice_of_tuples (Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionFrom < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > >> :: ffi_from (arr)))) ; ; } } pub mod slices { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::types::slices::slice_simple_len`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_slices_slice_simple_len (slice : * mut crate :: fermented :: generics :: Slice_u8) -> usize { let obj = example_simple :: types :: slices :: slice_simple_len (Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (slice)))) ; obj } # [doc = "FFI-representation of the [`example_simple::types::slices::slice_complex_len`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_slices_slice_complex_len (slice : * mut crate :: fermented :: generics :: Slice_example_simple_errors_context_ContextProviderError) -> usize { let obj = example_simple :: types :: slices :: slice_complex_len (Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Vec < example_simple :: errors :: context :: ContextProviderError > >> :: ffi_from (slice)))) ; obj } # [doc = "FFI-representation of the [`example_simple::types::slices::slice_of_string_len`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_slices_slice_of_string_len (slice : * mut crate :: fermented :: generics :: Slice_String) -> usize { let obj = example_simple :: types :: slices :: slice_of_string_len (Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (slice)))) ; obj } # [doc = "FFI-representation of the [`example_simple::types::slices::slice_generic_len`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_slices_slice_generic_len (slice : * mut crate :: fermented :: generics :: Slice_Vec_example_simple_errors_context_ContextProviderError) -> usize { let obj = example_simple :: types :: slices :: slice_generic_len (Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Vec < Vec < example_simple :: errors :: context :: ContextProviderError > > >> :: ffi_from (slice)))) ; obj } } pub mod callback { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::types::callback::QuorumPublicKeyCallback`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_types_callback_QuorumPublicKeyCallback { caller : unsafe extern "C" fn (quorum_type : u32 , quorum_hash : * mut crate :: fermented :: generics :: Arr_u8_48 , core_chain_locked_height : u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (result : * mut crate :: fermented :: generics :: Arr_u8_32) , } impl example_simple_types_callback_QuorumPublicKeyCallback { pub unsafe fn call (& self , quorum_type : u32 , quorum_hash : [u8 ; 48] , core_chain_locked_height : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (quorum_type , ferment :: FFIConversionTo :: ffi_to (quorum_hash) , core_chain_locked_height) ; let result = ferment :: FFIConversionFrom :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [doc = "FFI-representation of the [`example_simple::types::callback::get_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_callback_get_quorum (callback : crate :: fermented :: generics :: Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { let obj = example_simple :: types :: callback :: get_quorum (move | o_0 , o_1 , o_2 | unsafe { callback . call (o_0 , o_1 , o_2) }) ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj) } } pub mod result { use crate as example_nested ; # [doc = "FFI-representation of the [`ResultAll`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_types_result_ResultAll { pub primitive_primitive : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , pub primitive_string : * mut crate :: fermented :: generics :: Result_ok_u32_err_String , pub primitive_complex : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError , pub primitive_generic : * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError , pub primitive_opaque : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque } impl ferment :: FFIConversionFrom < example_simple :: types :: result :: ResultAll > for example_simple_types_result_ResultAll { unsafe fn ffi_from_const (ffi : * const example_simple_types_result_ResultAll) -> example_simple :: types :: result :: ResultAll { let ffi_ref = & * ffi ; example_simple :: types :: result :: ResultAll { primitive_primitive : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionFrom < Result < u32 , u32 > >> :: ffi_from (ffi_ref . primitive_primitive) , primitive_string : < crate :: fermented :: generics :: Result_ok_u32_err_String as ferment :: FFIConversionFrom < Result < u32 , String > >> :: ffi_from (ffi_ref . primitive_string) , primitive_complex : < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: context :: ContextProviderError > >> :: ffi_from (ffi_ref . primitive_complex) , primitive_generic : < crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > >> :: ffi_from (ffi_ref . primitive_generic) , primitive_opaque : < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque > >> :: ffi_from (ffi_ref . primitive_opaque) } } } impl ferment :: FFIConversionTo < example_simple :: types :: result :: ResultAll > for example_simple_types_result_ResultAll { unsafe fn ffi_to_const (obj : example_simple :: types :: result :: ResultAll) -> * const example_simple_types_result_ResultAll { ferment :: boxed (example_simple_types_result_ResultAll { primitive_primitive : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj . primitive_primitive) , primitive_string : < crate :: fermented :: generics :: Result_ok_u32_err_String as ferment :: FFIConversionTo < Result < u32 , String > >> :: ffi_to (obj . primitive_string) , primitive_complex : < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: context :: ContextProviderError > >> :: ffi_to (obj . primitive_complex) , primitive_generic : < crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > >> :: ffi_to (obj . primitive_generic) , primitive_opaque : < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque as ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque > >> :: ffi_to (obj . primitive_opaque) }) } } impl Drop for example_simple_types_result_ResultAll { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . primitive_primitive) ; ferment :: unbox_any (ffi_ref . primitive_string) ; ferment :: unbox_any (ffi_ref . primitive_complex) ; ferment :: unbox_any (ffi_ref . primitive_generic) ; ferment :: unbox_any (ffi_ref . primitive_opaque) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_ctor (primitive_primitive : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , primitive_string : * mut crate :: fermented :: generics :: Result_ok_u32_err_String , primitive_complex : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError , primitive_generic : * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError , primitive_opaque : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque) -> * mut example_simple_types_result_ResultAll { ferment :: boxed (example_simple_types_result_ResultAll { primitive_primitive , primitive_string , primitive_complex , primitive_generic , primitive_opaque }) } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_destroy (ffi : * mut example_simple_types_result_ResultAll) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_get_primitive_primitive (obj : * const example_simple_types_result_ResultAll) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { (* obj) . primitive_primitive } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_get_primitive_string (obj : * const example_simple_types_result_ResultAll) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_String { (* obj) . primitive_string } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_get_primitive_complex (obj : * const example_simple_types_result_ResultAll) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError { (* obj) . primitive_complex } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_get_primitive_generic (obj : * const example_simple_types_result_ResultAll) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { (* obj) . primitive_generic } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_get_primitive_opaque (obj : * const example_simple_types_result_ResultAll) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { (* obj) . primitive_opaque } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_set_primitive_primitive (obj : * mut example_simple_types_result_ResultAll , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32) { (* obj) . primitive_primitive = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_set_primitive_string (obj : * mut example_simple_types_result_ResultAll , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_String) { (* obj) . primitive_string = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_set_primitive_complex (obj : * mut example_simple_types_result_ResultAll , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError) { (* obj) . primitive_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_set_primitive_generic (obj : * mut example_simple_types_result_ResultAll , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError) { (* obj) . primitive_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_ResultAll_set_primitive_opaque (obj : * mut example_simple_types_result_ResultAll , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque) { (* obj) . primitive_opaque = value ; } # [doc = "FFI-representation of the [`example_simple::types::result::primitive_primitive`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_primitive_primitive (result : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_simple :: types :: result :: primitive_primitive (< crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionFrom < Result < u32 , u32 > >> :: ffi_from (result)) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::result::primitive_string`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_primitive_string (result : * mut crate :: fermented :: generics :: Result_ok_u32_err_String) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_String { let obj = example_simple :: types :: result :: primitive_string (< crate :: fermented :: generics :: Result_ok_u32_err_String as ferment :: FFIConversionFrom < Result < u32 , String > >> :: ffi_from (result)) ; < crate :: fermented :: generics :: Result_ok_u32_err_String as ferment :: FFIConversionTo < Result < u32 , String > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::result::primitive_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_primitive_complex (result : * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError { let obj = example_simple :: types :: result :: primitive_complex (< crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: context :: ContextProviderError > >> :: ffi_from (result)) ; < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: context :: ContextProviderError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::result::primitive_generic`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_result_primitive_generic (result : * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { let obj = example_simple :: types :: result :: primitive_generic (< crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > >> :: ffi_from (result)) ; < crate :: fermented :: generics :: Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > >> :: ffi_to (obj) } } pub mod opaque { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_function`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_function (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { let obj = example_simple :: types :: opaque :: opaque_cloneable_function (std :: ptr :: read (input)) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_with_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_with_ref (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> u32 { let obj = example_simple :: types :: opaque :: opaque_cloneable_with_ref (& * input) ; obj } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_modifier`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_modifier (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType , value : u32) { let obj = example_simple :: types :: opaque :: opaque_cloneable_modifier (& mut * input , value) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::maybe_opaque_cloneable`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_maybe_opaque_cloneable (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { let obj = example_simple :: types :: opaque :: maybe_opaque_cloneable (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 as ferment :: FFIConversionTo < Result < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_vec`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_vec (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: Vec_example_simple_types_opaque_OpaqueCloneableType { let obj = example_simple :: types :: opaque :: opaque_cloneable_vec (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: Vec_example_simple_types_opaque_OpaqueCloneableType as ferment :: FFIConversionTo < Vec < example_simple :: types :: opaque :: OpaqueCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_map1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_map1 (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { let obj = example_simple :: types :: opaque :: opaque_cloneable_map1 (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_map2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_map2 (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { let obj = example_simple :: types :: opaque :: opaque_cloneable_map2 (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_map3`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_map3 (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { let obj = example_simple :: types :: opaque :: opaque_cloneable_map3 (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < example_simple :: types :: opaque :: OpaqueCloneableType > > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_set`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_set (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut crate :: fermented :: generics :: std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { let obj = example_simple :: types :: opaque :: opaque_cloneable_set (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType as ferment :: FFIConversionTo < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_tuple`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_tuple (input : * mut crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueCloneableType_u32) -> * mut crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { let obj = example_simple :: types :: opaque :: opaque_cloneable_tuple (< crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 as ferment :: FFIConversionFrom < (example_simple :: types :: opaque :: OpaqueCloneableType , u32) >> :: ffi_from (input)) ; < crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 as ferment :: FFIConversionTo < (example_simple :: types :: opaque :: OpaqueCloneableType , u32) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_cloneable_callback`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_cloneable_callback (input : * mut example_simple :: types :: opaque :: OpaqueCloneableType , callback : crate :: fermented :: generics :: Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_) { let obj = example_simple :: types :: opaque :: opaque_cloneable_callback (std :: ptr :: read (input) , move | o_0 | unsafe { callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueCloneableType::new`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueCloneableType_new (field1 : u32 , field2 : * mut std :: os :: raw :: c_char) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { let obj = example_simple :: types :: opaque :: OpaqueCloneableType :: new (field1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (field2)) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueCloneableType::field1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueCloneableType_field1 (self_ : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> u32 { let obj = example_simple :: types :: opaque :: OpaqueCloneableType :: field1 (& * self_) ; obj } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueCloneableType::field2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueCloneableType_field2 (self_ : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut std :: os :: raw :: c_char { let obj = example_simple :: types :: opaque :: OpaqueCloneableType :: field2 (& * self_) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueCloneableType::update_field1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueCloneableType_update_field1 (self_ : * mut example_simple :: types :: opaque :: OpaqueCloneableType , value : u32) { let obj = example_simple :: types :: opaque :: OpaqueCloneableType :: update_field1 (& mut * self_ , value) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueCloneableType::update_field2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueCloneableType_update_field2 (self_ : * mut example_simple :: types :: opaque :: OpaqueCloneableType , value : * mut std :: os :: raw :: c_char) { let obj = example_simple :: types :: opaque :: OpaqueCloneableType :: update_field2 (& mut * self_ , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (value)) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_function`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_function (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut example_simple :: types :: opaque :: OpaqueNonCloneableType { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_function (std :: ptr :: read (input)) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_with_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_with_ref (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> u32 { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_with_ref (& * input) ; obj } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_modifier`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_modifier (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , value : u32) { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_modifier (& mut * input , value) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::maybe_opaque_non_cloneable`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_maybe_opaque_non_cloneable (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut crate :: fermented :: generics :: Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { let obj = example_simple :: types :: opaque :: maybe_opaque_non_cloneable (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 as ferment :: FFIConversionTo < Result < example_simple :: types :: opaque :: OpaqueNonCloneableType , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_vec`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_vec (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut crate :: fermented :: generics :: Vec_example_simple_types_opaque_OpaqueNonCloneableType { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_vec (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: Vec_example_simple_types_opaque_OpaqueNonCloneableType as ferment :: FFIConversionTo < Vec < example_simple :: types :: opaque :: OpaqueNonCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_map1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_map1 (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_map1 (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueNonCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_set`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_set (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut crate :: fermented :: generics :: std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_set (std :: ptr :: read (input)) ; < crate :: fermented :: generics :: std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType as ferment :: FFIConversionTo < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueNonCloneableType > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_tuple`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_tuple (input : * mut crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32) -> * mut crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_tuple (< crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 as ferment :: FFIConversionFrom < (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32) >> :: ffi_from (input)) ; < crate :: fermented :: generics :: Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 as ferment :: FFIConversionTo < (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::opaque_non_cloneable_callback`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_opaque_non_cloneable_callback (input : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , callback : crate :: fermented :: generics :: Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_) { let obj = example_simple :: types :: opaque :: opaque_non_cloneable_callback (std :: ptr :: read (input) , move | o_0 | unsafe { callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueNonCloneableType::new`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueNonCloneableType_new (field1 : u32 , field2 : * mut std :: os :: raw :: c_char) -> * mut example_simple :: types :: opaque :: OpaqueNonCloneableType { let obj = example_simple :: types :: opaque :: OpaqueNonCloneableType :: new (field1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (field2)) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueNonCloneableType::field1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueNonCloneableType_field1 (self_ : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> u32 { let obj = example_simple :: types :: opaque :: OpaqueNonCloneableType :: field1 (& * self_) ; obj } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueNonCloneableType::field2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueNonCloneableType_field2 (self_ : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut std :: os :: raw :: c_char { let obj = example_simple :: types :: opaque :: OpaqueNonCloneableType :: field2 (& * self_) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueNonCloneableType::update_field1`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueNonCloneableType_update_field1 (self_ : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , value : u32) { let obj = example_simple :: types :: opaque :: OpaqueNonCloneableType :: update_field1 (& mut * self_ , value) ; ; } # [doc = "FFI-representation of the [`example_simple::types::opaque::OpaqueNonCloneableType::update_field2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_types_opaque_OpaqueNonCloneableType_update_field2 (self_ : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , value : * mut std :: os :: raw :: c_char) { let obj = example_simple :: types :: opaque :: OpaqueNonCloneableType :: update_field2 (& mut * self_ , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (value)) ; ; } } } # [doc = "FFI-representation of the [`Unstable`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_Unstable { pub secs : * mut [u8 ; 16] , pub nanos : * mut [u8 ; 16] } impl ferment :: FFIConversionFrom < example_simple :: Unstable > for example_simple_Unstable { unsafe fn ffi_from_const (ffi : * const example_simple_Unstable) -> example_simple :: Unstable { let ffi_ref = & * ffi ; example_simple :: Unstable { secs : < [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (ffi_ref . secs) , nanos : < [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (ffi_ref . nanos) } } } impl ferment :: FFIConversionTo < example_simple :: Unstable > for example_simple_Unstable { unsafe fn ffi_to_const (obj : example_simple :: Unstable) -> * const example_simple_Unstable { ferment :: boxed (example_simple_Unstable { secs : < [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (obj . secs) , nanos : < [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (obj . nanos) }) } } impl Drop for example_simple_Unstable { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . secs) ; ferment :: unbox_any_opt (ffi_ref . nanos) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_ctor (secs : * mut [u8 ; 16] , nanos : * mut [u8 ; 16]) -> * mut example_simple_Unstable { ferment :: boxed (example_simple_Unstable { secs , nanos }) } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_destroy (ffi : * mut example_simple_Unstable) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_get_secs (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . secs } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_get_nanos (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . nanos } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_set_secs (obj : * mut example_simple_Unstable , value : * mut [u8 ; 16]) { (* obj) . secs = value ; } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_set_nanos (obj : * mut example_simple_Unstable , value : * mut [u8 ; 16]) { (* obj) . nanos = value ; } # [doc = "FFI-representation of the [`RootStruct`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_RootStruct { pub name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_simple :: RootStruct > for example_simple_RootStruct { unsafe fn ffi_from_const (ffi : * const example_simple_RootStruct) -> example_simple :: RootStruct { let ffi_ref = & * ffi ; example_simple :: RootStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) } } } impl ferment :: FFIConversionTo < example_simple :: RootStruct > for example_simple_RootStruct { unsafe fn ffi_to_const (obj : example_simple :: RootStruct) -> * const example_simple_RootStruct { ferment :: boxed (example_simple_RootStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) }) } } impl Drop for example_simple_RootStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_ctor (name : * mut std :: os :: raw :: c_char) -> * mut example_simple_RootStruct { ferment :: boxed (example_simple_RootStruct { name }) } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_destroy (ffi : * mut example_simple_RootStruct) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_get_name (obj : * const example_simple_RootStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_set_name (obj : * mut example_simple_RootStruct , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [doc = "FFI-representation of the [`example_simple::get_root_struct`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_get_root_struct () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: get_root_struct () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } pub mod nested { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::nested::get_root_struct_2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_nested_get_root_struct_2 () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: nested :: get_root_struct_2 () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`RootUser`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_nested_RootUser { pub root : * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct } impl ferment :: FFIConversionFrom < example_simple :: nested :: RootUser > for example_simple_nested_RootUser { unsafe fn ffi_from_const (ffi : * const example_simple_nested_RootUser) -> example_simple :: nested :: RootUser { let ffi_ref = & * ffi ; example_simple :: nested :: RootUser { root : < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionFrom < example_simple :: RootStruct >> :: ffi_from (ffi_ref . root) } } } impl ferment :: FFIConversionTo < example_simple :: nested :: RootUser > for example_simple_nested_RootUser { unsafe fn ffi_to_const (obj : example_simple :: nested :: RootUser) -> * const example_simple_nested_RootUser { ferment :: boxed (example_simple_nested_RootUser { root : < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj . root) }) } } impl Drop for example_simple_nested_RootUser { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . root) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_ctor (root : * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct) -> * mut example_simple_nested_RootUser { ferment :: boxed (example_simple_nested_RootUser { root }) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_destroy (ffi : * mut example_simple_nested_RootUser) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_get_root (obj : * const example_simple_nested_RootUser) -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { (* obj) . root } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_set_root (obj : * mut example_simple_nested_RootUser , value : * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct) { (* obj) . root = value ; } pub mod double_nested { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::nested::double_nested::get_root_struct_3`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_nested_double_nested_get_root_struct_3 () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: nested :: double_nested :: get_root_struct_3 () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } } # [doc = "FFI-representation of the [`HashID`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_nested_HashID (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < example_simple :: nested :: HashID > for example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const example_simple_nested_HashID) -> example_simple :: nested :: HashID { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < example_simple :: nested :: HashID > for example_simple_nested_HashID { unsafe fn ffi_to_const (obj : example_simple :: nested :: HashID) -> * const example_simple_nested_HashID { ferment :: boxed (example_simple_nested_HashID (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj))) } } impl Drop for example_simple_nested_HashID { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_ctor (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut example_simple_nested_HashID { ferment :: boxed (example_simple_nested_HashID (o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_destroy (ffi : * mut example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_get_0 (obj : * const example_simple_nested_HashID) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_set_0 (obj : * mut example_simple_nested_HashID , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestEnum`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_nested_TestEnum { Variant1 (* mut std :: os :: raw :: c_char) , Variant2 , Variant3 (* mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , u32) , Variant4 (* mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , u32 , * mut std :: os :: raw :: c_char) , Variant5 (* mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID , u32 , * mut std :: os :: raw :: c_char) , Variant6 (* mut crate :: fermented :: generics :: Arr_u8_32) } impl ferment :: FFIConversionFrom < example_simple :: nested :: TestEnum > for example_simple_nested_TestEnum { unsafe fn ffi_from_const (ffi : * const example_simple_nested_TestEnum) -> example_simple :: nested :: TestEnum { let ffi_ref = & * ffi ; match ffi_ref { example_simple_nested_TestEnum :: Variant1 (o_0) => example_simple :: nested :: TestEnum :: Variant1 (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_nested_TestEnum :: Variant2 => example_simple :: nested :: TestEnum :: Variant2 , example_simple_nested_TestEnum :: Variant3 (o_0 , o_1) => example_simple :: nested :: TestEnum :: Variant3 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (* o_0) , * o_1) , example_simple_nested_TestEnum :: Variant4 (o_0 , o_1 , o_2) => example_simple :: nested :: TestEnum :: Variant4 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (* o_0) , * o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_2)) , example_simple_nested_TestEnum :: Variant5 (o_0 , o_1 , o_2) => example_simple :: nested :: TestEnum :: Variant5 (< crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > >> :: ffi_from (* o_0) , * o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_2)) , example_simple_nested_TestEnum :: Variant6 (o_0) => example_simple :: nested :: TestEnum :: Variant6 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: nested :: TestEnum > for example_simple_nested_TestEnum { unsafe fn ffi_to_const (obj : example_simple :: nested :: TestEnum) -> * const example_simple_nested_TestEnum { ferment :: boxed (match obj { example_simple :: nested :: TestEnum :: Variant1 (o_0) => example_simple_nested_TestEnum :: Variant1 (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: nested :: TestEnum :: Variant2 => example_simple_nested_TestEnum :: Variant2 , example_simple :: nested :: TestEnum :: Variant3 (o_0 , o_1) => example_simple_nested_TestEnum :: Variant3 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o_0) , o_1) , example_simple :: nested :: TestEnum :: Variant4 (o_0 , o_1 , o_2) => example_simple_nested_TestEnum :: Variant4 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o_0) , o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_2)) , example_simple :: nested :: TestEnum :: Variant5 (o_0 , o_1 , o_2) => example_simple_nested_TestEnum :: Variant5 (< crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > >> :: ffi_to (o_0) , o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_2)) , example_simple :: nested :: TestEnum :: Variant6 (o_0) => example_simple_nested_TestEnum :: Variant6 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_nested_TestEnum { fn drop (& mut self) { unsafe { match self { example_simple_nested_TestEnum :: Variant1 (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_nested_TestEnum :: Variant2 => { } , example_simple_nested_TestEnum :: Variant3 (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ; } , example_simple_nested_TestEnum :: Variant4 (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ; ; ferment :: unbox_string (* o_2) ; } , example_simple_nested_TestEnum :: Variant5 (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ; ; ferment :: unbox_string (* o_2) ; } , example_simple_nested_TestEnum :: Variant6 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant1_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant2_ctor () -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant2 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant3_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_o_1 : u32) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant3 (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant4_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_o_1 : u32 , o_o_2 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant4 (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant5_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID , o_o_1 : u32 , o_o_2 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant5 (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant6_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant6 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_destroy (ffi : * mut example_simple_nested_TestEnum) { ferment :: unbox_any (ffi) ; } } } pub mod dpp { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; pub mod errors { use crate as example_nested ; pub mod contract { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_contract_DataContractError { DecodingContractError (* mut dpp :: consensus :: basic :: decode :: DecodingError) , DecodingDocumentError (* mut dpp :: consensus :: basic :: decode :: DecodingError) , InvalidDocumentTypeError (* mut dpp :: consensus :: basic :: document :: InvalidDocumentTypeError) , DocumentTypesAreMissingError (* mut dpp :: consensus :: basic :: data_contract :: DocumentTypesAreMissingError) , MissingRequiredKey (* mut std :: os :: raw :: c_char) , FieldRequirementUnmet (* mut std :: os :: raw :: c_char) , RegexError (* mut std :: os :: raw :: c_char) , KeyWrongType (* mut std :: os :: raw :: c_char) , ValueWrongType (* mut std :: os :: raw :: c_char) , InvalidURI (* mut std :: os :: raw :: c_char) , KeyWrongBounds (* mut std :: os :: raw :: c_char) , KeyValueMustExist (* mut std :: os :: raw :: c_char) , ValueDecodingError (* mut std :: os :: raw :: c_char) , EncodingDataStructureNotSupported (* mut std :: os :: raw :: c_char) , InvalidContractStructure (* mut std :: os :: raw :: c_char) , DocumentTypeNotFound (* mut std :: os :: raw :: c_char) , DocumentTypeFieldNotFound (* mut std :: os :: raw :: c_char) , ReferenceDefinitionNotFound (* mut std :: os :: raw :: c_char) , DocumentOwnerIdMissing (* mut std :: os :: raw :: c_char) , DocumentIdMissing (* mut std :: os :: raw :: c_char) , Unsupported (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , JsonSchema (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_contract_DataContractError) -> dpp :: data_contract :: errors :: contract :: DataContractError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (std :: ptr :: read (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (std :: ptr :: read (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (std :: ptr :: read (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (std :: ptr :: read (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: contract :: DataContractError) -> * const dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (ferment :: boxed (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (ferment :: boxed (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (ferment :: boxed (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (ferment :: boxed (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (o_0) => dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (o_0) => dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (o_0) => dpp_data_contract_errors_contract_DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (o_0) => dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (o_0) => dpp_data_contract_errors_contract_DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_contract_DataContractError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DecodingContractError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: decode :: DecodingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DecodingDocumentError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: decode :: DecodingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidDocumentTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: InvalidDocumentTypeError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypesAreMissingError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DocumentTypesAreMissingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_MissingRequiredKey_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_FieldRequirementUnmet_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_RegexError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: RegexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyWrongType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ValueWrongType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidURI_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyWrongBounds_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyValueMustExist_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ValueDecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_EncodingDataStructureNotSupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidContractStructure_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypeNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypeFieldNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ReferenceDefinitionNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentOwnerIdMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentIdMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_Unsupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_CorruptedSerialization_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_JsonSchema_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_destroy (ffi : * mut dpp_data_contract_errors_contract_DataContractError) { ferment :: unbox_any (ffi) ; } } pub mod data_contract_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_destroy (ffi : * mut dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_get_data_contract_id (obj : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_set_data_contract_id (obj : * mut dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod identity_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { pub id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { id : std :: ptr :: read (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError) -> * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { ferment :: boxed (dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { id : ferment :: boxed (obj . id) }) } } impl Drop for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_ctor (id : * mut types :: identifier :: Identifier) -> * mut dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { ferment :: boxed (dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_destroy (ffi : * mut dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_get_id (obj : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_set_id (obj : * mut dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } } pub mod invalid_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { pub doc_type : * mut std :: os :: raw :: c_char , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (ffi_ref . data_contract) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (obj . data_contract) }) } } impl Drop for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . doc_type) ; ferment :: unbox_any (ffi_ref . data_contract) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_ctor (doc_type : * mut std :: os :: raw :: c_char , data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { doc_type , data_contract }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_destroy (ffi : * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_get_doc_type (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . doc_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_get_data_contract (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_set_doc_type (obj : * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . doc_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_set_data_contract (obj : * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) { (* obj) . data_contract = value ; } } pub mod json_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`JsonSchemaError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_json_schema_error_JsonSchemaError { CreateSchemaError (* mut std :: os :: raw :: c_char) , SchemaCompatibilityValidationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_json_schema_error_JsonSchemaError) -> dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError) -> * const dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_json_schema_error_JsonSchemaError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_CreateSchemaError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_SchemaCompatibilityValidationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_destroy (ffi : * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError) { ferment :: unbox_any (ffi) ; } } } pub mod extra { use crate as example_nested ; # [cfg (test)] pub mod drive_api_tests { use crate as example_nested ; } } # [cfg (any (feature = "state-transitions" , feature = "factories"))] pub mod created_data_contract { use crate as example_nested ; pub mod fields { use crate as example_nested ; } } pub mod document_type { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod property { use crate as example_nested ; pub mod array { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ArrayItemType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_array_ArrayItemType { Integer , Number , String (* mut usize , * mut usize) , ByteArray (* mut usize , * mut usize) , Identifier , Boolean , Date } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_array_ArrayItemType) -> dpp :: data_contract :: document_type :: property :: array :: ArrayItemType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: array :: ArrayItemType) -> * const dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer => dpp_data_contract_document_type_property_array_ArrayItemType :: Integer , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number => dpp_data_contract_document_type_property_array_ArrayItemType :: Number , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: String (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier => dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean => dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date => dpp_data_contract_document_type_property_array_ArrayItemType :: Date , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => { ferment :: unbox_any_opt (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => { ferment :: unbox_any_opt (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Integer_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Integer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Number_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Number { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_String_ctor (o_o_0 : * mut usize , o_o_1 : * mut usize) -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_ByteArray_ctor (o_o_0 : * mut usize , o_o_1 : * mut usize) -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Identifier_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Boolean_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Date_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Date { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_destroy (ffi : * mut dpp_data_contract_document_type_property_array_ArrayItemType) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`DocumentProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_DocumentProperty { pub property_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType , pub required : bool , pub transient : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentProperty) -> dpp :: data_contract :: document_type :: property :: DocumentProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_from (ffi_ref . property_type) , required : ffi_ref . required , transient : ffi_ref . transient } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentProperty) -> * const dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (dpp_data_contract_document_type_property_DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_to (obj . property_type) , required : obj . required , transient : obj . transient }) } } impl Drop for dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . property_type) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_ctor (property_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType , required : bool , transient : bool) -> * mut dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (dpp_data_contract_document_type_property_DocumentProperty { property_type , required , transient }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_destroy (ffi : * mut dpp_data_contract_document_type_property_DocumentProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_property_type (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType { (* obj) . property_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_required (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . required } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_transient (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . transient } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_property_type (obj : * mut dpp_data_contract_document_type_property_DocumentProperty , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType) { (* obj) . property_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_required (obj : * mut dpp_data_contract_document_type_property_DocumentProperty , value : bool) { (* obj) . required = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_transient (obj : * mut dpp_data_contract_document_type_property_DocumentProperty , value : bool) { (* obj) . transient = value ; } # [doc = "FFI-representation of the [`StringPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_StringPropertySizes { pub min_length : * mut u16 , pub max_length : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_StringPropertySizes) -> dpp :: data_contract :: document_type :: property :: StringPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: StringPropertySizes { min_length : ferment :: from_opt_primitive (ffi_ref . min_length) , max_length : ferment :: from_opt_primitive (ffi_ref . max_length) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: StringPropertySizes) -> * const dpp_data_contract_document_type_property_StringPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_StringPropertySizes { min_length : ferment :: to_opt_primitive (obj . min_length) , max_length : ferment :: to_opt_primitive (obj . max_length) }) } } impl Drop for dpp_data_contract_document_type_property_StringPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . min_length) ; ferment :: unbox_any_opt (ffi_ref . max_length) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_ctor (min_length : * mut u16 , max_length : * mut u16) -> * mut dpp_data_contract_document_type_property_StringPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_StringPropertySizes { min_length , max_length }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_destroy (ffi : * mut dpp_data_contract_document_type_property_StringPropertySizes) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_get_min_length (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . min_length } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_get_max_length (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . max_length } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_set_min_length (obj : * mut dpp_data_contract_document_type_property_StringPropertySizes , value : * mut u16) { (* obj) . min_length = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_set_max_length (obj : * mut dpp_data_contract_document_type_property_StringPropertySizes , value : * mut u16) { (* obj) . max_length = value ; } # [doc = "FFI-representation of the [`ByteArrayPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_ByteArrayPropertySizes { pub min_size : * mut u16 , pub max_size : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { min_size : ferment :: from_opt_primitive (ffi_ref . min_size) , max_size : ferment :: from_opt_primitive (ffi_ref . max_size) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes) -> * const dpp_data_contract_document_type_property_ByteArrayPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_ByteArrayPropertySizes { min_size : ferment :: to_opt_primitive (obj . min_size) , max_size : ferment :: to_opt_primitive (obj . max_size) }) } } impl Drop for dpp_data_contract_document_type_property_ByteArrayPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . min_size) ; ferment :: unbox_any_opt (ffi_ref . max_size) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_ctor (min_size : * mut u16 , max_size : * mut u16) -> * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_ByteArrayPropertySizes { min_size , max_size }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_destroy (ffi : * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_get_min_size (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . min_size } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_get_max_size (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . max_size } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_set_min_size (obj : * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes , value : * mut u16) { (* obj) . min_size = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_set_max_size (obj : * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes , value : * mut u16) { (* obj) . max_size = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPropertyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_DocumentPropertyType { U128 , I128 , U64 , I64 , U32 , I32 , U16 , I16 , U8 , I8 , F64 , String (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes) , ByteArray (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes) , Identifier , Boolean , Date , Object (* mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) , Array (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) , VariableTypeArray (* mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentPropertyType) -> dpp :: data_contract :: document_type :: property :: DocumentPropertyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentPropertyType) -> * const dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 => dpp_data_contract_document_type_property_DocumentPropertyType :: U128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 => dpp_data_contract_document_type_property_DocumentPropertyType :: I128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 => dpp_data_contract_document_type_property_DocumentPropertyType :: U64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 => dpp_data_contract_document_type_property_DocumentPropertyType :: I64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 => dpp_data_contract_document_type_property_DocumentPropertyType :: U32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 => dpp_data_contract_document_type_property_DocumentPropertyType :: I32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 => dpp_data_contract_document_type_property_DocumentPropertyType :: U16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 => dpp_data_contract_document_type_property_DocumentPropertyType :: I16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 => dpp_data_contract_document_type_property_DocumentPropertyType :: U8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 => dpp_data_contract_document_type_property_DocumentPropertyType :: I8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 => dpp_data_contract_document_type_property_DocumentPropertyType :: F64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier => dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean => dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date => dpp_data_contract_document_type_property_DocumentPropertyType :: Date , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_DocumentPropertyType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U128_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U128 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I128_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I128 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U32_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U32 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I32_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I32 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U16_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U16 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I16_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I16 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U8_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U8 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I8_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I8 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_F64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: F64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_String_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_ByteArray_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Identifier_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Boolean_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Date_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Date { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Object_ctor (o_o_0 : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Array_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_VariableTypeArray_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_destroy (ffi : * mut dpp_data_contract_document_type_property_DocumentPropertyType) { ferment :: unbox_any (ffi) ; } } pub mod class_methods { use crate as example_nested ; pub mod create_document_types_from_document_schemas { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod try_from_schema { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod v1 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod index { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`OrderBy`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_OrderBy { Asc , Desc } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_OrderBy) -> dpp :: data_contract :: document_type :: index :: OrderBy { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_OrderBy :: Asc => dpp :: data_contract :: document_type :: index :: OrderBy :: Asc , dpp_data_contract_document_type_index_OrderBy :: Desc => dpp :: data_contract :: document_type :: index :: OrderBy :: Desc } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: OrderBy) -> * const dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: OrderBy :: Asc => dpp_data_contract_document_type_index_OrderBy :: Asc , dpp :: data_contract :: document_type :: index :: OrderBy :: Desc => dpp_data_contract_document_type_index_OrderBy :: Desc , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_OrderBy { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_OrderBy :: Asc => { } , dpp_data_contract_document_type_index_OrderBy :: Desc => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_Asc_ctor () -> * mut dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (dpp_data_contract_document_type_index_OrderBy :: Asc { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_Desc_ctor () -> * mut dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (dpp_data_contract_document_type_index_OrderBy :: Desc { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_destroy (ffi : * mut dpp_data_contract_document_type_index_OrderBy) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexResolution`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexResolution { MasternodeVote = 0 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexResolution) -> dpp :: data_contract :: document_type :: index :: ContestedIndexResolution { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexResolution) -> * const dpp_data_contract_document_type_index_ContestedIndexResolution { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote => dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexResolution { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexResolution_MasternodeVote_ctor () -> * mut dpp_data_contract_document_type_index_ContestedIndexResolution { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexResolution_destroy (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexResolution) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexFieldMatch`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexFieldMatch { Regex (* mut dpp :: data_contract :: document_type :: index :: LazyRegex) , PositiveIntegerMatch (* mut [u8 ; 16]) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex (std :: ptr :: read (* o_0)) , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch) -> * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (ferment :: boxed (o_0)) , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_Regex_ctor (o_o_0 : * mut dpp :: data_contract :: document_type :: index :: LazyRegex) -> * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_PositiveIntegerMatch_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_destroy (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`ContestedIndexInformation`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_ContestedIndexInformation { pub field_matches : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , pub resolution : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_from (ffi_ref . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_from (ffi_ref . resolution) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexInformation) -> * const dpp_data_contract_document_type_index_ContestedIndexInformation { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_to (obj . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_to (obj . resolution) }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexInformation { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . field_matches) ; ferment :: unbox_any (ffi_ref . resolution) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_ctor (field_matches : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , resolution : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution) -> * mut dpp_data_contract_document_type_index_ContestedIndexInformation { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexInformation { field_matches , resolution }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_destroy (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexInformation) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_get_field_matches (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { (* obj) . field_matches } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_get_resolution (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution { (* obj) . resolution } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_set_field_matches (obj : * mut dpp_data_contract_document_type_index_ContestedIndexInformation , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { (* obj) . field_matches = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_set_resolution (obj : * mut dpp_data_contract_document_type_index_ContestedIndexInformation , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution) { (* obj) . resolution = value ; } # [doc = "FFI-representation of the [`Index`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_Index { pub name : * mut std :: os :: raw :: c_char , pub properties : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty , pub unique : bool , pub null_searchable : bool , pub contested_index : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_Index) -> dpp :: data_contract :: document_type :: index :: Index { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_from (ffi_ref . properties) , unique : ffi_ref . unique , null_searchable : ffi_ref . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_from_opt (ffi_ref . contested_index) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: Index) -> * const dpp_data_contract_document_type_index_Index { ferment :: boxed (dpp_data_contract_document_type_index_Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_to (obj . properties) , unique : obj . unique , null_searchable : obj . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_to_opt (obj . contested_index) }) } } impl Drop for dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . properties) ; ; ; ferment :: unbox_any_opt (ffi_ref . contested_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_ctor (name : * mut std :: os :: raw :: c_char , properties : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty , unique : bool , null_searchable : bool , contested_index : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut dpp_data_contract_document_type_index_Index { ferment :: boxed (dpp_data_contract_document_type_index_Index { name , properties , unique , null_searchable , contested_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_destroy (ffi : * mut dpp_data_contract_document_type_index_Index) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_name (obj : * const dpp_data_contract_document_type_index_Index) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_properties (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_unique (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . unique } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_null_searchable (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . null_searchable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_contested_index (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation { (* obj) . contested_index } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_name (obj : * mut dpp_data_contract_document_type_index_Index , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_properties (obj : * mut dpp_data_contract_document_type_index_Index , value : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty) { (* obj) . properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_unique (obj : * mut dpp_data_contract_document_type_index_Index , value : bool) { (* obj) . unique = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_null_searchable (obj : * mut dpp_data_contract_document_type_index_Index , value : bool) { (* obj) . null_searchable = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_contested_index (obj : * mut dpp_data_contract_document_type_index_Index , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation) { (* obj) . contested_index = value ; } # [doc = "FFI-representation of the [`IndexProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_IndexProperty { pub name : * mut std :: os :: raw :: c_char , pub ascending : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_IndexProperty) -> dpp :: data_contract :: document_type :: index :: IndexProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , ascending : ffi_ref . ascending } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: IndexProperty) -> * const dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (dpp_data_contract_document_type_index_IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , ascending : obj . ascending }) } } impl Drop for dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_ctor (name : * mut std :: os :: raw :: c_char , ascending : bool) -> * mut dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (dpp_data_contract_document_type_index_IndexProperty { name , ascending }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_destroy (ffi : * mut dpp_data_contract_document_type_index_IndexProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_get_name (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_get_ascending (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> bool { (* obj) . ascending } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_set_name (obj : * mut dpp_data_contract_document_type_index_IndexProperty , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_set_ascending (obj : * mut dpp_data_contract_document_type_index_IndexProperty , value : bool) { (* obj) . ascending = value ; } } pub mod methods { use crate as example_nested ; # [cfg (feature = "validation")] pub mod validate_update { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod index_level { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IndexType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_level_IndexType { NonUniqueIndex , UniqueIndex , ContestedResourceIndex } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexType) -> dpp :: data_contract :: document_type :: index_level :: IndexType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexType) -> * const dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex => dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_NonUniqueIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_UniqueIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_ContestedResourceIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_destroy (ffi : * mut dpp_data_contract_document_type_index_level_IndexType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`IndexLevelTypeInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { pub should_insert_with_all_null : bool , pub index_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { should_insert_with_all_null : ffi_ref . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_from (ffi_ref . index_type) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo) -> * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { should_insert_with_all_null : obj . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_to (obj . index_type) }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . index_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_ctor (should_insert_with_all_null : bool , index_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType) -> * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { should_insert_with_all_null , index_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_destroy (ffi : * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_get_should_insert_with_all_null (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> bool { (* obj) . should_insert_with_all_null } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_get_index_type (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType { (* obj) . index_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_set_should_insert_with_all_null (obj : * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , value : bool) { (* obj) . should_insert_with_all_null = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_set_index_type (obj : * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType) { (* obj) . index_type = value ; } # [doc = "FFI-representation of the [`IndexLevel`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevel { pub sub_index_levels : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , pub has_index_with_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , pub level_identifier : u64 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevel) -> dpp :: data_contract :: document_type :: index_level :: IndexLevel { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_from (ffi_ref . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_from_opt (ffi_ref . has_index_with_type) , level_identifier : ffi_ref . level_identifier } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevel) -> * const dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_to (obj . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_to_opt (obj . has_index_with_type) , level_identifier : obj . level_identifier }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . sub_index_levels) ; ferment :: unbox_any_opt (ffi_ref . has_index_with_type) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_ctor (sub_index_levels : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , has_index_with_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , level_identifier : u64) -> * mut dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevel { sub_index_levels , has_index_with_type , level_identifier }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_destroy (ffi : * mut dpp_data_contract_document_type_index_level_IndexLevel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_sub_index_levels (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . sub_index_levels } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_has_index_with_type (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { (* obj) . has_index_with_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_level_identifier (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> u64 { (* obj) . level_identifier } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_sub_index_levels (obj : * mut dpp_data_contract_document_type_index_level_IndexLevel , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) { (* obj) . sub_index_levels = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_has_index_with_type (obj : * mut dpp_data_contract_document_type_index_level_IndexLevel , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) { (* obj) . has_index_with_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_level_identifier (obj : * mut dpp_data_contract_document_type_index_level_IndexLevel , value : u64) { (* obj) . level_identifier = value ; } } pub mod restricted_creation { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`CreationRestrictionMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { NoRestrictions , OwnerOnly , NoCreationAllowed } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) -> dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode) -> * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_NoRestrictions_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_OwnerOnly_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_NoCreationAllowed_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_destroy (ffi : * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) { ferment :: unbox_any (ffi) ; } } pub mod schema { use crate as example_nested ; pub mod enrich_with_base_schema { use crate as example_nested ; } pub mod find_identifier_and_binary_paths { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod recursive_schema_validator { use crate as example_nested ; pub mod traversal_validator { use crate as example_nested ; } } # [cfg (feature = "validation")] pub mod validate_max_depth { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [cfg (feature = "validation")] pub mod validate_schema_compatibility { use crate as example_nested ; } } pub mod token_costs { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenCostsV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { pub create : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub replace : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub delete : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub transfer : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub update_price : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , pub purchase : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 > for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 { create : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . create) , replace : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . replace) , delete : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . delete) , transfer : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . transfer) , update_price : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . update_price) , purchase : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_from_opt (ffi_ref . purchase) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 > for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0) -> * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { ferment :: boxed (dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { create : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . create) , replace : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . replace) , delete : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . delete) , transfer : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . transfer) , update_price : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . update_price) , purchase : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost >> :: ffi_to_opt (obj . purchase) }) } } impl Drop for dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . create) ; ferment :: unbox_any_opt (ffi_ref . replace) ; ferment :: unbox_any_opt (ffi_ref . delete) ; ferment :: unbox_any_opt (ffi_ref . transfer) ; ferment :: unbox_any_opt (ffi_ref . update_price) ; ferment :: unbox_any_opt (ffi_ref . purchase) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_ctor (create : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , replace : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , delete : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , transfer : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , update_price : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , purchase : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { ferment :: boxed (dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 { create , replace , delete , transfer , update_price , purchase }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_destroy (ffi : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_create (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . create } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_replace (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . replace } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_delete (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . delete } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_transfer (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . transfer } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_update_price (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . update_price } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_get_purchase (obj : * const dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { (* obj) . purchase } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_create (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . create = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_replace (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . replace = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_delete (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . delete = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_transfer (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . transfer = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_update_price (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . update_price = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_v0_TokenCostsV0_set_purchase (obj : * mut dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { (* obj) . purchase = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenCosts`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_token_costs_TokenCosts { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: TokenCosts > for dpp_data_contract_document_type_token_costs_TokenCosts { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_token_costs_TokenCosts) -> dpp :: data_contract :: document_type :: token_costs :: TokenCosts { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (o_0) => dpp :: data_contract :: document_type :: token_costs :: TokenCosts :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: TokenCosts > for dpp_data_contract_document_type_token_costs_TokenCosts { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: token_costs :: TokenCosts) -> * const dpp_data_contract_document_type_token_costs_TokenCosts { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: token_costs :: TokenCosts :: V0 (o_0) => dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: v0 :: TokenCostsV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_token_costs_TokenCosts { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_TokenCosts_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: v0 :: dpp_data_contract_document_type_token_costs_v0_TokenCostsV0) -> * mut dpp_data_contract_document_type_token_costs_TokenCosts { ferment :: boxed (dpp_data_contract_document_type_token_costs_TokenCosts :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_token_costs_TokenCosts_destroy (ffi : * mut dpp_data_contract_document_type_token_costs_TokenCosts) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v0_DocumentTypeV0 { pub name : * mut std :: os :: raw :: c_char , pub schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , pub index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , pub flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub documents_keep_history : bool , pub documents_mutable : bool , pub documents_can_be_deleted : bool , pub documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , pub trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , pub data_contract_id : * mut types :: identifier :: Identifier , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub security_level_requirement : * mut dpp :: identity :: SecurityLevel , # [cfg (feature = "validation")] pub json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_from (ffi_ref . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (ffi_ref . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . transient_fields) , documents_keep_history : ffi_ref . documents_keep_history , documents_mutable : ffi_ref . documents_mutable , documents_can_be_deleted : ffi_ref . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable >> :: ffi_from (ffi_ref . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionFrom < dpp :: nft :: TradeMode >> :: ffi_from (ffi_ref . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) , data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , security_level_requirement : std :: ptr :: read (ffi_ref . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : std :: ptr :: read (ffi_ref . json_schema_validator) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0) -> * const dpp_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (dpp_data_contract_document_type_v0_DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_to (obj . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (obj . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . transient_fields) , documents_keep_history : obj . documents_keep_history , documents_mutable : obj . documents_mutable , documents_can_be_deleted : obj . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable >> :: ffi_to (obj . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionTo < dpp :: nft :: TradeMode >> :: ffi_to (obj . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) , data_contract_id : ferment :: boxed (obj . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , security_level_requirement : ferment :: boxed (obj . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : ferment :: boxed (obj . json_schema_validator) }) } } impl Drop for dpp_data_contract_document_type_v0_DocumentTypeV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . schema) ; ferment :: unbox_any (ffi_ref . indices) ; ferment :: unbox_any (ffi_ref . index_structure) ; ferment :: unbox_any (ffi_ref . flattened_properties) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any (ffi_ref . identifier_paths) ; ferment :: unbox_any (ffi_ref . binary_paths) ; ferment :: unbox_any (ffi_ref . required_fields) ; ferment :: unbox_any (ffi_ref . transient_fields) ; ; ; ; ferment :: unbox_any (ffi_ref . documents_transferable) ; ferment :: unbox_any (ffi_ref . trade_mode) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ferment :: unbox_any (ffi_ref . security_level_requirement) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . json_schema_validator) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_ctor (name : * mut std :: os :: raw :: c_char , schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , documents_keep_history : bool , documents_mutable : bool , documents_can_be_deleted : bool , documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , data_contract_id : * mut types :: identifier :: Identifier , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , security_level_requirement : * mut dpp :: identity :: SecurityLevel , # [cfg (feature = "validation")] json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator) -> * mut dpp_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (dpp_data_contract_document_type_v0_DocumentTypeV0 { name , schema , indices , index_structure , flattened_properties , properties , identifier_paths , binary_paths , required_fields , transient_fields , documents_keep_history , documents_mutable , documents_can_be_deleted , documents_transferable , trade_mode , creation_restriction_mode , data_contract_id , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key , security_level_requirement , # [cfg (feature = "validation")] json_schema_validator }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_destroy (ffi : * mut dpp_data_contract_document_type_v0_DocumentTypeV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_name (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_schema (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . schema } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_indices (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { (* obj) . indices } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_index_structure (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . index_structure } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_flattened_properties (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . flattened_properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_properties (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_identifier_paths (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . identifier_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_binary_paths (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_required_fields (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . required_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_transient_fields (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . transient_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_keep_history (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_keep_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_mutable (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_mutable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_can_be_deleted (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_transferable (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable { (* obj) . documents_transferable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_trade_mode (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode { (* obj) . trade_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_creation_restriction_mode (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_data_contract_id (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_requires_identity_encryption_bounded_key (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_requires_identity_decryption_bounded_key (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_security_level_requirement (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level_requirement } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_json_schema_validator (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator { (* obj) . json_schema_validator } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_name (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_schema (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { (* obj) . schema = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_indices (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) { (* obj) . indices = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_index_structure (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel) { (* obj) . index_structure = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_flattened_properties (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { (* obj) . flattened_properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_properties (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { (* obj) . properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_identifier_paths (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . identifier_paths = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_binary_paths (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . binary_paths = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_required_fields (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . required_fields = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_transient_fields (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . transient_fields = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_keep_history (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : bool) { (* obj) . documents_keep_history = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_mutable (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : bool) { (* obj) . documents_mutable = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_can_be_deleted (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : bool) { (* obj) . documents_can_be_deleted = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_transferable (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable) { (* obj) . documents_transferable = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_trade_mode (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode) { (* obj) . trade_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_creation_restriction_mode (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) { (* obj) . creation_restriction_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_data_contract_id (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_requires_identity_encryption_bounded_key (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_encryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_requires_identity_decryption_bounded_key (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_decryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_security_level_requirement (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level_requirement = value ; } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_json_schema_validator (obj : * mut dpp_data_contract_document_type_v0_DocumentTypeV0 , value : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator) { (* obj) . json_schema_validator = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v1_DocumentTypeV1 { pub name : * mut std :: os :: raw :: c_char , pub schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , pub index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , pub flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub documents_keep_history : bool , pub documents_mutable : bool , pub documents_can_be_deleted : bool , pub documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , pub trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , pub data_contract_id : * mut types :: identifier :: Identifier , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub security_level_requirement : * mut dpp :: identity :: SecurityLevel , # [cfg (feature = "validation")] pub json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator , pub token_costs : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 > for dpp_data_contract_document_type_v1_DocumentTypeV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_from (ffi_ref . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (ffi_ref . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . transient_fields) , documents_keep_history : ffi_ref . documents_keep_history , documents_mutable : ffi_ref . documents_mutable , documents_can_be_deleted : ffi_ref . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable >> :: ffi_from (ffi_ref . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionFrom < dpp :: nft :: TradeMode >> :: ffi_from (ffi_ref . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) , data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , security_level_requirement : std :: ptr :: read (ffi_ref . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : std :: ptr :: read (ffi_ref . json_schema_validator) , token_costs : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: token_costs :: TokenCosts >> :: ffi_from (ffi_ref . token_costs) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 > for dpp_data_contract_document_type_v1_DocumentTypeV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1) -> * const dpp_data_contract_document_type_v1_DocumentTypeV1 { ferment :: boxed (dpp_data_contract_document_type_v1_DocumentTypeV1 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_to (obj . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (obj . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . transient_fields) , documents_keep_history : obj . documents_keep_history , documents_mutable : obj . documents_mutable , documents_can_be_deleted : obj . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable >> :: ffi_to (obj . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionTo < dpp :: nft :: TradeMode >> :: ffi_to (obj . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) , data_contract_id : ferment :: boxed (obj . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , security_level_requirement : ferment :: boxed (obj . security_level_requirement) , # [cfg (feature = "validation")] json_schema_validator : ferment :: boxed (obj . json_schema_validator) , token_costs : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: token_costs :: TokenCosts >> :: ffi_to (obj . token_costs) }) } } impl Drop for dpp_data_contract_document_type_v1_DocumentTypeV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . schema) ; ferment :: unbox_any (ffi_ref . indices) ; ferment :: unbox_any (ffi_ref . index_structure) ; ferment :: unbox_any (ffi_ref . flattened_properties) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any (ffi_ref . identifier_paths) ; ferment :: unbox_any (ffi_ref . binary_paths) ; ferment :: unbox_any (ffi_ref . required_fields) ; ferment :: unbox_any (ffi_ref . transient_fields) ; ; ; ; ferment :: unbox_any (ffi_ref . documents_transferable) ; ferment :: unbox_any (ffi_ref . trade_mode) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ferment :: unbox_any (ffi_ref . security_level_requirement) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . json_schema_validator) ; ferment :: unbox_any (ffi_ref . token_costs) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_ctor (name : * mut std :: os :: raw :: c_char , schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , documents_keep_history : bool , documents_mutable : bool , documents_can_be_deleted : bool , documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , data_contract_id : * mut types :: identifier :: Identifier , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , security_level_requirement : * mut dpp :: identity :: SecurityLevel , # [cfg (feature = "validation")] json_schema_validator : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator , token_costs : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts) -> * mut dpp_data_contract_document_type_v1_DocumentTypeV1 { ferment :: boxed (dpp_data_contract_document_type_v1_DocumentTypeV1 { name , schema , indices , index_structure , flattened_properties , properties , identifier_paths , binary_paths , required_fields , transient_fields , documents_keep_history , documents_mutable , documents_can_be_deleted , documents_transferable , trade_mode , creation_restriction_mode , data_contract_id , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key , security_level_requirement , # [cfg (feature = "validation")] json_schema_validator , token_costs }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_destroy (ffi : * mut dpp_data_contract_document_type_v1_DocumentTypeV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_name (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_schema (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . schema } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_indices (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { (* obj) . indices } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_index_structure (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . index_structure } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_flattened_properties (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . flattened_properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_properties (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_identifier_paths (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . identifier_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_binary_paths (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_required_fields (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . required_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_transient_fields (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . transient_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_documents_keep_history (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> bool { (* obj) . documents_keep_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_documents_mutable (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> bool { (* obj) . documents_mutable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_documents_can_be_deleted (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> bool { (* obj) . documents_can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_documents_transferable (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable { (* obj) . documents_transferable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_trade_mode (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode { (* obj) . trade_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_creation_restriction_mode (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_data_contract_id (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_requires_identity_encryption_bounded_key (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_requires_identity_decryption_bounded_key (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_security_level_requirement (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level_requirement } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_json_schema_validator (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator { (* obj) . json_schema_validator } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_get_token_costs (obj : * const dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts { (* obj) . token_costs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_name (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_schema (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { (* obj) . schema = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_indices (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) { (* obj) . indices = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_index_structure (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel) { (* obj) . index_structure = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_flattened_properties (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { (* obj) . flattened_properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_properties (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { (* obj) . properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_identifier_paths (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . identifier_paths = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_binary_paths (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . binary_paths = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_required_fields (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . required_fields = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_transient_fields (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . transient_fields = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_documents_keep_history (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : bool) { (* obj) . documents_keep_history = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_documents_mutable (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : bool) { (* obj) . documents_mutable = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_documents_can_be_deleted (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : bool) { (* obj) . documents_can_be_deleted = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_documents_transferable (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable) { (* obj) . documents_transferable = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_trade_mode (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode) { (* obj) . trade_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_creation_restriction_mode (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) { (* obj) . creation_restriction_mode = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_data_contract_id (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_requires_identity_encryption_bounded_key (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_encryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_requires_identity_decryption_bounded_key (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_decryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_security_level_requirement (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level_requirement = value ; } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_json_schema_validator (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut dpp :: data_contract :: document_type :: validator :: StatelessJsonSchemaLazyValidator) { (* obj) . json_schema_validator = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v1_DocumentTypeV1_set_token_costs (obj : * mut dpp_data_contract_document_type_v1_DocumentTypeV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: token_costs :: dpp_data_contract_document_type_token_costs_TokenCosts) { (* obj) . token_costs = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTypeRef`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentTypeRef { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) } impl < 'a , > ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentTypeRef) -> dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (Box :: leak (Box :: new (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)))) , dpp_data_contract_document_type_DocumentTypeRef :: V1 (o_0) => dpp :: data_contract :: document_type :: DocumentTypeRef :: V1 (Box :: leak (Box :: new (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_from (* o_0)))) } } } impl < 'a , > ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentTypeRef < 'a >) -> * const dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (o_0) => dpp_data_contract_document_type_DocumentTypeRef :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0 . clone ())) , dpp :: data_contract :: document_type :: DocumentTypeRef :: V1 (o_0) => dpp_data_contract_document_type_DocumentTypeRef :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_to (o_0 . clone ())) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentTypeRef { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_DocumentTypeRef :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentTypeRef_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentTypeRef_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (dpp_data_contract_document_type_DocumentTypeRef :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentTypeRef_destroy < 'a > (ffi : * mut dpp_data_contract_document_type_DocumentTypeRef) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentType { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentType) -> dpp :: data_contract :: document_type :: DocumentType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_DocumentType :: V1 (o_0) => dpp :: data_contract :: document_type :: DocumentType :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentType) -> * const dpp_data_contract_document_type_DocumentType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentType :: V0 (o_0) => dpp_data_contract_document_type_DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: DocumentType :: V1 (o_0) => dpp_data_contract_document_type_DocumentType :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v1 :: DocumentTypeV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_DocumentType :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentType_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp_data_contract_document_type_DocumentType { ferment :: boxed (dpp_data_contract_document_type_DocumentType :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentType_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v1 :: dpp_data_contract_document_type_v1_DocumentTypeV1) -> * mut dpp_data_contract_document_type_DocumentType { ferment :: boxed (dpp_data_contract_document_type_DocumentType :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentType_destroy (ffi : * mut dpp_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; pub mod conversion { use crate as example_nested ; } pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v0_data_contract_DataContractV0 { pub id : * mut types :: identifier :: Identifier , pub version : u32 , pub owner_id : * mut types :: identifier :: Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub metadata : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v0_data_contract_DataContractV0) -> dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { id : std :: ptr :: read (ffi_ref . id) , version : ffi_ref . version , owner_id : std :: ptr :: read (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionFrom < dpp :: metadata :: Metadata >> :: ffi_from_opt (ffi_ref . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v0 :: data_contract :: DataContractV0) -> * const dpp_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (dpp_data_contract_v0_data_contract_DataContractV0 { id : ferment :: boxed (obj . id) , version : obj . version , owner_id : ferment :: boxed (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionTo < dpp :: metadata :: Metadata >> :: ffi_to_opt (obj . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) }) } } impl Drop for dpp_data_contract_v0_data_contract_DataContractV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any_opt (ffi_ref . metadata) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_ctor (id : * mut types :: identifier :: Identifier , version : u32 , owner_id : * mut types :: identifier :: Identifier , document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , metadata : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) -> * mut dpp_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (dpp_data_contract_v0_data_contract_DataContractV0 { id , version , owner_id , document_types , metadata , config , schema_defs }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_destroy (ffi : * mut dpp_data_contract_v0_data_contract_DataContractV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_id (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_version (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_owner_id (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_document_types (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_metadata (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata { (* obj) . metadata } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_config (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_schema_defs (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_id (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_version (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : u32) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_owner_id (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_document_types (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) { (* obj) . document_types = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_metadata (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata) { (* obj) . metadata = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_config (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig) { (* obj) . config = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_schema_defs (obj : * mut dpp_data_contract_v0_data_contract_DataContractV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { (* obj) . schema_defs = value ; } } pub mod methods { use crate as example_nested ; pub mod schema { use crate as example_nested ; } } pub mod serialization { use crate as example_nested ; } } pub mod v1 { use crate as example_nested ; pub mod conversion { use crate as example_nested ; } pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v1_data_contract_DataContractV1 { pub id : * mut types :: identifier :: Identifier , pub version : u32 , pub owner_id : * mut types :: identifier :: Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub created_at : * mut dpp :: identity :: TimestampMillis , pub updated_at : * mut dpp :: identity :: TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , pub keywords : * mut crate :: fermented :: generics :: Vec_String , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v1_data_contract_DataContractV1) -> dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { id : std :: ptr :: read (ffi_ref . id) , version : ffi_ref . version , owner_id : std :: ptr :: read (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , created_at : ferment :: from_opt_opaque (ffi_ref . created_at) , updated_at : ferment :: from_opt_opaque (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > >> :: ffi_from (ffi_ref . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v1 :: data_contract :: DataContractV1) -> * const dpp_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (dpp_data_contract_v1_data_contract_DataContractV1 { id : ferment :: boxed (obj . id) , version : obj . version , owner_id : ferment :: boxed (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , created_at : ferment :: to_opt_primitive (obj . created_at) , updated_at : ferment :: to_opt_primitive (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > >> :: ffi_to (obj . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . description) }) } } impl Drop for dpp_data_contract_v1_data_contract_DataContractV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; ferment :: unbox_any (ffi_ref . keywords) ; ferment :: unbox_any_opt (ffi_ref . description) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_ctor (id : * mut types :: identifier :: Identifier , version : u32 , owner_id : * mut types :: identifier :: Identifier , document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , created_at : * mut dpp :: identity :: TimestampMillis , updated_at : * mut dpp :: identity :: TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , keywords : * mut crate :: fermented :: generics :: Vec_String , description : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (dpp_data_contract_v1_data_contract_DataContractV1 { id , version , owner_id , document_types , config , schema_defs , created_at , updated_at , created_at_block_height , updated_at_block_height , created_at_epoch , updated_at_epoch , groups , tokens , keywords , description }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_destroy (ffi : * mut dpp_data_contract_v1_data_contract_DataContractV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_id (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_version (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_owner_id (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_document_types (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_config (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_schema_defs (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut dpp :: identity :: TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut dpp :: identity :: TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at_block_height (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at_block_height (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at_epoch (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at_epoch (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_groups (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_tokens (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { (* obj) . tokens } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_keywords (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . keywords } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_description (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut std :: os :: raw :: c_char { (* obj) . description } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_id (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_version (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : u32) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_owner_id (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_document_types (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) { (* obj) . document_types = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_config (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig) { (* obj) . config = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_schema_defs (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { (* obj) . schema_defs = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . created_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . updated_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at_block_height (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . created_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at_block_height (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . updated_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at_epoch (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . created_at_epoch = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at_epoch (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . updated_at_epoch = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_groups (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) { (* obj) . groups = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_tokens (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract) { (* obj) . tokens = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_keywords (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . keywords = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_description (obj : * mut dpp_data_contract_v1_data_contract_DataContractV1 , value : * mut std :: os :: raw :: c_char) { (* obj) . description = value ; } } pub mod methods { use crate as example_nested ; pub mod schema { use crate as example_nested ; } } pub mod serialization { use crate as example_nested ; } } # [cfg (feature = "factories")] pub mod factory { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [cfg (any (feature = "data-contract-value-conversion" , feature = "data-contract-cbor-conversion" , feature = "data-contract-json-conversion"))] pub mod conversion { use crate as example_nested ; # [cfg (feature = "data-contract-cbor-conversion")] pub mod cbor { use crate as example_nested ; } # [cfg (feature = "data-contract-json-conversion")] pub mod json { use crate as example_nested ; } # [cfg (feature = "data-contract-value-conversion")] pub mod value { use crate as example_nested ; } } pub mod methods { use crate as example_nested ; pub mod equal_ignoring_time_based_fields { use crate as example_nested ; } pub mod registration_cost { use crate as example_nested ; } pub mod schema { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validate_document { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validate_groups { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validate_update { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod serialized_version { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { pub id : * mut types :: identifier :: Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut types :: identifier :: Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { id : std :: ptr :: read (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : std :: ptr :: read (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0) -> * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { ferment :: boxed (dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { id : ferment :: boxed (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : ferment :: boxed (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) }) } } impl Drop for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_ctor (id : * mut types :: identifier :: Identifier , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , version : u32 , owner_id : * mut types :: identifier :: Identifier , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) -> * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { ferment :: boxed (dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { id , config , version , owner_id , schema_defs , document_schemas }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_destroy (ffi : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_id (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_config (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_version (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_owner_id (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_schema_defs (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_document_schemas (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_id (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_config (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig) { (* obj) . config = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_version (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : u32) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_owner_id (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_schema_defs (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { (* obj) . schema_defs = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_document_schemas (obj : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) { (* obj) . document_schemas = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { pub id : * mut types :: identifier :: Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut types :: identifier :: Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , pub created_at : * mut dpp :: identity :: TimestampMillis , pub updated_at : * mut dpp :: identity :: TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , pub keywords : * mut crate :: fermented :: generics :: Vec_String , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { id : std :: ptr :: read (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : std :: ptr :: read (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) , created_at : ferment :: from_opt_opaque (ffi_ref . created_at) , updated_at : ferment :: from_opt_opaque (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > >> :: ffi_from (ffi_ref . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1) -> * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { ferment :: boxed (dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { id : ferment :: boxed (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : ferment :: boxed (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) , created_at : ferment :: to_opt_primitive (obj . created_at) , updated_at : ferment :: to_opt_primitive (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > >> :: ffi_to (obj . tokens) , keywords : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . keywords) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . description) }) } } impl Drop for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; ferment :: unbox_any (ffi_ref . keywords) ; ferment :: unbox_any_opt (ffi_ref . description) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_ctor (id : * mut types :: identifier :: Identifier , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , version : u32 , owner_id : * mut types :: identifier :: Identifier , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , created_at : * mut dpp :: identity :: TimestampMillis , updated_at : * mut dpp :: identity :: TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , keywords : * mut crate :: fermented :: generics :: Vec_String , description : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { ferment :: boxed (dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { id , config , version , owner_id , schema_defs , document_schemas , created_at , updated_at , created_at_block_height , updated_at_block_height , created_at_epoch , updated_at_epoch , groups , tokens , keywords , description }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_destroy (ffi : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_id (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_config (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_version (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_owner_id (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_schema_defs (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_document_schemas (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut dpp :: identity :: TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut dpp :: identity :: TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at_block_height (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at_block_height (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at_epoch (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at_epoch (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_groups (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_tokens (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { (* obj) . tokens } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_keywords (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . keywords } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_description (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut std :: os :: raw :: c_char { (* obj) . description } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_id (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_config (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig) { (* obj) . config = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_version (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : u32) { (* obj) . version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_owner_id (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_schema_defs (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { (* obj) . schema_defs = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_document_schemas (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) { (* obj) . document_schemas = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . created_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . updated_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at_block_height (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . created_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at_block_height (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . updated_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at_epoch (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . created_at_epoch = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at_epoch (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . updated_at_epoch = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_groups (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) { (* obj) . groups = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_tokens (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract) { (* obj) . tokens = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_keywords (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . keywords = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_description (obj : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 , value : * mut std :: os :: raw :: c_char) { (* obj) . description = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractInSerializationFormat`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_serialized_version_DataContractInSerializationFormat { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_DataContractInSerializationFormat) -> dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_from (* o_0)) , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat) -> * const dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (match obj { dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_serialized_version_DataContractInSerializationFormat { fn drop (& mut self) { unsafe { match self { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_destroy (ffi : * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat) { ferment :: unbox_any (ffi) ; } } pub mod accessors { use crate as example_nested ; } pub mod associated_token { use crate as example_nested ; pub mod token_configuration { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; pub mod apply_token_configuration_item { use crate as example_nested ; } pub mod authorized_action_takers_for_configuration_item { use crate as example_nested ; } pub mod can_apply_token_configuration_item { use crate as example_nested ; } pub mod validate_token_configuration_groups_exist { use crate as example_nested ; } pub mod validate_token_configuration_update { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; } } pub mod token_configuration_convention { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; pub mod validate_localizations { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigurationConventionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { pub localizations : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , pub decimals : u8 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_from (ffi_ref . localizations) , decimals : ffi_ref . decimals } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0) -> * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_to (obj . localizations) , decimals : obj . decimals }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . localizations) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_ctor (localizations : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , decimals : u8) -> * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { localizations , decimals }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_destroy (ffi : * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_get_localizations (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { (* obj) . localizations } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_get_decimals (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> u8 { (* obj) . decimals } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_set_localizations (obj : * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { (* obj) . localizations = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_set_decimals (obj : * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 , value : u8) { (* obj) . decimals = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationConvention`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention) -> * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> * mut dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention_destroy (ffi : * mut dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention) { ferment :: unbox_any (ffi) ; } } pub mod token_configuration_localization { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigurationLocalizationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { pub should_capitalize : bool , pub singular_form : * mut std :: os :: raw :: c_char , pub plural_form : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { should_capitalize : ffi_ref . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . plural_form) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0) -> * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { should_capitalize : obj . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . plural_form) }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . singular_form) ; ferment :: unbox_string (ffi_ref . plural_form) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_ctor (should_capitalize : bool , singular_form : * mut std :: os :: raw :: c_char , plural_form : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { should_capitalize , singular_form , plural_form }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_destroy (ffi : * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_should_capitalize (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> bool { (* obj) . should_capitalize } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_singular_form (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . singular_form } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_plural_form (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . plural_form } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_should_capitalize (obj : * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 , value : bool) { (* obj) . should_capitalize = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_singular_form (obj : * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . singular_form = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_plural_form (obj : * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . plural_form = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationLocalization`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization) -> * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_destroy (ffi : * mut dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { ferment :: unbox_any (ffi) ; } } pub mod token_distribution_key { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDistributionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { PreProgrammed = 0 , Perpetual = 1 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) -> dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType) -> * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed , dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => { } , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_PreProgrammed_ctor () -> * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_Perpetual_ctor () -> * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_destroy (ffi : * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) { ferment :: unbox_any (ffi) ; } } pub mod token_distribution_rules { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod token_keeps_history_rules { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod token_marketplace_rules { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod token_perpetual_distribution { use crate as example_nested ; pub mod distribution_function { use crate as example_nested ; pub mod evaluate { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod evaluate_interval { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod validation { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DistributionFunction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { FixedAmount { amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , Random { min : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , StepDecreasingAmount { step_count : u32 , decrease_per_interval_numerator : u16 , decrease_per_interval_denominator : u16 , start_decreasing_offset : * mut u64 , max_interval_count : * mut u16 , distribution_start_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , trailing_distribution_interval_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 } , Stepwise (* mut crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) , Linear { a : i64 , d : u64 , start_step : * mut u64 , starting_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Polynomial { a : i64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Exponential { a : u64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Logarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , InvertedLogarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* amount) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* max) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count : * step_count , decrease_per_interval_numerator : * decrease_per_interval_numerator , decrease_per_interval_denominator : * decrease_per_interval_denominator , start_decreasing_offset : ferment :: from_opt_primitive (* start_decreasing_offset) , max_interval_count : ferment :: from_opt_primitive (* max_interval_count) , distribution_start_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* distribution_start_amount) , trailing_distribution_interval_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* trailing_distribution_interval_amount) , min_value : ferment :: from_opt_primitive (* min_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a : * a , d : * d , start_step : ferment :: from_opt_primitive (* start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* starting_amount) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (amount) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min , max } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (max) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count : step_count , decrease_per_interval_numerator : decrease_per_interval_numerator , decrease_per_interval_denominator : decrease_per_interval_denominator , start_decreasing_offset : ferment :: to_opt_primitive (start_decreasing_offset) , max_interval_count : ferment :: to_opt_primitive (max_interval_count) , distribution_start_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (distribution_start_amount) , trailing_distribution_interval_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (trailing_distribution_interval_amount) , min_value : ferment :: to_opt_primitive (min_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a : a , d : d , start_step : ferment :: to_opt_primitive (start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (starting_amount) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => { ferment :: unbox_any (* amount) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => { ferment :: unbox_any (* min) ; ; ferment :: unbox_any (* max) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value } => { ; ; ; ; ; ; ferment :: unbox_any_opt (* start_decreasing_offset) ; ; ferment :: unbox_any_opt (* max_interval_count) ; ; ferment :: unbox_any (* distribution_start_amount) ; ; ferment :: unbox_any (* trailing_distribution_interval_amount) ; ; ferment :: unbox_any_opt (* min_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => { ; ; ; ; ferment :: unbox_any_opt (* start_step) ; ; ferment :: unbox_any (* starting_amount) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: unbox_any_opt (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: unbox_any_opt (* min_value) ; ; ferment :: unbox_any_opt (* max_value) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_FixedAmount_ctor (amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Random_ctor (min : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_StepDecreasingAmount_ctor (step_count : u32 , decrease_per_interval_numerator : u16 , decrease_per_interval_denominator : u16 , start_decreasing_offset : * mut u64 , max_interval_count : * mut u16 , distribution_start_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , trailing_distribution_interval_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , start_decreasing_offset , max_interval_count , distribution_start_amount , trailing_distribution_interval_amount , min_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Stepwise_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Linear_ctor (a : i64 , d : u64 , start_step : * mut u64 , starting_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Polynomial_ctor (a : i64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Exponential_ctor (a : u64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Logarithmic_ctor (a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_InvertedLogarithmic_ctor (a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_destroy (ffi : * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) { ferment :: unbox_any (ffi) ; } } pub mod methods { use crate as example_nested ; } pub mod reward_distribution_moment { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`RewardDistributionMoment`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { BlockBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) , TimeBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) , EpochBasedMoment (* mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_BlockBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_TimeBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_EpochBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_destroy (ffi : * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) { ferment :: unbox_any (ffi) ; } } pub mod reward_distribution_type { use crate as example_nested ; pub mod validation { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; } } pub mod token_pre_programmed_distribution { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } } } pub mod change_control_rules { use crate as example_nested ; pub mod authorized_action_takers { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AuthorizedActionTakers`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { NoOne , ContractOwner , Identity (* mut types :: identifier :: Identifier) , MainGroup , Group (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) -> dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (std :: ptr :: read (* o_0)) , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers) -> * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (ferment :: boxed (o_0)) , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_NoOne_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_ContractOwner_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_Identity_ctor (o_o_0 : * mut types :: identifier :: Identifier) -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_MainGroup_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_Group_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_destroy (ffi : * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ChangeControlRulesV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { pub authorized_to_make_change : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub admin_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub changing_authorized_action_takers_to_no_one_allowed : bool , pub changing_admin_action_takers_to_no_one_allowed : bool , pub self_changing_admin_action_takers_allowed : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : ffi_ref . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : ffi_ref . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : ffi_ref . self_changing_admin_action_takers_allowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0) -> * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { ferment :: boxed (dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : obj . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : obj . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : obj . self_changing_admin_action_takers_allowed }) } } impl Drop for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . authorized_to_make_change) ; ferment :: unbox_any (ffi_ref . admin_action_takers) ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_ctor (authorized_to_make_change : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , admin_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , changing_authorized_action_takers_to_no_one_allowed : bool , changing_admin_action_takers_to_no_one_allowed : bool , self_changing_admin_action_takers_allowed : bool) -> * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { ferment :: boxed (dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { authorized_to_make_change , admin_action_takers , changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_destroy (ffi : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_authorized_to_make_change (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_to_make_change } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_admin_action_takers (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . admin_action_takers } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_changing_authorized_action_takers_to_no_one_allowed (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_authorized_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_changing_admin_action_takers_to_no_one_allowed (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_admin_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_self_changing_admin_action_takers_allowed (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . self_changing_admin_action_takers_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_authorized_to_make_change (obj : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) { (* obj) . authorized_to_make_change = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_admin_action_takers (obj : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) { (* obj) . admin_action_takers = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_changing_authorized_action_takers_to_no_one_allowed (obj : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 , value : bool) { (* obj) . changing_authorized_action_takers_to_no_one_allowed = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_changing_admin_action_takers_to_no_one_allowed (obj : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 , value : bool) { (* obj) . changing_admin_action_takers_to_no_one_allowed = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_self_changing_admin_action_takers_allowed (obj : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 , value : bool) { (* obj) . self_changing_admin_action_takers_allowed = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ChangeControlRules`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_ChangeControlRules { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_ChangeControlRules) -> dpp :: data_contract :: change_control_rules :: ChangeControlRules { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: ChangeControlRules) -> * const dpp_data_contract_change_control_rules_ChangeControlRules { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (o_0) => dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_ChangeControlRules { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_ChangeControlRules_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut dpp_data_contract_change_control_rules_ChangeControlRules { ferment :: boxed (dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_ChangeControlRules_destroy (ffi : * mut dpp_data_contract_change_control_rules_ChangeControlRules) { ferment :: unbox_any (ffi) ; } } pub mod config { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; pub mod validate_update { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v0_DataContractConfigV0 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v0_DataContractConfigV0) -> dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v0 :: DataContractConfigV0) -> * const dpp_data_contract_config_v0_DataContractConfigV0 { ferment :: boxed (dpp_data_contract_config_v0_DataContractConfigV0 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) }) } } impl Drop for dpp_data_contract_config_v0_DataContractConfigV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_ctor (can_be_deleted : bool , readonly : bool , keeps_history : bool , documents_keep_history_contract_default : bool , documents_mutable_contract_default : bool , documents_can_be_deleted_contract_default : bool , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) -> * mut dpp_data_contract_config_v0_DataContractConfigV0 { ferment :: boxed (dpp_data_contract_config_v0_DataContractConfigV0 { can_be_deleted , readonly , keeps_history , documents_keep_history_contract_default , documents_mutable_contract_default , documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_destroy (ffi : * mut dpp_data_contract_config_v0_DataContractConfigV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_can_be_deleted (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_readonly (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_keeps_history (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_keep_history_contract_default (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_mutable_contract_default (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_can_be_deleted_contract_default (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_requires_identity_encryption_bounded_key (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_requires_identity_decryption_bounded_key (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_can_be_deleted (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . can_be_deleted = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_readonly (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . readonly = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_keeps_history (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . keeps_history = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_keep_history_contract_default (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . documents_keep_history_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_mutable_contract_default (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . documents_mutable_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_can_be_deleted_contract_default (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : bool) { (* obj) . documents_can_be_deleted_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_requires_identity_encryption_bounded_key (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_encryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_requires_identity_decryption_bounded_key (obj : * mut dpp_data_contract_config_v0_DataContractConfigV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_decryption_bounded_key = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v1_DataContractConfigV1 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub sized_integer_types : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v1_DataContractConfigV1) -> dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , sized_integer_types : ffi_ref . sized_integer_types } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v1 :: DataContractConfigV1) -> * const dpp_data_contract_config_v1_DataContractConfigV1 { ferment :: boxed (dpp_data_contract_config_v1_DataContractConfigV1 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , sized_integer_types : obj . sized_integer_types }) } } impl Drop for dpp_data_contract_config_v1_DataContractConfigV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_ctor (can_be_deleted : bool , readonly : bool , keeps_history : bool , documents_keep_history_contract_default : bool , documents_mutable_contract_default : bool , documents_can_be_deleted_contract_default : bool , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , sized_integer_types : bool) -> * mut dpp_data_contract_config_v1_DataContractConfigV1 { ferment :: boxed (dpp_data_contract_config_v1_DataContractConfigV1 { can_be_deleted , readonly , keeps_history , documents_keep_history_contract_default , documents_mutable_contract_default , documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key , sized_integer_types }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_destroy (ffi : * mut dpp_data_contract_config_v1_DataContractConfigV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_can_be_deleted (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_readonly (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_keeps_history (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_keep_history_contract_default (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_mutable_contract_default (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_can_be_deleted_contract_default (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_requires_identity_encryption_bounded_key (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_requires_identity_decryption_bounded_key (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_sized_integer_types (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . sized_integer_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_can_be_deleted (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . can_be_deleted = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_readonly (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . readonly = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_keeps_history (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . keeps_history = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_keep_history_contract_default (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . documents_keep_history_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_mutable_contract_default (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . documents_mutable_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_can_be_deleted_contract_default (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . documents_can_be_deleted_contract_default = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_requires_identity_encryption_bounded_key (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_encryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_requires_identity_decryption_bounded_key (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { (* obj) . requires_identity_decryption_bounded_key = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_sized_integer_types (obj : * mut dpp_data_contract_config_v1_DataContractConfigV1 , value : bool) { (* obj) . sized_integer_types = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractConfig`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_config_DataContractConfig { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_DataContractConfig) -> dpp :: data_contract :: config :: DataContractConfig { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_from (* o_0)) , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: DataContractConfig) -> * const dpp_data_contract_config_DataContractConfig { ferment :: boxed (match obj { dpp :: data_contract :: config :: DataContractConfig :: V0 (o_0) => dpp_data_contract_config_DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: config :: DataContractConfig :: V1 (o_0) => dpp_data_contract_config_DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_config_DataContractConfig { fn drop (& mut self) { unsafe { match self { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0) -> * mut dpp_data_contract_config_DataContractConfig { ferment :: boxed (dpp_data_contract_config_DataContractConfig :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1) -> * mut dpp_data_contract_config_DataContractConfig { ferment :: boxed (dpp_data_contract_config_DataContractConfig :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_destroy (ffi : * mut dpp_data_contract_config_DataContractConfig) { ferment :: unbox_any (ffi) ; } } pub mod group { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_v0_GroupV0 { pub members : * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_v0_GroupV0) -> dpp :: data_contract :: group :: v0 :: GroupV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: group :: v0 :: GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_from (ffi_ref . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: v0 :: GroupV0) -> * const dpp_data_contract_group_v0_GroupV0 { ferment :: boxed (dpp_data_contract_group_v0_GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_to (obj . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_data_contract_group_v0_GroupV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . members) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_ctor (members : * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) -> * mut dpp_data_contract_group_v0_GroupV0 { ferment :: boxed (dpp_data_contract_group_v0_GroupV0 { members , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_destroy (ffi : * mut dpp_data_contract_group_v0_GroupV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_get_members (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { (* obj) . members } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_get_required_power (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_set_members (obj : * mut dpp_data_contract_group_v0_GroupV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) { (* obj) . members = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_set_required_power (obj : * mut dpp_data_contract_group_v0_GroupV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) { (* obj) . required_power = value ; } # [cfg (test)] pub mod tests { use crate as example_nested ; } } # [doc = "FFI-representation of the [`GroupMemberPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupMemberPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupMemberPower) -> dpp :: data_contract :: group :: GroupMemberPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupMemberPower) -> * const dpp_data_contract_group_GroupMemberPower { ferment :: boxed (dpp_data_contract_group_GroupMemberPower (obj)) } } impl Drop for dpp_data_contract_group_GroupMemberPower { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_ctor (o_0 : u32) -> * mut dpp_data_contract_group_GroupMemberPower { ferment :: boxed (dpp_data_contract_group_GroupMemberPower (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_destroy (ffi : * mut dpp_data_contract_group_GroupMemberPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_get_0 (obj : * const dpp_data_contract_group_GroupMemberPower) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_set_0 (obj : * mut dpp_data_contract_group_GroupMemberPower , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`GroupSumPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupSumPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower > for dpp_data_contract_group_GroupSumPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupSumPower) -> dpp :: data_contract :: group :: GroupSumPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower > for dpp_data_contract_group_GroupSumPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupSumPower) -> * const dpp_data_contract_group_GroupSumPower { ferment :: boxed (dpp_data_contract_group_GroupSumPower (obj)) } } impl Drop for dpp_data_contract_group_GroupSumPower { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupSumPower_ctor (o_0 : u32) -> * mut dpp_data_contract_group_GroupSumPower { ferment :: boxed (dpp_data_contract_group_GroupSumPower (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupSumPower_destroy (ffi : * mut dpp_data_contract_group_GroupSumPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupSumPower_get_0 (obj : * const dpp_data_contract_group_GroupSumPower) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupSumPower_set_0 (obj : * mut dpp_data_contract_group_GroupSumPower , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`GroupRequiredPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupRequiredPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupRequiredPower) -> dpp :: data_contract :: group :: GroupRequiredPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupRequiredPower) -> * const dpp_data_contract_group_GroupRequiredPower { ferment :: boxed (dpp_data_contract_group_GroupRequiredPower (obj)) } } impl Drop for dpp_data_contract_group_GroupRequiredPower { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_ctor (o_0 : u32) -> * mut dpp_data_contract_group_GroupRequiredPower { ferment :: boxed (dpp_data_contract_group_GroupRequiredPower (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_destroy (ffi : * mut dpp_data_contract_group_GroupRequiredPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_get_0 (obj : * const dpp_data_contract_group_GroupRequiredPower) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_set_0 (obj : * mut dpp_data_contract_group_GroupRequiredPower , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Group`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_group_Group { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_Group) -> dpp :: data_contract :: group :: Group { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_group_Group :: V0 (o_0) => dpp :: data_contract :: group :: Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: Group) -> * const dpp_data_contract_group_Group { ferment :: boxed (match obj { dpp :: data_contract :: group :: Group :: V0 (o_0) => dpp_data_contract_group_Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { match self { dpp_data_contract_group_Group :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_Group_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0) -> * mut dpp_data_contract_group_Group { ferment :: boxed (dpp_data_contract_group_Group :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_Group_destroy (ffi : * mut dpp_data_contract_group_Group) { ferment :: unbox_any (ffi) ; } } pub mod storage_requirements { use crate as example_nested ; pub mod keys_for_document_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StorageKeyRequirements`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { Unique = 0 , Multiple = 1 , MultipleReferenceToLatest = 2 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) -> dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_to_const (obj : dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements) -> * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (match obj { dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { fn drop (& mut self) { unsafe { match self { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_Unique_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_Multiple_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_MultipleReferenceToLatest_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_destroy (ffi : * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { ferment :: unbox_any (ffi) ; } } } # [doc = "FFI-representation of the [`JsonSchema`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_JsonSchema (* mut example_nested :: serde_json_Value) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_JsonSchema) -> dpp :: data_contract :: JsonSchema { let ffi_ref = & * ffi ; < example_nested :: serde_json_Value as ferment :: FFIConversionFrom < serde_json :: Value >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_to_const (obj : dpp :: data_contract :: JsonSchema) -> * const dpp_data_contract_JsonSchema { ferment :: boxed (dpp_data_contract_JsonSchema (< example_nested :: serde_json_Value as ferment :: FFIConversionTo < serde_json :: Value >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_JsonSchema { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_ctor (o_0 : * mut example_nested :: serde_json_Value) -> * mut dpp_data_contract_JsonSchema { ferment :: boxed (dpp_data_contract_JsonSchema (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_destroy (ffi : * mut dpp_data_contract_JsonSchema) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_get_0 (obj : * const dpp_data_contract_JsonSchema) -> * mut example_nested :: serde_json_Value { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_set_0 (obj : * mut dpp_data_contract_JsonSchema , value : * mut example_nested :: serde_json_Value) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`DefinitionName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DefinitionName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DefinitionName) -> dpp :: data_contract :: DefinitionName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DefinitionName) -> * const dpp_data_contract_DefinitionName { ferment :: boxed (dpp_data_contract_DefinitionName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DefinitionName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_ctor (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_DefinitionName { ferment :: boxed (dpp_data_contract_DefinitionName (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_destroy (ffi : * mut dpp_data_contract_DefinitionName) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_get_0 (obj : * const dpp_data_contract_DefinitionName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_set_0 (obj : * mut dpp_data_contract_DefinitionName , value : * mut std :: os :: raw :: c_char) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`DocumentName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DocumentName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DocumentName) -> dpp :: data_contract :: DocumentName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DocumentName) -> * const dpp_data_contract_DocumentName { ferment :: boxed (dpp_data_contract_DocumentName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DocumentName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_ctor (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_DocumentName { ferment :: boxed (dpp_data_contract_DocumentName (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_destroy (ffi : * mut dpp_data_contract_DocumentName) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_get_0 (obj : * const dpp_data_contract_DocumentName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_set_0 (obj : * mut dpp_data_contract_DocumentName , value : * mut std :: os :: raw :: c_char) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`GroupContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_GroupContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_GroupContractPosition) -> dpp :: data_contract :: GroupContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: GroupContractPosition) -> * const dpp_data_contract_GroupContractPosition { ferment :: boxed (dpp_data_contract_GroupContractPosition (obj)) } } impl Drop for dpp_data_contract_GroupContractPosition { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_ctor (o_0 : u16) -> * mut dpp_data_contract_GroupContractPosition { ferment :: boxed (dpp_data_contract_GroupContractPosition (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_destroy (ffi : * mut dpp_data_contract_GroupContractPosition) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_get_0 (obj : * const dpp_data_contract_GroupContractPosition) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_set_0 (obj : * mut dpp_data_contract_GroupContractPosition , value : u16) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TokenContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_TokenContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_TokenContractPosition) -> dpp :: data_contract :: TokenContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: TokenContractPosition) -> * const dpp_data_contract_TokenContractPosition { ferment :: boxed (dpp_data_contract_TokenContractPosition (obj)) } } impl Drop for dpp_data_contract_TokenContractPosition { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_ctor (o_0 : u16) -> * mut dpp_data_contract_TokenContractPosition { ferment :: boxed (dpp_data_contract_TokenContractPosition (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_destroy (ffi : * mut dpp_data_contract_TokenContractPosition) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_get_0 (obj : * const dpp_data_contract_TokenContractPosition) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_set_0 (obj : * mut dpp_data_contract_TokenContractPosition , value : u16) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`PropertyPath`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_PropertyPath (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_PropertyPath) -> dpp :: data_contract :: PropertyPath { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_to_const (obj : dpp :: data_contract :: PropertyPath) -> * const dpp_data_contract_PropertyPath { ferment :: boxed (dpp_data_contract_PropertyPath (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_PropertyPath { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_ctor (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_PropertyPath { ferment :: boxed (dpp_data_contract_PropertyPath (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_destroy (ffi : * mut dpp_data_contract_PropertyPath) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_get_0 (obj : * const dpp_data_contract_PropertyPath) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_set_0 (obj : * mut dpp_data_contract_PropertyPath , value : * mut std :: os :: raw :: c_char) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContract`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_DataContract { V0 (* mut data_contract) , V1 (* mut data_contract) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DataContract) -> dpp :: data_contract :: DataContract { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_DataContract :: V0 (o_0) => dpp :: data_contract :: DataContract :: V0 (std :: ptr :: read (* o_0)) , dpp_data_contract_DataContract :: V1 (o_0) => dpp :: data_contract :: DataContract :: V1 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DataContract) -> * const dpp_data_contract_DataContract { ferment :: boxed (match obj { dpp :: data_contract :: DataContract :: V0 (o_0) => dpp_data_contract_DataContract :: V0 (ferment :: boxed (o_0)) , dpp :: data_contract :: DataContract :: V1 (o_0) => dpp_data_contract_DataContract :: V1 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_DataContract { fn drop (& mut self) { unsafe { match self { dpp_data_contract_DataContract :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_DataContract :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_V0_ctor (o_o_0 : * mut data_contract) -> * mut dpp_data_contract_DataContract { ferment :: boxed (dpp_data_contract_DataContract :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_V1_ctor (o_o_0 : * mut data_contract) -> * mut dpp_data_contract_DataContract { ferment :: boxed (dpp_data_contract_DataContract :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_destroy (ffi : * mut dpp_data_contract_DataContract) { ferment :: unbox_any (ffi) ; } } pub mod document { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } # [cfg (feature = "factories")] pub mod document_factory { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod document_methods { use crate as example_nested ; pub mod get_raw_for_contract { use crate as example_nested ; } pub mod get_raw_for_document_type { use crate as example_nested ; } pub mod hash { use crate as example_nested ; } pub mod is_equal_ignoring_timestamps { use crate as example_nested ; } } pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_errors_DocumentError { # [cfg (feature = "state-transitions")] DocumentAlreadyExistsError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , # [cfg (feature = "state-transitions")] DocumentNotProvidedError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidActionError (u8) , InvalidActionNameError { actions : * mut crate :: fermented :: generics :: Vec_String } , # [cfg (feature = "state-transitions")] InvalidDocumentActionError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidDocumentError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_ConsensusError , raw_document : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , InvalidInitialRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , RevisionAbsentError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToReplaceImmutableDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToDeleteIndelibleDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , MismatchOwnerIdsError { documents : * mut crate :: fermented :: generics :: Vec_dpp_document_Document } , DocumentNoRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , NoDocumentsSuppliedError } impl ferment :: FFIConversionFrom < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_from_const (ffi : * const dpp_document_errors_DocumentError) -> dpp :: document :: errors :: DocumentError { let ffi_ref = & * ffi ; match ffi_ref { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => dpp :: document :: errors :: DocumentError :: InvalidActionError (* o_0) , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* actions) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: ConsensusError > >> :: ffi_from (* errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_document) } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > >> :: ffi_from (* documents) } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError } } } impl ferment :: FFIConversionTo < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_to_const (obj : dpp :: document :: errors :: DocumentError) -> * const dpp_document_errors_DocumentError { ferment :: boxed (match obj { # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition } => dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidActionError (o_0) => dpp_document_errors_DocumentError :: InvalidActionError (o_0) , dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions } => dpp_document_errors_DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (actions) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition } => dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors , raw_document } => dpp_document_errors_DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: ConsensusError > >> :: ffi_to (errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_document) } , dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document } => dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document } => dpp_document_errors_DocumentError :: RevisionAbsentError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document } => dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents } => dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionTo < Vec < dpp :: document :: Document > >> :: ffi_to (documents) } , dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document } => dpp_document_errors_DocumentError :: DocumentNoRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError => dpp_document_errors_DocumentError :: NoDocumentsSuppliedError , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_errors_DocumentError { fn drop (& mut self) { unsafe { match self { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => { ; } , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => { ferment :: unbox_any (* actions) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_document) ; } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => { ferment :: unbox_any (* documents) ; } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentAlreadyExistsError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition }) } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentNotProvidedError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidActionError_ctor (o_o_0 : u8) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidActionNameError_ctor (actions : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidActionNameError { actions }) } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidDocumentActionError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidDocumentError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_ConsensusError , raw_document : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidInitialRevisionError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_RevisionAbsentError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: RevisionAbsentError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_TryingToReplaceImmutableDocument_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_TryingToDeleteIndelibleDocument_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_MismatchOwnerIdsError_ctor (documents : * mut crate :: fermented :: generics :: Vec_dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentNoRevisionError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentNoRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_NoDocumentsSuppliedError_ctor () -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: NoDocumentsSuppliedError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_destroy (ffi : * mut dpp_document_errors_DocumentError) { ferment :: unbox_any (ffi) ; } } # [cfg (feature = "extended-document")] pub mod extended_document { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod fields { use crate as example_nested ; } pub mod serialization_traits { use crate as example_nested ; # [cfg (feature = "document-cbor-conversion")] pub mod cbor_conversion { use crate as example_nested ; } # [cfg (feature = "document-json-conversion")] pub mod json_conversion { use crate as example_nested ; } pub mod platform_serialization_conversion { use crate as example_nested ; pub mod deserialize { use crate as example_nested ; } pub mod serialize { use crate as example_nested ; } } # [cfg (feature = "document-value-conversion")] pub mod platform_value_conversion { use crate as example_nested ; } } # [cfg (feature = "factories")] pub mod specialized_document_factory { use crate as example_nested ; } pub mod transfer { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Transferable`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_transfer_Transferable { Never = 0 , Always = 1 } impl ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_from_const (ffi : * const dpp_document_transfer_Transferable) -> dpp :: document :: transfer :: Transferable { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_transfer_Transferable :: Never => dpp :: document :: transfer :: Transferable :: Never , dpp_document_transfer_Transferable :: Always => dpp :: document :: transfer :: Transferable :: Always } } } impl ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_to_const (obj : dpp :: document :: transfer :: Transferable) -> * const dpp_document_transfer_Transferable { ferment :: boxed (match obj { dpp :: document :: transfer :: Transferable :: Never => dpp_document_transfer_Transferable :: Never , dpp :: document :: transfer :: Transferable :: Always => dpp_document_transfer_Transferable :: Always , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_transfer_Transferable { fn drop (& mut self) { unsafe { match self { dpp_document_transfer_Transferable :: Never => { } , dpp_document_transfer_Transferable :: Always => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_Never_ctor () -> * mut dpp_document_transfer_Transferable { ferment :: boxed (dpp_document_transfer_Transferable :: Never { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_Always_ctor () -> * mut dpp_document_transfer_Transferable { ferment :: boxed (dpp_document_transfer_Transferable :: Always { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_destroy (ffi : * mut dpp_document_transfer_Transferable) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_document_v0_DocumentV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub properties : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub created_at : * mut dpp :: identity :: TimestampMillis , pub updated_at : * mut dpp :: identity :: TimestampMillis , pub transferred_at : * mut dpp :: identity :: TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub transferred_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub updated_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub transferred_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight } impl ferment :: FFIConversionFrom < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_from_const (ffi : * const dpp_document_v0_DocumentV0) -> dpp :: document :: v0 :: DocumentV0 { let ffi_ref = & * ffi ; dpp :: document :: v0 :: DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , created_at : ferment :: from_opt_opaque (ffi_ref . created_at) , updated_at : ferment :: from_opt_opaque (ffi_ref . updated_at) , transferred_at : ferment :: from_opt_opaque (ffi_ref . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_core_block_height) } } } impl ferment :: FFIConversionTo < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_to_const (obj : dpp :: document :: v0 :: DocumentV0) -> * const dpp_document_v0_DocumentV0 { ferment :: boxed (dpp_document_v0_DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , created_at : ferment :: to_opt_primitive (obj . created_at) , updated_at : ferment :: to_opt_primitive (obj . updated_at) , transferred_at : ferment :: to_opt_primitive (obj . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . transferred_at_core_block_height) }) } } impl Drop for dpp_document_v0_DocumentV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . transferred_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_core_block_height) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , properties : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , created_at : * mut dpp :: identity :: TimestampMillis , updated_at : * mut dpp :: identity :: TimestampMillis , transferred_at : * mut dpp :: identity :: TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , transferred_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , updated_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , transferred_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) -> * mut dpp_document_v0_DocumentV0 { ferment :: boxed (dpp_document_v0_DocumentV0 { id , owner_id , properties , revision , created_at , updated_at , transferred_at , created_at_block_height , updated_at_block_height , transferred_at_block_height , created_at_core_block_height , updated_at_core_block_height , transferred_at_core_block_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_destroy (ffi : * mut dpp_document_v0_DocumentV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_id (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_owner_id (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_properties (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_revision (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at (obj : * const dpp_document_v0_DocumentV0) -> * mut dpp :: identity :: TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at (obj : * const dpp_document_v0_DocumentV0) -> * mut dpp :: identity :: TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at (obj : * const dpp_document_v0_DocumentV0) -> * mut dpp :: identity :: TimestampMillis { (* obj) . transferred_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . transferred_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at_core_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . created_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at_core_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . updated_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at_core_block_height (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . transferred_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_id (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_owner_id (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_properties (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value) { (* obj) . properties = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_revision (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at (obj : * mut dpp_document_v0_DocumentV0 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . created_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at (obj : * mut dpp_document_v0_DocumentV0 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . updated_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at (obj : * mut dpp_document_v0_DocumentV0 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . transferred_at = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . created_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . updated_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . transferred_at_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at_core_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) { (* obj) . created_at_core_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at_core_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) { (* obj) . updated_at_core_block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at_core_block_height (obj : * mut dpp_document_v0_DocumentV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) { (* obj) . transferred_at_core_block_height = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Document`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_Document { V0 (* mut dpp :: document :: DocumentV0) } impl ferment :: FFIConversionFrom < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_from_const (ffi : * const dpp_document_Document) -> dpp :: document :: Document { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_Document :: V0 (o_0) => dpp :: document :: Document :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_to_const (obj : dpp :: document :: Document) -> * const dpp_document_Document { ferment :: boxed (match obj { dpp :: document :: Document :: V0 (o_0) => dpp_document_Document :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_Document { fn drop (& mut self) { unsafe { match self { dpp_document_Document :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_Document_V0_ctor (o_o_0 : * mut dpp :: document :: DocumentV0) -> * mut dpp_document_Document { ferment :: boxed (dpp_document_Document :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_document_Document_destroy (ffi : * mut dpp_document_Document) { ferment :: unbox_any (ffi) ; } } pub mod identity { use crate as example_nested ; pub mod core_script { use crate as example_nested ; # [doc = "FFI-representation of the [`CoreScript`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_core_script_CoreScript (* mut dashcore :: blockdata :: script :: ScriptBuf) ; impl ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_from_const (ffi : * const dpp_identity_core_script_CoreScript) -> dpp :: identity :: core_script :: CoreScript { let ffi_ref = & * ffi ; dpp :: identity :: core_script :: CoreScript (std :: ptr :: read (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_to_const (obj : dpp :: identity :: core_script :: CoreScript) -> * const dpp_identity_core_script_CoreScript { ferment :: boxed (dpp_identity_core_script_CoreScript (ferment :: boxed (obj . 0))) } } impl Drop for dpp_identity_core_script_CoreScript { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_ctor (o_0 : * mut dashcore :: blockdata :: script :: ScriptBuf) -> * mut dpp_identity_core_script_CoreScript { ferment :: boxed (dpp_identity_core_script_CoreScript (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_destroy (ffi : * mut dpp_identity_core_script_CoreScript) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_get_0 (obj : * const dpp_identity_core_script_CoreScript) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_set_0 (obj : * mut dpp_identity_core_script_CoreScript , value : * mut dashcore :: blockdata :: script :: ScriptBuf) { (* obj) . 0 = value ; } } pub mod identity { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Identity`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_Identity { V0 (* mut crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_Identity) -> dpp :: identity :: identity :: Identity { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_Identity :: V0 (o_0) => dpp :: identity :: identity :: Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: Identity) -> * const dpp_identity_identity_Identity { ferment :: boxed (match obj { dpp :: identity :: identity :: Identity :: V0 (o_0) => dpp_identity_identity_Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_Identity { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_Identity :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_Identity_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0) -> * mut dpp_identity_identity_Identity { ferment :: boxed (dpp_identity_identity_Identity :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_Identity_destroy (ffi : * mut dpp_identity_identity_Identity) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`PartialIdentity`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_PartialIdentity { pub id : * mut types :: identifier :: Identifier , pub loaded_public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey , pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub not_found_public_keys : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_PartialIdentity) -> dpp :: identity :: identity :: PartialIdentity { let ffi_ref = & * ffi ; dpp :: identity :: identity :: PartialIdentity { id : std :: ptr :: read (ffi_ref . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: KeyID , dpp :: identity :: IdentityPublicKey > >> :: ffi_from (ffi_ref . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from_opt (ffi_ref . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . not_found_public_keys) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: PartialIdentity) -> * const dpp_identity_identity_PartialIdentity { ferment :: boxed (dpp_identity_identity_PartialIdentity { id : ferment :: boxed (obj . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: KeyID , dpp :: identity :: IdentityPublicKey > >> :: ffi_to (obj . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to_opt (obj . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID as ferment :: FFIConversionTo < std :: collections :: BTreeSet < dpp :: identity :: KeyID > >> :: ffi_to (obj . not_found_public_keys) }) } } impl Drop for dpp_identity_identity_PartialIdentity { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . loaded_public_keys) ; ferment :: unbox_any_opt (ffi_ref . balance) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . not_found_public_keys) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_ctor (id : * mut types :: identifier :: Identifier , loaded_public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey , balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , not_found_public_keys : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID) -> * mut dpp_identity_identity_PartialIdentity { ferment :: boxed (dpp_identity_identity_PartialIdentity { id , loaded_public_keys , balance , revision , not_found_public_keys }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_destroy (ffi : * mut dpp_identity_identity_PartialIdentity) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_id (obj : * const dpp_identity_identity_PartialIdentity) -> * mut types :: identifier :: Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_loaded_public_keys (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey { (* obj) . loaded_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_balance (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_revision (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_not_found_public_keys (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID { (* obj) . not_found_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_id (obj : * mut dpp_identity_identity_PartialIdentity , value : * mut types :: identifier :: Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_loaded_public_keys (obj : * mut dpp_identity_identity_PartialIdentity , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey) { (* obj) . loaded_public_keys = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_balance (obj : * mut dpp_identity_identity_PartialIdentity , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_revision (obj : * mut dpp_identity_identity_PartialIdentity , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_not_found_public_keys (obj : * mut dpp_identity_identity_PartialIdentity , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_KeyID) { (* obj) . not_found_public_keys = value ; } } pub mod identity_public_key { use crate as example_nested ; pub mod key_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_key_type_KeyType { ECDSA_SECP256K1 = 0 , BLS12_381 = 1 , ECDSA_HASH160 = 2 , BIP13_SCRIPT_HASH = 3 , EDDSA_25519_HASH160 = 4 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_key_type_KeyType) -> dpp :: identity :: identity_public_key :: key_type :: KeyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: key_type :: KeyType) -> * const dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 => dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH => dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH , dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_key_type_KeyType { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => { } , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => { } , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_ECDSA_SECP256K1_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_BLS12_381_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_ECDSA_HASH160_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_BIP13_SCRIPT_HASH_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_EDDSA_25519_HASH160_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_destroy (ffi : * mut dpp_identity_identity_public_key_key_type_KeyType) { ferment :: unbox_any (ffi) ; } } pub mod purpose { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Purpose`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_purpose_Purpose { AUTHENTICATION = 0 , ENCRYPTION = 1 , DECRYPTION = 2 , TRANSFER = 3 , SYSTEM = 4 , VOTING = 5 , OWNER = 6 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_purpose_Purpose) -> dpp :: identity :: identity_public_key :: purpose :: Purpose { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: purpose :: Purpose) -> * const dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION => dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER => dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER , dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM => dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM , dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING => dpp_identity_identity_public_key_purpose_Purpose :: VOTING , dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER => dpp_identity_identity_public_key_purpose_Purpose :: OWNER , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_purpose_Purpose { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => { } , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => { } , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => { } , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => { } , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_AUTHENTICATION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_ENCRYPTION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_DECRYPTION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_TRANSFER_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_SYSTEM_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_VOTING_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: VOTING { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_OWNER_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: OWNER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_destroy (ffi : * mut dpp_identity_identity_public_key_purpose_Purpose) { ferment :: unbox_any (ffi) ; } } pub mod security_level { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SecurityLevel`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_security_level_SecurityLevel { MASTER = 0 , CRITICAL = 1 , HIGH = 2 , MEDIUM = 3 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_security_level_SecurityLevel) -> dpp :: identity :: identity_public_key :: security_level :: SecurityLevel { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: security_level :: SecurityLevel) -> * const dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER => dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL => dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH => dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM => dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_security_level_SecurityLevel { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_MASTER_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_CRITICAL_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_HIGH_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_MEDIUM_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_destroy (ffi : * mut dpp_identity_identity_public_key_security_level_SecurityLevel) { ferment :: unbox_any (ffi) ; } } pub mod accessors { use crate as example_nested ; } pub mod conversion { use crate as example_nested ; # [cfg (feature = "json-object")] pub mod json { use crate as example_nested ; } # [cfg (feature = "platform-value")] pub mod platform_value { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; pub mod conversion { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } # [doc = "FFI-representation of the [`IdentityPublicKeyV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { pub id : * mut dpp :: identity :: KeyID , pub purpose : * mut dpp :: identity :: Purpose , pub security_level : * mut dpp :: identity :: SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , pub key_type : * mut dpp :: identity :: KeyType , pub read_only : bool , pub data : * mut types :: binary_data :: BinaryData , pub disabled_at : * mut dpp :: identity :: TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { let ffi_ref = & * ffi ; dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { id : std :: ptr :: read (ffi_ref . id) , purpose : std :: ptr :: read (ffi_ref . purpose) , security_level : std :: ptr :: read (ffi_ref . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_from_opt (ffi_ref . contract_bounds) , key_type : std :: ptr :: read (ffi_ref . key_type) , read_only : ffi_ref . read_only , data : std :: ptr :: read (ffi_ref . data) , disabled_at : ferment :: from_opt_opaque (ffi_ref . disabled_at) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0) -> * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { ferment :: boxed (dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { id : ferment :: boxed (obj . id) , purpose : ferment :: boxed (obj . purpose) , security_level : ferment :: boxed (obj . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_to_opt (obj . contract_bounds) , key_type : ferment :: boxed (obj . key_type) , read_only : obj . read_only , data : ferment :: boxed (obj . data) , disabled_at : ferment :: to_opt_primitive (obj . disabled_at) }) } } impl Drop for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ferment :: unbox_any (ffi_ref . key_type) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . disabled_at) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_ctor (id : * mut dpp :: identity :: KeyID , purpose : * mut dpp :: identity :: Purpose , security_level : * mut dpp :: identity :: SecurityLevel , contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , key_type : * mut dpp :: identity :: KeyType , read_only : bool , data : * mut types :: binary_data :: BinaryData , disabled_at : * mut dpp :: identity :: TimestampMillis) -> * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { ferment :: boxed (dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { id , purpose , security_level , contract_bounds , key_type , read_only , data , disabled_at }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_destroy (ffi : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_id (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp :: identity :: KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_purpose (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp :: identity :: Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_security_level (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_contract_bounds (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_key_type (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp :: identity :: KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_read_only (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_data (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut types :: binary_data :: BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_disabled_at (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp :: identity :: TimestampMillis { (* obj) . disabled_at } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_id (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_purpose (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut dpp :: identity :: Purpose) { (* obj) . purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_security_level (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_contract_bounds (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds) { (* obj) . contract_bounds = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_key_type (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut dpp :: identity :: KeyType) { (* obj) . key_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_read_only (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : bool) { (* obj) . read_only = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_data (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . data = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_disabled_at (obj : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . disabled_at = value ; } } pub mod methods { use crate as example_nested ; pub mod hash { use crate as example_nested ; } } pub mod contract_bounds { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContractBounds`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_contract_bounds_ContractBounds { SingleContract { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } , SingleContractDocumentType { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_contract_bounds_ContractBounds) -> dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* document_type_name) } } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds) -> * const dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) } , dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (document_type_name) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_contract_bounds_ContractBounds { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => { ferment :: unbox_any (* id) ; } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => { ferment :: unbox_any (* id) ; ; ferment :: unbox_string (* document_type_name) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_SingleContract_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_SingleContractDocumentType_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_destroy (ffi : * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`KeyID`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyID (u32) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyID) -> dpp :: identity :: identity_public_key :: KeyID { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyID) -> * const dpp_identity_identity_public_key_KeyID { ferment :: boxed (dpp_identity_identity_public_key_KeyID (obj)) } } impl Drop for dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_ctor (o_0 : u32) -> * mut dpp_identity_identity_public_key_KeyID { ferment :: boxed (dpp_identity_identity_public_key_KeyID (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_destroy (ffi : * mut dpp_identity_identity_public_key_KeyID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_get_0 (obj : * const dpp_identity_identity_public_key_KeyID) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_set_0 (obj : * mut dpp_identity_identity_public_key_KeyID , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`KeyCount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyCount (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyCount) -> dpp :: identity :: identity_public_key :: KeyCount { let ffi_ref = & * ffi ; < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyCount) -> * const dpp_identity_identity_public_key_KeyCount { ferment :: boxed (dpp_identity_identity_public_key_KeyCount (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj))) } } impl Drop for dpp_identity_identity_public_key_KeyCount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_ctor (o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_identity_identity_public_key_KeyCount { ferment :: boxed (dpp_identity_identity_public_key_KeyCount (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_destroy (ffi : * mut dpp_identity_identity_public_key_KeyCount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_get_0 (obj : * const dpp_identity_identity_public_key_KeyCount) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_set_0 (obj : * mut dpp_identity_identity_public_key_KeyCount , value : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_TimestampMillis) -> dpp :: identity :: identity_public_key :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: TimestampMillis) -> * const dpp_identity_identity_public_key_TimestampMillis { ferment :: boxed (dpp_identity_identity_public_key_TimestampMillis (obj)) } } impl Drop for dpp_identity_identity_public_key_TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_ctor (o_0 : u64) -> * mut dpp_identity_identity_public_key_TimestampMillis { ferment :: boxed (dpp_identity_identity_public_key_TimestampMillis (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_destroy (ffi : * mut dpp_identity_identity_public_key_TimestampMillis) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_get_0 (obj : * const dpp_identity_identity_public_key_TimestampMillis) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_set_0 (obj : * mut dpp_identity_identity_public_key_TimestampMillis , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKey`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_IdentityPublicKey { V0 (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_IdentityPublicKey) -> dpp :: identity :: identity_public_key :: IdentityPublicKey { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: IdentityPublicKey) -> * const dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (o_0) => dpp_identity_identity_public_key_IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_IdentityPublicKey { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_IdentityPublicKey_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_IdentityPublicKey_destroy (ffi : * mut dpp_identity_identity_public_key_IdentityPublicKey) { ferment :: unbox_any (ffi) ; } } pub mod state_transition { use crate as example_nested ; pub mod asset_lock_proof { use crate as example_nested ; pub mod chain { use crate as example_nested ; pub mod chain_asset_lock_proof { use crate as example_nested ; # [doc = "FFI-representation of the [`ChainAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { pub core_chain_locked_height : u32 , pub out_point : * mut dashcore :: transaction :: outpoint :: OutPoint } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { core_chain_locked_height : ffi_ref . core_chain_locked_height , out_point : std :: ptr :: read (ffi_ref . out_point) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { core_chain_locked_height : obj . core_chain_locked_height , out_point : ferment :: boxed (obj . out_point) }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . out_point) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_ctor (core_chain_locked_height : u32 , out_point : * mut dashcore :: transaction :: outpoint :: OutPoint) -> * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { core_chain_locked_height , out_point }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_destroy (ffi : * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_get_core_chain_locked_height (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> u32 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_get_out_point (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> * mut dashcore :: transaction :: outpoint :: OutPoint { (* obj) . out_point } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_set_core_chain_locked_height (obj : * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof , value : u32) { (* obj) . core_chain_locked_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_set_out_point (obj : * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof , value : * mut dashcore :: transaction :: outpoint :: OutPoint) { (* obj) . out_point = value ; } } } pub mod instant { use crate as example_nested ; pub mod instant_asset_lock_proof { use crate as example_nested ; # [doc = "FFI-representation of the [`InstantAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { pub instant_lock : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock , pub transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction , pub output_index : u32 } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_from (ffi_ref . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (ffi_ref . transaction) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_to (obj . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_to (obj . transaction) , output_index : obj . output_index }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock) ; ferment :: unbox_any (ffi_ref . transaction) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_ctor (instant_lock : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock , transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction , output_index : u32) -> * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { instant_lock , transaction , output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_destroy (ffi : * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_instant_lock (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock { (* obj) . instant_lock } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_transaction (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction { (* obj) . transaction } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_output_index (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> u32 { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_instant_lock (obj : * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof , value : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock) { (* obj) . instant_lock = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_transaction (obj : * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction) { (* obj) . transaction = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_output_index (obj : * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof , value : u32) { (* obj) . output_index = value ; } } pub mod methods { use crate as example_nested ; pub mod validate_structure { use crate as example_nested ; } } } pub mod validate_asset_lock_transaction_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AssetLockProof`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_state_transition_asset_lock_proof_AssetLockProof { Instant (* mut dpp :: identity :: state_transition :: asset_lock_proof :: InstantAssetLockProof) , Chain (* mut identity) } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (std :: ptr :: read (* o_0)) , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (match obj { dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (ferment :: boxed (o_0)) , dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { fn drop (& mut self) { unsafe { match self { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_Instant_ctor (o_o_0 : * mut dpp :: identity :: state_transition :: asset_lock_proof :: InstantAssetLockProof) -> * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_Chain_ctor (o_o_0 : * mut identity) -> * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_destroy (ffi : * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof) { ferment :: unbox_any (ffi) ; } } } pub mod credits_converter { use crate as example_nested ; } pub mod errors { use crate as example_nested ; pub mod asset_lock_output_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) -> dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError) -> * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { }) } } impl Drop for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError_ctor () -> * mut dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError_destroy (ffi : * mut dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) { ferment :: unbox_any (ffi) ; } } pub mod asset_lock_transaction_is_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError) -> * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) }) } } impl Drop for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_ctor (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) -> * mut dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_destroy (ffi : * mut dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_get_transaction_id (obj : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_set_transaction_id (obj : * mut dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . transaction_id = value ; } } pub mod unknown_asset_lock_proof_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownAssetLockProofTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { pub asset_lock_type : * mut u8 } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { asset_lock_type : ferment :: from_opt_primitive (ffi_ref . asset_lock_type) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError) -> * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { ferment :: boxed (dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { asset_lock_type : ferment :: to_opt_primitive (obj . asset_lock_type) }) } } impl Drop for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . asset_lock_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_ctor (asset_lock_type : * mut u8) -> * mut dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { ferment :: boxed (dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { asset_lock_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_destroy (ffi : * mut dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_get_asset_lock_type (obj : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> * mut u8 { (* obj) . asset_lock_type } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_set_asset_lock_type (obj : * mut dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError , value : * mut u8) { (* obj) . asset_lock_type = value ; } } } pub mod accessors { use crate as example_nested ; } pub mod conversion { use crate as example_nested ; # [cfg (feature = "identity-cbor-conversion")] pub mod cbor { use crate as example_nested ; } # [cfg (feature = "identity-json-conversion")] pub mod json { use crate as example_nested ; } # [cfg (feature = "identity-value-conversion")] pub mod platform_value { use crate as example_nested ; } } pub mod fields { use crate as example_nested ; } pub mod identity_nonce { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MergeIdentityNonceResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_nonce_MergeIdentityNonceResult { InvalidNonce , NonceTooFarInFuture , NonceTooFarInPast , NonceAlreadyPresentAtTip , NonceAlreadyPresentInPast (u64) , MergeIdentityNonceSuccess (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_nonce_MergeIdentityNonceResult) -> dpp :: identity :: identity_nonce :: MergeIdentityNonceResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (* o_0) , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_nonce :: MergeIdentityNonceResult) -> * const dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (match obj { dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce => dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_nonce_MergeIdentityNonceResult { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => { ; } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_InvalidNonce_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceTooFarInFuture_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceTooFarInPast_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceAlreadyPresentAtTip_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceAlreadyPresentInPast_ctor (o_o_0 : u64) -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_MergeIdentityNonceSuccess_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_destroy (ffi : * mut dpp_identity_identity_nonce_MergeIdentityNonceResult) { ferment :: unbox_any (ffi) ; } } pub mod methods { use crate as example_nested ; pub mod create_basic_identity { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; pub mod conversion { use crate as example_nested ; } # [doc = "FFI-representation of the [`IdentityV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_v0_IdentityV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey , pub balance : u64 , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_v0_IdentityV0) -> dpp :: identity :: v0 :: IdentityV0 { let ffi_ref = & * ffi ; dpp :: identity :: v0 :: IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: KeyID , dpp :: identity :: IdentityPublicKey > >> :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) } } } impl ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: v0 :: IdentityV0) -> * const dpp_identity_v0_IdentityV0 { ferment :: boxed (dpp_identity_v0_IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: KeyID , dpp :: identity :: IdentityPublicKey > >> :: ffi_to (obj . public_keys) , balance : obj . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) }) } } impl Drop for dpp_identity_v0_IdentityV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . public_keys) ; ; ferment :: unbox_any (ffi_ref . revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey , balance : u64 , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_identity_v0_IdentityV0 { ferment :: boxed (dpp_identity_v0_IdentityV0 { id , public_keys , balance , revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_destroy (ffi : * mut dpp_identity_v0_IdentityV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_id (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_public_keys (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_balance (obj : * const dpp_identity_v0_IdentityV0) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_revision (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_id (obj : * mut dpp_identity_v0_IdentityV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_public_keys (obj : * mut dpp_identity_v0_IdentityV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_KeyID_values_dpp_identity_IdentityPublicKey) { (* obj) . public_keys = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_balance (obj : * mut dpp_identity_v0_IdentityV0 , value : u64) { (* obj) . balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_revision (obj : * mut dpp_identity_v0_IdentityV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } } } pub mod metadata { use crate as example_nested ; # [doc = "FFI-representation of the [`Metadata`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_metadata_Metadata { pub block_height : u64 , pub core_chain_locked_height : u64 , pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion } impl ferment :: FFIConversionFrom < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_from_const (ffi : * const dpp_metadata_Metadata) -> dpp :: metadata :: Metadata { let ffi_ref = & * ffi ; dpp :: metadata :: Metadata { block_height : ffi_ref . block_height , core_chain_locked_height : ffi_ref . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_from (ffi_ref . protocol_version) } } } impl ferment :: FFIConversionTo < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_to_const (obj : dpp :: metadata :: Metadata) -> * const dpp_metadata_Metadata { ferment :: boxed (dpp_metadata_Metadata { block_height : obj . block_height , core_chain_locked_height : obj . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_to (obj . protocol_version) }) } } impl Drop for dpp_metadata_Metadata { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . protocol_version) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_ctor (block_height : u64 , core_chain_locked_height : u64 , time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion) -> * mut dpp_metadata_Metadata { ferment :: boxed (dpp_metadata_Metadata { block_height , core_chain_locked_height , time_ms , protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_destroy (ffi : * mut dpp_metadata_Metadata) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_block_height (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_core_chain_locked_height (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_time_ms (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_protocol_version (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion { (* obj) . protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_block_height (obj : * mut dpp_metadata_Metadata , value : u64) { (* obj) . block_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_core_chain_locked_height (obj : * mut dpp_metadata_Metadata , value : u64) { (* obj) . core_chain_locked_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_time_ms (obj : * mut dpp_metadata_Metadata , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) { (* obj) . time_ms = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_protocol_version (obj : * mut dpp_metadata_Metadata , value : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion) { (* obj) . protocol_version = value ; } } # [cfg (feature = "state-transitions")] pub mod state_transition { use crate as example_nested ; pub mod abstract_state_transition { use crate as example_nested ; } pub mod state_transition_types { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transition_types_StateTransitionType { DataContractCreate = 0 , Batch = 1 , IdentityCreate = 2 , IdentityTopUp = 3 , DataContractUpdate = 4 , IdentityUpdate = 5 , IdentityCreditWithdrawal = 6 , IdentityCreditTransfer = 7 , MasternodeVote = 8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transition_types_StateTransitionType) -> dpp :: state_transition :: state_transition_types :: StateTransitionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transition_types :: StateTransitionType) -> * const dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch => dpp_state_transition_state_transition_types_StateTransitionType :: Batch , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp , dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer , dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote => dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transition_types_StateTransitionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => { } , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => { } , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_DataContractCreate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_Batch_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: Batch { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityTopUp_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_DataContractUpdate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityUpdate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreditWithdrawal_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreditTransfer_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_MasternodeVote_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_destroy (ffi : * mut dpp_state_transition_state_transition_types_StateTransitionType) { ferment :: unbox_any (ffi) ; } } pub mod errors { use crate as example_nested ; # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut dpp :: identity :: KeyType } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : std :: ptr :: read (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : ferment :: boxed (obj . public_key_type) }) } } impl Drop for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor (public_key_type : * mut dpp :: identity :: KeyType) -> * mut dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy (ffi : * mut dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type (obj : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut dpp :: identity :: KeyType { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type (obj : * mut dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError , value : * mut dpp :: identity :: KeyType) { (* obj) . public_key_type = value ; } } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_signature_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { pub public_key : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError) -> * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { ferment :: boxed (dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_ctor (public_key : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { ferment :: boxed (dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { public_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_destroy (ffi : * mut dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_get_public_key (obj : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . public_key } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_set_public_key (obj : * mut dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . public_key = value ; } } # [cfg (feature = "state-transition-validation")] pub mod public_key_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { pub public_key : * mut dpp :: identity :: IdentityPublicKey } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { public_key : std :: ptr :: read (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError) -> * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { ferment :: boxed (dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { public_key : ferment :: boxed (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_ctor (public_key : * mut dpp :: identity :: IdentityPublicKey) -> * mut dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { ferment :: boxed (dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { public_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_destroy (ffi : * mut dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_get_public_key (obj : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> * mut dpp :: identity :: IdentityPublicKey { (* obj) . public_key } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_set_public_key (obj : * mut dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError , value : * mut dpp :: identity :: IdentityPublicKey) { (* obj) . public_key = value ; } } # [cfg (feature = "state-transition-validation")] pub mod public_key_security_level_not_met_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut dpp :: identity :: SecurityLevel , pub required_security_level : * mut dpp :: identity :: SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : std :: ptr :: read (ffi_ref . public_key_security_level) , required_security_level : std :: ptr :: read (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : ferment :: boxed (obj . public_key_security_level) , required_security_level : ferment :: boxed (obj . required_security_level) }) } } impl Drop for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_ctor (public_key_security_level : * mut dpp :: identity :: SecurityLevel , required_security_level : * mut dpp :: identity :: SecurityLevel) -> * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level , required_security_level }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_destroy (ffi : * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_public_key_security_level (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_required_security_level (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . required_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_public_key_security_level (obj : * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . public_key_security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_required_security_level (obj : * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . required_security_level = value ; } } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation"))] pub mod state_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_errors_state_transition_error_StateTransitionError { InvalidStateTransitionError { errors : * mut crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError , raw_state_transition : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , StateTransitionIsNotActiveError { state_transition_type : * mut std :: os :: raw :: c_char , active_version_range : * mut std :: ops :: RangeInclusive < platform_version :: version :: ProtocolVersion > , current_protocol_version : * mut platform_version :: version :: ProtocolVersion } } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_error_StateTransitionError) -> dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: consensus :: ConsensusError > >> :: ffi_from (* errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_state_transition) } , dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* state_transition_type) , active_version_range : std :: ptr :: read (* active_version_range) , current_protocol_version : std :: ptr :: read (* current_protocol_version) } } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError) -> * const dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (match obj { dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: consensus :: ConsensusError > >> :: ffi_to (errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_state_transition) } , dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (state_transition_type) , active_version_range : ferment :: boxed (active_version_range) , current_protocol_version : ferment :: boxed (current_protocol_version) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_errors_state_transition_error_StateTransitionError { fn drop (& mut self) { unsafe { match self { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_state_transition) ; } , dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version } => { ferment :: unbox_string (* state_transition_type) ; ; ferment :: unbox_any (* active_version_range) ; ; ferment :: unbox_any (* current_protocol_version) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_error_StateTransitionError_InvalidStateTransitionError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError , raw_state_transition : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_error_StateTransitionError_StateTransitionIsNotActiveError_ctor (state_transition_type : * mut std :: os :: raw :: c_char , active_version_range : * mut std :: ops :: RangeInclusive < platform_version :: version :: ProtocolVersion > , current_protocol_version : * mut platform_version :: version :: ProtocolVersion) -> * mut dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (dpp_state_transition_errors_state_transition_error_StateTransitionError :: StateTransitionIsNotActiveError { state_transition_type , active_version_range , current_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_error_StateTransitionError_destroy (ffi : * mut dpp_state_transition_errors_state_transition_error_StateTransitionError) { ferment :: unbox_any (ffi) ; } } # [cfg (feature = "state-transition-validation")] pub mod state_transition_is_not_signed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionIsNotSignedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { pub state_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition >> :: ffi_from (ffi_ref . state_transition) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError) -> * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { ferment :: boxed (dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition >> :: ffi_to (obj . state_transition) }) } } impl Drop for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . state_transition) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_ctor (state_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition) -> * mut dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { ferment :: boxed (dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { state_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_destroy (ffi : * mut dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_get_state_transition (obj : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition { (* obj) . state_transition } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_set_state_transition (obj : * mut dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError , value : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition) { (* obj) . state_transition = value ; } } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] pub mod wrong_public_key_purpose_error { use crate as example_nested ; # [doc = "FFI-representation of the [`WrongPublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { pub public_key_purpose : * mut dpp :: identity :: Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { public_key_purpose : std :: ptr :: read (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose : ferment :: boxed (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_ctor (public_key_purpose : * mut dpp :: identity :: Purpose , allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) -> * mut dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose , allowed_key_purposes }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_destroy (ffi : * mut dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_public_key_purpose (obj : * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut dpp :: identity :: Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_allowed_key_purposes (obj : * const dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose { (* obj) . allowed_key_purposes } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_public_key_purpose (obj : * mut dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError , value : * mut dpp :: identity :: Purpose) { (* obj) . public_key_purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_allowed_key_purposes (obj : * mut dpp_state_transition_errors_wrong_public_key_purpose_error_WrongPublicKeyPurposeError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) { (* obj) . allowed_key_purposes = value ; } } } pub mod proof_result { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionProofResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_proof_result_StateTransitionProofResult { VerifiedDataContract (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) , VerifiedIdentity (* mut dpp :: identity :: Identity) , VerifiedTokenBalanceAbsence (* mut types :: identifier :: Identifier) , VerifiedTokenBalance (* mut types :: identifier :: Identifier , * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) , VerifiedTokenIdentityInfo (* mut types :: identifier :: Identifier , * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) , VerifiedTokenPricingSchedule (* mut types :: identifier :: Identifier , * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) , VerifiedTokenStatus (* mut crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus) , VerifiedTokenIdentitiesBalances (* mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) , VerifiedPartialIdentity (* mut dpp :: identity :: PartialIdentity) , VerifiedBalanceTransfer (* mut dpp :: identity :: PartialIdentity , * mut dpp :: identity :: PartialIdentity) , VerifiedDocuments (* mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document) , VerifiedTokenActionWithDocument (* mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) , VerifiedTokenGroupActionWithDocument (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) , VerifiedTokenGroupActionWithTokenBalance (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) , VerifiedTokenGroupActionWithTokenIdentityInfo (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) , VerifiedTokenGroupActionWithTokenPricingSchedule (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) , VerifiedMasternodeVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) , VerifiedNextDistribution (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_proof_result_StateTransitionProofResult) -> dpp :: state_transition :: proof_result :: StateTransitionProofResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (std :: ptr :: read (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (std :: ptr :: read (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (std :: ptr :: read (* o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (std :: ptr :: read (* o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenPricingSchedule (std :: ptr :: read (* o_0) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (std :: ptr :: read (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (std :: ptr :: read (* o_0) , std :: ptr :: read (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from_opt (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_from (* o_1) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (* o_2)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_to_const (obj : dpp :: state_transition :: proof_result :: StateTransitionProofResult) -> * const dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (match obj { dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (ferment :: boxed (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (ferment :: boxed (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (ferment :: boxed (o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (ferment :: boxed (o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (ferment :: boxed (o_0) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (ferment :: boxed (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (ferment :: boxed (o_0) , ferment :: boxed (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to_opt (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (< crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupSumPower >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus as ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus >> :: ffi_to (o_1) , < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (o_2)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_proof_result_StateTransitionProofResult { fn drop (& mut self) { unsafe { match self { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any_opt (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; ; ferment :: unbox_any_opt (* o_2) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedDataContract_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedIdentity_ctor (o_o_0 : * mut dpp :: identity :: Identity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenBalanceAbsence_ctor (o_o_0 : * mut types :: identifier :: Identifier) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenBalance_ctor (o_o_0 : * mut types :: identifier :: Identifier , o_o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenIdentityInfo_ctor (o_o_0 : * mut types :: identifier :: Identifier , o_o_1 : * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenPricingSchedule_ctor (o_o_0 : * mut types :: identifier :: Identifier , o_o_1 : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenPricingSchedule (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenStatus_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenIdentitiesBalances_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedPartialIdentity_ctor (o_o_0 : * mut dpp :: identity :: PartialIdentity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedBalanceTransfer_ctor (o_o_0 : * mut dpp :: identity :: PartialIdentity , o_o_1 : * mut dpp :: identity :: PartialIdentity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedDocuments_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenActionWithDocument_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenGroupActionWithDocument_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , o_o_1 : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithDocument (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenGroupActionWithTokenBalance_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , o_o_1 : * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , o_o_2 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenBalance (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenGroupActionWithTokenIdentityInfo_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , o_o_1 : * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , o_o_2 : * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenIdentityInfo (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenGroupActionWithTokenPricingSchedule_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupSumPower , o_o_1 : * mut crate :: fermented :: types :: dpp :: group :: group_action_status :: dpp_group_group_action_status_GroupActionStatus , o_o_2 : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenGroupActionWithTokenPricingSchedule (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedMasternodeVote_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedNextDistribution_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_destroy (ffi : * mut dpp_state_transition_proof_result_StateTransitionProofResult) { ferment :: unbox_any (ffi) ; } } pub mod serialization { use crate as example_nested ; } pub mod state_transitions { use crate as example_nested ; pub mod common_fields { use crate as example_nested ; } pub mod contract { use crate as example_nested ; pub mod common_fields { use crate as example_nested ; } pub mod data_contract_create_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } # [cfg (feature = "state-transition-json-conversion")] pub mod json_conversion { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . identity_nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_ctor (data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { data_contract , identity_nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_data_contract (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_identity_nonce (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_data_contract (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat) { (* obj) . data_contract = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_identity_nonce (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . identity_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { V0 (* mut dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { ferment :: unbox_any (ffi) ; } } pub mod data_contract_update_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_ctor (identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { identity_contract_nonce , data_contract , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_identity_contract_nonce (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_data_contract (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_identity_contract_nonce (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . identity_contract_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_data_contract (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat) { (* obj) . data_contract = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { V0 (* mut dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) { ferment :: unbox_any (ffi) ; } } } pub mod document { use crate as example_nested ; pub mod batch_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod batched_transition { use crate as example_nested ; pub mod document_base_transition { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub document_type_name : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , document_type_name : * mut std :: os :: raw :: c_char , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { id , identity_contract_nonce , document_type_name , data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_identity_contract_nonce (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_document_type_name (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_data_contract_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_identity_contract_nonce (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . identity_contract_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_document_type_name (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_data_contract_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentBaseTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub document_type_name : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_payment_info : * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_payment_info : < crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo as ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: TokenPaymentInfo >> :: ffi_from_opt (ffi_ref . token_payment_info) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_payment_info : < crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo as ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: TokenPaymentInfo >> :: ffi_to_opt (obj . token_payment_info) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . token_payment_info) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , document_type_name : * mut std :: os :: raw :: c_char , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , token_payment_info : * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 { id , identity_contract_nonce , document_type_name , data_contract_id , token_payment_info }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_get_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_get_identity_contract_nonce (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_get_document_type_name (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_get_data_contract_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_get_token_payment_info (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo { (* obj) . token_payment_info } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_set_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_set_identity_contract_nonce (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . identity_contract_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_set_document_type_name (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_set_data_contract_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1_set_token_payment_info (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v1_DocumentBaseTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: dpp_tokens_token_payment_info_TokenPaymentInfo) { (* obj) . token_payment_info = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { V0 (* mut dpp :: state_transition :: batch_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0) , V1 (* mut dpp :: state_transition :: batch_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V1 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V1 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition_V1_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: v1 :: DocumentBaseTransitionV1) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_create_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , pub entropy : * mut crate :: fermented :: generics :: Arr_u8_32 , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub prefunded_voting_balance : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) >> :: ffi_from_opt (ffi_ref . prefunded_voting_balance) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { base : ferment :: boxed (obj . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) >> :: ffi_to_opt (obj . prefunded_voting_balance) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . entropy) ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . prefunded_voting_balance) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , entropy : * mut crate :: fermented :: generics :: Arr_u8_32 , data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , prefunded_voting_balance : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { base , entropy , data , prefunded_voting_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_entropy (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . entropy } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_data (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_prefunded_voting_balance (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits { (* obj) . prefunded_voting_balance } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_entropy (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . entropy = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_data (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value) { (* obj) . data = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_prefunded_voting_balance (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 , value : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits) { (* obj) . prefunded_voting_balance = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_delete_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentDeleteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { base : std :: ptr :: read (ffi_ref . base) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { base : ferment :: boxed (obj . base) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { base }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentDeleteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_purchase_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { base : ferment :: boxed (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { base , revision , price }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_revision (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_price (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_revision (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_price (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . price = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_replace_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentReplaceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { base : ferment :: boxed (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . data) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { base , revision , data }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_revision (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_data (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_revision (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_data (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value) { (* obj) . data = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentReplaceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_transfer_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub recipient_owner_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , recipient_owner_id : std :: ptr :: read (ffi_ref . recipient_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { base : ferment :: boxed (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , recipient_owner_id : ferment :: boxed (obj . recipient_owner_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . recipient_owner_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , recipient_owner_id : * mut types :: identifier :: Identifier) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { base , revision , recipient_owner_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_revision (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_recipient_owner_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . recipient_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_revision (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_recipient_owner_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . recipient_owner_id = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { Create (* mut dpp :: state_transition :: batch_transition :: DocumentCreateTransition) , Replace (* mut dpp :: state_transition :: batch_transition :: DocumentReplaceTransition) , Delete (* mut dpp :: state_transition :: batch_transition :: DocumentDeleteTransition) , Transfer (* mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentTransferTransition) , UpdatePrice (* mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentUpdatePriceTransition) , Purchase (* mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentPurchaseTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Create_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: DocumentCreateTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Replace_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: DocumentReplaceTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Delete_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: DocumentDeleteTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Transfer_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentTransferTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_UpdatePrice_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentUpdatePriceTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Purchase_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: batched_transition :: DocumentPurchaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_transition_action_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransitionActionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { Create , Replace , Delete , Transfer , Purchase , UpdatePrice , IgnoreWhileBumpingRevision } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Create_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Replace_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Delete_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Transfer_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Purchase_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_UpdatePrice_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_IgnoreWhileBumpingRevision_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType) { ferment :: unbox_any (ffi) ; } } pub mod document_update_price_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentUpdatePriceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { base : ferment :: boxed (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { base , revision , price }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_revision (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_price (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: document_base_transition :: DocumentBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_revision (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_price (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . price = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentUpdatePriceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_base_transition { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub token_contract_position : u16 , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub using_group_info : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , token_contract_position : ffi_ref . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo >> :: ffi_from_opt (ffi_ref . using_group_info) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , token_contract_position : obj . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo >> :: ffi_to_opt (obj . using_group_info) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any_opt (ffi_ref . using_group_info) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_ctor (identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , token_contract_position : u16 , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , using_group_info : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { identity_contract_nonce , token_contract_position , data_contract_id , token_id , using_group_info }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_identity_contract_nonce (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_token_contract_position (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> u16 { (* obj) . token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_data_contract_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_token_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_using_group_info (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo { (* obj) . using_group_info } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_identity_contract_nonce (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . identity_contract_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_token_contract_position (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 , value : u16) { (* obj) . token_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_data_contract_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_token_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_using_group_info (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo) { (* obj) . using_group_info = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { V0 (* mut dpp :: state_transition :: batch_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_burn_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenBurnTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub burn_amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , burn_amount : ffi_ref . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { base : ferment :: boxed (obj . base) , burn_amount : obj . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , burn_amount : u64 , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { base , burn_amount , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_burn_amount (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> u64 { (* obj) . burn_amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_burn_amount (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 , value : u64) { (* obj) . burn_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBurnTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_claim_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenClaimTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub distribution_type : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_from (ffi_ref . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { base : ferment :: boxed (obj . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_to (obj . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . distribution_type) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , distribution_type : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { base , distribution_type , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_distribution_type (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { (* obj) . distribution_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_distribution_type (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) { (* obj) . distribution_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenClaimTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_config_update_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub update_token_configuration_item : * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , update_token_configuration_item : < example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_item :: TokenConfigurationChangeItem >> :: ffi_from (ffi_ref . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { base : ferment :: boxed (obj . base) , update_token_configuration_item : < example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_item :: TokenConfigurationChangeItem >> :: ffi_to (obj . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . update_token_configuration_item) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , update_token_configuration_item : * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { base , update_token_configuration_item , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_update_token_configuration_item (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI { (* obj) . update_token_configuration_item } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_update_token_configuration_item (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 , value : * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI) { (* obj) . update_token_configuration_item = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_destroy_frozen_funds_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenDestroyFrozenFundsTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub frozen_identity_id : * mut types :: identifier :: Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , frozen_identity_id : std :: ptr :: read (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { base : ferment :: boxed (obj . base) , frozen_identity_id : ferment :: boxed (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , frozen_identity_id : * mut types :: identifier :: Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { base , frozen_identity_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_frozen_identity_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_frozen_identity_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . frozen_identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDestroyFrozenFundsTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_direct_purchase_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenDirectPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub token_count : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub total_agreed_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , token_count : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . token_count) , total_agreed_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . total_agreed_price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { base : ferment :: boxed (obj . base) , token_count : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . token_count) , total_agreed_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . total_agreed_price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . token_count) ; ferment :: unbox_any (ffi_ref . total_agreed_price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , token_count : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , total_agreed_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 { base , token_count , total_agreed_price }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_get_token_count (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . token_count } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_get_total_agreed_price (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . total_agreed_price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_set_token_count (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . token_count = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0_set_total_agreed_price (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . total_agreed_price = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDirectPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: TokenDirectPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_v0_TokenDirectPurchaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_direct_purchase_transition_TokenDirectPurchaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_emergency_action_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenEmergencyActionTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub emergency_action : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_from (ffi_ref . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { base : ferment :: boxed (obj . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_to (obj . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . emergency_action) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , emergency_action : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { base , emergency_action , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_emergency_action (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction { (* obj) . emergency_action } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_emergency_action (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction) { (* obj) . emergency_action = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyActionTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_freeze_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenFreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub identity_to_freeze_id : * mut types :: identifier :: Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , identity_to_freeze_id : std :: ptr :: read (ffi_ref . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { base : ferment :: boxed (obj . base) , identity_to_freeze_id : ferment :: boxed (obj . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . identity_to_freeze_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , identity_to_freeze_id : * mut types :: identifier :: Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { base , identity_to_freeze_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_identity_to_freeze_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . identity_to_freeze_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_identity_to_freeze_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . identity_to_freeze_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenFreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_mint_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenMintTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub issued_to_identity_id : * mut types :: identifier :: Identifier , pub amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , issued_to_identity_id : ferment :: from_opt_opaque (ffi_ref . issued_to_identity_id) , amount : ffi_ref . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { base : ferment :: boxed (obj . base) , issued_to_identity_id : ferment :: to_opt_primitive (obj . issued_to_identity_id) , amount : obj . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any_opt (ffi_ref . issued_to_identity_id) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , issued_to_identity_id : * mut types :: identifier :: Identifier , amount : u64 , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { base , issued_to_identity_id , amount , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_issued_to_identity_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . issued_to_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_amount (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_issued_to_identity_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . issued_to_identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_amount (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenMintTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_set_price_for_direct_purchase_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenSetPriceForDirectPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub price : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , price : < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_from_opt (ffi_ref . price) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { base : ferment :: boxed (obj . base) , price : < crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule as ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule >> :: ffi_to_opt (obj . price) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any_opt (ffi_ref . price) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , price : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 { base , price , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_get_price (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule { (* obj) . price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_set_price (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_pricing_schedule :: dpp_tokens_token_pricing_schedule_TokenPricingSchedule) { (* obj) . price = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenSetPriceForDirectPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: TokenSetPriceForDirectPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_set_price_for_direct_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_v0_TokenSetPriceForDirectPurchaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_set_price_for_direct_purchase_transition_TokenSetPriceForDirectPurchaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_transfer_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub amount : u64 , pub recipient_id : * mut types :: identifier :: Identifier , pub public_note : * mut std :: os :: raw :: c_char , pub shared_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote , pub private_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , amount : ffi_ref . amount , recipient_id : std :: ptr :: read (ffi_ref . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote >> :: ffi_from_opt (ffi_ref . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_from_opt (ffi_ref . private_encrypted_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { base : ferment :: boxed (obj . base) , amount : obj . amount , recipient_id : ferment :: boxed (obj . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote >> :: ffi_to_opt (obj . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_to_opt (obj . private_encrypted_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; ferment :: unbox_any_opt (ffi_ref . shared_encrypted_note) ; ferment :: unbox_any_opt (ffi_ref . private_encrypted_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , amount : u64 , recipient_id : * mut types :: identifier :: Identifier , public_note : * mut std :: os :: raw :: c_char , shared_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote , private_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { base , amount , recipient_id , public_note , shared_encrypted_note , private_encrypted_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_amount (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_recipient_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_shared_encrypted_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote { (* obj) . shared_encrypted_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_private_encrypted_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote { (* obj) . private_encrypted_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_amount (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_recipient_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . recipient_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_shared_encrypted_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote) { (* obj) . shared_encrypted_note = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_private_encrypted_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote) { (* obj) . private_encrypted_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { Burn (* mut dpp :: state_transition :: batch_transition :: TokenBurnTransition) , Mint (* mut dpp :: state_transition :: batch_transition :: TokenMintTransition) , Transfer (* mut dpp :: state_transition :: batch_transition :: TokenTransferTransition) , Freeze (* mut dpp :: state_transition :: batch_transition :: TokenFreezeTransition) , Unfreeze (* mut dpp :: state_transition :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition) , DestroyFrozenFunds (* mut dpp :: state_transition :: batch_transition :: TokenDestroyFrozenFundsTransition) , Claim (* mut dpp :: state_transition :: batch_transition :: TokenClaimTransition) , EmergencyAction (* mut dpp :: state_transition :: batch_transition :: TokenEmergencyActionTransition) , ConfigUpdate (* mut dpp :: state_transition :: batch_transition :: TokenConfigUpdateTransition) , DirectPurchase (* mut dpp :: state_transition :: batch_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition) , SetPriceForDirectPurchase (* mut dpp :: state_transition :: batch_transition :: TokenSetPriceForDirectPurchaseTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DirectPurchase (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: SetPriceForDirectPurchase (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DirectPurchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: SetPriceForDirectPurchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Burn_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenBurnTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Mint_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenMintTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Transfer_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenTransferTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Freeze_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenFreezeTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Unfreeze_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_DestroyFrozenFunds_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenDestroyFrozenFundsTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Claim_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenClaimTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_EmergencyAction_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenEmergencyActionTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_ConfigUpdate_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenConfigUpdateTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_DirectPurchase_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: token_direct_purchase_transition :: TokenDirectPurchaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DirectPurchase (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_SetPriceForDirectPurchase_ctor (o_o_0 : * mut dpp :: state_transition :: batch_transition :: TokenSetPriceForDirectPurchaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: SetPriceForDirectPurchase (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_unfreeze_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenUnfreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { pub base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , pub frozen_identity_id : * mut types :: identifier :: Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { base : std :: ptr :: read (ffi_ref . base) , frozen_identity_id : std :: ptr :: read (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { base : ferment :: boxed (obj . base) , frozen_identity_id : ferment :: boxed (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_ctor (base : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition , frozen_identity_id : * mut types :: identifier :: Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { base , frozen_identity_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_base (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_frozen_identity_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_public_note (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_base (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 , value : * mut dpp :: state_transition :: batch_transition :: token_base_transition :: TokenBaseTransition) { (* obj) . base = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_frozen_identity_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . frozen_identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_public_note (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 , value : * mut std :: os :: raw :: c_char) { (* obj) . public_note = value ; } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenUnfreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchedTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { Document (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) , Token (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_Document_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_Token_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) { ferment :: unbox_any (ffi) ; } } pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod resolvers { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`BatchTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { pub owner_id : * mut types :: identifier :: Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { owner_id : std :: ptr :: read (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { owner_id : ferment :: boxed (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_ctor (owner_id : * mut types :: identifier :: Identifier , transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { owner_id , transitions , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_owner_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_transitions (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_owner_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_transitions (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { (* obj) . transitions = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`BatchTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { pub owner_id : * mut types :: identifier :: Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { owner_id : std :: ptr :: read (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1) -> * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { owner_id : ferment :: boxed (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_ctor (owner_id : * mut types :: identifier :: Identifier , transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { owner_id , transitions , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_owner_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut types :: identifier :: Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_transitions (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_signature (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_owner_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 , value : * mut types :: identifier :: Identifier) { (* obj) . owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_transitions (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 , value : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_batch_transition_batched_transition_BatchedTransition) { (* obj) . transitions = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_signature (obj : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [cfg (feature = "validation")] pub mod validation { use crate as example_nested ; pub mod find_duplicates_by_id { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod validate_basic_structure { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { V0 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransitionV0) , V1 (* mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_V1_ctor (o_o_0 : * mut dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransitionV1) -> * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) { ferment :: unbox_any (ffi) ; } } } pub mod identity { use crate as example_nested ; pub mod common_fields { use crate as example_nested ; } pub mod identity_create_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { pub public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation , pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut types :: binary_data :: BinaryData , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : std :: ptr :: read (ffi_ref . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : ferment :: boxed (obj . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_keys) ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_ctor (public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation , asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature : * mut types :: binary_data :: BinaryData , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { public_keys , asset_lock_proof , user_fee_increase , signature , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_public_keys (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_asset_lock_proof (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_public_keys (obj : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation) { (* obj) . public_keys = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_asset_lock_proof (obj : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof) { (* obj) . asset_lock_proof = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { V0 (* mut dpp :: state_transition :: identity_create_transition :: v0 :: IdentityCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: identity_create_transition :: v0 :: IdentityCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) { ferment :: unbox_any (ffi) ; } } pub mod identity_credit_transfer_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , amount : ffi_ref . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , amount : obj . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { identity_id , recipient_id , amount , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_recipient_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_amount (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_nonce (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_recipient_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . recipient_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_amount (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_nonce (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { V0 (* mut dpp :: state_transition :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod identity_credit_withdrawal_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , core_fee_per_byte : u32 , pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { identity_id , amount , core_fee_per_byte , pooling , output_script , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_amount (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_core_fee_per_byte (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_pooling (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_output_script (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_nonce (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_amount (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_core_fee_per_byte (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : u32) { (* obj) . core_fee_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_pooling (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling) { (* obj) . pooling = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_output_script (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) { (* obj) . output_script = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_nonce (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from_opt (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to_opt (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any_opt (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , core_fee_per_byte : u32 , pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { identity_id , amount , core_fee_per_byte , pooling , output_script , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_amount (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_core_fee_per_byte (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_pooling (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_output_script (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_nonce (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_amount (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_core_fee_per_byte (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : u32) { (* obj) . core_fee_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_pooling (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling) { (* obj) . pooling = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_output_script (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) { (* obj) . output_script = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_nonce (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditWithdrawalTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { V0 (* mut dpp :: state_transition :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0) , V1 (* mut dpp :: state_transition :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (std :: ptr :: read (* o_0)) , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (ferment :: boxed (o_0)) , dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_V1_ctor (o_o_0 : * mut dpp :: state_transition :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) { ferment :: unbox_any (ffi) ; } } pub mod identity_topup_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTopUpTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_ctor (asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { asset_lock_proof , identity_id , user_fee_increase , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_asset_lock_proof (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_asset_lock_proof (obj : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof) { (* obj) . asset_lock_proof = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTopUpTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { V0 (* mut dpp :: state_transition :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) { ferment :: unbox_any (ffi) ; } } pub mod identity_update_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [cfg (feature = "state-transition-json-conversion")] pub mod json_conversion { use crate as example_nested ; } # [doc = "FFI-representation of the [`IdentityUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub add_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation , pub disable_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . add_public_keys) ; ferment :: unbox_any (ffi_ref . disable_public_keys) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , add_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation , disable_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { identity_id , revision , nonce , add_public_keys , disable_public_keys , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_identity_id (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_revision (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_nonce (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_add_public_keys (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . add_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_disable_public_keys (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . disable_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_user_fee_increase (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_revision (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_nonce (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_add_public_keys (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_public_key_in_creation_IdentityPublicKeyInCreation) { (* obj) . add_public_keys = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_disable_public_keys (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . disable_public_keys = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_user_fee_increase (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease) { (* obj) . user_fee_increase = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { V0 (* mut dpp :: state_transition :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) { ferment :: unbox_any (ffi) ; } } pub mod masternode_vote_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVoteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub vote : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub signature_public_key_id : * mut dpp :: identity :: KeyID , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (ffi_ref . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , signature_public_key_id : std :: ptr :: read (ffi_ref . signature_public_key_id) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (obj . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , signature_public_key_id : ferment :: boxed (obj . signature_public_key_id) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . voter_identity_id) ; ferment :: unbox_any (ffi_ref . vote) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_ctor (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , vote : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , signature_public_key_id : * mut dpp :: identity :: KeyID , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pro_tx_hash , voter_identity_id , vote , nonce , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_pro_tx_hash (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_voter_identity_id (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_vote (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote { (* obj) . vote } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_nonce (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_signature_public_key_id (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut dpp :: identity :: KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_pro_tx_hash (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_voter_identity_id (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . voter_identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_vote (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) { (* obj) . vote = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_nonce (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_signature_public_key_id (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . signature_public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MasternodeVoteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { V0 (* mut dpp :: state_transition :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition_V0_ctor (o_o_0 : * mut dpp :: state_transition :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) { ferment :: unbox_any (ffi) ; } } pub mod public_key_in_creation { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod duplicated_key_ids_witness { use crate as example_nested ; } pub mod duplicated_keys_witness { use crate as example_nested ; } # [cfg (feature = "state-transition-signing")] pub mod from_public_key_signed_external { use crate as example_nested ; } # [cfg (feature = "state-transition-signing")] pub mod from_public_key_signed_with_private_key { use crate as example_nested ; } pub mod hash { use crate as example_nested ; } pub mod validate_identity_public_keys_structure { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyInCreationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { pub id : * mut dpp :: identity :: KeyID , pub key_type : * mut dpp :: identity :: KeyType , pub purpose : * mut dpp :: identity :: Purpose , pub security_level : * mut dpp :: identity :: SecurityLevel , pub contract_bounds : * mut dpp :: identity :: contract_bounds :: ContractBounds , pub read_only : bool , pub data : * mut types :: binary_data :: BinaryData , pub signature : * mut types :: binary_data :: BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { id : std :: ptr :: read (ffi_ref . id) , key_type : std :: ptr :: read (ffi_ref . key_type) , purpose : std :: ptr :: read (ffi_ref . purpose) , security_level : std :: ptr :: read (ffi_ref . security_level) , contract_bounds : ferment :: from_opt_opaque (ffi_ref . contract_bounds) , read_only : ffi_ref . read_only , data : std :: ptr :: read (ffi_ref . data) , signature : std :: ptr :: read (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { id : ferment :: boxed (obj . id) , key_type : ferment :: boxed (obj . key_type) , purpose : ferment :: boxed (obj . purpose) , security_level : ferment :: boxed (obj . security_level) , contract_bounds : ferment :: to_opt_primitive (obj . contract_bounds) , read_only : obj . read_only , data : ferment :: boxed (obj . data) , signature : ferment :: boxed (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . key_type) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_ctor (id : * mut dpp :: identity :: KeyID , key_type : * mut dpp :: identity :: KeyType , purpose : * mut dpp :: identity :: Purpose , security_level : * mut dpp :: identity :: SecurityLevel , contract_bounds : * mut dpp :: identity :: contract_bounds :: ContractBounds , read_only : bool , data : * mut types :: binary_data :: BinaryData , signature : * mut types :: binary_data :: BinaryData) -> * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { id , key_type , purpose , security_level , contract_bounds , read_only , data , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_id (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp :: identity :: KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_key_type (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp :: identity :: KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_purpose (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp :: identity :: Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_security_level (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_contract_bounds (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp :: identity :: contract_bounds :: ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_read_only (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_data (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut types :: binary_data :: BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_signature (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut types :: binary_data :: BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_id (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut dpp :: identity :: KeyID) { (* obj) . id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_key_type (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut dpp :: identity :: KeyType) { (* obj) . key_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_purpose (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut dpp :: identity :: Purpose) { (* obj) . purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_security_level (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_contract_bounds (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut dpp :: identity :: contract_bounds :: ContractBounds) { (* obj) . contract_bounds = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_read_only (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : bool) { (* obj) . read_only = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_data (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . data = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_signature (obj : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 , value : * mut types :: binary_data :: BinaryData) { (* obj) . signature = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKeyInCreation`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { V0 (* mut dpp :: state_transition :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (o_0) => dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_V0_ctor (o_o_0 : * mut dpp :: state_transition :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0) -> * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_destroy (ffi : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) { ferment :: unbox_any (ffi) ; } } } } pub mod traits { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_StateTransition { DataContractCreate (* mut state_transition) , DataContractUpdate (* mut state_transition) , Batch (* mut state_transition) , IdentityCreate (* mut state_transition) , IdentityTopUp (* mut state_transition) , IdentityCreditWithdrawal (* mut state_transition) , IdentityUpdate (* mut state_transition) , IdentityCreditTransfer (* mut state_transition) , MasternodeVote (* mut state_transition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_StateTransition) -> dpp :: state_transition :: StateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => dpp :: state_transition :: StateTransition :: DataContractCreate (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => dpp :: state_transition :: StateTransition :: DataContractUpdate (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: Batch (o_0) => dpp :: state_transition :: StateTransition :: Batch (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreate (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => dpp :: state_transition :: StateTransition :: IdentityTopUp (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => dpp :: state_transition :: StateTransition :: IdentityUpdate (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (std :: ptr :: read (* o_0)) , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => dpp :: state_transition :: StateTransition :: MasternodeVote (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: StateTransition) -> * const dpp_state_transition_StateTransition { ferment :: boxed (match obj { dpp :: state_transition :: StateTransition :: DataContractCreate (o_0) => dpp_state_transition_StateTransition :: DataContractCreate (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: DataContractUpdate (o_0) => dpp_state_transition_StateTransition :: DataContractUpdate (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: Batch (o_0) => dpp_state_transition_StateTransition :: Batch (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreate (o_0) => dpp_state_transition_StateTransition :: IdentityCreate (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: IdentityTopUp (o_0) => dpp_state_transition_StateTransition :: IdentityTopUp (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (o_0) => dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: IdentityUpdate (o_0) => dpp_state_transition_StateTransition :: IdentityUpdate (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (o_0) => dpp_state_transition_StateTransition :: IdentityCreditTransfer (ferment :: boxed (o_0)) , dpp :: state_transition :: StateTransition :: MasternodeVote (o_0) => dpp_state_transition_StateTransition :: MasternodeVote (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_StateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: Batch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_DataContractCreate_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: DataContractCreate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_DataContractUpdate_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: DataContractUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_Batch_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: Batch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreate_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityTopUp_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityTopUp (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreditWithdrawal_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityUpdate_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreditTransfer_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_MasternodeVote_ctor (o_o_0 : * mut state_transition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: MasternodeVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_destroy (ffi : * mut dpp_state_transition_StateTransition) { ferment :: unbox_any (ffi) ; } } pub mod util { use crate as example_nested ; # [cfg (feature = "cbor")] pub mod cbor_value { use crate as example_nested ; pub mod convert { use crate as example_nested ; } pub mod canonical { use crate as example_nested ; } } pub mod deserializer { use crate as example_nested ; # [doc = "FFI-representation of the [`ProtocolVersion`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_util_deserializer_ProtocolVersion (u32) ; impl ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_from_const (ffi : * const dpp_util_deserializer_ProtocolVersion) -> dpp :: util :: deserializer :: ProtocolVersion { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_to_const (obj : dpp :: util :: deserializer :: ProtocolVersion) -> * const dpp_util_deserializer_ProtocolVersion { ferment :: boxed (dpp_util_deserializer_ProtocolVersion (obj)) } } impl Drop for dpp_util_deserializer_ProtocolVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_ctor (o_0 : u32) -> * mut dpp_util_deserializer_ProtocolVersion { ferment :: boxed (dpp_util_deserializer_ProtocolVersion (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_destroy (ffi : * mut dpp_util_deserializer_ProtocolVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_get_0 (obj : * const dpp_util_deserializer_ProtocolVersion) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_set_0 (obj : * mut dpp_util_deserializer_ProtocolVersion , value : u32) { (* obj) . 0 = value ; } } pub mod json_path { use crate as example_nested ; } pub mod json_schema { use crate as example_nested ; } pub mod json_value { use crate as example_nested ; pub mod insert_with_path { use crate as example_nested ; } pub mod remove_path { use crate as example_nested ; } } pub mod strings { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } pub mod errors { use crate as example_nested ; pub mod compatible_protocol_version_is_not_defined_error { use crate as example_nested ; # [doc = "FFI-representation of the [`CompatibleProtocolVersionIsNotDefinedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { let ffi_ref = & * ffi ; dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_to_const (obj : dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError) -> * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { ferment :: boxed (dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : obj . current_protocol_version }) } } impl Drop for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_ctor (current_protocol_version : u32) -> * mut dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { ferment :: boxed (dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { current_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_destroy (ffi : * mut dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_get_current_protocol_version (obj : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> u32 { (* obj) . current_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_set_current_protocol_version (obj : * mut dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError , value : u32) { (* obj) . current_protocol_version = value ; } } pub mod consensus { use crate as example_nested ; pub mod basic { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; pub mod contested_unique_index_on_mutable_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedUniqueIndexOnMutableDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_ctor (document_type : * mut std :: os :: raw :: c_char , contested_unique_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { document_type , contested_unique_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_get_contested_unique_index_name (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_set_contested_unique_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . contested_unique_index_name = value ; } } pub mod contested_unique_index_with_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedUniqueIndexWithUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char , pub unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; ferment :: unbox_string (ffi_ref . unique_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_ctor (document_type : * mut std :: os :: raw :: c_char , contested_unique_index_name : * mut std :: os :: raw :: c_char , unique_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { document_type , contested_unique_index_name , unique_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_contested_unique_index_name (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_unique_index_name (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_contested_unique_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . contested_unique_index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_unique_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . unique_index_name = value ; } } pub mod data_contract_have_new_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractHaveNewUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } } pub mod data_contract_immutable_properties_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractImmutablePropertiesUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub new_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . new_value) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . new_value) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_value) ; ferment :: unbox_any (ffi_ref . new_value) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_ctor (operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char , old_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , new_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { operation , field_path , old_value , new_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_operation (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_field_path (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_old_value (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . old_value } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_new_value (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . new_value } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_operation (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . operation = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_field_path (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . field_path = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_old_value (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { (* obj) . old_value = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_new_value (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { (* obj) . new_value = value ; } } pub mod data_contract_invalid_index_definition_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInvalidIndexDefinitionUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { pub document_type : * mut std :: os :: raw :: c_char , pub index_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_ctor (document_type : * mut std :: os :: raw :: c_char , index_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { document_type , index_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_get_index_path (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . index_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_set_index_path (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_path = value ; } } pub mod data_contract_max_depth_exceed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractMaxDepthExceedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { pub max_depth : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { max_depth : ffi_ref . max_depth } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { max_depth : obj . max_depth }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_ctor (max_depth : usize) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { max_depth }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_get_max_depth (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> usize { (* obj) . max_depth } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_set_max_depth (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError , value : usize) { (* obj) . max_depth = value ; } } pub mod data_contract_token_configuration_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractTokenConfigurationUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_config : * mut data_contract , pub new_config : * mut data_contract } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_config : std :: ptr :: read (ffi_ref . old_config) , new_config : std :: ptr :: read (ffi_ref . new_config) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_config : ferment :: boxed (obj . old_config) , new_config : ferment :: boxed (obj . new_config) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_config) ; ferment :: unbox_any (ffi_ref . new_config) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_ctor (operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char , old_config : * mut data_contract , new_config : * mut data_contract) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { operation , field_path , old_config , new_config }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_operation (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_field_path (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_old_config (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut data_contract { (* obj) . old_config } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_new_config (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut data_contract { (* obj) . new_config } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_operation (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . operation = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_field_path (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . field_path = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_old_config (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError , value : * mut data_contract) { (* obj) . old_config = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_new_config (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError , value : * mut data_contract) { (* obj) . new_config = value ; } } pub mod data_contract_unique_indices_changed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUniqueIndicesChangedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } } pub mod document_types_are_missing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypesAreMissingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError) -> * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_ctor (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } } pub mod duplicate_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } } pub mod duplicate_index_name_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateIndexNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { pub document_type : * mut std :: os :: raw :: c_char , pub duplicate_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . duplicate_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . duplicate_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . duplicate_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_ctor (document_type : * mut std :: os :: raw :: c_char , duplicate_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { document_type , duplicate_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_get_duplicate_index_name (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . duplicate_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_set_duplicate_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError , value : * mut std :: os :: raw :: c_char) { (* obj) . duplicate_index_name = value ; } } pub mod duplicate_keywords_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateKeywordsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { pub data_contract_id : * mut types :: identifier :: Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError > for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError > for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_keywords_error :: DuplicateKeywordsError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { data_contract_id : ferment :: boxed (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_ctor (data_contract_id : * mut types :: identifier :: Identifier , keyword : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError { data_contract_id , keyword }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_get_keyword (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError_set_keyword (obj : * mut dpp_errors_consensus_basic_data_contract_duplicate_keywords_error_DuplicateKeywordsError , value : * mut std :: os :: raw :: c_char) { (* obj) . keyword = value ; } } pub mod group_exceeds_max_members_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupExceedsMaxMembersError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { pub max_members : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { max_members : ffi_ref . max_members } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError) -> * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { max_members : obj . max_members }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_ctor (max_members : u32) -> * mut dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { max_members }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_get_max_members (obj : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> u32 { (* obj) . max_members } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_set_max_members (obj : * mut dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError , value : u32) { (* obj) . max_members = value ; } } pub mod group_member_has_power_of_zero_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOfZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_ctor (member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { member_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_get_member_id (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_set_member_id (obj : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . member_id = value ; } } pub mod group_member_has_power_over_limit_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOverLimitError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . max_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . max_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; ferment :: unbox_any (ffi_ref . power) ; ferment :: unbox_any (ffi_ref . max_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_ctor (member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { member_id , power , max_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_member_id (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_power (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_max_power (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . max_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_member_id (obj : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . member_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . power = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_max_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . max_power = value ; } } pub mod group_non_unilateral_member_power_has_less_than_required_power_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_ctor (total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_get_total_power (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_get_required_power (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_set_total_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . total_power = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_set_required_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . required_power = value ; } } pub mod group_position_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupPositionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { pub missing_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError) -> * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_group_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_group_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_ctor (missing_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { missing_group_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_get_missing_group_position (obj : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_set_missing_group_position (obj : * mut dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . missing_group_position = value ; } } pub mod group_required_power_is_invalid_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupRequiredPowerIsInvalidError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower , pub max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError > for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError { required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . required_power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . max_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError > for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_required_power_is_invalid_error :: GroupRequiredPowerIsInvalidError) -> * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . required_power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . max_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . required_power) ; ferment :: unbox_any (ffi_ref . max_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_ctor (required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower , max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) -> * mut dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError { required_power , max_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_get_required_power (obj : * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_get_max_power (obj : * const dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower { (* obj) . max_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_set_required_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) { (* obj) . required_power = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError_set_max_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_required_power_is_invalid_error_GroupRequiredPowerIsInvalidError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) { (* obj) . max_power = value ; } } pub mod group_total_power_has_less_than_required_power_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupTotalPowerLessThanRequiredError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError) -> * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_ctor (total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { total_power , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_get_total_power (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_get_required_power (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_set_total_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . total_power = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_set_required_power (obj : * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { (* obj) . required_power = value ; } } pub mod incompatible_data_contract_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleDataContractSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_ctor (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { data_contract_id , operation , field_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_operation (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_field_path (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_operation (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . operation = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_field_path (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . field_path = value ; } } pub mod incompatible_document_type_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleDocumentTypeSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { pub document_type_name : * mut std :: os :: raw :: c_char , pub operation : * mut std :: os :: raw :: c_char , pub property_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . property_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_ctor (document_type_name : * mut std :: os :: raw :: c_char , operation : * mut std :: os :: raw :: c_char , property_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { document_type_name , operation , property_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_document_type_name (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_operation (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_property_path (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_document_type_name (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_operation (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . operation = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_property_path (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_path = value ; } } pub mod incompatible_re2_pattern_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleRe2PatternError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pub pattern : * mut std :: os :: raw :: c_char , pub path : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . pattern) ; ferment :: unbox_string (ffi_ref . path) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_ctor (pattern : * mut std :: os :: raw :: c_char , path : * mut std :: os :: raw :: c_char , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pattern , path , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_pattern (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . pattern } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_path (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_message (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_pattern (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError , value : * mut std :: os :: raw :: c_char) { (* obj) . pattern = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_path (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError , value : * mut std :: os :: raw :: c_char) { (* obj) . path = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_message (obj : * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod invalid_compound_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidCompoundIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError) -> * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } } pub mod invalid_data_contract_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDataContractIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { pub expected_id : * mut crate :: fermented :: generics :: Vec_u8 , pub invalid_id : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_ctor (expected_id : * mut crate :: fermented :: generics :: Vec_u8 , invalid_id : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { expected_id , invalid_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_get_expected_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_get_invalid_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . invalid_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_set_expected_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . expected_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_set_invalid_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . invalid_id = value ; } } pub mod invalid_data_contract_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDataContractVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { pub expected_version : u32 , pub version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { expected_version : ffi_ref . expected_version , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { expected_version : obj . expected_version , version : obj . version }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_ctor (expected_version : u32 , version : u32) -> * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { expected_version , version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_get_expected_version (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . expected_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_get_version (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_set_expected_version (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError , value : u32) { (* obj) . expected_version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_set_version (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError , value : u32) { (* obj) . version = value ; } } pub mod invalid_description_length_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDescriptionLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { pub data_contract_id : * mut types :: identifier :: Identifier , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError > for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError > for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_description_length_error :: InvalidDescriptionLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { data_contract_id : ferment :: boxed (obj . data_contract_id) , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . description) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . description) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_ctor (data_contract_id : * mut types :: identifier :: Identifier , description : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError { data_contract_id , description }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_get_description (obj : * const dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError) -> * mut std :: os :: raw :: c_char { (* obj) . description } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError_set_description (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_description_length_error_InvalidDescriptionLengthError , value : * mut std :: os :: raw :: c_char) { (* obj) . description = value ; } } pub mod invalid_document_type_name_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { pub name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_ctor (name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_get_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_set_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } } pub mod invalid_document_type_required_security_level { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeRequiredSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { pub security_level : * mut dpp :: identity :: SecurityLevel , pub contract_id : * mut types :: identifier :: Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { security_level : std :: ptr :: read (ffi_ref . security_level) , contract_id : std :: ptr :: read (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { security_level : ferment :: boxed (obj . security_level) , contract_id : ferment :: boxed (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_ctor (security_level : * mut dpp :: identity :: SecurityLevel , contract_id : * mut types :: identifier :: Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { security_level , contract_id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_security_level (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_document_type_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_security_level (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_document_type_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } } pub mod invalid_index_property_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIndexPropertyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub property_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError) -> * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_type) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . property_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char , property_type : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { document_type , index_name , property_name , property_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_property_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_property_type (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_property_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_property_type (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_type = value ; } } pub mod invalid_indexed_property_constraint_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIndexedPropertyConstraintError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub constraint_name : * mut std :: os :: raw :: c_char , pub reason : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . reason) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError) -> * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . reason) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . constraint_name) ; ferment :: unbox_string (ffi_ref . reason) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char , constraint_name : * mut std :: os :: raw :: c_char , reason : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { document_type , index_name , property_name , constraint_name , reason }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_property_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_constraint_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . constraint_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_reason (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . reason } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_property_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_constraint_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError , value : * mut std :: os :: raw :: c_char) { (* obj) . constraint_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_reason (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError , value : * mut std :: os :: raw :: c_char) { (* obj) . reason = value ; } } pub mod invalid_json_schema_ref_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidJsonSchemaRefError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError) -> * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_get_message (obj : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_set_message (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod invalid_keyword_character_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidKeywordCharacterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { pub data_contract_id : * mut types :: identifier :: Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_character_error :: InvalidKeywordCharacterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { data_contract_id : ferment :: boxed (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_ctor (data_contract_id : * mut types :: identifier :: Identifier , keyword : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError { data_contract_id , keyword }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_get_keyword (obj : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError_set_keyword (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_character_error_InvalidKeywordCharacterError , value : * mut std :: os :: raw :: c_char) { (* obj) . keyword = value ; } } pub mod invalid_keyword_length_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidKeywordLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { pub data_contract_id : * mut types :: identifier :: Identifier , pub keyword : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError > for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_keyword_length_error :: InvalidKeywordLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { data_contract_id : ferment :: boxed (obj . data_contract_id) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . keyword) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_ctor (data_contract_id : * mut types :: identifier :: Identifier , keyword : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError { data_contract_id , keyword }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_get_keyword (obj : * const dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError_set_keyword (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_keyword_length_error_InvalidKeywordLengthError , value : * mut std :: os :: raw :: c_char) { (* obj) . keyword = value ; } } pub mod invalid_token_base_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenBaseSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { pub base_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { base_supply : ffi_ref . base_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { base_supply : obj . base_supply }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_ctor (base_supply : u64) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { base_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_get_base_supply (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> u64 { (* obj) . base_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_set_base_supply (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError , value : u64) { (* obj) . base_supply = value ; } } pub mod invalid_token_distribution_function_divide_by_zero_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionDivideByZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { pub distribution_function : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_from (ffi_ref . distribution_function) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_to (obj . distribution_function) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . distribution_function) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_ctor (distribution_function : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { distribution_function }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_get_distribution_function (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { (* obj) . distribution_function } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_set_distribution_function (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) { (* obj) . distribution_function = value ; } } pub mod invalid_token_distribution_function_incoherence_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionIncoherenceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_get_message (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_set_message (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod invalid_token_distribution_function_invalid_parameter_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { pub parameter : * mut std :: os :: raw :: c_char , pub min : i64 , pub max : i64 , pub not_valid : * mut i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parameter) , min : ffi_ref . min , max : ffi_ref . max , not_valid : ferment :: from_opt_primitive (ffi_ref . not_valid) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parameter) , min : obj . min , max : obj . max , not_valid : ferment :: to_opt_primitive (obj . not_valid) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parameter) ; ; ; ferment :: unbox_any_opt (ffi_ref . not_valid) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_ctor (parameter : * mut std :: os :: raw :: c_char , min : i64 , max : i64 , not_valid : * mut i64) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { parameter , min , max , not_valid }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_parameter (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut std :: os :: raw :: c_char { (* obj) . parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_min (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . min } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_max (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . max } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_not_valid (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut i64 { (* obj) . not_valid } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_parameter (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError , value : * mut std :: os :: raw :: c_char) { (* obj) . parameter = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_min (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError , value : i64) { (* obj) . min = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_max (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError , value : i64) { (* obj) . max = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_not_valid (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError , value : * mut i64) { (* obj) . not_valid = value ; } } pub mod invalid_token_distribution_function_invalid_parameter_tuple_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterTupleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { pub first_parameter : * mut std :: os :: raw :: c_char , pub second_parameter : * mut std :: os :: raw :: c_char , pub relation : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . relation) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . relation) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . first_parameter) ; ferment :: unbox_string (ffi_ref . second_parameter) ; ferment :: unbox_string (ffi_ref . relation) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_ctor (first_parameter : * mut std :: os :: raw :: c_char , second_parameter : * mut std :: os :: raw :: c_char , relation : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter , second_parameter , relation }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_first_parameter (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . first_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_second_parameter (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . second_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_relation (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . relation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_first_parameter (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError , value : * mut std :: os :: raw :: c_char) { (* obj) . first_parameter = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_second_parameter (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError , value : * mut std :: os :: raw :: c_char) { (* obj) . second_parameter = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_relation (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError , value : * mut std :: os :: raw :: c_char) { (* obj) . relation = value ; } } pub mod invalid_token_language_code_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenLanguageCodeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { pub language_code : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError > for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError { language_code : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . language_code) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError > for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_language_code_error :: InvalidTokenLanguageCodeError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { language_code : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . language_code) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . language_code) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError_ctor (language_code : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError { language_code }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError_get_language_code (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError) -> * mut std :: os :: raw :: c_char { (* obj) . language_code } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError_set_language_code (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_language_code_error_InvalidTokenLanguageCodeError , value : * mut std :: os :: raw :: c_char) { (* obj) . language_code = value ; } } pub mod invalid_token_name_character_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenNameCharacterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { pub form : * mut std :: os :: raw :: c_char , pub token_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError { form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . form) , token_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . token_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_character_error :: InvalidTokenNameCharacterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . form) , token_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . token_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . form) ; ferment :: unbox_string (ffi_ref . token_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_ctor (form : * mut std :: os :: raw :: c_char , token_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError { form , token_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_get_form (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) -> * mut std :: os :: raw :: c_char { (* obj) . form } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_get_token_name (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError) -> * mut std :: os :: raw :: c_char { (* obj) . token_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_set_form (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError , value : * mut std :: os :: raw :: c_char) { (* obj) . form = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError_set_token_name (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_character_error_InvalidTokenNameCharacterError , value : * mut std :: os :: raw :: c_char) { (* obj) . token_name = value ; } } pub mod invalid_token_name_length_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenNameLengthError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { pub actual : usize , pub min : usize , pub max : usize , pub form : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError { actual : ffi_ref . actual , min : ffi_ref . min , max : ffi_ref . max , form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . form) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError > for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_name_length_error :: InvalidTokenNameLengthError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { actual : obj . actual , min : obj . min , max : obj . max , form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . form) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ferment :: unbox_string (ffi_ref . form) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_ctor (actual : usize , min : usize , max : usize , form : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError { actual , min , max , form }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_get_actual (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> usize { (* obj) . actual } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_get_min (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> usize { (* obj) . min } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_get_max (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> usize { (* obj) . max } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_get_form (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError) -> * mut std :: os :: raw :: c_char { (* obj) . form } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_set_actual (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError , value : usize) { (* obj) . actual = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_set_min (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError , value : usize) { (* obj) . min = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_set_max (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError , value : usize) { (* obj) . max = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError_set_form (obj : * mut dpp_errors_consensus_basic_data_contract_invalid_token_name_length_error_InvalidTokenNameLengthError , value : * mut std :: os :: raw :: c_char) { (* obj) . form = value ; } } pub mod keywords_over_limit { use crate as example_nested ; # [doc = "FFI-representation of the [`TooManyKeywordsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { pub data_contract_id : * mut types :: identifier :: Identifier , pub keywords_len : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError > for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) -> dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , keywords_len : ffi_ref . keywords_len } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError > for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: keywords_over_limit :: TooManyKeywordsError) -> * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { data_contract_id : ferment :: boxed (obj . data_contract_id) , keywords_len : obj . keywords_len }) } } impl Drop for dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_ctor (data_contract_id : * mut types :: identifier :: Identifier , keywords_len : u8) -> * mut dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError { data_contract_id , keywords_len }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_get_keywords_len (obj : * const dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError) -> u8 { (* obj) . keywords_len } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError_set_keywords_len (obj : * mut dpp_errors_consensus_basic_data_contract_keywords_over_limit_TooManyKeywordsError , value : u8) { (* obj) . keywords_len = value ; } } pub mod main_group_is_not_defined { use crate as example_nested ; # [doc = "FFI-representation of the [`MainGroupIsNotDefinedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError > for dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError) -> dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError > for dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: main_group_is_not_defined :: MainGroupIsNotDefinedError) -> * const dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { }) } } impl Drop for dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError_ctor () -> * mut dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_main_group_is_not_defined_MainGroupIsNotDefinedError) { ferment :: unbox_any (ffi) ; } } pub mod new_tokens_destination_identity_option_required_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewTokensDestinationIdentityOptionRequiredError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { pub contract_id : * mut types :: identifier :: Identifier , pub token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError > for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) -> dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError { contract_id : std :: ptr :: read (ffi_ref . contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError > for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: new_tokens_destination_identity_option_required_error :: NewTokensDestinationIdentityOptionRequiredError) -> * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { contract_id : ferment :: boxed (obj . contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . token_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_ctor (contract_id : * mut types :: identifier :: Identifier , token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError { contract_id , token_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_get_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_get_token_position (obj : * const dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_set_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError_set_token_position (obj : * mut dpp_errors_consensus_basic_data_contract_new_tokens_destination_identity_option_required_error_NewTokensDestinationIdentityOptionRequiredError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . token_position = value ; } } pub mod non_contiguous_contract_group_positions_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonContiguousContractGroupPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_ctor (missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { missing_position , followed_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_get_missing_position (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_get_followed_position (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . followed_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_set_missing_position (obj : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . missing_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_set_followed_position (obj : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . followed_position = value ; } } pub mod non_contiguous_contract_token_positions_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonContiguousContractTokenPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_ctor (missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { missing_position , followed_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_get_missing_position (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_get_followed_position (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . followed_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_set_missing_position (obj : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . missing_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_set_followed_position (obj : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . followed_position = value ; } } pub mod redundant_document_paid_for_by_token_with_contract_id { use crate as example_nested ; # [doc = "FFI-representation of the [`RedundantDocumentPaidForByTokenWithContractId`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { pub contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId > for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId) -> dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId { contract_id : std :: ptr :: read (ffi_ref . contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId > for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: redundant_document_paid_for_by_token_with_contract_id :: RedundantDocumentPaidForByTokenWithContractId) -> * const dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { ferment :: boxed (dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { contract_id : ferment :: boxed (obj . contract_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId_ctor (contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { ferment :: boxed (dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId { contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId_get_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId_set_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_redundant_document_paid_for_by_token_with_contract_id_RedundantDocumentPaidForByTokenWithContractId , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } } pub mod system_property_index_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemPropertyIndexAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError) -> * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { document_type , index_name , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_property_name (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_property_name (obj : * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_name = value ; } } pub mod token_decimals_over_limit_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DecimalsOverLimitError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { pub decimals : u8 , pub max_decimals : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError > for dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) -> dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError { decimals : ffi_ref . decimals , max_decimals : ffi_ref . max_decimals } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError > for dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: token_decimals_over_limit_error :: DecimalsOverLimitError) -> * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { decimals : obj . decimals , max_decimals : obj . max_decimals }) } } impl Drop for dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_ctor (decimals : u8 , max_decimals : u8) -> * mut dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError { decimals , max_decimals }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_get_decimals (obj : * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) -> u8 { (* obj) . decimals } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_get_max_decimals (obj : * const dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError) -> u8 { (* obj) . max_decimals } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_set_decimals (obj : * mut dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError , value : u8) { (* obj) . decimals = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError_set_max_decimals (obj : * mut dpp_errors_consensus_basic_data_contract_token_decimals_over_limit_error_DecimalsOverLimitError , value : u8) { (* obj) . max_decimals = value ; } } pub mod token_payment_by_burning_only_allowed_on_internal_token_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenPaymentByBurningOnlyAllowedOnInternalTokenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { pub external_token_contract_id : * mut types :: identifier :: Identifier , pub external_token_contract_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError > for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError { external_token_contract_id : std :: ptr :: read (ffi_ref . external_token_contract_id) , external_token_contract_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . external_token_contract_token_position) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError > for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: token_payment_by_burning_only_allowed_on_internal_token_error :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { external_token_contract_id : ferment :: boxed (obj . external_token_contract_id) , external_token_contract_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . external_token_contract_token_position) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . external_token_contract_id) ; ferment :: unbox_any (ffi_ref . external_token_contract_token_position) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_ctor (external_token_contract_id : * mut types :: identifier :: Identifier , external_token_contract_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError { external_token_contract_id , external_token_contract_token_position , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_get_external_token_contract_id (obj : * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * mut types :: identifier :: Identifier { (* obj) . external_token_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_get_external_token_contract_token_position (obj : * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . external_token_contract_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_get_action (obj : * const dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_set_external_token_contract_id (obj : * mut dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError , value : * mut types :: identifier :: Identifier) { (* obj) . external_token_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_set_external_token_contract_token_position (obj : * mut dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . external_token_contract_token_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_set_action (obj : * mut dpp_errors_consensus_basic_data_contract_token_payment_by_burning_only_allowed_on_internal_token_error_TokenPaymentByBurningOnlyAllowedOnInternalTokenError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod undefined_index_property_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UndefinedIndexPropertyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError) -> * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_ctor (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { document_type , index_name , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_index_name (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_property_name (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_index_name (obj : * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_property_name (obj : * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_name = value ; } } pub mod unique_indices_limit_reached_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UniqueIndicesLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_limit : u16 , pub is_contested_limit : bool } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_limit : ffi_ref . index_limit , is_contested_limit : ffi_ref . is_contested_limit } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError) -> * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_limit : obj . index_limit , is_contested_limit : obj . is_contested_limit }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_ctor (document_type : * mut std :: os :: raw :: c_char , index_limit : u16 , is_contested_limit : bool) -> * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { document_type , index_limit , is_contested_limit }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_document_type (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_index_limit (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> u16 { (* obj) . index_limit } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_is_contested_limit (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> bool { (* obj) . is_contested_limit } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_document_type (obj : * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_index_limit (obj : * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError , value : u16) { (* obj) . index_limit = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_is_contested_limit (obj : * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError , value : bool) { (* obj) . is_contested_limit = value ; } } pub mod unknown_document_action_token_effect_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownDocumentActionTokenEffectError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError > for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError > for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_action_token_effect_error :: UnknownDocumentActionTokenEffectError) -> * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u64) -> * mut dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError) -> u64 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_document_action_token_effect_error_UnknownDocumentActionTokenEffectError , value : u64) { (* obj) . received = value ; } } pub mod unknown_document_creation_restriction_mode_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownDocumentCreationRestrictionModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError , value : u8) { (* obj) . received = value ; } } pub mod unknown_gas_fees_paid_by_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownGasFeesPaidByError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError > for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError > for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_gas_fees_paid_by_error :: UnknownGasFeesPaidByError) -> * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u64) -> * mut dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError) -> u64 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_gas_fees_paid_by_error_UnknownGasFeesPaidByError , value : u64) { (* obj) . received = value ; } } pub mod unknown_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError , value : u8) { (* obj) . received = value ; } } pub mod unknown_storage_key_requirements_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownStorageKeyRequirementsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : * mut [u8 ; 16] } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (ffi_ref . received) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError) -> * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (obj . received) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ferment :: unbox_any_opt (ffi_ref . received) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : * mut [u8 ; 16]) -> * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut [u8 ; 16] { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError , value : * mut [u8 ; 16]) { (* obj) . received = value ; } } pub mod unknown_trade_mode_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownTradeModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError , value : u8) { (* obj) . received = value ; } } pub mod unknown_transferable_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownTransferableTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_ctor (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_get_allowed_values (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_get_received (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_set_allowed_values (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . allowed_values = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_set_received (obj : * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError , value : u8) { (* obj) . received = value ; } } } pub mod decode { use crate as example_nested ; pub mod decoding_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DecodingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_decoding_error_DecodingError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError) -> * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError { ferment :: boxed (dpp_errors_consensus_basic_decode_decoding_error_DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_ctor (error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_decoding_error_DecodingError { ferment :: boxed (dpp_errors_consensus_basic_decode_decoding_error_DecodingError { error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_destroy (ffi : * mut dpp_errors_consensus_basic_decode_decoding_error_DecodingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_get_error (obj : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> * mut std :: os :: raw :: c_char { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_set_error (obj : * mut dpp_errors_consensus_basic_decode_decoding_error_DecodingError , value : * mut std :: os :: raw :: c_char) { (* obj) . error = value ; } } pub mod protocol_version_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ProtocolVersionParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError) -> * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_ctor (parsing_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { parsing_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_destroy (ffi : * mut dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_get_parsing_error (obj : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_set_parsing_error (obj : * mut dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError , value : * mut std :: os :: raw :: c_char) { (* obj) . parsing_error = value ; } } pub mod serialized_object_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SerializedObjectParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError) -> * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_ctor (parsing_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { parsing_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_destroy (ffi : * mut dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_get_parsing_error (obj : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_set_parsing_error (obj : * mut dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError , value : * mut std :: os :: raw :: c_char) { (* obj) . parsing_error = value ; } } pub mod version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_version_error_VersionError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError) -> * const dpp_errors_consensus_basic_decode_version_error_VersionError { ferment :: boxed (dpp_errors_consensus_basic_decode_version_error_VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_version_error_VersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_ctor (error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_version_error_VersionError { ferment :: boxed (dpp_errors_consensus_basic_decode_version_error_VersionError { error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_destroy (ffi : * mut dpp_errors_consensus_basic_decode_version_error_VersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_get_error (obj : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> * mut std :: os :: raw :: c_char { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_set_error (obj : * mut dpp_errors_consensus_basic_decode_version_error_VersionError , value : * mut std :: os :: raw :: c_char) { (* obj) . error = value ; } } } pub mod document { use crate as example_nested ; pub mod contested_documents_temporarily_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentsTemporarilyNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { pub current_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub target_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . target_epoch) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError) -> * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . target_epoch) }) } } impl Drop for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . current_epoch) ; ferment :: unbox_any (ffi_ref . target_epoch) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_ctor (current_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , target_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) -> * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { current_epoch , target_epoch }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_destroy (ffi : * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_get_current_epoch (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . current_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_get_target_epoch (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . target_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_set_current_epoch (obj : * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . current_epoch = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_set_target_epoch (obj : * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . target_epoch = value ; } } pub mod data_contract_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_destroy (ffi : * mut dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod document_creation_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentCreationNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { pub data_contract_id : * mut types :: identifier :: Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError) -> * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { data_contract_id : ferment :: boxed (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) }) } } impl Drop for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_ctor (data_contract_id : * mut types :: identifier :: Identifier , document_type_name : * mut std :: os :: raw :: c_char , creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) -> * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { data_contract_id , document_type_name , creation_restriction_mode }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_destroy (ffi : * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_document_type_name (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_creation_restriction_mode (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_document_type_name (obj : * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_creation_restriction_mode (obj : * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) { (* obj) . creation_restriction_mode = value ; } } pub mod document_field_max_size_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentFieldMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { pub field : * mut std :: os :: raw :: c_char , pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field) , actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError) -> * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field) , actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } impl Drop for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . field) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_ctor (field : * mut std :: os :: raw :: c_char , actual_size_bytes : u64 , max_size_bytes : u64) -> * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { field , actual_size_bytes , max_size_bytes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_destroy (ffi : * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_field (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> * mut std :: os :: raw :: c_char { (* obj) . field } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_actual_size_bytes (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_max_size_bytes (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_field (obj : * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError , value : * mut std :: os :: raw :: c_char) { (* obj) . field = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_actual_size_bytes (obj : * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError , value : u64) { (* obj) . actual_size_bytes = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_max_size_bytes (obj : * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError , value : u64) { (* obj) . max_size_bytes = value ; } } pub mod document_transitions_are_absent_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTransitionsAreAbsentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) -> dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError) -> * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { ferment :: boxed (dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { }) } } impl Drop for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError_ctor () -> * mut dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { ferment :: boxed (dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError_destroy (ffi : * mut dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) { ferment :: unbox_any (ffi) ; } } pub mod duplicate_document_transitions_with_ids_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_ctor (references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) -> * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { references }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_destroy (ffi : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_get_references (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_set_references (obj : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError , value : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) { (* obj) . references = value ; } } pub mod duplicate_document_transitions_with_indices_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIndicesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_ctor (references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) -> * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { references }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_destroy (ffi : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_get_references (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_set_references (obj : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError , value : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) { (* obj) . references = value ; } } pub mod identity_contract_nonce_out_of_bounds_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonceOutOfBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError) -> * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { ferment :: boxed (dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) }) } } impl Drop for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . nonce) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_ctor (nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) -> * mut dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { ferment :: boxed (dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { nonce }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_destroy (ffi : * mut dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_get_nonce (obj : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_set_nonce (obj : * mut dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . nonce = value ; } } pub mod inconsistent_compound_index_data_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InconsistentCompoundIndexDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { pub document_type : * mut std :: os :: raw :: c_char , pub index_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . index_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError) -> * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { ferment :: boxed (dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . index_properties) }) } } impl Drop for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . index_properties) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_ctor (document_type : * mut std :: os :: raw :: c_char , index_properties : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { ferment :: boxed (dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { document_type , index_properties }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_destroy (ffi : * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_get_document_type (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_get_index_properties (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . index_properties } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_set_document_type (obj : * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_set_index_properties (obj : * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . index_properties = value ; } } pub mod invalid_document_transition_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_ctor (action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_destroy (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_get_action (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_set_action (obj : * mut dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod invalid_document_transition_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { pub expected_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_ctor (expected_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { expected_id , invalid_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_destroy (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_get_expected_id (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_get_invalid_id (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_set_expected_id (obj : * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . expected_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_set_invalid_id (obj : * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . invalid_id = value ; } } pub mod invalid_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_ctor (document_type : * mut std :: os :: raw :: c_char , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { document_type , data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_get_document_type (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_set_document_type (obj : * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . data_contract_id = value ; } } pub mod max_documents_transitions_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MaxDocumentsTransitionsExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { pub max_transitions : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { max_transitions : ffi_ref . max_transitions } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError) -> * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { max_transitions : obj . max_transitions }) } } impl Drop for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_ctor (max_transitions : u16) -> * mut dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { max_transitions }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_destroy (ffi : * mut dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_get_max_transitions (obj : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> u16 { (* obj) . max_transitions } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_set_max_transitions (obj : * mut dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError , value : u16) { (* obj) . max_transitions = value ; } } pub mod missing_data_contract_id_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDataContractIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) -> dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError) -> * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError_ctor () -> * mut dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError_destroy (ffi : * mut dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) { ferment :: unbox_any (ffi) ; } } pub mod missing_document_transition_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError_ctor () -> * mut dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError_destroy (ffi : * mut dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) { ferment :: unbox_any (ffi) ; } } pub mod missing_document_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError_ctor () -> * mut dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) { ferment :: unbox_any (ffi) ; } } pub mod missing_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError_ctor () -> * mut dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) { ferment :: unbox_any (ffi) ; } } pub mod missing_positions_in_document_type_properties_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingPositionsInDocumentTypePropertiesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { pub missing_position : u32 , pub contract_id : * mut types :: identifier :: Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { missing_position : ffi_ref . missing_position , contract_id : std :: ptr :: read (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError) -> * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { missing_position : obj . missing_position , contract_id : ferment :: boxed (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_ctor (missing_position : u32 , contract_id : * mut types :: identifier :: Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { missing_position , contract_id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_destroy (ffi : * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_missing_position (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> u32 { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_contract_id (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_document_type_name (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_missing_position (obj : * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError , value : u32) { (* obj) . missing_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_contract_id (obj : * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_document_type_name (obj : * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } } } pub mod identity { use crate as example_nested ; pub mod data_contract_bounds_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractBoundsNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError) -> * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_get_data_contract_id (obj : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_set_data_contract_id (obj : * mut dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod disabling_key_id_also_being_added_in_same_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DisablingKeyIdAlsoBeingAddedInSameTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { pub key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : std :: ptr :: read (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { ferment :: boxed (dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : ferment :: boxed (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_ctor (key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { ferment :: boxed (dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_get_key_id (obj : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * mut dpp :: identity :: KeyID { (* obj) . key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_set_key_id (obj : * mut dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError , value : * mut dpp :: identity :: KeyID) { (* obj) . key_id = value ; } } pub mod duplicated_identity_public_key_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_ctor (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) -> * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_get_duplicated_ids (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_set_duplicated_ids (obj : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . duplicated_ids = value ; } } pub mod duplicated_identity_public_key_id_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_ctor (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) -> * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_get_duplicated_ids (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_set_duplicated_ids (obj : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . duplicated_ids = value ; } } pub mod identity_asset_lock_proof_locked_transaction_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockProofLockedTransactionMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { pub instant_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub asset_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . instant_lock_transaction_id) , asset_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . asset_lock_transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . instant_lock_transaction_id) , asset_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . asset_lock_transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock_transaction_id) ; ferment :: unbox_any (ffi_ref . asset_lock_transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_ctor (instant_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , asset_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id , asset_lock_transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_get_instant_lock_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . instant_lock_transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_get_asset_lock_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . asset_lock_transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_set_instant_lock_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . instant_lock_transaction_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_set_asset_lock_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . asset_lock_transaction_id = value ; } } pub mod identity_asset_lock_transaction_is_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { pub transaction_id : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_ctor (transaction_id : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_get_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_set_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . transaction_id = value ; } } pub mod identity_asset_lock_transaction_out_point_already_consumed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointAlreadyConsumedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_ctor (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id , output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_get_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_set_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . transaction_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError , value : usize) { (* obj) . output_index = value ; } } pub mod identity_asset_lock_state_transition_replay_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockStateTransitionReplayError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize , pub state_transition_id : * mut types :: bytes_32 :: Bytes32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , state_transition_id : std :: ptr :: read (ffi_ref . state_transition_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index , state_transition_id : ferment :: boxed (obj . state_transition_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . state_transition_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_ctor (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize , state_transition_id : * mut types :: bytes_32 :: Bytes32) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { transaction_id , output_index , state_transition_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_state_transition_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut types :: bytes_32 :: Bytes32 { (* obj) . state_transition_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . transaction_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError , value : usize) { (* obj) . output_index = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_state_transition_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError , value : * mut types :: bytes_32 :: Bytes32) { (* obj) . state_transition_id = value ; } } pub mod identity_asset_lock_transaction_out_point_not_enough_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointNotEnoughBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize , pub initial_asset_lock_credits : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_left : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_required : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_required) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_required) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . initial_asset_lock_credits) ; ferment :: unbox_any (ffi_ref . credits_left) ; ferment :: unbox_any (ffi_ref . credits_required) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_ctor (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize , initial_asset_lock_credits : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , credits_left : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , credits_required : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id , output_index , initial_asset_lock_credits , credits_left , credits_required }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_transaction_id (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_initial_asset_lock_credits (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . initial_asset_lock_credits } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_credits_left (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_left } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_credits_required (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_required } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . transaction_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError , value : usize) { (* obj) . output_index = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_initial_asset_lock_credits (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . initial_asset_lock_credits = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_credits_left (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . credits_left = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_credits_required (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . credits_required = value ; } } pub mod identity_asset_lock_transaction_output_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_ctor (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError , value : usize) { (* obj) . output_index = value ; } } pub mod identity_credit_transfer_to_self_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditTransferToSelfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) -> dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError) -> * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError_ctor () -> * mut dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_asset_lock_proof_core_chain_height_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockProofCoreChainHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { pub proof_core_chain_locked_height : u32 , pub current_core_chain_locked_height : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , current_core_chain_locked_height : ffi_ref . current_core_chain_locked_height } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , current_core_chain_locked_height : obj . current_core_chain_locked_height }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_ctor (proof_core_chain_locked_height : u32 , current_core_chain_locked_height : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height , current_core_chain_locked_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_get_proof_core_chain_locked_height (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_get_current_core_chain_locked_height (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . current_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_set_proof_core_chain_locked_height (obj : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError , value : u32) { (* obj) . proof_core_chain_locked_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_set_current_core_chain_locked_height (obj : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError , value : u32) { (* obj) . current_core_chain_locked_height = value ; } } pub mod invalid_asset_lock_proof_transaction_height_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockProofTransactionHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { pub proof_core_chain_locked_height : u32 , pub transaction_height : * mut u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , transaction_height : ferment :: from_opt_primitive (ffi_ref . transaction_height) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , transaction_height : ferment :: to_opt_primitive (obj . transaction_height) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any_opt (ffi_ref . transaction_height) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_ctor (proof_core_chain_locked_height : u32 , transaction_height : * mut u32) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height , transaction_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_get_proof_core_chain_locked_height (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_get_transaction_height (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> * mut u32 { (* obj) . transaction_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_set_proof_core_chain_locked_height (obj : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError , value : u32) { (* obj) . proof_core_chain_locked_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_set_transaction_height (obj : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError , value : * mut u32) { (* obj) . transaction_height = value ; } } pub mod invalid_asset_lock_transaction_output_return_size { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockTransactionOutputReturnSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_ctor (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError , value : usize) { (* obj) . output_index = value ; } } pub mod invalid_identity_asset_lock_proof_chain_lock_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockProofChainLockValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub height_reported_not_locked : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , height_reported_not_locked : ffi_ref . height_reported_not_locked } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , height_reported_not_locked : obj . height_reported_not_locked }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_ctor (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , height_reported_not_locked : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { transaction_id , height_reported_not_locked }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_get_transaction_id (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_get_height_reported_not_locked (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> u32 { (* obj) . height_reported_not_locked } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_set_transaction_id (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError , value : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) { (* obj) . transaction_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_set_height_reported_not_locked (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError , value : u32) { (* obj) . height_reported_not_locked = value ; } } pub mod invalid_identity_asset_lock_transaction_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_get_message (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_set_message (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod invalid_identity_asset_lock_transaction_output_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionOutputError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_ctor (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_get_output_index (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_set_output_index (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError , value : usize) { (* obj) . output_index = value ; } } pub mod invalid_identity_credit_transfer_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditTransferAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { pub amount : u64 , pub min_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { amount : obj . amount , min_amount : obj . min_amount }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_ctor (amount : u64 , min_amount : u64) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { amount , min_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_get_amount (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_get_min_amount (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . min_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_set_amount (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_set_min_amount (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError , value : u64) { (* obj) . min_amount = value ; } } pub mod invalid_identity_credit_withdrawal_transition_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { pub amount : u64 , pub min_amount : u64 , pub max_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount , max_amount : ffi_ref . max_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { amount : obj . amount , min_amount : obj . min_amount , max_amount : obj . max_amount }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_ctor (amount : u64 , min_amount : u64 , max_amount : u64) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { amount , min_amount , max_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_amount (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_min_amount (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . min_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_max_amount (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . max_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_amount (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError , value : u64) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_min_amount (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError , value : u64) { (* obj) . min_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_max_amount (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError , value : u64) { (* obj) . max_amount = value ; } } pub mod invalid_identity_credit_withdrawal_transition_core_fee_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionCoreFeeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { pub core_fee_per_byte : u32 , pub min_core_fee_per_byte : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : ffi_ref . core_fee_per_byte , min_core_fee_per_byte : ffi_ref . min_core_fee_per_byte } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : obj . core_fee_per_byte , min_core_fee_per_byte : obj . min_core_fee_per_byte }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_ctor (core_fee_per_byte : u32 , min_core_fee_per_byte : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte , min_core_fee_per_byte }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_get_core_fee_per_byte (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_get_min_core_fee_per_byte (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . min_core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_set_core_fee_per_byte (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError , value : u32) { (* obj) . core_fee_per_byte = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_set_min_core_fee_per_byte (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError , value : u32) { (* obj) . min_core_fee_per_byte = value ; } } pub mod invalid_identity_credit_withdrawal_transition_output_script_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionOutputScriptError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_ctor (output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_get_output_script (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_set_output_script (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError , value : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) { (* obj) . output_script = value ; } } pub mod invalid_identity_key_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityKeySignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { pub public_key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { public_key_id : std :: ptr :: read (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { public_key_id : ferment :: boxed (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_ctor (public_key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_get_public_key_id (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_set_public_key_id (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_id = value ; } } pub mod invalid_identity_public_key_data_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { pub public_key_id : * mut dpp :: identity :: KeyID , pub validation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { public_key_id : std :: ptr :: read (ffi_ref . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . validation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { public_key_id : ferment :: boxed (obj . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . validation_error) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_string (ffi_ref . validation_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_ctor (public_key_id : * mut dpp :: identity :: KeyID , validation_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { public_key_id , validation_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_get_public_key_id (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_get_validation_error (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut std :: os :: raw :: c_char { (* obj) . validation_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_set_public_key_id (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_set_validation_error (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError , value : * mut std :: os :: raw :: c_char) { (* obj) . validation_error = value ; } } pub mod invalid_identity_public_key_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { pub public_key_id : * mut dpp :: identity :: KeyID , pub purpose : * mut dpp :: identity :: Purpose , pub security_level : * mut dpp :: identity :: SecurityLevel , pub allowed_security_levels : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { public_key_id : std :: ptr :: read (ffi_ref . public_key_id) , purpose : std :: ptr :: read (ffi_ref . purpose) , security_level : std :: ptr :: read (ffi_ref . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . allowed_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { public_key_id : ferment :: boxed (obj . public_key_id) , purpose : ferment :: boxed (obj . purpose) , security_level : ferment :: boxed (obj . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . allowed_security_levels) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_string (ffi_ref . allowed_security_levels) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_ctor (public_key_id : * mut dpp :: identity :: KeyID , purpose : * mut dpp :: identity :: Purpose , security_level : * mut dpp :: identity :: SecurityLevel , allowed_security_levels : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { public_key_id , purpose , security_level , allowed_security_levels }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_public_key_id (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_purpose (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut dpp :: identity :: Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_security_level (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_allowed_security_levels (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . allowed_security_levels } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_public_key_id (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_purpose (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError , value : * mut dpp :: identity :: Purpose) { (* obj) . purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_security_level (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_allowed_security_levels (obj : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError , value : * mut std :: os :: raw :: c_char) { (* obj) . allowed_security_levels = value ; } } pub mod invalid_identity_update_transition_disable_keys_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionDisableKeysError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError_ctor () -> * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_identity_update_transition_empty_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionEmptyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError_ctor () -> * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_instant_asset_lock_proof_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_get_message (obj : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_set_message (obj : * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod invalid_instant_asset_lock_proof_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError_ctor () -> * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) { ferment :: unbox_any (ffi) ; } } pub mod missing_master_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError_ctor () -> * mut dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) { ferment :: unbox_any (ffi) ; } } pub mod not_implemented_identity_credit_withdrawal_transition_pooling_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NotImplementedIdentityCreditWithdrawalTransitionPoolingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pub pooling : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : ffi_ref . pooling } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { ferment :: boxed (dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : obj . pooling }) } } impl Drop for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_ctor (pooling : u8) -> * mut dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { ferment :: boxed (dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_get_pooling (obj : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> u8 { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_set_pooling (obj : * mut dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError , value : u8) { (* obj) . pooling = value ; } } pub mod too_many_master_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TooManyMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError_ctor () -> * mut dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) { ferment :: unbox_any (ffi) ; } } pub mod withdrawal_output_script_not_allowed_when_signing_with_owner_key { use crate as example_nested ; # [doc = "FFI-representation of the [`WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , key_id : std :: ptr :: read (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , key_id : ferment :: boxed (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_ctor (output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script , key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_destroy (ffi : * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_get_output_script (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_get_key_id (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut dpp :: identity :: KeyID { (* obj) . key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_set_output_script (obj : * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError , value : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) { (* obj) . output_script = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_set_key_id (obj : * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError , value : * mut dpp :: identity :: KeyID) { (* obj) . key_id = value ; } } } pub mod incompatible_protocol_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { pub parsed_protocol_version : u32 , pub minimal_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , minimal_protocol_version : ffi_ref . minimal_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError) -> * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , minimal_protocol_version : obj . minimal_protocol_version }) } } impl Drop for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_ctor (parsed_protocol_version : u32 , minimal_protocol_version : u32) -> * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { parsed_protocol_version , minimal_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_destroy (ffi : * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_get_parsed_protocol_version (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_get_minimal_protocol_version (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . minimal_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_set_parsed_protocol_version (obj : * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError , value : u32) { (* obj) . parsed_protocol_version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_set_minimal_protocol_version (obj : * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError , value : u32) { (* obj) . minimal_protocol_version = value ; } } pub mod token { use crate as example_nested ; pub mod choosing_token_mint_recipient_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ChoosingTokenMintRecipientNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { pub token_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { token_id : std :: ptr :: read (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError) -> * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { token_id : ferment :: boxed (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_ctor (token_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_destroy (ffi : * mut dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_get_token_id (obj : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_set_token_id (obj : * mut dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } } pub mod contract_has_no_tokens_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContractHasNoTokensError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { pub contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { contract_id : std :: ptr :: read (ffi_ref . contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError) -> * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { ferment :: boxed (dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { contract_id : ferment :: boxed (obj . contract_id) }) } } impl Drop for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_ctor (contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { ferment :: boxed (dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_destroy (ffi : * mut dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_get_contract_id (obj : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_set_contract_id (obj : * mut dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } } pub mod destination_identity_for_token_minting_not_set_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DestinationIdentityForTokenMintingNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { pub token_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { token_id : std :: ptr :: read (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError) -> * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { ferment :: boxed (dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { token_id : ferment :: boxed (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_ctor (token_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { ferment :: boxed (dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_destroy (ffi : * mut dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_get_token_id (obj : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_set_token_id (obj : * mut dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } } pub mod invalid_action_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidActionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { pub expected_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError) -> * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_action_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_action_id) ; ferment :: unbox_any (ffi_ref . invalid_action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_ctor (expected_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { expected_action_id , invalid_action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_get_expected_action_id (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_get_invalid_action_id (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_set_expected_action_id (obj : * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . expected_action_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_set_invalid_action_id (obj : * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . invalid_action_id = value ; } } pub mod invalid_token_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { pub max_token_amount : u64 , pub token_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { max_token_amount : ffi_ref . max_token_amount , token_amount : ffi_ref . token_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError) -> * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { max_token_amount : obj . max_token_amount , token_amount : obj . token_amount }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_ctor (max_token_amount : u64 , token_amount : u64) -> * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { max_token_amount , token_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_get_max_token_amount (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . max_token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_get_token_amount (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_set_max_token_amount (obj : * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError , value : u64) { (* obj) . max_token_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_set_token_amount (obj : * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError , value : u64) { (* obj) . token_amount = value ; } } pub mod invalid_token_config_update_no_change_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenConfigUpdateNoChangeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError) -> * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError_ctor () -> * mut dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_token_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { pub expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError) -> * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_token_id) ; ferment :: unbox_any (ffi_ref . invalid_token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_ctor (expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { expected_token_id , invalid_token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_get_expected_token_id (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_get_invalid_token_id (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_set_expected_token_id (obj : * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . expected_token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_set_invalid_token_id (obj : * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . invalid_token_id = value ; } } pub mod invalid_token_note_too_big_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenNoteTooBigError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { pub max_note_length : u32 , pub note_type : * mut std :: os :: raw :: c_char , pub note_length : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { max_note_length : ffi_ref . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . note_type) , note_length : ffi_ref . note_length } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError) -> * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { max_note_length : obj . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . note_type) , note_length : obj . note_length }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . note_type) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_ctor (max_note_length : u32 , note_type : * mut std :: os :: raw :: c_char , note_length : u32) -> * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { max_note_length , note_type , note_length }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_max_note_length (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . max_note_length } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_note_type (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> * mut std :: os :: raw :: c_char { (* obj) . note_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_note_length (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . note_length } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_max_note_length (obj : * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError , value : u32) { (* obj) . max_note_length = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_note_type (obj : * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError , value : * mut std :: os :: raw :: c_char) { (* obj) . note_type = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_note_length (obj : * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError , value : u32) { (* obj) . note_length = value ; } } pub mod invalid_token_position_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { pub max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from_opt (ffi_ref . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . invalid_token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError) -> * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to_opt (obj . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . invalid_token_position) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_token_position) ; ferment :: unbox_any (ffi_ref . invalid_token_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_ctor (max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { max_token_position , invalid_token_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_destroy (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_get_max_token_position (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . max_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_get_invalid_token_position (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . invalid_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_set_max_token_position (obj : * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . max_token_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_set_invalid_token_position (obj : * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . invalid_token_position = value ; } } pub mod missing_default_localization { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDefaultLocalizationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) -> dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError) -> * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { ferment :: boxed (dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { }) } } impl Drop for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError_ctor () -> * mut dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { ferment :: boxed (dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError_destroy (ffi : * mut dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) { ferment :: unbox_any (ffi) ; } } pub mod token_note_only_allowed_on_proposer_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenNoteOnlyAllowedWhenProposerError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError > for dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError) -> dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError > for dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: token_note_only_allowed_on_proposer_error :: TokenNoteOnlyAllowedWhenProposerError) -> * const dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { ferment :: boxed (dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { }) } } impl Drop for dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError_ctor () -> * mut dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { ferment :: boxed (dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError_destroy (ffi : * mut dpp_errors_consensus_basic_token_token_note_only_allowed_on_proposer_error_TokenNoteOnlyAllowedWhenProposerError) { ferment :: unbox_any (ffi) ; } } pub mod token_transfer_to_ourselves_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenTransferToOurselfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError) -> * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { ferment :: boxed (dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { ferment :: boxed (dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { token_id , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_destroy (ffi : * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_get_token_id (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_get_identity_id (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_set_token_id (obj : * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_set_identity_id (obj : * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } } pub mod unsupported_protocol_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { pub parsed_protocol_version : u32 , pub latest_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , latest_version : ffi_ref . latest_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError) -> * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , latest_version : obj . latest_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_ctor (parsed_protocol_version : u32 , latest_version : u32) -> * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { parsed_protocol_version , latest_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_destroy (ffi : * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_get_parsed_protocol_version (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_get_latest_version (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . latest_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_set_parsed_protocol_version (obj : * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError , value : u32) { (* obj) . parsed_protocol_version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_set_latest_version (obj : * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError , value : u32) { (* obj) . latest_version = value ; } } pub mod basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BasicError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_basic_basic_error_BasicError { ProtocolVersionParsingError (* mut dpp :: consensus :: basic :: decode :: ProtocolVersionParsingError) , VersionError (* mut dpp :: consensus :: basic :: decode :: VersionError) , ContractError (* mut contract :: DataContractError) , UnknownSecurityLevelError (* mut dpp :: consensus :: basic :: data_contract :: UnknownSecurityLevelError) , UnknownStorageKeyRequirementsError (* mut dpp :: consensus :: basic :: data_contract :: UnknownStorageKeyRequirementsError) , UnknownTransferableTypeError (* mut dpp :: consensus :: basic :: data_contract :: UnknownTransferableTypeError) , UnknownTradeModeError (* mut dpp :: consensus :: basic :: data_contract :: UnknownTradeModeError) , UnknownDocumentCreationRestrictionModeError (* mut dpp :: consensus :: basic :: data_contract :: UnknownDocumentCreationRestrictionModeError) , SerializedObjectParsingError (* mut dpp :: consensus :: basic :: decode :: SerializedObjectParsingError) , UnsupportedProtocolVersionError (* mut dpp :: consensus :: basic :: UnsupportedProtocolVersionError) , UnsupportedVersionError (* mut dpp :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError) , IncompatibleProtocolVersionError (* mut dpp :: consensus :: basic :: IncompatibleProtocolVersionError) , JsonSchemaCompilationError (* mut dpp :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError) , JsonSchemaError (* mut dpp :: consensus :: basic :: json_schema_error :: JsonSchemaError) , InvalidIdentifierError (* mut dpp :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError) , ValueError (* mut dpp :: consensus :: basic :: value_error :: ValueError) , DataContractMaxDepthExceedError (* mut dpp :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError) , DuplicateIndexError (* mut dpp :: consensus :: basic :: data_contract :: DuplicateIndexError) , IncompatibleRe2PatternError (* mut dpp :: consensus :: basic :: data_contract :: IncompatibleRe2PatternError) , InvalidCompoundIndexError (* mut dpp :: consensus :: basic :: data_contract :: InvalidCompoundIndexError) , InvalidDataContractIdError (* mut dpp :: consensus :: basic :: data_contract :: InvalidDataContractIdError) , InvalidIndexedPropertyConstraintError (* mut dpp :: consensus :: basic :: data_contract :: InvalidIndexedPropertyConstraintError) , InvalidIndexPropertyTypeError (* mut dpp :: consensus :: basic :: data_contract :: InvalidIndexPropertyTypeError) , InvalidJsonSchemaRefError (* mut dpp :: consensus :: basic :: data_contract :: InvalidJsonSchemaRefError) , SystemPropertyIndexAlreadyPresentError (* mut dpp :: consensus :: basic :: data_contract :: SystemPropertyIndexAlreadyPresentError) , UndefinedIndexPropertyError (* mut dpp :: consensus :: basic :: data_contract :: UndefinedIndexPropertyError) , UniqueIndicesLimitReachedError (* mut dpp :: consensus :: basic :: data_contract :: UniqueIndicesLimitReachedError) , DuplicateIndexNameError (* mut dpp :: consensus :: basic :: data_contract :: DuplicateIndexNameError) , InvalidDataContractVersionError (* mut dpp :: consensus :: basic :: data_contract :: InvalidDataContractVersionError) , IncompatibleDataContractSchemaError (* mut dpp :: consensus :: basic :: data_contract :: IncompatibleDataContractSchemaError) , DataContractImmutablePropertiesUpdateError (* mut dpp :: consensus :: basic :: data_contract :: DataContractImmutablePropertiesUpdateError) , DataContractUniqueIndicesChangedError (* mut dpp :: consensus :: basic :: data_contract :: DataContractUniqueIndicesChangedError) , DataContractInvalidIndexDefinitionUpdateError (* mut dpp :: consensus :: basic :: data_contract :: DataContractInvalidIndexDefinitionUpdateError) , DataContractHaveNewUniqueIndexError (* mut dpp :: consensus :: basic :: data_contract :: DataContractHaveNewUniqueIndexError) , DataContractNotPresentError (* mut dpp :: consensus :: basic :: document :: DataContractNotPresentError) , DocumentCreationNotAllowedError (* mut dpp :: consensus :: basic :: document :: DocumentCreationNotAllowedError) , DataContractBoundsNotPresentError (* mut dpp :: consensus :: basic :: identity :: DataContractBoundsNotPresentError) , DuplicateDocumentTransitionsWithIdsError (* mut dpp :: consensus :: basic :: document :: DuplicateDocumentTransitionsWithIdsError) , DuplicateDocumentTransitionsWithIndicesError (* mut dpp :: consensus :: basic :: document :: DuplicateDocumentTransitionsWithIndicesError) , NonceOutOfBoundsError (* mut dpp :: consensus :: basic :: document :: NonceOutOfBoundsError) , InconsistentCompoundIndexDataError (* mut dpp :: consensus :: basic :: document :: InconsistentCompoundIndexDataError) , InvalidDocumentTransitionActionError (* mut dpp :: consensus :: basic :: document :: InvalidDocumentTransitionActionError) , InvalidDocumentTransitionIdError (* mut dpp :: consensus :: basic :: document :: InvalidDocumentTransitionIdError) , InvalidDocumentTypeError (* mut dpp :: consensus :: basic :: document :: InvalidDocumentTypeError) , MissingPositionsInDocumentTypePropertiesError (* mut dpp :: consensus :: basic :: document :: MissingPositionsInDocumentTypePropertiesError) , MissingDataContractIdBasicError (* mut dpp :: consensus :: basic :: document :: MissingDataContractIdBasicError) , MissingDocumentTransitionActionError (* mut dpp :: consensus :: basic :: document :: MissingDocumentTransitionActionError) , MissingDocumentTransitionTypeError (* mut dpp :: consensus :: basic :: document :: MissingDocumentTransitionTypeError) , MissingDocumentTypeError (* mut dpp :: consensus :: basic :: document :: MissingDocumentTypeError) , MaxDocumentsTransitionsExceededError (* mut dpp :: consensus :: basic :: document :: MaxDocumentsTransitionsExceededError) , DuplicatedIdentityPublicKeyBasicError (* mut dpp :: consensus :: basic :: identity :: DuplicatedIdentityPublicKeyBasicError) , DuplicatedIdentityPublicKeyIdBasicError (* mut dpp :: consensus :: basic :: identity :: DuplicatedIdentityPublicKeyIdBasicError) , DisablingKeyIdAlsoBeingAddedInSameTransitionError (* mut dpp :: consensus :: basic :: identity :: DisablingKeyIdAlsoBeingAddedInSameTransitionError) , IdentityAssetLockProofLockedTransactionMismatchError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockProofLockedTransactionMismatchError) , IdentityAssetLockTransactionIsNotFoundError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionIsNotFoundError) , IdentityAssetLockTransactionOutPointAlreadyConsumedError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutPointAlreadyConsumedError) , IdentityAssetLockTransactionOutPointNotEnoughBalanceError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError) , IdentityAssetLockStateTransitionReplayError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockStateTransitionReplayError) , IdentityAssetLockTransactionOutputNotFoundError (* mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutputNotFoundError) , InvalidAssetLockProofCoreChainHeightError (* mut dpp :: consensus :: basic :: identity :: InvalidAssetLockProofCoreChainHeightError) , InvalidIdentityAssetLockProofChainLockValidationError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockProofChainLockValidationError) , InvalidAssetLockProofTransactionHeightError (* mut dpp :: consensus :: basic :: identity :: InvalidAssetLockProofTransactionHeightError) , InvalidAssetLockTransactionOutputReturnSizeError (* mut dpp :: consensus :: basic :: identity :: InvalidAssetLockTransactionOutputReturnSizeError) , InvalidIdentityAssetLockTransactionError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockTransactionError) , InvalidIdentityAssetLockTransactionOutputError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockTransactionOutputError) , InvalidIdentityPublicKeyDataError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityPublicKeyDataError) , InvalidInstantAssetLockProofError (* mut dpp :: consensus :: basic :: identity :: InvalidInstantAssetLockProofError) , InvalidInstantAssetLockProofSignatureError (* mut dpp :: consensus :: basic :: identity :: InvalidInstantAssetLockProofSignatureError) , MissingMasterPublicKeyError (* mut dpp :: consensus :: basic :: identity :: MissingMasterPublicKeyError) , TooManyMasterPublicKeyError (* mut dpp :: consensus :: basic :: identity :: TooManyMasterPublicKeyError) , MasterPublicKeyUpdateError (* mut dpp :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError) , InvalidDocumentTypeRequiredSecurityLevelError (* mut dpp :: consensus :: basic :: data_contract :: InvalidDocumentTypeRequiredSecurityLevelError) , InvalidIdentityPublicKeySecurityLevelError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityPublicKeySecurityLevelError) , InvalidIdentityKeySignatureError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityKeySignatureError) , InvalidIdentityCreditTransferAmountError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditTransferAmountError) , InvalidIdentityCreditWithdrawalTransitionOutputScriptError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError) , WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (* mut dpp :: consensus :: basic :: identity :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) , InvalidIdentityCreditWithdrawalTransitionCoreFeeError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError) , InvalidIdentityCreditWithdrawalTransitionAmountError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionAmountError) , InvalidIdentityUpdateTransitionEmptyError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityUpdateTransitionEmptyError) , InvalidIdentityUpdateTransitionDisableKeysError (* mut dpp :: consensus :: basic :: identity :: InvalidIdentityUpdateTransitionDisableKeysError) , NotImplementedIdentityCreditWithdrawalTransitionPoolingError (* mut dpp :: consensus :: basic :: identity :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError) , InvalidStateTransitionTypeError (* mut dpp :: consensus :: basic :: state_transition :: InvalidStateTransitionTypeError) , MissingStateTransitionTypeError (* mut dpp :: consensus :: basic :: state_transition :: MissingStateTransitionTypeError) , DocumentFieldMaxSizeExceededError (* mut dpp :: consensus :: basic :: document :: DocumentFieldMaxSizeExceededError) , StateTransitionMaxSizeExceededError (* mut dpp :: consensus :: basic :: state_transition :: StateTransitionMaxSizeExceededError) , DocumentTransitionsAreAbsentError (* mut dpp :: consensus :: basic :: document :: DocumentTransitionsAreAbsentError) , IdentityCreditTransferToSelfError (* mut dpp :: consensus :: basic :: identity :: IdentityCreditTransferToSelfError) , InvalidDocumentTypeNameError (* mut dpp :: consensus :: basic :: data_contract :: InvalidDocumentTypeNameError) , IncompatibleDocumentTypeSchemaError (* mut dpp :: consensus :: basic :: data_contract :: IncompatibleDocumentTypeSchemaError) , ContestedUniqueIndexOnMutableDocumentTypeError (* mut dpp :: consensus :: basic :: data_contract :: ContestedUniqueIndexOnMutableDocumentTypeError) , ContestedUniqueIndexWithUniqueIndexError (* mut dpp :: consensus :: basic :: data_contract :: ContestedUniqueIndexWithUniqueIndexError) , OverflowError (* mut dpp :: consensus :: basic :: overflow_error :: OverflowError) , UnsupportedFeatureError (* mut dpp :: consensus :: basic :: UnsupportedFeatureError) , ContestedDocumentsTemporarilyNotAllowedError (* mut dpp :: consensus :: basic :: document :: ContestedDocumentsTemporarilyNotAllowedError) , DataContractTokenConfigurationUpdateError (* mut dpp :: consensus :: basic :: data_contract :: DataContractTokenConfigurationUpdateError) , NonContiguousContractTokenPositionsError (* mut dpp :: consensus :: basic :: data_contract :: NonContiguousContractTokenPositionsError) , NonContiguousContractGroupPositionsError (* mut dpp :: consensus :: basic :: data_contract :: NonContiguousContractGroupPositionsError) , InvalidTokenBaseSupplyError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenBaseSupplyError) , InvalidTokenIdError (* mut dpp :: consensus :: basic :: token :: InvalidTokenIdError) , InvalidTokenAmountError (* mut dpp :: consensus :: basic :: token :: InvalidTokenAmountError) , InvalidTokenPositionError (* mut dpp :: consensus :: basic :: token :: InvalidTokenPositionError) , InvalidTokenConfigUpdateNoChangeError (* mut dpp :: consensus :: basic :: token :: InvalidTokenConfigUpdateNoChangeError) , InvalidTokenDistributionFunctionDivideByZeroError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionDivideByZeroError) , InvalidTokenDistributionFunctionInvalidParameterError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionInvalidParameterError) , InvalidTokenDistributionFunctionInvalidParameterTupleError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionInvalidParameterTupleError) , InvalidTokenDistributionFunctionIncoherenceError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionIncoherenceError) , TokenTransferToOurselfError (* mut dpp :: consensus :: basic :: token :: TokenTransferToOurselfError) , InvalidTokenNoteTooBigError (* mut dpp :: consensus :: basic :: token :: InvalidTokenNoteTooBigError) , ContractHasNoTokensError (* mut dpp :: consensus :: basic :: token :: ContractHasNoTokensError) , GroupPositionDoesNotExistError (* mut dpp :: consensus :: basic :: data_contract :: GroupPositionDoesNotExistError) , InvalidActionIdError (* mut dpp :: consensus :: basic :: token :: InvalidActionIdError) , DestinationIdentityForTokenMintingNotSetError (* mut dpp :: consensus :: basic :: token :: DestinationIdentityForTokenMintingNotSetError) , ChoosingTokenMintRecipientNotAllowedError (* mut dpp :: consensus :: basic :: token :: ChoosingTokenMintRecipientNotAllowedError) , GroupActionNotAllowedOnTransitionError (* mut dpp :: consensus :: basic :: group :: GroupActionNotAllowedOnTransitionError) , GroupExceedsMaxMembersError (* mut dpp :: consensus :: basic :: data_contract :: GroupExceedsMaxMembersError) , GroupMemberHasPowerOfZeroError (* mut dpp :: consensus :: basic :: data_contract :: GroupMemberHasPowerOfZeroError) , GroupMemberHasPowerOverLimitError (* mut dpp :: consensus :: basic :: data_contract :: GroupMemberHasPowerOverLimitError) , GroupTotalPowerLessThanRequiredError (* mut dpp :: consensus :: basic :: data_contract :: GroupTotalPowerLessThanRequiredError) , GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (* mut dpp :: consensus :: basic :: data_contract :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) , MissingDefaultLocalizationError (* mut dpp :: consensus :: basic :: token :: MissingDefaultLocalizationError) , UnknownGasFeesPaidByError (* mut dpp :: consensus :: basic :: data_contract :: UnknownGasFeesPaidByError) , UnknownDocumentActionTokenEffectError (* mut dpp :: consensus :: basic :: data_contract :: UnknownDocumentActionTokenEffectError) , TokenPaymentByBurningOnlyAllowedOnInternalTokenError (* mut dpp :: consensus :: basic :: data_contract :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError) , TooManyKeywordsError (* mut super :: data_contract :: TooManyKeywordsError) , DuplicateKeywordsError (* mut super :: data_contract :: DuplicateKeywordsError) , InvalidKeywordLengthError (* mut super :: data_contract :: InvalidKeywordLengthError) , InvalidDescriptionLengthError (* mut super :: data_contract :: InvalidDescriptionLengthError) , NewTokensDestinationIdentityOptionRequiredError (* mut dpp :: consensus :: basic :: data_contract :: NewTokensDestinationIdentityOptionRequiredError) , InvalidKeywordCharacterError (* mut dpp :: consensus :: basic :: data_contract :: InvalidKeywordCharacterError) , InvalidTokenNameCharacterError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenNameCharacterError) , DecimalsOverLimitError (* mut dpp :: consensus :: basic :: data_contract :: DecimalsOverLimitError) , InvalidTokenNameLengthError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenNameLengthError) , InvalidTokenLanguageCodeError (* mut dpp :: consensus :: basic :: data_contract :: InvalidTokenLanguageCodeError) , MainGroupIsNotDefinedError (* mut dpp :: consensus :: basic :: data_contract :: MainGroupIsNotDefinedError) , GroupRequiredPowerIsInvalidError (* mut dpp :: consensus :: basic :: data_contract :: GroupRequiredPowerIsInvalidError) , TokenNoteOnlyAllowedWhenProposerError (* mut dpp :: consensus :: basic :: token :: TokenNoteOnlyAllowedWhenProposerError) , InvalidTokenDistributionBlockIntervalTooShortError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionBlockIntervalTooShortError) , InvalidTokenDistributionTimeIntervalTooShortError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalTooShortError) , InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (* mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError) , RedundantDocumentPaidForByTokenWithContractId (* mut dpp :: consensus :: basic :: data_contract :: RedundantDocumentPaidForByTokenWithContractId) , GroupHasTooFewMembersError (* mut dpp :: consensus :: basic :: data_contract :: GroupHasTooFewMembersError) , InvalidKeyPurposeForContractBoundsError (* mut dpp :: consensus :: basic :: identity :: InvalidKeyPurposeForContractBoundsError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_basic_error_BasicError) -> dpp :: errors :: consensus :: basic :: basic_error :: BasicError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownGasFeesPaidByError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentActionTokenEffectError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyKeywordsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateKeywordsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordLengthError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDescriptionLengthError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NewTokensDestinationIdentityOptionRequiredError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordCharacterError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameCharacterError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DecimalsOverLimitError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameLengthError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenLanguageCodeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MainGroupIsNotDefinedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupRequiredPowerIsInvalidError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenNoteOnlyAllowedWhenProposerError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: RedundantDocumentPaidForByTokenWithContractId (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupHasTooFewMembersError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeyPurposeForContractBoundsError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: basic_error :: BasicError) -> * const dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (match obj { dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownGasFeesPaidByError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentActionTokenEffectError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyKeywordsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateKeywordsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDescriptionLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeywordCharacterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameCharacterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DecimalsOverLimitError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNameLengthError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenLanguageCodeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MainGroupIsNotDefinedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupRequiredPowerIsInvalidError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupHasTooFewMembersError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_basic_basic_error_BasicError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ProtocolVersionParsingError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: decode :: ProtocolVersionParsingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_VersionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: decode :: VersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContractError_ctor (o_o_0 : * mut contract :: DataContractError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownSecurityLevelError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownSecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownStorageKeyRequirementsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownStorageKeyRequirementsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownTransferableTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownTransferableTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownTradeModeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownTradeModeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownDocumentCreationRestrictionModeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownDocumentCreationRestrictionModeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_SerializedObjectParsingError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: decode :: SerializedObjectParsingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedProtocolVersionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: UnsupportedProtocolVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedVersionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleProtocolVersionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: IncompatibleProtocolVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_JsonSchemaCompilationError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_JsonSchemaError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: json_schema_error :: JsonSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentifierError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ValueError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: value_error :: ValueError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractMaxDepthExceedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateIndexError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DuplicateIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleRe2PatternError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: IncompatibleRe2PatternError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidCompoundIndexError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidCompoundIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDataContractIdError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidDataContractIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIndexedPropertyConstraintError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidIndexedPropertyConstraintError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIndexPropertyTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidIndexPropertyTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidJsonSchemaRefError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidJsonSchemaRefError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_SystemPropertyIndexAlreadyPresentError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: SystemPropertyIndexAlreadyPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UndefinedIndexPropertyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UndefinedIndexPropertyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UniqueIndicesLimitReachedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UniqueIndicesLimitReachedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateIndexNameError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DuplicateIndexNameError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDataContractVersionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidDataContractVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleDataContractSchemaError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: IncompatibleDataContractSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractImmutablePropertiesUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DataContractImmutablePropertiesUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractUniqueIndicesChangedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DataContractUniqueIndicesChangedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractInvalidIndexDefinitionUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DataContractInvalidIndexDefinitionUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractHaveNewUniqueIndexError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DataContractHaveNewUniqueIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractNotPresentError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DataContractNotPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentCreationNotAllowedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DocumentCreationNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractBoundsNotPresentError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: DataContractBoundsNotPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateDocumentTransitionsWithIdsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DuplicateDocumentTransitionsWithIdsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateDocumentTransitionsWithIndicesError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DuplicateDocumentTransitionsWithIndicesError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonceOutOfBoundsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: NonceOutOfBoundsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InconsistentCompoundIndexDataError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: InconsistentCompoundIndexDataError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTransitionActionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: InvalidDocumentTransitionActionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTransitionIdError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: InvalidDocumentTransitionIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: InvalidDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingPositionsInDocumentTypePropertiesError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MissingPositionsInDocumentTypePropertiesError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDataContractIdBasicError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MissingDataContractIdBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTransitionActionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MissingDocumentTransitionActionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTransitionTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MissingDocumentTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MissingDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MaxDocumentsTransitionsExceededError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: MaxDocumentsTransitionsExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicatedIdentityPublicKeyBasicError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: DuplicatedIdentityPublicKeyBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicatedIdentityPublicKeyIdBasicError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: DuplicatedIdentityPublicKeyIdBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DisablingKeyIdAlsoBeingAddedInSameTransitionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockProofLockedTransactionMismatchError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockProofLockedTransactionMismatchError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionIsNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionIsNotFoundError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutPointAlreadyConsumedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockStateTransitionReplayError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockStateTransitionReplayError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutputNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityAssetLockTransactionOutputNotFoundError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockProofCoreChainHeightError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidAssetLockProofCoreChainHeightError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockProofChainLockValidationError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockProofChainLockValidationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockProofTransactionHeightError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidAssetLockProofTransactionHeightError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockTransactionOutputReturnSizeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidAssetLockTransactionOutputReturnSizeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockTransactionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockTransactionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockTransactionOutputError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityAssetLockTransactionOutputError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityPublicKeyDataError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityPublicKeyDataError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidInstantAssetLockProofError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidInstantAssetLockProofError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidInstantAssetLockProofSignatureError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidInstantAssetLockProofSignatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingMasterPublicKeyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: MissingMasterPublicKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TooManyMasterPublicKeyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: TooManyMasterPublicKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MasterPublicKeyUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeRequiredSecurityLevelError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidDocumentTypeRequiredSecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityPublicKeySecurityLevelError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityPublicKeySecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityKeySignatureError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityKeySignatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditTransferAmountError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditTransferAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionAmountError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityCreditWithdrawalTransitionAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityUpdateTransitionEmptyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityUpdateTransitionEmptyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityUpdateTransitionDisableKeysError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidIdentityUpdateTransitionDisableKeysError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidStateTransitionTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: state_transition :: InvalidStateTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingStateTransitionTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: state_transition :: MissingStateTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentFieldMaxSizeExceededError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DocumentFieldMaxSizeExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_StateTransitionMaxSizeExceededError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: state_transition :: StateTransitionMaxSizeExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentTransitionsAreAbsentError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: DocumentTransitionsAreAbsentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityCreditTransferToSelfError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: IdentityCreditTransferToSelfError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeNameError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidDocumentTypeNameError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleDocumentTypeSchemaError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: IncompatibleDocumentTypeSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedUniqueIndexOnMutableDocumentTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedUniqueIndexWithUniqueIndexError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: ContestedUniqueIndexWithUniqueIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_OverflowError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: overflow_error :: OverflowError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedFeatureError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: UnsupportedFeatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedDocumentsTemporarilyNotAllowedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: document :: ContestedDocumentsTemporarilyNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractTokenConfigurationUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DataContractTokenConfigurationUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonContiguousContractTokenPositionsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: NonContiguousContractTokenPositionsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonContiguousContractGroupPositionsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: NonContiguousContractGroupPositionsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenBaseSupplyError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenBaseSupplyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenIdError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenAmountError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenPositionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenPositionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenConfigUpdateNoChangeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenConfigUpdateNoChangeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionDivideByZeroError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionDivideByZeroError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionInvalidParameterError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionInvalidParameterError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionInvalidParameterTupleError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionIncoherenceError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenDistributionFunctionIncoherenceError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TokenTransferToOurselfError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: TokenTransferToOurselfError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenNoteTooBigError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenNoteTooBigError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContractHasNoTokensError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: ContractHasNoTokensError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupPositionDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupPositionDoesNotExistError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidActionIdError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidActionIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DestinationIdentityForTokenMintingNotSetError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: DestinationIdentityForTokenMintingNotSetError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ChoosingTokenMintRecipientNotAllowedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: ChoosingTokenMintRecipientNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupActionNotAllowedOnTransitionError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: group :: GroupActionNotAllowedOnTransitionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupExceedsMaxMembersError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupExceedsMaxMembersError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupMemberHasPowerOfZeroError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupMemberHasPowerOfZeroError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupMemberHasPowerOverLimitError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupMemberHasPowerOverLimitError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupTotalPowerLessThanRequiredError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupTotalPowerLessThanRequiredError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDefaultLocalizationError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: MissingDefaultLocalizationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownGasFeesPaidByError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownGasFeesPaidByError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownGasFeesPaidByError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownDocumentActionTokenEffectError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: UnknownDocumentActionTokenEffectError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentActionTokenEffectError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TokenPaymentByBurningOnlyAllowedOnInternalTokenError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TokenPaymentByBurningOnlyAllowedOnInternalTokenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TooManyKeywordsError_ctor (o_o_0 : * mut super :: data_contract :: TooManyKeywordsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TooManyKeywordsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateKeywordsError_ctor (o_o_0 : * mut super :: data_contract :: DuplicateKeywordsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateKeywordsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidKeywordLengthError_ctor (o_o_0 : * mut super :: data_contract :: InvalidKeywordLengthError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordLengthError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDescriptionLengthError_ctor (o_o_0 : * mut super :: data_contract :: InvalidDescriptionLengthError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDescriptionLengthError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NewTokensDestinationIdentityOptionRequiredError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: NewTokensDestinationIdentityOptionRequiredError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NewTokensDestinationIdentityOptionRequiredError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidKeywordCharacterError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidKeywordCharacterError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeywordCharacterError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenNameCharacterError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenNameCharacterError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameCharacterError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DecimalsOverLimitError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: DecimalsOverLimitError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DecimalsOverLimitError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenNameLengthError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenNameLengthError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNameLengthError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenLanguageCodeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: InvalidTokenLanguageCodeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenLanguageCodeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MainGroupIsNotDefinedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: MainGroupIsNotDefinedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MainGroupIsNotDefinedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupRequiredPowerIsInvalidError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupRequiredPowerIsInvalidError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupRequiredPowerIsInvalidError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TokenNoteOnlyAllowedWhenProposerError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: TokenNoteOnlyAllowedWhenProposerError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TokenNoteOnlyAllowedWhenProposerError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionBlockIntervalTooShortError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionBlockIntervalTooShortError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionBlockIntervalTooShortError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionTimeIntervalTooShortError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalTooShortError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalTooShortError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionTimeIntervalNotMinuteAlignedError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: token :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionTimeIntervalNotMinuteAlignedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_RedundantDocumentPaidForByTokenWithContractId_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: RedundantDocumentPaidForByTokenWithContractId) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: RedundantDocumentPaidForByTokenWithContractId (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupHasTooFewMembersError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: data_contract :: GroupHasTooFewMembersError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupHasTooFewMembersError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidKeyPurposeForContractBoundsError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: identity :: InvalidKeyPurposeForContractBoundsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidKeyPurposeForContractBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_destroy (ffi : * mut dpp_errors_consensus_basic_basic_error_BasicError) { ferment :: unbox_any (ffi) ; } } pub mod group { use crate as example_nested ; pub mod group_action_not_allowed_on_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionNotAllowedOnTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { pub transition_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . transition_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError) -> * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { ferment :: boxed (dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . transition_type) }) } } impl Drop for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . transition_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_ctor (transition_type : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { ferment :: boxed (dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { transition_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_destroy (ffi : * mut dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_get_transition_type (obj : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> * mut std :: os :: raw :: c_char { (* obj) . transition_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_set_transition_type (obj : * mut dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError , value : * mut std :: os :: raw :: c_char) { (* obj) . transition_type = value ; } } } pub mod invalid_identifier_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentifierError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { pub identifier_name : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError) -> * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { ferment :: boxed (dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . identifier_name) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_ctor (identifier_name : * mut std :: os :: raw :: c_char , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { ferment :: boxed (dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { identifier_name , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_destroy (ffi : * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_get_identifier_name (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . identifier_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_get_message (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_set_identifier_name (obj : * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError , value : * mut std :: os :: raw :: c_char) { (* obj) . identifier_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_set_message (obj : * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod json_schema_compilation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`JsonSchemaCompilationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { pub compilation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . compilation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError) -> * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . compilation_error) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . compilation_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_ctor (compilation_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { compilation_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_destroy (ffi : * mut dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_get_compilation_error (obj : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> * mut std :: os :: raw :: c_char { (* obj) . compilation_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_set_compilation_error (obj : * mut dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError , value : * mut std :: os :: raw :: c_char) { (* obj) . compilation_error = value ; } } pub mod json_schema_error { use crate as example_nested ; pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`JsonSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { pub error_summary : * mut std :: os :: raw :: c_char , pub keyword : * mut std :: os :: raw :: c_char , pub instance_path : * mut std :: os :: raw :: c_char , pub schema_path : * mut std :: os :: raw :: c_char , pub params : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_error :: error :: JsonSchemaError) -> * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error_summary) ; ferment :: unbox_string (ffi_ref . keyword) ; ferment :: unbox_string (ffi_ref . instance_path) ; ferment :: unbox_string (ffi_ref . schema_path) ; ferment :: unbox_any (ffi_ref . params) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_ctor (error_summary : * mut std :: os :: raw :: c_char , keyword : * mut std :: os :: raw :: c_char , instance_path : * mut std :: os :: raw :: c_char , schema_path : * mut std :: os :: raw :: c_char , params : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError { error_summary , keyword , instance_path , schema_path , params , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_destroy (ffi : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_error_summary (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . error_summary } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_keyword (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_instance_path (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . instance_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_schema_path (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . schema_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_params (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . params } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_get_property_name (obj : * const dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_error_summary (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . error_summary = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_keyword (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . keyword = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_instance_path (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . instance_path = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_schema_path (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . schema_path = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_params (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { (* obj) . params = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError_set_property_name (obj : * mut dpp_errors_consensus_basic_json_schema_error_error_JsonSchemaError , value : * mut std :: os :: raw :: c_char) { (* obj) . property_name = value ; } } } pub mod overflow_error { use crate as example_nested ; # [doc = "FFI-representation of the [`OverflowError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_overflow_error_OverflowError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError) -> * const dpp_errors_consensus_basic_overflow_error_OverflowError { ferment :: boxed (dpp_errors_consensus_basic_overflow_error_OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_overflow_error_OverflowError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_overflow_error_OverflowError { ferment :: boxed (dpp_errors_consensus_basic_overflow_error_OverflowError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_destroy (ffi : * mut dpp_errors_consensus_basic_overflow_error_OverflowError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_get_message (obj : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_set_message (obj : * mut dpp_errors_consensus_basic_overflow_error_OverflowError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod state_transition { use crate as example_nested ; pub mod invalid_state_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { pub transition_type : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { transition_type : ffi_ref . transition_type } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { transition_type : obj . transition_type }) } } impl Drop for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_ctor (transition_type : u8) -> * mut dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { transition_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_get_transition_type (obj : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> u8 { (* obj) . transition_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_set_transition_type (obj : * mut dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError , value : u8) { (* obj) . transition_type = value ; } } pub mod missing_state_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { }) } } impl Drop for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError_ctor () -> * mut dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError_destroy (ffi : * mut dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) { ferment :: unbox_any (ffi) ; } } pub mod state_transition_max_size_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError) -> * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } impl Drop for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_ctor (actual_size_bytes : u64 , max_size_bytes : u64) -> * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { actual_size_bytes , max_size_bytes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_destroy (ffi : * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_get_actual_size_bytes (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_get_max_size_bytes (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_set_actual_size_bytes (obj : * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError , value : u64) { (* obj) . actual_size_bytes = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_set_max_size_bytes (obj : * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError , value : u64) { (* obj) . max_size_bytes = value ; } } } pub mod unsupported_feature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedFeatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { pub feature_name : * mut std :: os :: raw :: c_char , pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . feature_name) , current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError) -> * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . feature_name) , current_protocol_version : obj . current_protocol_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . feature_name) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_ctor (feature_name : * mut std :: os :: raw :: c_char , current_protocol_version : u32) -> * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { feature_name , current_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_destroy (ffi : * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_get_feature_name (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> * mut std :: os :: raw :: c_char { (* obj) . feature_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_get_current_protocol_version (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> u32 { (* obj) . current_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_set_feature_name (obj : * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError , value : * mut std :: os :: raw :: c_char) { (* obj) . feature_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_set_current_protocol_version (obj : * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError , value : u32) { (* obj) . current_protocol_version = value ; } } pub mod unsupported_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { pub received_version : u16 , pub min_version : u16 , pub max_version : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { received_version : ffi_ref . received_version , min_version : ffi_ref . min_version , max_version : ffi_ref . max_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError) -> * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { received_version : obj . received_version , min_version : obj . min_version , max_version : obj . max_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_ctor (received_version : u16 , min_version : u16 , max_version : u16) -> * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { received_version , min_version , max_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_destroy (ffi : * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_received_version (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . received_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_min_version (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . min_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_max_version (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . max_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_received_version (obj : * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError , value : u16) { (* obj) . received_version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_min_version (obj : * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError , value : u16) { (* obj) . min_version = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_max_version (obj : * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError , value : u16) { (* obj) . max_version = value ; } } pub mod value_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ValueError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_value_error_ValueError { pub value_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_value_error_ValueError) -> dpp :: errors :: consensus :: basic :: value_error :: ValueError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: value_error :: ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . value_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: value_error :: ValueError) -> * const dpp_errors_consensus_basic_value_error_ValueError { ferment :: boxed (dpp_errors_consensus_basic_value_error_ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . value_error) }) } } impl Drop for dpp_errors_consensus_basic_value_error_ValueError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . value_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_ctor (value_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_value_error_ValueError { ferment :: boxed (dpp_errors_consensus_basic_value_error_ValueError { value_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_destroy (ffi : * mut dpp_errors_consensus_basic_value_error_ValueError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_get_value_error (obj : * const dpp_errors_consensus_basic_value_error_ValueError) -> * mut std :: os :: raw :: c_char { (* obj) . value_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_set_value_error (obj : * mut dpp_errors_consensus_basic_value_error_ValueError , value : * mut std :: os :: raw :: c_char) { (* obj) . value_error = value ; } } } pub mod consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_consensus_error_ConsensusError { DefaultError , BasicError (* mut dpp :: errors :: consensus :: basic :: BasicError) , StateError (* mut dpp :: consensus :: state :: state_error :: StateError) , SignatureError (* mut dpp :: consensus :: signature :: SignatureError) , FeeError (* mut dpp :: consensus :: fee :: fee_error :: FeeError) , # [cfg (test)] TestConsensusError (* mut dpp :: consensus :: test_consensus_error :: TestConsensusError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_consensus_error_ConsensusError) -> dpp :: errors :: consensus :: consensus_error :: ConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (std :: ptr :: read (* o_0)) , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: consensus_error :: ConsensusError) -> * const dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (match obj { dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError => dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: StateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (ferment :: boxed (o_0)) , # [cfg (test)] dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_consensus_error_ConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => { } , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_DefaultError_ctor () -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_BasicError_ctor (o_o_0 : * mut dpp :: errors :: consensus :: basic :: BasicError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_StateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: state_error :: StateError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_SignatureError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: SignatureError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_FeeError_ctor (o_o_0 : * mut dpp :: consensus :: fee :: fee_error :: FeeError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_o_0)) } # [cfg (test)] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_TestConsensusError_ctor (o_o_0 : * mut dpp :: consensus :: test_consensus_error :: TestConsensusError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_destroy (ffi : * mut dpp_errors_consensus_consensus_error_ConsensusError) { ferment :: unbox_any (ffi) ; } } pub mod fee { use crate as example_nested ; pub mod balance_is_not_enough_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BalanceIsNotEnoughError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub fee : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . fee) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError) -> * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { ferment :: boxed (dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . fee) }) } } impl Drop for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance) ; ferment :: unbox_any (ffi_ref . fee) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_ctor (balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , fee : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { ferment :: boxed (dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { balance , fee }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_destroy (ffi : * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_get_balance (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_get_fee (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . fee } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_set_balance (obj : * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_set_fee (obj : * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . fee = value ; } } pub mod fee_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`FeeError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_fee_fee_error_FeeError { BalanceIsNotEnoughError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_fee_error_FeeError) -> dpp :: errors :: consensus :: fee :: fee_error :: FeeError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: fee_error :: FeeError) -> * const dpp_errors_consensus_fee_fee_error_FeeError { ferment :: boxed (match obj { dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (o_0) => dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_fee_fee_error_FeeError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_fee_error_FeeError_BalanceIsNotEnoughError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut dpp_errors_consensus_fee_fee_error_FeeError { ferment :: boxed (dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_fee_error_FeeError_destroy (ffi : * mut dpp_errors_consensus_fee_fee_error_FeeError) { ferment :: unbox_any (ffi) ; } } } pub mod signature { use crate as example_nested ; pub mod basic_bls_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BasicBLSError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError) -> * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { ferment :: boxed (dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { ferment :: boxed (dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_destroy (ffi : * mut dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_get_message (obj : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_set_message (obj : * mut dpp_errors_consensus_signature_basic_bls_error_BasicBLSError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod basic_ecdsa_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BasicECDSAError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError) -> * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { ferment :: boxed (dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { ferment :: boxed (dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_destroy (ffi : * mut dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_get_message (obj : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_set_message (obj : * mut dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod identity_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError) -> * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { ferment :: boxed (dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { ferment :: boxed (dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_destroy (ffi : * mut dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_get_identity_id (obj : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_set_identity_id (obj : * mut dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } } pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut dpp :: identity :: KeyType } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : std :: ptr :: read (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : ferment :: boxed (obj . public_key_type) }) } } impl Drop for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor (public_key_type : * mut dpp :: identity :: KeyType) -> * mut dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy (ffi : * mut dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type (obj : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut dpp :: identity :: KeyType { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type (obj : * mut dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError , value : * mut dpp :: identity :: KeyType) { (* obj) . public_key_type = value ; } } pub mod invalid_signature_public_key_purpose_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { pub public_key_purpose : * mut dpp :: identity :: Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { public_key_purpose : std :: ptr :: read (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { public_key_purpose : ferment :: boxed (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_ctor (public_key_purpose : * mut dpp :: identity :: Purpose , allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) -> * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { public_key_purpose , allowed_key_purposes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_destroy (ffi : * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_get_public_key_purpose (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut dpp :: identity :: Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_get_allowed_key_purposes (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose { (* obj) . allowed_key_purposes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_set_public_key_purpose (obj : * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError , value : * mut dpp :: identity :: Purpose) { (* obj) . public_key_purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_set_allowed_key_purposes (obj : * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) { (* obj) . allowed_key_purposes = value ; } } pub mod invalid_signature_public_key_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { pub public_key_security_level : * mut dpp :: identity :: SecurityLevel , pub allowed_key_security_levels : * mut crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : std :: ptr :: read (ffi_ref . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel as ferment :: FFIConversionFrom < Vec < dpp :: identity :: SecurityLevel > >> :: ffi_from (ffi_ref . allowed_key_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : ferment :: boxed (obj . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel as ferment :: FFIConversionTo < Vec < dpp :: identity :: SecurityLevel > >> :: ffi_to (obj . allowed_key_security_levels) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . allowed_key_security_levels) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_ctor (public_key_security_level : * mut dpp :: identity :: SecurityLevel , allowed_key_security_levels : * mut crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel) -> * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { public_key_security_level , allowed_key_security_levels }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_destroy (ffi : * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_get_public_key_security_level (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_get_allowed_key_security_levels (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel { (* obj) . allowed_key_security_levels } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_set_public_key_security_level (obj : * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . public_key_security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_set_allowed_key_security_levels (obj : * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_SecurityLevel) { (* obj) . allowed_key_security_levels = value ; } } pub mod invalid_state_transition_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidStateTransitionSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError) -> * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { ferment :: boxed (dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { ferment :: boxed (dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_destroy (ffi : * mut dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_get_message (obj : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_set_message (obj : * mut dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod missing_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { pub public_key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { public_key_id : std :: ptr :: read (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError) -> * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { ferment :: boxed (dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { public_key_id : ferment :: boxed (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_ctor (public_key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { ferment :: boxed (dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_destroy (ffi : * mut dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_get_public_key_id (obj : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_set_public_key_id (obj : * mut dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_id = value ; } } pub mod public_key_is_disabled_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { pub public_key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { public_key_id : std :: ptr :: read (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError) -> * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { public_key_id : ferment :: boxed (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_ctor (public_key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_destroy (ffi : * mut dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_get_public_key_id (obj : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_set_public_key_id (obj : * mut dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_id = value ; } } pub mod public_key_security_level_not_met_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut dpp :: identity :: SecurityLevel , pub required_security_level : * mut dpp :: identity :: SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : std :: ptr :: read (ffi_ref . public_key_security_level) , required_security_level : std :: ptr :: read (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : ferment :: boxed (obj . public_key_security_level) , required_security_level : ferment :: boxed (obj . required_security_level) }) } } impl Drop for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_ctor (public_key_security_level : * mut dpp :: identity :: SecurityLevel , required_security_level : * mut dpp :: identity :: SecurityLevel) -> * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level , required_security_level }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_destroy (ffi : * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_public_key_security_level (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_required_security_level (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp :: identity :: SecurityLevel { (* obj) . required_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_public_key_security_level (obj : * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . public_key_security_level = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_required_security_level (obj : * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError , value : * mut dpp :: identity :: SecurityLevel) { (* obj) . required_security_level = value ; } } pub mod signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SignatureError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_signature_signature_error_SignatureError { IdentityNotFoundError (* mut dpp :: consensus :: signature :: IdentityNotFoundError) , InvalidIdentityPublicKeyTypeError (* mut dpp :: consensus :: signature :: InvalidIdentityPublicKeyTypeError) , InvalidStateTransitionSignatureError (* mut dpp :: consensus :: signature :: InvalidStateTransitionSignatureError) , MissingPublicKeyError (* mut dpp :: consensus :: signature :: MissingPublicKeyError) , InvalidSignaturePublicKeyPurposeError (* mut dpp :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError) , InvalidSignaturePublicKeySecurityLevelError (* mut dpp :: consensus :: signature :: InvalidSignaturePublicKeySecurityLevelError) , WrongPublicKeyPurposeError (* mut dpp :: consensus :: signature :: WrongPublicKeyPurposeError) , PublicKeyIsDisabledError (* mut dpp :: consensus :: signature :: PublicKeyIsDisabledError) , PublicKeySecurityLevelNotMetError (* mut dpp :: consensus :: signature :: PublicKeySecurityLevelNotMetError) , SignatureShouldNotBePresentError (* mut dpp :: consensus :: signature :: SignatureShouldNotBePresentError) , BasicECDSAError (* mut dpp :: consensus :: signature :: BasicECDSAError) , BasicBLSError (* mut dpp :: consensus :: signature :: BasicBLSError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_error_SignatureError) -> dpp :: errors :: consensus :: signature :: signature_error :: SignatureError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_error :: SignatureError) -> * const dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (match obj { dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_signature_signature_error_SignatureError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_IdentityNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: IdentityNotFoundError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidIdentityPublicKeyTypeError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: InvalidIdentityPublicKeyTypeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidStateTransitionSignatureError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: InvalidStateTransitionSignatureError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_MissingPublicKeyError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: MissingPublicKeyError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidSignaturePublicKeyPurposeError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidSignaturePublicKeySecurityLevelError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: InvalidSignaturePublicKeySecurityLevelError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_WrongPublicKeyPurposeError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: WrongPublicKeyPurposeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_PublicKeyIsDisabledError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: PublicKeyIsDisabledError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_PublicKeySecurityLevelNotMetError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: PublicKeySecurityLevelNotMetError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_SignatureShouldNotBePresentError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: SignatureShouldNotBePresentError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_BasicECDSAError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: BasicECDSAError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_BasicBLSError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: BasicBLSError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_destroy (ffi : * mut dpp_errors_consensus_signature_signature_error_SignatureError) { ferment :: unbox_any (ffi) ; } } pub mod signature_should_not_be_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SignatureShouldNotBePresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError) -> * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { ferment :: boxed (dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { ferment :: boxed (dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_destroy (ffi : * mut dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_get_message (obj : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_set_message (obj : * mut dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod wrong_public_key_purpose_error { use crate as example_nested ; # [doc = "FFI-representation of the [`WrongPublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { pub public_key_purpose : * mut dpp :: identity :: Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { public_key_purpose : std :: ptr :: read (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose : ferment :: boxed (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_ctor (public_key_purpose : * mut dpp :: identity :: Purpose , allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) -> * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose , allowed_key_purposes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_destroy (ffi : * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_public_key_purpose (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut dpp :: identity :: Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_allowed_key_purposes (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose { (* obj) . allowed_key_purposes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_public_key_purpose (obj : * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError , value : * mut dpp :: identity :: Purpose) { (* obj) . public_key_purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_allowed_key_purposes (obj : * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_Purpose) { (* obj) . allowed_key_purposes = value ; } } } pub mod state { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; pub mod data_contract_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError) -> * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod data_contract_config_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { pub data_contract_id : * mut types :: identifier :: Identifier , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError) -> * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { data_contract_id : ferment :: boxed (obj . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_ctor (data_contract_id : * mut types :: identifier :: Identifier , additional_message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { data_contract_id , additional_message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_get_additional_message (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_set_additional_message (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . additional_message = value ; } } pub mod data_contract_is_readonly_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractIsReadonlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError) -> * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod data_contract_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { pub data_contract_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError > for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError > for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError) -> * const dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { data_contract_id : ferment :: boxed (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError_ctor (data_contract_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_not_found_error_DataContractNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } } pub mod data_contract_update_action_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdateActionNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { pub data_contract_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { data_contract_id : ferment :: boxed (obj . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_ctor (data_contract_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { data_contract_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_get_action (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_set_action (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod data_contract_update_permission_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdatePermissionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { pub data_contract_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { data_contract_id : ferment :: boxed (obj . data_contract_id) , identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_ctor (data_contract_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { data_contract_id , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_get_identity_id (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_set_identity_id (obj : * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod document_type_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { pub data_contract_id : * mut types :: identifier :: Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError) -> * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { data_contract_id : ferment :: boxed (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_ctor (data_contract_id : * mut types :: identifier :: Identifier , document_type_name : * mut std :: os :: raw :: c_char , additional_message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { data_contract_id , document_type_name , additional_message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_destroy (ffi : * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_document_type_name (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_additional_message (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_document_type_name (obj : * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_additional_message (obj : * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . additional_message = value ; } } } pub mod data_trigger { use crate as example_nested ; pub mod data_trigger_condition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerConditionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { pub data_contract_id : * mut types :: identifier :: Identifier , pub document_id : * mut types :: identifier :: Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , document_id : std :: ptr :: read (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { data_contract_id : ferment :: boxed (obj . data_contract_id) , document_id : ferment :: boxed (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_ctor (data_contract_id : * mut types :: identifier :: Identifier , document_id : * mut types :: identifier :: Identifier , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { data_contract_id , document_id , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_destroy (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_document_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_message (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_document_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_message (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod data_trigger_execution_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerExecutionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { pub data_contract_id : * mut types :: identifier :: Identifier , pub document_id : * mut types :: identifier :: Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , document_id : std :: ptr :: read (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { data_contract_id : ferment :: boxed (obj . data_contract_id) , document_id : ferment :: boxed (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_ctor (data_contract_id : * mut types :: identifier :: Identifier , document_id : * mut types :: identifier :: Identifier , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { data_contract_id , document_id , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_destroy (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_document_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_message (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_document_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_message (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod data_trigger_invalid_result_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerInvalidResultError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { pub data_contract_id : * mut types :: identifier :: Identifier , pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { data_contract_id : ferment :: boxed (obj . data_contract_id) , document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_ctor (data_contract_id : * mut types :: identifier :: Identifier , document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { data_contract_id , document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_destroy (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_get_data_contract_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_get_document_id (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_set_document_id (obj : * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataTriggerError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_data_trigger_DataTriggerError { DataTriggerConditionError (* mut dpp :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError) , DataTriggerExecutionError (* mut dpp :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError) , DataTriggerInvalidResultError (* mut dpp :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_DataTriggerError) -> dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError) -> * const dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_data_trigger_DataTriggerError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerConditionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerExecutionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerInvalidResultError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_destroy (ffi : * mut dpp_errors_consensus_state_data_trigger_DataTriggerError) { ferment :: unbox_any (ffi) ; } } pub mod document { use crate as example_nested ; pub mod document_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod document_contest_currently_locked_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestCurrentlyLockedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub unlock_cost : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , unlock_cost : ffi_ref . unlock_cost } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError) -> * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , unlock_cost : obj . unlock_cost }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , unlock_cost : u64) -> * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { vote_poll , stored_info , unlock_cost }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_vote_poll (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_stored_info (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_unlock_cost (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> u64 { (* obj) . unlock_cost } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_vote_poll (obj : * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) { (* obj) . vote_poll = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_stored_info (obj : * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) { (* obj) . stored_info = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_unlock_cost (obj : * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError , value : u64) { (* obj) . unlock_cost = value ; } } pub mod document_contest_document_with_same_id_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestDocumentWithSameIdAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod document_contest_identity_already_contestant { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestIdentityAlreadyContestantError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError) -> * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { vote_poll , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_get_vote_poll (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_get_identity_id (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_set_vote_poll (obj : * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) { (* obj) . vote_poll = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_set_identity_id (obj : * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod document_contest_not_joinable_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestNotJoinableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub start_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub current_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub joinable_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . joinable_time) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError) -> * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . joinable_time) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ferment :: unbox_any (ffi_ref . start_time) ; ferment :: unbox_any (ffi_ref . current_time) ; ferment :: unbox_any (ffi_ref . joinable_time) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , start_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , current_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , joinable_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) -> * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { vote_poll , stored_info , start_time , current_time , joinable_time }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_vote_poll (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_stored_info (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_start_time (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . start_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_current_time (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . current_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_joinable_time (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . joinable_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_vote_poll (obj : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) { (* obj) . vote_poll = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_stored_info (obj : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) { (* obj) . stored_info = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_start_time (obj : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) { (* obj) . start_time = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_current_time (obj : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) { (* obj) . current_time = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_joinable_time (obj : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) { (* obj) . joinable_time = value ; } } pub mod document_contest_not_paid_for_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestNotPaidForError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { pub document_id : * mut types :: identifier :: Identifier , pub expected_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub paid_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { document_id : std :: ptr :: read (ffi_ref . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . paid_amount) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError) -> * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { document_id : ferment :: boxed (obj . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . paid_amount) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . expected_amount) ; ferment :: unbox_any (ffi_ref . paid_amount) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_ctor (document_id : * mut types :: identifier :: Identifier , expected_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , paid_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { document_id , expected_amount , paid_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_expected_amount (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . expected_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_paid_amount (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . paid_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_expected_amount (obj : * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . expected_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_paid_amount (obj : * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . paid_amount = value ; } } pub mod document_incorrect_purchase_price_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentIncorrectPurchasePriceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { pub document_id : * mut types :: identifier :: Identifier , pub trying_to_purchase_at_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub actual_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { document_id : std :: ptr :: read (ffi_ref . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . actual_price) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError) -> * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { ferment :: boxed (dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { document_id : ferment :: boxed (obj . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . actual_price) }) } } impl Drop for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . trying_to_purchase_at_price) ; ferment :: unbox_any (ffi_ref . actual_price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_ctor (document_id : * mut types :: identifier :: Identifier , trying_to_purchase_at_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , actual_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { ferment :: boxed (dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { document_id , trying_to_purchase_at_price , actual_price }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_trying_to_purchase_at_price (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . trying_to_purchase_at_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_actual_price (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . actual_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_trying_to_purchase_at_price (obj : * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . trying_to_purchase_at_price = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_actual_price (obj : * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . actual_price = value ; } } pub mod document_not_for_sale_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentNotForSaleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError) -> * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod document_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError) -> * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod document_owner_id_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentOwnerIdMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { pub document_id : * mut types :: identifier :: Identifier , pub document_owner_id : * mut types :: identifier :: Identifier , pub existing_document_owner_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { document_id : std :: ptr :: read (ffi_ref . document_id) , document_owner_id : std :: ptr :: read (ffi_ref . document_owner_id) , existing_document_owner_id : std :: ptr :: read (ffi_ref . existing_document_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError) -> * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { document_id : ferment :: boxed (obj . document_id) , document_owner_id : ferment :: boxed (obj . document_owner_id) , existing_document_owner_id : ferment :: boxed (obj . existing_document_owner_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . document_owner_id) ; ferment :: unbox_any (ffi_ref . existing_document_owner_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_ctor (document_id : * mut types :: identifier :: Identifier , document_owner_id : * mut types :: identifier :: Identifier , existing_document_owner_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { document_id , document_owner_id , existing_document_owner_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_document_owner_id (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut types :: identifier :: Identifier { (* obj) . document_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_existing_document_owner_id (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut types :: identifier :: Identifier { (* obj) . existing_document_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_document_owner_id (obj : * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError , value : * mut types :: identifier :: Identifier) { (* obj) . document_owner_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_existing_document_owner_id (obj : * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError , value : * mut types :: identifier :: Identifier) { (* obj) . existing_document_owner_id = value ; } } pub mod document_timestamp_window_violation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampWindowViolationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { pub timestamp_name : * mut std :: os :: raw :: c_char , pub document_id : * mut types :: identifier :: Identifier , pub timestamp : i64 , pub time_window_start : i64 , pub time_window_end : i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . timestamp_name) , document_id : std :: ptr :: read (ffi_ref . document_id) , timestamp : ffi_ref . timestamp , time_window_start : ffi_ref . time_window_start , time_window_end : ffi_ref . time_window_end } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError) -> * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . timestamp_name) , document_id : ferment :: boxed (obj . document_id) , timestamp : obj . timestamp , time_window_start : obj . time_window_start , time_window_end : obj . time_window_end }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . timestamp_name) ; ferment :: unbox_any (ffi_ref . document_id) ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_ctor (timestamp_name : * mut std :: os :: raw :: c_char , document_id : * mut types :: identifier :: Identifier , timestamp : i64 , time_window_start : i64 , time_window_end : i64) -> * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { timestamp_name , document_id , timestamp , time_window_start , time_window_end }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_timestamp_name (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut std :: os :: raw :: c_char { (* obj) . timestamp_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_timestamp (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . timestamp } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_time_window_start (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_start } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_time_window_end (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_end } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_timestamp_name (obj : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError , value : * mut std :: os :: raw :: c_char) { (* obj) . timestamp_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_timestamp (obj : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError , value : i64) { (* obj) . timestamp = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_time_window_start (obj : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError , value : i64) { (* obj) . time_window_start = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_time_window_end (obj : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError , value : i64) { (* obj) . time_window_end = value ; } } pub mod document_timestamps_are_equal_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampsAreEqualError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError) -> * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod document_timestamps_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampsMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { pub document_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { document_id : std :: ptr :: read (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError) -> * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { document_id : ferment :: boxed (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_ctor (document_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_destroy (ffi : * mut dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_get_document_id (obj : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_set_document_id (obj : * mut dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } } pub mod duplicate_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { pub document_id : * mut types :: identifier :: Identifier , pub duplicating_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { document_id : std :: ptr :: read (ffi_ref . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . duplicating_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError) -> * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { ferment :: boxed (dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { document_id : ferment :: boxed (obj . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . duplicating_properties) }) } } impl Drop for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . duplicating_properties) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_ctor (document_id : * mut types :: identifier :: Identifier , duplicating_properties : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { ferment :: boxed (dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { document_id , duplicating_properties }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_destroy (ffi : * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_get_document_id (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_get_duplicating_properties (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . duplicating_properties } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_set_document_id (obj : * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_set_duplicating_properties (obj : * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . duplicating_properties = value ; } } pub mod invalid_document_revision_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { pub document_id : * mut types :: identifier :: Identifier , pub previous_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub desired_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { document_id : std :: ptr :: read (ffi_ref . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . desired_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError) -> * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { ferment :: boxed (dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { document_id : ferment :: boxed (obj . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . desired_revision) }) } } impl Drop for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any_opt (ffi_ref . previous_revision) ; ferment :: unbox_any (ffi_ref . desired_revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_ctor (document_id : * mut types :: identifier :: Identifier , previous_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , desired_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { ferment :: boxed (dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { document_id , previous_revision , desired_revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_destroy (ffi : * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_document_id (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut types :: identifier :: Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_previous_revision (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . previous_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_desired_revision (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . desired_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_document_id (obj : * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError , value : * mut types :: identifier :: Identifier) { (* obj) . document_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_previous_revision (obj : * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . previous_revision = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_desired_revision (obj : * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . desired_revision = value ; } } } pub mod group { use crate as example_nested ; pub mod group_action_already_completed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionAlreadyCompletedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { pub data_contract_id : * mut types :: identifier :: Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : std :: ptr :: read (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError) -> * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { data_contract_id : ferment :: boxed (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : ferment :: boxed (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_ctor (data_contract_id : * mut types :: identifier :: Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_destroy (ffi : * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_data_contract_id (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_group_contract_position (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_action_id (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut types :: identifier :: Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_group_contract_position (obj : * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_action_id (obj : * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError , value : * mut types :: identifier :: Identifier) { (* obj) . action_id = value ; } } pub mod group_action_already_signed_by_identity_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionAlreadySignedByIdentityError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { pub identity_id : * mut types :: identifier :: Identifier , pub data_contract_id : * mut types :: identifier :: Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { identity_id : std :: ptr :: read (ffi_ref . identity_id) , data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : std :: ptr :: read (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError) -> * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { identity_id : ferment :: boxed (obj . identity_id) , data_contract_id : ferment :: boxed (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : ferment :: boxed (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_ctor (identity_id : * mut types :: identifier :: Identifier , data_contract_id : * mut types :: identifier :: Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { identity_id , data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_destroy (ffi : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_identity_id (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_data_contract_id (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_group_contract_position (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_action_id (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut types :: identifier :: Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_identity_id (obj : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_group_contract_position (obj : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_action_id (obj : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError , value : * mut types :: identifier :: Identifier) { (* obj) . action_id = value ; } } pub mod group_action_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { pub data_contract_id : * mut types :: identifier :: Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : std :: ptr :: read (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError) -> * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { data_contract_id : ferment :: boxed (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : ferment :: boxed (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_ctor (data_contract_id : * mut types :: identifier :: Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_data_contract_id (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_group_contract_position (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_action_id (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_group_contract_position (obj : * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_action_id (obj : * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . action_id = value ; } } pub mod identity_not_member_of_group_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotMemberOfGroupError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { pub identity_id : * mut types :: identifier :: Identifier , pub data_contract_id : * mut types :: identifier :: Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { identity_id : std :: ptr :: read (ffi_ref . identity_id) , data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError) -> * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { ferment :: boxed (dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { identity_id : ferment :: boxed (obj . identity_id) , data_contract_id : ferment :: boxed (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_ctor (identity_id : * mut types :: identifier :: Identifier , data_contract_id : * mut types :: identifier :: Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { ferment :: boxed (dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { identity_id , data_contract_id , group_contract_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_destroy (ffi : * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_identity_id (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_data_contract_id (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_group_contract_position (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_identity_id (obj : * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_group_contract_position (obj : * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } } pub mod identity_for_group_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityMemberOfGroupNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { pub contract_id : * mut types :: identifier :: Identifier , pub group_position : u16 , pub member_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError > for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) -> dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError { contract_id : std :: ptr :: read (ffi_ref . contract_id) , group_position : ffi_ref . group_position , member_id : std :: ptr :: read (ffi_ref . member_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError > for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: identity_for_group_not_found_error :: IdentityMemberOfGroupNotFoundError) -> * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { ferment :: boxed (dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { contract_id : ferment :: boxed (obj . contract_id) , group_position : obj . group_position , member_id : ferment :: boxed (obj . member_id) }) } } impl Drop for dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ; ferment :: unbox_any (ffi_ref . member_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_ctor (contract_id : * mut types :: identifier :: Identifier , group_position : u16 , member_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { ferment :: boxed (dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError { contract_id , group_position , member_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_get_contract_id (obj : * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_get_group_position (obj : * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) -> u16 { (* obj) . group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_get_member_id (obj : * const dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_set_contract_id (obj : * mut dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_set_group_position (obj : * mut dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError , value : u16) { (* obj) . group_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError_set_member_id (obj : * mut dpp_errors_consensus_state_group_identity_for_group_not_found_error_IdentityMemberOfGroupNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . member_id = value ; } } pub mod modification_of_group_action_main_parameters_not_permitted_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ModificationOfGroupActionMainParametersNotPermittedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { pub original : * mut std :: os :: raw :: c_char , pub modified : * mut std :: os :: raw :: c_char , pub changed_internal_fields : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError > for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) -> dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError { original : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . original) , modified : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . modified) , changed_internal_fields : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . changed_internal_fields) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError > for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: modification_of_group_action_main_parameters_not_permitted_error :: ModificationOfGroupActionMainParametersNotPermittedError) -> * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { ferment :: boxed (dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { original : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . original) , modified : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . modified) , changed_internal_fields : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . changed_internal_fields) }) } } impl Drop for dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . original) ; ferment :: unbox_string (ffi_ref . modified) ; ferment :: unbox_any (ffi_ref . changed_internal_fields) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_ctor (original : * mut std :: os :: raw :: c_char , modified : * mut std :: os :: raw :: c_char , changed_internal_fields : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { ferment :: boxed (dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError { original , modified , changed_internal_fields }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_destroy (ffi : * mut dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_get_original (obj : * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) -> * mut std :: os :: raw :: c_char { (* obj) . original } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_get_modified (obj : * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) -> * mut std :: os :: raw :: c_char { (* obj) . modified } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_get_changed_internal_fields (obj : * const dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . changed_internal_fields } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_set_original (obj : * mut dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError , value : * mut std :: os :: raw :: c_char) { (* obj) . original = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_set_modified (obj : * mut dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError , value : * mut std :: os :: raw :: c_char) { (* obj) . modified = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError_set_changed_internal_fields (obj : * mut dpp_errors_consensus_state_group_modification_of_group_action_main_parameters_not_permitted_error_ModificationOfGroupActionMainParametersNotPermittedError , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . changed_internal_fields = value ; } } } pub mod identity { use crate as example_nested ; pub mod duplicated_identity_public_key_id_state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_ctor (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) -> * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_destroy (ffi : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_get_duplicated_ids (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_set_duplicated_ids (obj : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . duplicated_ids = value ; } } pub mod duplicated_identity_public_key_state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { pub duplicated_public_key_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . duplicated_public_key_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . duplicated_public_key_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_public_key_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_ctor (duplicated_public_key_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) -> * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_destroy (ffi : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_get_duplicated_public_key_ids (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . duplicated_public_key_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_set_duplicated_public_key_ids (obj : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . duplicated_public_key_ids = value ; } } pub mod identity_already_exists_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAlreadyExistsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError) -> * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_ctor (identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod identity_insufficient_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityInsufficientBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError) -> * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , balance : u64 , required_balance : u64) -> * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { identity_id , balance , required_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_balance (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_required_balance (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_balance (obj : * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError , value : u64) { (* obj) . balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_required_balance (obj : * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError , value : u64) { (* obj) . required_balance = value ; } } pub mod identity_public_key_already_exists_for_unique_contract_bounds_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { pub identity_id : * mut types :: identifier :: Identifier , pub contract_id : * mut types :: identifier :: Identifier , pub purpose : * mut dpp :: identity :: Purpose , pub new_key_id : * mut dpp :: identity :: KeyID , pub old_key_id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : std :: ptr :: read (ffi_ref . identity_id) , contract_id : std :: ptr :: read (ffi_ref . contract_id) , purpose : std :: ptr :: read (ffi_ref . purpose) , new_key_id : std :: ptr :: read (ffi_ref . new_key_id) , old_key_id : std :: ptr :: read (ffi_ref . old_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : ferment :: boxed (obj . identity_id) , contract_id : ferment :: boxed (obj . contract_id) , purpose : ferment :: boxed (obj . purpose) , new_key_id : ferment :: boxed (obj . new_key_id) , old_key_id : ferment :: boxed (obj . old_key_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . new_key_id) ; ferment :: unbox_any (ffi_ref . old_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_ctor (identity_id : * mut types :: identifier :: Identifier , contract_id : * mut types :: identifier :: Identifier , purpose : * mut dpp :: identity :: Purpose , new_key_id : * mut dpp :: identity :: KeyID , old_key_id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id , contract_id , purpose , new_key_id , old_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_contract_id (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_purpose (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut dpp :: identity :: Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_new_key_id (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut dpp :: identity :: KeyID { (* obj) . new_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_old_key_id (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut dpp :: identity :: KeyID { (* obj) . old_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_contract_id (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_purpose (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError , value : * mut dpp :: identity :: Purpose) { (* obj) . purpose = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_new_key_id (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError , value : * mut dpp :: identity :: KeyID) { (* obj) . new_key_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_old_key_id (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError , value : * mut dpp :: identity :: KeyID) { (* obj) . old_key_id = value ; } } pub mod identity_public_key_is_disabled_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { pub public_key_index : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { public_key_index : std :: ptr :: read (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { public_key_index : ferment :: boxed (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_ctor (public_key_index : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { public_key_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_get_public_key_index (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_set_public_key_index (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_index = value ; } } pub mod identity_public_key_is_read_only_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsReadOnlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { pub public_key_index : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { public_key_index : std :: ptr :: read (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { public_key_index : ferment :: boxed (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_ctor (public_key_index : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { public_key_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_get_public_key_index (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> * mut dpp :: identity :: KeyID { (* obj) . public_key_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_set_public_key_index (obj : * mut dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError , value : * mut dpp :: identity :: KeyID) { (* obj) . public_key_index = value ; } } pub mod invalid_identity_contract_nonce_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityNonceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub setting_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub error : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from_opt (ffi_ref . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError) -> * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to_opt (obj . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any_opt (ffi_ref . current_identity_nonce) ; ferment :: unbox_any (ffi_ref . setting_identity_nonce) ; ferment :: unbox_any (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , setting_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , error : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult) -> * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { identity_id , current_identity_nonce , setting_identity_nonce , error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_destroy (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_current_identity_nonce (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . current_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_setting_identity_nonce (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . setting_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_error (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_current_identity_nonce (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . current_identity_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_setting_identity_nonce (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) { (* obj) . setting_identity_nonce = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_error (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError , value : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult) { (* obj) . error = value ; } } pub mod invalid_identity_public_key_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { pub id : * mut dpp :: identity :: KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { id : std :: ptr :: read (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError) -> * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { id : ferment :: boxed (obj . id) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_ctor (id : * mut dpp :: identity :: KeyID) -> * mut dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_destroy (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_get_id (obj : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> * mut dpp :: identity :: KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_set_id (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError , value : * mut dpp :: identity :: KeyID) { (* obj) . id = value ; } } pub mod invalid_identity_revision_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . current_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError) -> * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . current_revision) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . current_revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_ctor (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { identity_id , current_revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_destroy (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_get_current_revision (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . current_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_set_current_revision (obj : * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) { (* obj) . current_revision = value ; } } pub mod master_public_key_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasterPublicKeyUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { pub adding : usize , pub removing : usize , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { adding : ffi_ref . adding , removing : ffi_ref . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError) -> * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { ferment :: boxed (dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { adding : obj . adding , removing : obj . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . description) }) } } impl Drop for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_string (ffi_ref . description) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_ctor (adding : usize , removing : usize , description : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { ferment :: boxed (dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { adding , removing , description }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_destroy (ffi : * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_adding (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . adding } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_removing (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . removing } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_description (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . description } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_adding (obj : * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError , value : usize) { (* obj) . adding = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_removing (obj : * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError , value : usize) { (* obj) . removing = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_description (obj : * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError , value : * mut std :: os :: raw :: c_char) { (* obj) . description = value ; } } pub mod max_identity_public_key_limit_reached_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MaxIdentityPublicKeyLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { pub max_items : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { max_items : ffi_ref . max_items } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError) -> * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { ferment :: boxed (dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { max_items : obj . max_items }) } } impl Drop for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_ctor (max_items : usize) -> * mut dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { ferment :: boxed (dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { max_items }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_destroy (ffi : * mut dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_get_max_items (obj : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> usize { (* obj) . max_items } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_set_max_items (obj : * mut dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError , value : usize) { (* obj) . max_items = value ; } } pub mod missing_identity_public_key_ids_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingIdentityPublicKeyIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { pub ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: KeyID > >> :: ffi_from (ffi_ref . ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError) -> * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: KeyID > >> :: ffi_to (obj . ids) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_ctor (ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) -> * mut dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_destroy (ffi : * mut dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_get_ids (obj : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID { (* obj) . ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_set_ids (obj : * mut dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError , value : * mut crate :: fermented :: generics :: Vec_dpp_identity_KeyID) { (* obj) . ids = value ; } } pub mod missing_transfer_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingTransferKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError) -> * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_ctor (identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_destroy (ffi : * mut dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod no_transfer_key_for_core_withdrawal_available_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NoTransferKeyForCoreWithdrawalAvailableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError) -> * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { ferment :: boxed (dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_ctor (identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { ferment :: boxed (dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_destroy (ffi : * mut dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod identity_for_token_configuration_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationIdentityContext`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ChangeControlRule (* mut std :: os :: raw :: c_char) , DefaultMintingRecipient , PerpetualDistributionRecipient , PreProgrammedDistributionRecipient } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext) -> dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: ChangeControlRule (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: DefaultMintingRecipient , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PerpetualDistributionRecipient , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext) -> * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: DefaultMintingRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient , dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient => { } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient => { } , dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext_ChangeControlRule_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: ChangeControlRule (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext_DefaultMintingRecipient_ctor () -> * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: DefaultMintingRecipient { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext_PerpetualDistributionRecipient_ctor () -> * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PerpetualDistributionRecipient { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext_PreProgrammedDistributionRecipient_ctor () -> * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext :: PreProgrammedDistributionRecipient { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`IdentityInTokenConfigurationNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { pub contract_id : * mut types :: identifier :: Identifier , pub token_position : u16 , pub context : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext , pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError { contract_id : std :: ptr :: read (ffi_ref . contract_id) , token_position : ffi_ref . token_position , context : < crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext >> :: ffi_from (ffi_ref . context) , identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError > for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError) -> * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { contract_id : ferment :: boxed (obj . contract_id) , token_position : obj . token_position , context : < crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: TokenConfigurationIdentityContext >> :: ffi_to (obj . context) , identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ; ferment :: unbox_any (ffi_ref . context) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_ctor (contract_id : * mut types :: identifier :: Identifier , token_position : u16 , context : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext , identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError { contract_id , token_position , context , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_get_contract_id (obj : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_get_token_position (obj : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> u16 { (* obj) . token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_get_context (obj : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext { (* obj) . context } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_get_identity_id (obj : * const dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_set_contract_id (obj : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_set_token_position (obj : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError , value : u16) { (* obj) . token_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_set_context (obj : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError , value : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_TokenConfigurationIdentityContext) { (* obj) . context = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError_set_identity_id (obj : * mut dpp_errors_consensus_state_identity_identity_for_token_configuration_not_found_error_IdentityInTokenConfigurationNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod identity_to_freeze_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityToFreezeDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { pub identity_to_freeze_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError > for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError) -> dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError { identity_to_freeze_id : std :: ptr :: read (ffi_ref . identity_to_freeze_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError > for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError) -> * const dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { identity_to_freeze_id : ferment :: boxed (obj . identity_to_freeze_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_to_freeze_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError_ctor (identity_to_freeze_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError { identity_to_freeze_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError_get_identity_to_freeze_id (obj : * const dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . identity_to_freeze_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError_set_identity_to_freeze_id (obj : * mut dpp_errors_consensus_state_identity_identity_to_freeze_does_not_exist_error_IdentityToFreezeDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_to_freeze_id = value ; } } pub mod recipient_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`RecipientIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { pub recipient_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { recipient_id : std :: ptr :: read (ffi_ref . recipient_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { recipient_id : ferment :: boxed (obj . recipient_id) }) } } impl Drop for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . recipient_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_ctor (recipient_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { recipient_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_get_recipient_id (obj : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_set_recipient_id (obj : * mut dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . recipient_id = value ; } } } pub mod prefunded_specialized_balances { use crate as example_nested ; pub mod prefunded_specialized_balance_insufficient_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceInsufficientError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_ctor (balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , balance : u64 , required_balance : u64) -> * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { balance_id , balance , required_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_destroy (ffi : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_balance_id (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_balance (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_required_balance (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_balance_id (obj : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . balance_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_balance (obj : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError , value : u64) { (* obj) . balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_required_balance (obj : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError , value : u64) { (* obj) . required_balance = value ; } } pub mod prefunded_specialized_balance_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_ctor (balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { balance_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_get_balance_id (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_set_balance_id (obj : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . balance_id = value ; } } } pub mod state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_state_error_StateError { DataContractAlreadyPresentError (* mut dpp :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError) , DataTriggerError (* mut dpp :: consensus :: state :: data_trigger :: DataTriggerError) , DocumentAlreadyPresentError (* mut dpp :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError) , DocumentContestCurrentlyLockedError (* mut dpp :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError) , DocumentContestNotJoinableError (* mut dpp :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError) , DocumentContestIdentityAlreadyContestantError (* mut dpp :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError) , DocumentContestNotPaidForError (* mut dpp :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError) , DocumentContestDocumentWithSameIdAlreadyPresentError (* mut dpp :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError) , DocumentNotFoundError (* mut dpp :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError) , DocumentNotForSaleError (* mut dpp :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError) , DocumentIncorrectPurchasePriceError (* mut dpp :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError) , DocumentOwnerIdMismatchError (* mut dpp :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError) , DocumentTimestampsMismatchError (* mut dpp :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError) , DocumentTimestampWindowViolationError (* mut dpp :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError) , DuplicateUniqueIndexError (* mut dpp :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError) , InvalidDocumentRevisionError (* mut dpp :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError) , IdentityAlreadyExistsError (* mut dpp :: consensus :: state :: identity :: IdentityAlreadyExistsError) , IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (* mut dpp :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) , IdentityPublicKeyIsReadOnlyError (* mut dpp :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError) , MissingIdentityPublicKeyIdsError (* mut dpp :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError) , MissingTransferKeyError (* mut dpp :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError) , NoTransferKeyForCoreWithdrawalAvailableError (* mut dpp :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError) , InvalidIdentityPublicKeyIdError (* mut dpp :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError) , InvalidIdentityRevisionError (* mut dpp :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError) , InvalidIdentityNonceError (* mut dpp :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError) , MaxIdentityPublicKeyLimitReachedError (* mut dpp :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError) , DuplicatedIdentityPublicKeyStateError (* mut dpp :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError) , DuplicatedIdentityPublicKeyIdStateError (* mut dpp :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError) , IdentityPublicKeyIsDisabledError (* mut dpp :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError) , IdentityInsufficientBalanceError (* mut dpp :: consensus :: state :: identity :: IdentityInsufficientBalanceError) , DocumentTimestampsAreEqualError (* mut super :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError) , DataContractIsReadonlyError (* mut dpp :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError) , DataContractConfigUpdateError (* mut dpp :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError) , DocumentTypeUpdateError (* mut dpp :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError) , PrefundedSpecializedBalanceInsufficientError (* mut dpp :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError) , PrefundedSpecializedBalanceNotFoundError (* mut dpp :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError) , DataContractUpdatePermissionError (* mut dpp :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError) , MasternodeNotFoundError (* mut dpp :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError) , MasternodeIncorrectVoterIdentityIdError (* mut dpp :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError) , MasternodeIncorrectVotingAddressError (* mut dpp :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError) , VotePollNotFoundError (* mut dpp :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError) , VotePollNotAvailableForVotingError (* mut dpp :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError) , MasternodeVotedTooManyTimesError (* mut dpp :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError) , MasternodeVoteAlreadyPresentError (* mut dpp :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError) , RecipientIdentityDoesNotExistError (* mut dpp :: consensus :: state :: identity :: RecipientIdentityDoesNotExistError) , IdentityDoesNotHaveEnoughTokenBalanceError (* mut dpp :: consensus :: state :: token :: IdentityDoesNotHaveEnoughTokenBalanceError) , UnauthorizedTokenActionError (* mut dpp :: consensus :: state :: token :: UnauthorizedTokenActionError) , IdentityTokenAccountFrozenError (* mut dpp :: consensus :: state :: token :: IdentityTokenAccountFrozenError) , IdentityTokenAccountNotFrozenError (* mut dpp :: consensus :: state :: token :: IdentityTokenAccountNotFrozenError) , IdentityNotMemberOfGroupError (* mut dpp :: consensus :: state :: group :: IdentityNotMemberOfGroupError) , GroupActionDoesNotExistError (* mut dpp :: consensus :: state :: group :: GroupActionDoesNotExistError) , GroupActionAlreadyCompletedError (* mut dpp :: consensus :: state :: group :: GroupActionAlreadyCompletedError) , GroupActionAlreadySignedByIdentityError (* mut dpp :: consensus :: state :: group :: GroupActionAlreadySignedByIdentityError) , DataContractUpdateActionNotAllowedError (* mut dpp :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError) , TokenSettingMaxSupplyToLessThanCurrentSupplyError (* mut dpp :: consensus :: state :: token :: TokenSettingMaxSupplyToLessThanCurrentSupplyError) , TokenMintPastMaxSupplyError (* mut dpp :: consensus :: state :: token :: TokenMintPastMaxSupplyError) , InvalidTokenClaimPropertyMismatch (* mut dpp :: consensus :: state :: token :: InvalidTokenClaimPropertyMismatch) , InvalidTokenClaimNoCurrentRewards (* mut dpp :: consensus :: state :: token :: InvalidTokenClaimNoCurrentRewards) , InvalidTokenClaimWrongClaimant (* mut dpp :: consensus :: state :: token :: InvalidTokenClaimWrongClaimant) , NewTokensDestinationIdentityDoesNotExistError (* mut dpp :: consensus :: state :: token :: NewTokensDestinationIdentityDoesNotExistError) , NewAuthorizedActionTakerIdentityDoesNotExistError (* mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerIdentityDoesNotExistError) , NewAuthorizedActionTakerGroupDoesNotExistError (* mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerGroupDoesNotExistError) , NewAuthorizedActionTakerMainGroupNotSetError (* mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerMainGroupNotSetError) , InvalidGroupPositionError (* mut dpp :: consensus :: state :: token :: InvalidGroupPositionError) , TokenIsPausedError (* mut dpp :: consensus :: state :: token :: TokenIsPausedError) , IdentityTokenAccountAlreadyFrozenError (* mut dpp :: consensus :: state :: token :: IdentityTokenAccountAlreadyFrozenError) , TokenAlreadyPausedError (* mut dpp :: consensus :: state :: token :: TokenAlreadyPausedError) , TokenNotPausedError (* mut dpp :: consensus :: state :: token :: TokenNotPausedError) , TokenTransferRecipientIdentityNotExistError (* mut dpp :: consensus :: state :: token :: TokenTransferRecipientIdentityNotExistError) , PreProgrammedDistributionTimestampInPastError (* mut dpp :: consensus :: state :: token :: PreProgrammedDistributionTimestampInPastError) , IdentityHasNotAgreedToPayRequiredTokenAmountError (* mut dpp :: consensus :: state :: token :: IdentityHasNotAgreedToPayRequiredTokenAmountError) , RequiredTokenPaymentInfoNotSetError (* mut dpp :: consensus :: state :: token :: RequiredTokenPaymentInfoNotSetError) , IdentityTryingToPayWithWrongTokenError (* mut dpp :: consensus :: state :: token :: IdentityTryingToPayWithWrongTokenError) , TokenDirectPurchaseUserPriceTooLow (* mut dpp :: consensus :: state :: token :: TokenDirectPurchaseUserPriceTooLow) , TokenAmountUnderMinimumSaleAmount (* mut dpp :: consensus :: state :: token :: TokenAmountUnderMinimumSaleAmount) , TokenNotForDirectSale (* mut dpp :: consensus :: state :: token :: TokenNotForDirectSale) , IdentityInTokenConfigurationNotFoundError (* mut dpp :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError) , IdentityMemberOfGroupNotFoundError (* mut dpp :: consensus :: state :: group :: IdentityMemberOfGroupNotFoundError) , ModificationOfGroupActionMainParametersNotPermittedError (* mut dpp :: consensus :: state :: group :: ModificationOfGroupActionMainParametersNotPermittedError) , IdentityToFreezeDoesNotExistError (* mut dpp :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError) , DataContractNotFoundError (* mut dpp :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError) , InvalidTokenPositionStateError (* mut dpp :: consensus :: state :: token :: InvalidTokenPositionStateError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_state_error_StateError) -> dpp :: errors :: consensus :: state :: state_error :: StateError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenTransferRecipientIdentityNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PreProgrammedDistributionTimestampInPastError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: RequiredTokenPaymentInfoNotSetError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTryingToPayWithWrongTokenError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenDirectPurchaseUserPriceTooLow (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAmountUnderMinimumSaleAmount (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotForDirectSale (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInTokenConfigurationNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityMemberOfGroupNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: ModificationOfGroupActionMainParametersNotPermittedError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityToFreezeDoesNotExistError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenPositionStateError (std :: ptr :: read (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: state_error :: StateError) -> * const dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotForDirectSale (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityMemberOfGroupNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityToFreezeDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenPositionStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (ferment :: boxed (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_state_error_StateError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractAlreadyPresentError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataTriggerError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_trigger :: DataTriggerError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentAlreadyPresentError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestCurrentlyLockedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestNotJoinableError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestIdentityAlreadyContestantError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestNotPaidForError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestDocumentWithSameIdAlreadyPresentError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentNotForSaleError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentIncorrectPurchasePriceError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentOwnerIdMismatchError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampsMismatchError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampWindowViolationError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicateUniqueIndexError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidDocumentRevisionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityAlreadyExistsError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: IdentityAlreadyExistsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyIsReadOnlyError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MissingIdentityPublicKeyIdsError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MissingTransferKeyError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NoTransferKeyForCoreWithdrawalAvailableError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityPublicKeyIdError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityRevisionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityNonceError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MaxIdentityPublicKeyLimitReachedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicatedIdentityPublicKeyStateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicatedIdentityPublicKeyIdStateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyIsDisabledError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityInsufficientBalanceError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: IdentityInsufficientBalanceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampsAreEqualError_ctor (o_o_0 : * mut super :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractIsReadonlyError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractConfigUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTypeUpdateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_PrefundedSpecializedBalanceInsufficientError_ctor (o_o_0 : * mut dpp :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_PrefundedSpecializedBalanceNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractUpdatePermissionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeIncorrectVoterIdentityIdError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeIncorrectVotingAddressError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_VotePollNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_VotePollNotAvailableForVotingError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeVotedTooManyTimesError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeVoteAlreadyPresentError_ctor (o_o_0 : * mut dpp :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_RecipientIdentityDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: RecipientIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityDoesNotHaveEnoughTokenBalanceError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_UnauthorizedTokenActionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: UnauthorizedTokenActionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountFrozenError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityTokenAccountFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountNotFrozenError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityTokenAccountNotFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityNotMemberOfGroupError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: IdentityNotMemberOfGroupError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: GroupActionDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionAlreadyCompletedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: GroupActionAlreadyCompletedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionAlreadySignedByIdentityError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: GroupActionAlreadySignedByIdentityError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractUpdateActionNotAllowedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenSettingMaxSupplyToLessThanCurrentSupplyError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenMintPastMaxSupplyError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenMintPastMaxSupplyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimPropertyMismatch_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: InvalidTokenClaimPropertyMismatch) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimNoCurrentRewards_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: InvalidTokenClaimNoCurrentRewards) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimWrongClaimant_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: InvalidTokenClaimWrongClaimant) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewTokensDestinationIdentityDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: NewTokensDestinationIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerIdentityDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerGroupDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerGroupDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerMainGroupNotSetError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: NewAuthorizedActionTakerMainGroupNotSetError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidGroupPositionError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: InvalidGroupPositionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenIsPausedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenIsPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountAlreadyFrozenError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityTokenAccountAlreadyFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenAlreadyPausedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenAlreadyPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenNotPausedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenNotPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenTransferRecipientIdentityNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenTransferRecipientIdentityNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenTransferRecipientIdentityNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_PreProgrammedDistributionTimestampInPastError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: PreProgrammedDistributionTimestampInPastError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: PreProgrammedDistributionTimestampInPastError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityHasNotAgreedToPayRequiredTokenAmountError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityHasNotAgreedToPayRequiredTokenAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_RequiredTokenPaymentInfoNotSetError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: RequiredTokenPaymentInfoNotSetError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: RequiredTokenPaymentInfoNotSetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTryingToPayWithWrongTokenError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: IdentityTryingToPayWithWrongTokenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTryingToPayWithWrongTokenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenDirectPurchaseUserPriceTooLow_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenDirectPurchaseUserPriceTooLow) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenDirectPurchaseUserPriceTooLow (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenAmountUnderMinimumSaleAmount_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenAmountUnderMinimumSaleAmount) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenAmountUnderMinimumSaleAmount (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenNotForDirectSale_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: TokenNotForDirectSale) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenNotForDirectSale (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityInTokenConfigurationNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: identity_for_token_configuration_not_found_error :: IdentityInTokenConfigurationNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityInTokenConfigurationNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityMemberOfGroupNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: IdentityMemberOfGroupNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityMemberOfGroupNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_ModificationOfGroupActionMainParametersNotPermittedError_ctor (o_o_0 : * mut dpp :: consensus :: state :: group :: ModificationOfGroupActionMainParametersNotPermittedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: ModificationOfGroupActionMainParametersNotPermittedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityToFreezeDoesNotExistError_ctor (o_o_0 : * mut dpp :: consensus :: state :: identity :: identity_to_freeze_does_not_exist_error :: IdentityToFreezeDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityToFreezeDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractNotFoundError_ctor (o_o_0 : * mut dpp :: consensus :: state :: data_contract :: data_contract_not_found_error :: DataContractNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenPositionStateError_ctor (o_o_0 : * mut dpp :: consensus :: state :: token :: InvalidTokenPositionStateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenPositionStateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_destroy (ffi : * mut dpp_errors_consensus_state_state_error_StateError) { ferment :: unbox_any (ffi) ; } } pub mod token { use crate as example_nested ; pub mod identity_does_not_have_enough_token_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityDoesNotHaveEnoughTokenBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier , pub required_balance : u64 , pub actual_balance : u64 , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) , required_balance : ffi_ref . required_balance , actual_balance : ffi_ref . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError) -> * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { ferment :: boxed (dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) , required_balance : obj . required_balance , actual_balance : obj . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier , required_balance : u64 , actual_balance : u64 , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { ferment :: boxed (dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { token_id , identity_id , required_balance , actual_balance , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_token_id (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_identity_id (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_required_balance (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_actual_balance (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . actual_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_action (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_token_id (obj : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_required_balance (obj : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError , value : u64) { (* obj) . required_balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_actual_balance (obj : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError , value : u64) { (* obj) . actual_balance = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_action (obj : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod identity_has_not_agreed_to_pay_required_token_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityHasNotAgreedToPayRequiredTokenAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { pub token_id : * mut types :: identifier :: Identifier , pub required_amount : u64 , pub identity_min_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub identity_max_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError > for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError { token_id : std :: ptr :: read (ffi_ref . token_id) , required_amount : ffi_ref . required_amount , identity_min_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . identity_min_offer) , identity_max_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . identity_max_offer) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError > for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_has_not_agreed_to_pay_required_token_amount_error :: IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { ferment :: boxed (dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { token_id : ferment :: boxed (obj . token_id) , required_amount : obj . required_amount , identity_min_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . identity_min_offer) , identity_max_offer : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . identity_max_offer) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ferment :: unbox_any_opt (ffi_ref . identity_min_offer) ; ferment :: unbox_any_opt (ffi_ref . identity_max_offer) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_ctor (token_id : * mut types :: identifier :: Identifier , required_amount : u64 , identity_min_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , identity_max_offer : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { ferment :: boxed (dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError { token_id , required_amount , identity_min_offer , identity_max_offer , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_get_token_id (obj : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_get_required_amount (obj : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> u64 { (* obj) . required_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_get_identity_min_offer (obj : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . identity_min_offer } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_get_identity_max_offer (obj : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . identity_max_offer } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_get_action (obj : * const dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_set_token_id (obj : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_set_required_amount (obj : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError , value : u64) { (* obj) . required_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_set_identity_min_offer (obj : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . identity_min_offer = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_set_identity_max_offer (obj : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . identity_max_offer = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError_set_action (obj : * mut dpp_errors_consensus_state_token_identity_has_not_agreed_to_pay_required_token_amount_error_IdentityHasNotAgreedToPayRequiredTokenAmountError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod identity_token_account_already_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountAlreadyFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_token_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_identity_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_action (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_token_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_action (obj : * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod identity_token_account_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_token_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_identity_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_action (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_token_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_action (obj : * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod identity_token_account_not_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountNotFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_token_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_identity_id (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_action (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_token_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_action (obj : * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod identity_trying_to_pay_with_wrong_token_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTryingToPayWithWrongTokenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { pub expected_contract_id : * mut types :: identifier :: Identifier , pub expected_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub expected_token_id : * mut types :: identifier :: Identifier , pub actual_contract_id : * mut types :: identifier :: Identifier , pub actual_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub actual_token_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError > for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError { expected_contract_id : ferment :: from_opt_opaque (ffi_ref . expected_contract_id) , expected_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . expected_token_contract_position) , expected_token_id : std :: ptr :: read (ffi_ref . expected_token_id) , actual_contract_id : ferment :: from_opt_opaque (ffi_ref . actual_contract_id) , actual_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . actual_token_contract_position) , actual_token_id : std :: ptr :: read (ffi_ref . actual_token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError > for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_trying_to_pay_with_wrong_token_error :: IdentityTryingToPayWithWrongTokenError) -> * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { expected_contract_id : ferment :: to_opt_primitive (obj . expected_contract_id) , expected_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . expected_token_contract_position) , expected_token_id : ferment :: boxed (obj . expected_token_id) , actual_contract_id : ferment :: to_opt_primitive (obj . actual_contract_id) , actual_token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . actual_token_contract_position) , actual_token_id : ferment :: boxed (obj . actual_token_id) }) } } impl Drop for dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . expected_contract_id) ; ferment :: unbox_any (ffi_ref . expected_token_contract_position) ; ferment :: unbox_any (ffi_ref . expected_token_id) ; ferment :: unbox_any_opt (ffi_ref . actual_contract_id) ; ferment :: unbox_any (ffi_ref . actual_token_contract_position) ; ferment :: unbox_any (ffi_ref . actual_token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_ctor (expected_contract_id : * mut types :: identifier :: Identifier , expected_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , expected_token_id : * mut types :: identifier :: Identifier , actual_contract_id : * mut types :: identifier :: Identifier , actual_token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , actual_token_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError { expected_contract_id , expected_token_contract_position , expected_token_id , actual_contract_id , actual_token_contract_position , actual_token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_destroy (ffi : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_expected_contract_id (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut types :: identifier :: Identifier { (* obj) . expected_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_expected_token_contract_position (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . expected_token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_expected_token_id (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut types :: identifier :: Identifier { (* obj) . expected_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_actual_contract_id (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut types :: identifier :: Identifier { (* obj) . actual_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_actual_token_contract_position (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . actual_token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_get_actual_token_id (obj : * const dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError) -> * mut types :: identifier :: Identifier { (* obj) . actual_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_expected_contract_id (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut types :: identifier :: Identifier) { (* obj) . expected_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_expected_token_contract_position (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . expected_token_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_expected_token_id (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut types :: identifier :: Identifier) { (* obj) . expected_token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_actual_contract_id (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut types :: identifier :: Identifier) { (* obj) . actual_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_actual_token_contract_position (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . actual_token_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError_set_actual_token_id (obj : * mut dpp_errors_consensus_state_token_identity_trying_to_pay_with_wrong_token_error_IdentityTryingToPayWithWrongTokenError , value : * mut types :: identifier :: Identifier) { (* obj) . actual_token_id = value ; } } pub mod invalid_group_position_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidGroupPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { pub max_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub invalid_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from_opt (ffi_ref . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . invalid_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError) -> * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to_opt (obj . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . invalid_group_position) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_group_position) ; ferment :: unbox_any (ffi_ref . invalid_group_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_ctor (max_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , invalid_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { max_group_position , invalid_group_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_destroy (ffi : * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_get_max_group_position (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . max_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_get_invalid_group_position (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . invalid_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_set_max_group_position (obj : * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . max_group_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_set_invalid_group_position (obj : * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . invalid_group_position = value ; } } pub mod invalid_token_claim_no_current_rewards { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimNoCurrentRewards`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment , pub last_claimed_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from (ffi_ref . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from_opt (ffi_ref . last_claimed_moment) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards) -> * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to (obj . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to_opt (obj . last_claimed_moment) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any (ffi_ref . current_moment) ; ferment :: unbox_any_opt (ffi_ref . last_claimed_moment) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_ctor (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment , last_claimed_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { token_id , recipient_id , current_moment , last_claimed_moment }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_destroy (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_token_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_recipient_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_current_moment (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . current_moment } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_last_claimed_moment (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . last_claimed_moment } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_token_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_recipient_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . recipient_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_current_moment (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards , value : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) { (* obj) . current_moment = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_last_claimed_moment (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards , value : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) { (* obj) . last_claimed_moment = value ; } } pub mod invalid_token_claim_property_mismatch { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimPropertyMismatch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { pub property : * mut std :: os :: raw :: c_char , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch) -> * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . property) ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_ctor (property : * mut std :: os :: raw :: c_char , token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { property , token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_destroy (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_get_property (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut std :: os :: raw :: c_char { (* obj) . property } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_get_token_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_set_property (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch , value : * mut std :: os :: raw :: c_char) { (* obj) . property = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_set_token_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . token_id = value ; } } pub mod invalid_token_claim_wrong_claimant { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimWrongClaimant`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . claimant_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant) -> * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . claimant_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . expected_claimant_id) ; ferment :: unbox_any (ffi_ref . claimant_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_ctor (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , expected_claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { token_id , expected_claimant_id , claimant_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_destroy (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_token_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_expected_claimant_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_claimant_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_claimant_id (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . claimant_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_token_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_expected_claimant_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . expected_claimant_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_claimant_id (obj : * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant , value : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) { (* obj) . claimant_id = value ; } } pub mod invalid_token_position_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenPositionStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { pub max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError > for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) -> dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from_opt (ffi_ref . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . invalid_token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError > for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_position_error :: InvalidTokenPositionStateError) -> * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to_opt (obj . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . invalid_token_position) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_token_position) ; ferment :: unbox_any (ffi_ref . invalid_token_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_ctor (max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError { max_token_position , invalid_token_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_destroy (ffi : * mut dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_get_max_token_position (obj : * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . max_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_get_invalid_token_position (obj : * const dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . invalid_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_set_max_token_position (obj : * mut dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . max_token_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError_set_invalid_token_position (obj : * mut dpp_errors_consensus_state_token_invalid_token_position_error_InvalidTokenPositionStateError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . invalid_token_position = value ; } } pub mod new_authorized_action_taker_group_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerGroupDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_ctor (group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_get_group_contract_position (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_set_group_contract_position (obj : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } } pub mod new_authorized_action_taker_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_ctor (identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_get_identity_id (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod new_authorized_action_taker_main_group_not_set_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerMainGroupNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError_ctor () -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError_destroy (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) { ferment :: unbox_any (ffi) ; } } pub mod new_tokens_destination_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewTokensDestinationIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { pub identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { identity_id : std :: ptr :: read (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { identity_id : ferment :: boxed (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_ctor (identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_get_identity_id (obj : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } } pub mod pre_programmed_distribution_timestamp_in_past_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PreProgrammedDistributionTimestampInPastError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { pub data_contract_id : * mut types :: identifier :: Identifier , pub token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub pre_programmed_timestamp : * mut dpp :: identity :: TimestampMillis , pub current_timestamp : * mut dpp :: identity :: TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError > for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError { data_contract_id : std :: ptr :: read (ffi_ref . data_contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_position) , pre_programmed_timestamp : std :: ptr :: read (ffi_ref . pre_programmed_timestamp) , current_timestamp : std :: ptr :: read (ffi_ref . current_timestamp) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError > for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: pre_programmed_distribution_timestamp_in_past_error :: PreProgrammedDistributionTimestampInPastError) -> * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { ferment :: boxed (dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { data_contract_id : ferment :: boxed (obj . data_contract_id) , token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_position) , pre_programmed_timestamp : ferment :: boxed (obj . pre_programmed_timestamp) , current_timestamp : ferment :: boxed (obj . current_timestamp) }) } } impl Drop for dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . token_position) ; ferment :: unbox_any (ffi_ref . pre_programmed_timestamp) ; ferment :: unbox_any (ffi_ref . current_timestamp) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_ctor (data_contract_id : * mut types :: identifier :: Identifier , token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pre_programmed_timestamp : * mut dpp :: identity :: TimestampMillis , current_timestamp : * mut dpp :: identity :: TimestampMillis) -> * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { ferment :: boxed (dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError { data_contract_id , token_position , pre_programmed_timestamp , current_timestamp }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_destroy (ffi : * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_get_data_contract_id (obj : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> * mut types :: identifier :: Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_get_token_position (obj : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_get_pre_programmed_timestamp (obj : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> * mut dpp :: identity :: TimestampMillis { (* obj) . pre_programmed_timestamp } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_get_current_timestamp (obj : * const dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError) -> * mut dpp :: identity :: TimestampMillis { (* obj) . current_timestamp } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_set_data_contract_id (obj : * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError , value : * mut types :: identifier :: Identifier) { (* obj) . data_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_set_token_position (obj : * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . token_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_set_pre_programmed_timestamp (obj : * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . pre_programmed_timestamp = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError_set_current_timestamp (obj : * mut dpp_errors_consensus_state_token_pre_programmed_distribution_timestamp_in_past_error_PreProgrammedDistributionTimestampInPastError , value : * mut dpp :: identity :: TimestampMillis) { (* obj) . current_timestamp = value ; } } pub mod required_token_payment_info_not_set_error { use crate as example_nested ; # [doc = "FFI-representation of the [`RequiredTokenPaymentInfoNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { pub token_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError > for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) -> dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError { token_id : std :: ptr :: read (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError > for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: required_token_payment_info_not_set_error :: RequiredTokenPaymentInfoNotSetError) -> * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { token_id : ferment :: boxed (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_ctor (token_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError { token_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_destroy (ffi : * mut dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_get_token_id (obj : * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_get_action (obj : * const dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_set_token_id (obj : * mut dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError_set_action (obj : * mut dpp_errors_consensus_state_token_required_token_payment_info_not_set_error_RequiredTokenPaymentInfoNotSetError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod token_already_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenAlreadyPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { pub token_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { token_id : std :: ptr :: read (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError) -> * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { token_id : ferment :: boxed (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_ctor (token_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { token_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_get_token_id (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_get_action (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_set_action (obj : * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod token_amount_under_minimum_sale_amount { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenAmountUnderMinimumSaleAmount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { pub token_id : * mut types :: identifier :: Identifier , pub desired_amount : u64 , pub minimum_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount > for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) -> dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount { token_id : std :: ptr :: read (ffi_ref . token_id) , desired_amount : ffi_ref . desired_amount , minimum_amount : ffi_ref . minimum_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount > for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_amount_under_minimum_sale_amount :: TokenAmountUnderMinimumSaleAmount) -> * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { ferment :: boxed (dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { token_id : ferment :: boxed (obj . token_id) , desired_amount : obj . desired_amount , minimum_amount : obj . minimum_amount }) } } impl Drop for dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_ctor (token_id : * mut types :: identifier :: Identifier , desired_amount : u64 , minimum_amount : u64) -> * mut dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { ferment :: boxed (dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount { token_id , desired_amount , minimum_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_destroy (ffi : * mut dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_get_token_id (obj : * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_get_desired_amount (obj : * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) -> u64 { (* obj) . desired_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_get_minimum_amount (obj : * const dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount) -> u64 { (* obj) . minimum_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_set_desired_amount (obj : * mut dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount , value : u64) { (* obj) . desired_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount_set_minimum_amount (obj : * mut dpp_errors_consensus_state_token_token_amount_under_minimum_sale_amount_TokenAmountUnderMinimumSaleAmount , value : u64) { (* obj) . minimum_amount = value ; } } pub mod token_direct_purchase_user_price_too_low { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenDirectPurchaseUserPriceTooLow`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { pub token_id : * mut types :: identifier :: Identifier , pub user_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub required_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow > for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) -> dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow { token_id : std :: ptr :: read (ffi_ref . token_id) , user_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . user_price) , required_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . required_price) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow > for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_direct_purchase_user_price_too_low :: TokenDirectPurchaseUserPriceTooLow) -> * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { ferment :: boxed (dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { token_id : ferment :: boxed (obj . token_id) , user_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . user_price) , required_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . required_price) }) } } impl Drop for dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . user_price) ; ferment :: unbox_any (ffi_ref . required_price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_ctor (token_id : * mut types :: identifier :: Identifier , user_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , required_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { ferment :: boxed (dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow { token_id , user_price , required_price }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_destroy (ffi : * mut dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_get_token_id (obj : * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_get_user_price (obj : * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . user_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_get_required_price (obj : * const dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . required_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_set_user_price (obj : * mut dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . user_price = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow_set_required_price (obj : * mut dpp_errors_consensus_state_token_token_direct_purchase_user_price_too_low_TokenDirectPurchaseUserPriceTooLow , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { (* obj) . required_price = value ; } } pub mod token_is_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenIsPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { pub token_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { token_id : std :: ptr :: read (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError) -> * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { token_id : ferment :: boxed (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_ctor (token_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_get_token_id (obj : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } } pub mod token_mint_past_max_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenMintPastMaxSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { pub token_id : * mut types :: identifier :: Identifier , pub amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub current_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub max_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { token_id : std :: ptr :: read (ffi_ref . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . max_supply) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError) -> * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { token_id : ferment :: boxed (obj . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . max_supply) }) } } impl Drop for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . amount) ; ferment :: unbox_any (ffi_ref . current_supply) ; ferment :: unbox_any (ffi_ref . max_supply) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_ctor (token_id : * mut types :: identifier :: Identifier , amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , current_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { token_id , amount , current_supply , max_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_token_id (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_amount (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_current_supply (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . current_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_max_supply (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . max_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_amount (obj : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_current_supply (obj : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . current_supply = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_max_supply (obj : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . max_supply = value ; } } pub mod token_not_for_direct_sale { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenNotForDirectSale`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { pub token_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale > for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale) -> dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale { token_id : std :: ptr :: read (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale > for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_not_for_direct_sale :: TokenNotForDirectSale) -> * const dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { ferment :: boxed (dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { token_id : ferment :: boxed (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale_ctor (token_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { ferment :: boxed (dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale_destroy (ffi : * mut dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale_get_token_id (obj : * const dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_not_for_direct_sale_TokenNotForDirectSale , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } } pub mod token_not_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenNotPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { pub token_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { token_id : std :: ptr :: read (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError) -> * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { token_id : ferment :: boxed (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_ctor (token_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { token_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_get_token_id (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_get_action (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_set_action (obj : * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } } pub mod token_setting_max_supply_to_less_than_current_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenSettingMaxSupplyToLessThanCurrentSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { pub token_id : * mut types :: identifier :: Identifier , pub max_supply : u64 , pub current_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : std :: ptr :: read (ffi_ref . token_id) , max_supply : ffi_ref . max_supply , current_supply : ffi_ref . current_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : ferment :: boxed (obj . token_id) , max_supply : obj . max_supply , current_supply : obj . current_supply }) } } impl Drop for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_ctor (token_id : * mut types :: identifier :: Identifier , max_supply : u64 , current_supply : u64) -> * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id , max_supply , current_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_token_id (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_max_supply (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . max_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_current_supply (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . current_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_token_id (obj : * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_max_supply (obj : * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError , value : u64) { (* obj) . max_supply = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_current_supply (obj : * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError , value : u64) { (* obj) . current_supply = value ; } } pub mod token_transfer_recipient_identity_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenTransferRecipientIdentityNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { pub recipient_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError > for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError) -> dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError { recipient_id : std :: ptr :: read (ffi_ref . recipient_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError > for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_transfer_recipient_identity_not_exist_error :: TokenTransferRecipientIdentityNotExistError) -> * const dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { recipient_id : ferment :: boxed (obj . recipient_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . recipient_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError_ctor (recipient_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError { recipient_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError_destroy (ffi : * mut dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError_get_recipient_id (obj : * const dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError) -> * mut types :: identifier :: Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError_set_recipient_id (obj : * mut dpp_errors_consensus_state_token_token_transfer_recipient_identity_not_exist_error_TokenTransferRecipientIdentityNotExistError , value : * mut types :: identifier :: Identifier) { (* obj) . recipient_id = value ; } } pub mod unauthorized_token_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnauthorizedTokenActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { pub token_id : * mut types :: identifier :: Identifier , pub identity_id : * mut types :: identifier :: Identifier , pub action : * mut std :: os :: raw :: c_char , pub authorized_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { token_id : std :: ptr :: read (ffi_ref . token_id) , identity_id : std :: ptr :: read (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_action_takers) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError) -> * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { ferment :: boxed (dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { token_id : ferment :: boxed (obj . token_id) , identity_id : ferment :: boxed (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_action_takers) }) } } impl Drop for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; ferment :: unbox_any (ffi_ref . authorized_action_takers) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_ctor (token_id : * mut types :: identifier :: Identifier , identity_id : * mut types :: identifier :: Identifier , action : * mut std :: os :: raw :: c_char , authorized_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) -> * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { ferment :: boxed (dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { token_id , identity_id , action , authorized_action_takers }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_destroy (ffi : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_token_id (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut types :: identifier :: Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_identity_id (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut types :: identifier :: Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_action (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_authorized_action_takers (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_action_takers } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_token_id (obj : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError , value : * mut types :: identifier :: Identifier) { (* obj) . token_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_identity_id (obj : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError , value : * mut types :: identifier :: Identifier) { (* obj) . identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_action (obj : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError , value : * mut std :: os :: raw :: c_char) { (* obj) . action = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_authorized_action_takers (obj : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError , value : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) { (* obj) . authorized_action_takers = value ; } } } pub mod voting { use crate as example_nested ; pub mod masternode_incorrect_voter_identity_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeIncorrectVoterIdentityIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pub pro_tx_hash : * mut types :: identifier :: Identifier , pub expected_voter_identity_id : * mut types :: identifier :: Identifier , pub provided_voter_identity_id : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , expected_voter_identity_id : std :: ptr :: read (ffi_ref . expected_voter_identity_id) , provided_voter_identity_id : std :: ptr :: read (ffi_ref . provided_voter_identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , expected_voter_identity_id : ferment :: boxed (obj . expected_voter_identity_id) , provided_voter_identity_id : ferment :: boxed (obj . provided_voter_identity_id) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . expected_voter_identity_id) ; ferment :: unbox_any (ffi_ref . provided_voter_identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_ctor (pro_tx_hash : * mut types :: identifier :: Identifier , expected_voter_identity_id : * mut types :: identifier :: Identifier , provided_voter_identity_id : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pro_tx_hash , expected_voter_identity_id , provided_voter_identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_destroy (ffi : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_pro_tx_hash (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut types :: identifier :: Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_expected_voter_identity_id (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut types :: identifier :: Identifier { (* obj) . expected_voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_provided_voter_identity_id (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut types :: identifier :: Identifier { (* obj) . provided_voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_pro_tx_hash (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError , value : * mut types :: identifier :: Identifier) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_expected_voter_identity_id (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError , value : * mut types :: identifier :: Identifier) { (* obj) . expected_voter_identity_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_provided_voter_identity_id (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError , value : * mut types :: identifier :: Identifier) { (* obj) . provided_voter_identity_id = value ; } } pub mod masternode_incorrect_voting_address_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeIncorrectVotingAddressError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pub pro_tx_hash : * mut types :: identifier :: Identifier , pub current_voting_address : * mut types :: bytes_20 :: Bytes20 , pub given_voting_address : * mut types :: bytes_20 :: Bytes20 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , current_voting_address : std :: ptr :: read (ffi_ref . current_voting_address) , given_voting_address : std :: ptr :: read (ffi_ref . given_voting_address) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , current_voting_address : ferment :: boxed (obj . current_voting_address) , given_voting_address : ferment :: boxed (obj . given_voting_address) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . current_voting_address) ; ferment :: unbox_any (ffi_ref . given_voting_address) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_ctor (pro_tx_hash : * mut types :: identifier :: Identifier , current_voting_address : * mut types :: bytes_20 :: Bytes20 , given_voting_address : * mut types :: bytes_20 :: Bytes20) -> * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pro_tx_hash , current_voting_address , given_voting_address }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_destroy (ffi : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_pro_tx_hash (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut types :: identifier :: Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_current_voting_address (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut types :: bytes_20 :: Bytes20 { (* obj) . current_voting_address } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_given_voting_address (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut types :: bytes_20 :: Bytes20 { (* obj) . given_voting_address } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_pro_tx_hash (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError , value : * mut types :: identifier :: Identifier) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_current_voting_address (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError , value : * mut types :: bytes_20 :: Bytes20) { (* obj) . current_voting_address = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_given_voting_address (obj : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError , value : * mut types :: bytes_20 :: Bytes20) { (* obj) . given_voting_address = value ; } } pub mod masternode_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pub pro_tx_hash : * mut types :: identifier :: Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError) -> * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_ctor (pro_tx_hash : * mut types :: identifier :: Identifier) -> * mut dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pro_tx_hash }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_get_pro_tx_hash (obj : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> * mut types :: identifier :: Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_set_pro_tx_hash (obj : * mut dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError , value : * mut types :: identifier :: Identifier) { (* obj) . pro_tx_hash = value ; } } pub mod masternode_vote_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVoteAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pub pro_tx_hash : * mut types :: identifier :: Identifier , pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError) -> * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_ctor (pro_tx_hash : * mut types :: identifier :: Identifier , vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) -> * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pro_tx_hash , vote_poll }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_destroy (ffi : * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_get_pro_tx_hash (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut types :: identifier :: Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_get_vote_poll (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_set_pro_tx_hash (obj : * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError , value : * mut types :: identifier :: Identifier) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_set_vote_poll (obj : * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) { (* obj) . vote_poll = value ; } } pub mod masternode_voted_too_many_times { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVotedTooManyTimesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pub pro_tx_hash : * mut types :: identifier :: Identifier , pub times_already_voted : u16 , pub max_times_allowed : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { pro_tx_hash : std :: ptr :: read (ffi_ref . pro_tx_hash) , times_already_voted : ffi_ref . times_already_voted , max_times_allowed : ffi_ref . max_times_allowed } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError) -> * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pro_tx_hash : ferment :: boxed (obj . pro_tx_hash) , times_already_voted : obj . times_already_voted , max_times_allowed : obj . max_times_allowed }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_ctor (pro_tx_hash : * mut types :: identifier :: Identifier , times_already_voted : u16 , max_times_allowed : u16) -> * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pro_tx_hash , times_already_voted , max_times_allowed }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_destroy (ffi : * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_pro_tx_hash (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> * mut types :: identifier :: Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_times_already_voted (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . times_already_voted } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_max_times_allowed (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . max_times_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_pro_tx_hash (obj : * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError , value : * mut types :: identifier :: Identifier) { (* obj) . pro_tx_hash = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_times_already_voted (obj : * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError , value : u16) { (* obj) . times_already_voted = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_max_times_allowed (obj : * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError , value : u16) { (* obj) . max_times_allowed = value ; } } pub mod vote_poll_not_available_for_voting_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VotePollNotAvailableForVotingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . status) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . status) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . status) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) -> * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { vote_poll , status }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_destroy (ffi : * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_get_vote_poll (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_get_status (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . status } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_set_vote_poll (obj : * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) { (* obj) . vote_poll = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_set_status (obj : * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) { (* obj) . status = value ; } } pub mod vote_poll_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VotePollNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) -> * mut dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { vote_poll }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_destroy (ffi : * mut dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_get_vote_poll (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_set_vote_poll (obj : * mut dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) { (* obj) . vote_poll = value ; } } } } # [cfg (test)] pub mod test_consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TestConsensusError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_test_consensus_error_TestConsensusError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError) -> * const dpp_errors_consensus_test_consensus_error_TestConsensusError { ferment :: boxed (dpp_errors_consensus_test_consensus_error_TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_test_consensus_error_TestConsensusError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_test_consensus_error_TestConsensusError { ferment :: boxed (dpp_errors_consensus_test_consensus_error_TestConsensusError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_destroy (ffi : * mut dpp_errors_consensus_test_consensus_error_TestConsensusError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_get_message (obj : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_set_message (obj : * mut dpp_errors_consensus_test_consensus_error_TestConsensusError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } } pub mod dpp_init_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DashPlatformProtocolInitError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_init_error_DashPlatformProtocolInitError { SchemaDeserializationError (* mut example_nested :: serde_json_Error) , InvalidSchemaError (* mut std :: os :: raw :: c_char) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError) -> dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (< example_nested :: serde_json_Error as ferment :: FFIConversionFrom < serde_json :: Error >> :: ffi_from (* o_0)) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError) -> * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (match obj { dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (< example_nested :: serde_json_Error as ferment :: FFIConversionTo < serde_json :: Error >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_SchemaDeserializationError_ctor (o_o_0 : * mut example_nested :: serde_json_Error) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_InvalidSchemaError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_destroy (ffi : * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_vector_size_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidVectorSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { pub expected_size : usize , pub actual_size : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { let ffi_ref = & * ffi ; dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { expected_size : ffi_ref . expected_size , actual_size : ffi_ref . actual_size } } } impl ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError) -> * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { ferment :: boxed (dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { expected_size : obj . expected_size , actual_size : obj . actual_size }) } } impl Drop for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_ctor (expected_size : usize , actual_size : usize) -> * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { ferment :: boxed (dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { expected_size , actual_size }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_destroy (ffi : * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_get_expected_size (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . expected_size } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_get_actual_size (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . actual_size } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_set_expected_size (obj : * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError , value : usize) { (* obj) . expected_size = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_set_actual_size (obj : * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError , value : usize) { (* obj) . actual_size = value ; } } pub mod non_consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`NonConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_non_consensus_error_NonConsensusError { ValueError (* mut error :: Error) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , SerdeParsingError (* mut dpp :: SerdeParsingError) , CompatibleProtocolVersionIsNotDefinedError (* mut dpp :: CompatibleProtocolVersionIsNotDefinedError) , SerdeJsonError (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut dpp :: InvalidVectorSizeError) , StateRepositoryFetchError (* mut std :: os :: raw :: c_char) , WithdrawalError (* mut std :: os :: raw :: c_char) , IdentifierCreateError (* mut std :: os :: raw :: c_char) , StateTransitionCreationError (* mut std :: os :: raw :: c_char) , IdentityPublicKeyCreateError (* mut std :: os :: raw :: c_char) , RequiredPropertyError { property_name : * mut std :: os :: raw :: c_char } , InvalidDataProcessedError (* mut std :: os :: raw :: c_char) , ObjectCreationError { object_name : * mut std :: os :: raw :: c_char , details : * mut std :: os :: raw :: c_char } , DPPError (* mut dpp :: DPPError) , Error (* mut example_nested :: anyhow_Error) , Overflow (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_non_consensus_error_NonConsensusError) -> dpp :: errors :: non_consensus_error :: NonConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (std :: ptr :: read (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (std :: ptr :: read (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (std :: ptr :: read (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (std :: ptr :: read (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* property_name) } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* object_name))) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* details) } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (std :: ptr :: read (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionFrom < anyhow :: Error >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) } } } impl ferment :: FFIConversionTo < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: non_consensus_error :: NonConsensusError) -> * const dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (match obj { dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: ValueError (ferment :: boxed (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (ferment :: boxed (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (ferment :: boxed (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (ferment :: boxed (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name } => dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (property_name) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name , details } => dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (object_name) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (details) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: DPPError (ferment :: boxed (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionTo < anyhow :: Error >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_non_consensus_error_NonConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => { ferment :: unbox_string (* property_name) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => { ferment :: unbox_string (* object_name) ; ; ferment :: unbox_string (* details) ; } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_ValueError_ctor (o_o_0 : * mut error :: Error) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_SerdeParsingError_ctor (o_o_0 : * mut dpp :: SerdeParsingError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_CompatibleProtocolVersionIsNotDefinedError_ctor (o_o_0 : * mut dpp :: CompatibleProtocolVersionIsNotDefinedError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_SerdeJsonError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_InvalidVectorSizeError_ctor (o_o_0 : * mut dpp :: InvalidVectorSizeError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_StateRepositoryFetchError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_WithdrawalError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_IdentifierCreateError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_StateTransitionCreationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_IdentityPublicKeyCreateError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_RequiredPropertyError_ctor (property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_InvalidDataProcessedError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_ObjectCreationError_ctor (object_name : * mut std :: os :: raw :: c_char , details : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_DPPError_ctor (o_o_0 : * mut dpp :: DPPError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_Error_ctor (o_o_0 : * mut example_nested :: anyhow_Error) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: Error (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_Overflow_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_destroy (ffi : * mut dpp_errors_non_consensus_error_NonConsensusError) { ferment :: unbox_any (ffi) ; } } pub mod public_key_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_public_key_validation_error_PublicKeyValidationError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { let ffi_ref = & * ffi ; dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: public_key_validation_error :: PublicKeyValidationError) -> * const dpp_errors_public_key_validation_error_PublicKeyValidationError { ferment :: boxed (dpp_errors_public_key_validation_error_PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_public_key_validation_error_PublicKeyValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_public_key_validation_error_PublicKeyValidationError { ferment :: boxed (dpp_errors_public_key_validation_error_PublicKeyValidationError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_destroy (ffi : * mut dpp_errors_public_key_validation_error_PublicKeyValidationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_get_message (obj : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_set_message (obj : * mut dpp_errors_public_key_validation_error_PublicKeyValidationError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod serde_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SerdeParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_serde_parsing_error_SerdeParsingError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> dpp :: errors :: serde_parsing_error :: SerdeParsingError { let ffi_ref = & * ffi ; dpp :: errors :: serde_parsing_error :: SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: serde_parsing_error :: SerdeParsingError) -> * const dpp_errors_serde_parsing_error_SerdeParsingError { ferment :: boxed (dpp_errors_serde_parsing_error_SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_serde_parsing_error_SerdeParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_ctor (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_serde_parsing_error_SerdeParsingError { ferment :: boxed (dpp_errors_serde_parsing_error_SerdeParsingError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_destroy (ffi : * mut dpp_errors_serde_parsing_error_SerdeParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_get_message (obj : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_set_message (obj : * mut dpp_errors_serde_parsing_error_SerdeParsingError , value : * mut std :: os :: raw :: c_char) { (* obj) . message = value ; } } pub mod protocol_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProtocolError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_protocol_error_ProtocolError { IdentifierError (* mut std :: os :: raw :: c_char) , StringDecodeError (* mut std :: os :: raw :: c_char) , EmptyPublicKeyDataError , MaxEncodedBytesReachedError { max_size_kbytes : usize , size_hit : usize } , EncodingError (* mut std :: os :: raw :: c_char) , DecodingError (* mut std :: os :: raw :: c_char) , FileNotFound (* mut std :: os :: raw :: c_char) , UnsupportedVersionMismatch { method : * mut std :: os :: raw :: c_char , allowed_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion } , CurrentProtocolVersionNotInitialized , UnknownVersionError (* mut std :: os :: raw :: c_char) , UnknownProtocolVersionError (* mut std :: os :: raw :: c_char) , NoProtocolVersionError , ParsingError (* mut std :: os :: raw :: c_char) , ParsingJsonError (* mut example_nested :: serde_json_Error) , Error (* mut example_nested :: anyhow_Error) , InvalidKeyContractBoundsError (* mut std :: os :: raw :: c_char) , UnknownStorageKeyRequirements (* mut std :: os :: raw :: c_char) , UnknownContestedIndexResolution (* mut std :: os :: raw :: c_char) , DataContractError (* mut dpp :: errors :: protocol_error :: DataContractError) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] StateTransitionError (* mut dpp :: state_transition :: errors :: StateTransitionError) , InvalidStateTransitionType (* mut std :: os :: raw :: c_char) , PlatformVersionError (* mut crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError) , ConsensusError (* mut crate :: fermented :: types :: dpp :: consensus :: dpp_consensus_ConsensusError) , Document (* mut crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_DocumentError) , Token (* mut crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError) , Generic (* mut std :: os :: raw :: c_char) , NotSupported (* mut std :: os :: raw :: c_char) , # [cfg (feature = "message-signing")] InvalidSigningKeyTypeError (* mut std :: os :: raw :: c_char) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] InvalidIdentityPublicKeyTypeError (* mut state_transition) , # [cfg (feature = "state-transition-validation")] StateTransitionIsNotSignedError (* mut state_transition) , # [cfg (feature = "state-transition-validation")] PublicKeySecurityLevelNotMetError (* mut dpp :: state_transition :: errors :: PublicKeySecurityLevelNotMetError) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] WrongPublicKeyPurposeError (* mut state_transition) , # [cfg (feature = "state-transition-validation")] PublicKeyMismatchError (* mut state_transition) , # [cfg (feature = "state-transition-validation")] InvalidSignaturePublicKeyError (* mut state_transition) , NonConsensusError (* mut dpp :: NonConsensusError) , CompatibleProtocolVersionIsNotDefinedError (* mut dpp :: CompatibleProtocolVersionIsNotDefinedError) , InvalidDocumentTypeError (* mut dpp :: errors :: protocol_error :: InvalidDocumentTypeError) , DataContractNotPresentError (* mut dpp :: errors :: protocol_error :: DataContractNotPresentError) , InvalidSignaturePublicKeySecurityLevelError (* mut dpp :: consensus :: signature :: InvalidSignaturePublicKeySecurityLevelError) , InvalidStateTransitionTypeError (* mut dpp :: consensus :: basic :: state_transition :: InvalidStateTransitionTypeError) , PublicKeyIsDisabledError (* mut dpp :: consensus :: signature :: PublicKeyIsDisabledError) , IdentityNotPresentError (* mut dpp :: errors :: protocol_error :: IdentityNotPresentError) , Overflow (* mut std :: os :: raw :: c_char) , DivideByZero (* mut std :: os :: raw :: c_char) , DesiredKeyWithTypePurposeSecurityLevelMissing (* mut std :: os :: raw :: c_char) , ValueError (* mut error :: Error) , PlatformSerializationError (* mut std :: os :: raw :: c_char) , PlatformDeserializationError (* mut std :: os :: raw :: c_char) , DashCoreError (* mut dashcore :: error :: Error) , InvalidIdentityError { errors : * mut crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError , raw_identity : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , VoteError (* mut std :: os :: raw :: c_char) , PublicKeyGenerationError (* mut std :: os :: raw :: c_char) , GroupMemberNotFound (* mut std :: os :: raw :: c_char) , GroupNotFound (* mut std :: os :: raw :: c_char) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , CriticalCorruptedCreditsCodeExecution (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut dpp :: InvalidVectorSizeError) , InvalidCBOR (* mut std :: os :: raw :: c_char) , # [cfg (feature = "bls-signatures")] BlsError (* mut dashcore :: blsful :: BlsError) , PrivateKeySizeError { got : u32 } , InvalidBLSPrivateKeyError (* mut std :: os :: raw :: c_char) , BlsSignatureSizeError { got : u32 } , AddingDifferentTypes (* mut std :: os :: raw :: c_char) , InvalidDistributionStep (* mut std :: os :: raw :: c_char) , MissingEpochInfo (* mut std :: os :: raw :: c_char) , InvalidBatchedTransitionActionVariant { expected : * mut std :: os :: raw :: c_char , found : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const dpp_errors_protocol_error_ProtocolError) -> dpp :: errors :: protocol_error :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : * max_size_kbytes , size_hit : * size_hit } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , allowed_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* allowed_versions) , received : std :: ptr :: read (* received) } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionFrom < Vec < dpp :: version :: FeatureVersion > >> :: ffi_from (* known_versions) , received : std :: ptr :: read (* received) } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (< example_nested :: serde_json_Error as ferment :: FFIConversionFrom < serde_json :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionFrom < anyhow :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (std :: ptr :: read (* o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (Box :: from_raw (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Document (Box :: from_raw (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Token (Box :: new (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (std :: ptr :: read (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (std :: ptr :: read (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (std :: ptr :: read (* o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError (std :: ptr :: read (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (std :: ptr :: read (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ValueError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: consensus :: ConsensusError > >> :: ffi_from (* errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_identity) } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: BlsError (std :: ptr :: read (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => dpp :: errors :: protocol_error :: ProtocolError :: InvalidBatchedTransitionActionVariant { expected : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* expected))) , found : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* found))) } } } } impl ferment :: FFIConversionTo < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : dpp :: errors :: protocol_error :: ProtocolError) -> * const dpp_errors_protocol_error_ProtocolError { ferment :: boxed (match obj { dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (o_0) => dpp_errors_protocol_error_ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError => dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError , dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : max_size_kbytes , size_hit : size_hit } , dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , allowed_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (allowed_versions) , received : ferment :: boxed (received) } , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion as ferment :: FFIConversionTo < Vec < dpp :: version :: FeatureVersion > >> :: ffi_to (known_versions) , received : ferment :: boxed (received) } , dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized => dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError => dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError , dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (< example_nested :: serde_json_Error as ferment :: FFIConversionTo < serde_json :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Error (o_0) => dpp_errors_protocol_error_ProtocolError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionTo < anyhow :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractError (ferment :: boxed (o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: ConsensusError (* o_0) , dpp :: errors :: protocol_error :: ProtocolError :: Document (o_0) => dpp_errors_protocol_error_ProtocolError :: Document (* o_0) , dpp :: errors :: protocol_error :: ProtocolError :: Token (o_0) => dpp_errors_protocol_error_ProtocolError :: Token (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Generic (o_0) => dpp_errors_protocol_error_ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (o_0) => dpp_errors_protocol_error_ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "message-signing")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (ferment :: boxed (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (ferment :: boxed (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (ferment :: boxed (o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (ferment :: boxed (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (ferment :: boxed (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: NonConsensusError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Overflow (o_0) => dpp_errors_protocol_error_ProtocolError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (o_0) => dpp_errors_protocol_error_ProtocolError :: DivideByZero (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ValueError (o_0) => dpp_errors_protocol_error_ProtocolError :: ValueError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (o_0) => dpp_errors_protocol_error_ProtocolError :: DashCoreError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: consensus :: ConsensusError > >> :: ffi_to (errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_identity) } , dpp :: errors :: protocol_error :: ProtocolError :: VoteError (o_0) => dpp_errors_protocol_error_ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "bls-signatures")] dpp :: errors :: protocol_error :: ProtocolError :: BlsError (o_0) => dpp_errors_protocol_error_ProtocolError :: BlsError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got } => dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got } => dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (o_0) => dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (o_0) => dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (expected) , found : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (found) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { match self { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => { } , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => { ; ; ; } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* allowed_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => { } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => { } , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_identity) ; } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found } => { ferment :: unbox_string (* expected) ; ; ferment :: unbox_string (* found) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_IdentifierError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StringDecodeError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_EmptyPublicKeyDataError_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_MaxEncodedBytesReachedError_ctor (max_size_kbytes : usize , size_hit : usize) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_EncodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: EncodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_FileNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnsupportedVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , allowed_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_dpp_version_FeatureVersion , received : * mut dpp :: version :: FeatureVersion) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CurrentProtocolVersionNotInitialized_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownProtocolVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NoProtocolVersionError_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ParsingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ParsingJsonError_ctor (o_o_0 : * mut example_nested :: serde_json_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Error_ctor (o_o_0 : * mut example_nested :: anyhow_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Error (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidKeyContractBoundsError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownStorageKeyRequirements_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownContestedIndexResolution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DataContractError_ctor (o_o_0 : * mut dpp :: errors :: protocol_error :: DataContractError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DataContractError (o_o_0)) } # [cfg (all (feature = "state-transitions" , feature = "validation"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StateTransitionError_ctor (o_o_0 : * mut dpp :: state_transition :: errors :: StateTransitionError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidStateTransitionType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ConsensusError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: consensus :: dpp_consensus_ConsensusError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Document_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_DocumentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Document (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Token_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Token (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Generic_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Generic (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NotSupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NotSupported (o_o_0)) } # [cfg (feature = "message-signing")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSigningKeyTypeError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_o_0)) } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidIdentityPublicKeyTypeError_ctor (o_o_0 : * mut state_transition) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StateTransitionIsNotSignedError_ctor (o_o_0 : * mut state_transition) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeySecurityLevelNotMetError_ctor (o_o_0 : * mut dpp :: state_transition :: errors :: PublicKeySecurityLevelNotMetError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_o_0)) } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_WrongPublicKeyPurposeError_ctor (o_o_0 : * mut state_transition) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyMismatchError_ctor (o_o_0 : * mut state_transition) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSignaturePublicKeyError_ctor (o_o_0 : * mut state_transition) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NonConsensusError_ctor (o_o_0 : * mut dpp :: NonConsensusError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CompatibleProtocolVersionIsNotDefinedError_ctor (o_o_0 : * mut dpp :: CompatibleProtocolVersionIsNotDefinedError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidDocumentTypeError_ctor (o_o_0 : * mut dpp :: errors :: protocol_error :: InvalidDocumentTypeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DataContractNotPresentError_ctor (o_o_0 : * mut dpp :: errors :: protocol_error :: DataContractNotPresentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSignaturePublicKeySecurityLevelError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: InvalidSignaturePublicKeySecurityLevelError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidStateTransitionTypeError_ctor (o_o_0 : * mut dpp :: consensus :: basic :: state_transition :: InvalidStateTransitionTypeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyIsDisabledError_ctor (o_o_0 : * mut dpp :: consensus :: signature :: PublicKeyIsDisabledError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_IdentityNotPresentError_ctor (o_o_0 : * mut dpp :: errors :: protocol_error :: IdentityNotPresentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Overflow_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Overflow (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DivideByZero_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DesiredKeyWithTypePurposeSecurityLevelMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ValueError_ctor (o_o_0 : * mut error :: Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformDeserializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DashCoreError_ctor (o_o_0 : * mut dashcore :: error :: Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidIdentityError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_consensus_ConsensusError , raw_identity : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_VoteError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: VoteError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyGenerationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_GroupMemberNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_GroupNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CorruptedSerialization_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CriticalCorruptedCreditsCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidVectorSizeError_ctor (o_o_0 : * mut dpp :: InvalidVectorSizeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidCBOR_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_o_0)) } # [cfg (feature = "bls-signatures")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_BlsError_ctor (o_o_0 : * mut dashcore :: blsful :: BlsError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: BlsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PrivateKeySizeError_ctor (got : u32) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidBLSPrivateKeyError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_BlsSignatureSizeError_ctor (got : u32) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_AddingDifferentTypes_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidDistributionStep_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_MissingEpochInfo_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidBatchedTransitionActionVariant_ctor (expected : * mut std :: os :: raw :: c_char , found : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidBatchedTransitionActionVariant { expected , found }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_destroy (ffi : * mut dpp_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } } pub mod dpp_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DPPError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_error_DPPError { AssetLockOutputNotFoundError (* mut dpp :: identity :: errors :: AssetLockOutputNotFoundError) , AssetLockTransactionIsNotFoundError (* mut dpp :: identity :: errors :: AssetLockTransactionIsNotFoundError) , WrongPublicKeyHashSize , WrongBurnOutputType , InvalidAssetLockTransaction , CoreMessageCorruption (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_error_DPPError) -> dpp :: errors :: dpp_error :: DPPError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (std :: ptr :: read (* o_0)) , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_error :: DPPError) -> * const dpp_errors_dpp_error_DPPError { ferment :: boxed (match obj { dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (ferment :: boxed (o_0)) , dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize => dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize , dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType => dpp_errors_dpp_error_DPPError :: WrongBurnOutputType , dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction => dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction , dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (o_0) => dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_error_DPPError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => { } , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => { } , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => { } , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_AssetLockOutputNotFoundError_ctor (o_o_0 : * mut dpp :: identity :: errors :: AssetLockOutputNotFoundError) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_AssetLockTransactionIsNotFoundError_ctor (o_o_0 : * mut dpp :: identity :: errors :: AssetLockTransactionIsNotFoundError) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_WrongPublicKeyHashSize_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_WrongBurnOutputType_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: WrongBurnOutputType { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_InvalidAssetLockTransaction_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_CoreMessageCorruption_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_destroy (ffi : * mut dpp_errors_dpp_error_DPPError) { ferment :: unbox_any (ffi) ; } } } pub mod validation { use crate as example_nested ; # [cfg (feature = "validation")] pub mod byte_array_keyword { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } # [cfg (feature = "validation")] pub mod json_schema_validator { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod compile { use crate as example_nested ; } pub mod new { use crate as example_nested ; } pub mod validate { use crate as example_nested ; } } } } pub mod bls { use crate as example_nested ; } # [cfg (feature = "fixtures-and-mocks")] pub mod tests { use crate as example_nested ; pub mod fixtures { use crate as example_nested ; } } pub mod asset_lock { use crate as example_nested ; pub mod reduced_asset_lock_value { use crate as example_nested ; } } pub mod balances { use crate as example_nested ; pub mod credits { use crate as example_nested ; # [doc = "FFI-representation of the [`Credits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_Credits (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_Credits) -> dpp :: balances :: credits :: Credits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: Credits) -> * const dpp_balances_credits_Credits { ferment :: boxed (dpp_balances_credits_Credits (obj)) } } impl Drop for dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_ctor (o_0 : u64) -> * mut dpp_balances_credits_Credits { ferment :: boxed (dpp_balances_credits_Credits (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_destroy (ffi : * mut dpp_balances_credits_Credits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_get_0 (obj : * const dpp_balances_credits_Credits) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_set_0 (obj : * mut dpp_balances_credits_Credits , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TokenAmount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_TokenAmount (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_TokenAmount) -> dpp :: balances :: credits :: TokenAmount { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: TokenAmount) -> * const dpp_balances_credits_TokenAmount { ferment :: boxed (dpp_balances_credits_TokenAmount (obj)) } } impl Drop for dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_ctor (o_0 : u64) -> * mut dpp_balances_credits_TokenAmount { ferment :: boxed (dpp_balances_credits_TokenAmount (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_destroy (ffi : * mut dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_get_0 (obj : * const dpp_balances_credits_TokenAmount) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_set_0 (obj : * mut dpp_balances_credits_TokenAmount , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`SignedCredits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_SignedCredits (i64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_SignedCredits) -> dpp :: balances :: credits :: SignedCredits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: SignedCredits) -> * const dpp_balances_credits_SignedCredits { ferment :: boxed (dpp_balances_credits_SignedCredits (obj)) } } impl Drop for dpp_balances_credits_SignedCredits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_ctor (o_0 : i64) -> * mut dpp_balances_credits_SignedCredits { ferment :: boxed (dpp_balances_credits_SignedCredits (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_destroy (ffi : * mut dpp_balances_credits_SignedCredits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_get_0 (obj : * const dpp_balances_credits_SignedCredits) -> i64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_set_0 (obj : * mut dpp_balances_credits_SignedCredits , value : i64) { (* obj) . 0 = value ; } } } pub mod block { use crate as example_nested ; pub mod block_info { use crate as example_nested ; # [doc = "FFI-representation of the [`BlockInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_block_info_BlockInfo { pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub core_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch } impl ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_from_const (ffi : * const dpp_block_block_info_BlockInfo) -> dpp :: block :: block_info :: BlockInfo { let ffi_ref = & * ffi ; dpp :: block :: block_info :: BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (ffi_ref . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from (ffi_ref . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch >> :: ffi_from (ffi_ref . epoch) } } } impl ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_to_const (obj : dpp :: block :: block_info :: BlockInfo) -> * const dpp_block_block_info_BlockInfo { ferment :: boxed (dpp_block_block_info_BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (obj . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to (obj . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch >> :: ffi_to (obj . epoch) }) } } impl Drop for dpp_block_block_info_BlockInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . height) ; ferment :: unbox_any (ffi_ref . core_height) ; ferment :: unbox_any (ffi_ref . epoch) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_ctor (time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , core_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch) -> * mut dpp_block_block_info_BlockInfo { ferment :: boxed (dpp_block_block_info_BlockInfo { time_ms , height , core_height , epoch }) } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_destroy (ffi : * mut dpp_block_block_info_BlockInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_time_ms (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_height (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_core_height (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . core_height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_epoch (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch { (* obj) . epoch } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_time_ms (obj : * mut dpp_block_block_info_BlockInfo , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) { (* obj) . time_ms = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_height (obj : * mut dpp_block_block_info_BlockInfo , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) { (* obj) . height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_core_height (obj : * mut dpp_block_block_info_BlockInfo , value : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) { (* obj) . core_height = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_epoch (obj : * mut dpp_block_block_info_BlockInfo , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch) { (* obj) . epoch = value ; } } pub mod epoch { use crate as example_nested ; # [doc = "FFI-representation of the [`EpochIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_EpochIndex (u16) ; impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_EpochIndex) -> dpp :: block :: epoch :: EpochIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: EpochIndex) -> * const dpp_block_epoch_EpochIndex { ferment :: boxed (dpp_block_epoch_EpochIndex (obj)) } } impl Drop for dpp_block_epoch_EpochIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_ctor (o_0 : u16) -> * mut dpp_block_epoch_EpochIndex { ferment :: boxed (dpp_block_epoch_EpochIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_destroy (ffi : * mut dpp_block_epoch_EpochIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_get_0 (obj : * const dpp_block_epoch_EpochIndex) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_set_0 (obj : * mut dpp_block_epoch_EpochIndex , value : u16) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`Epoch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_Epoch { pub index : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub key : * mut crate :: fermented :: generics :: Arr_u8_2 } impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_Epoch) -> dpp :: block :: epoch :: Epoch { let ffi_ref = & * ffi ; dpp :: block :: epoch :: Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionFrom < [u8 ; 2] >> :: ffi_from (ffi_ref . key) } } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: Epoch) -> * const dpp_block_epoch_Epoch { ferment :: boxed (dpp_block_epoch_Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionTo < [u8 ; 2] >> :: ffi_to (obj . key) }) } } impl Drop for dpp_block_epoch_Epoch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . index) ; ferment :: unbox_any (ffi_ref . key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_ctor (index : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , key : * mut crate :: fermented :: generics :: Arr_u8_2) -> * mut dpp_block_epoch_Epoch { ferment :: boxed (dpp_block_epoch_Epoch { index , key }) } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_destroy (ffi : * mut dpp_block_epoch_Epoch) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_get_index (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_get_key (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: generics :: Arr_u8_2 { (* obj) . key } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_set_index (obj : * mut dpp_block_epoch_Epoch , value : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) { (* obj) . index = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_set_key (obj : * mut dpp_block_epoch_Epoch , value : * mut crate :: fermented :: generics :: Arr_u8_2) { (* obj) . key = value ; } } pub mod extended_block_info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod extended_epoch_info { use crate as example_nested ; } pub mod finalized_epoch_info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod core_subsidy { use crate as example_nested ; pub mod epoch_core_reward_credits_for_distribution { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod fee { use crate as example_nested ; pub mod default_costs { use crate as example_nested ; } pub mod epoch { use crate as example_nested ; # [cfg (feature = "fee-distribution")] pub mod distribution { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } # [cfg (feature = "fee-distribution")] pub mod fee_result { use crate as example_nested ; pub mod refunds { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod nft { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TradeMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_nft_TradeMode { None = 0 , DirectPurchase = 1 } impl ferment :: FFIConversionFrom < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_from_const (ffi : * const dpp_nft_TradeMode) -> dpp :: nft :: TradeMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_nft_TradeMode :: None => dpp :: nft :: TradeMode :: None , dpp_nft_TradeMode :: DirectPurchase => dpp :: nft :: TradeMode :: DirectPurchase } } } impl ferment :: FFIConversionTo < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_to_const (obj : dpp :: nft :: TradeMode) -> * const dpp_nft_TradeMode { ferment :: boxed (match obj { dpp :: nft :: TradeMode :: None => dpp_nft_TradeMode :: None , dpp :: nft :: TradeMode :: DirectPurchase => dpp_nft_TradeMode :: DirectPurchase , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_nft_TradeMode { fn drop (& mut self) { unsafe { match self { dpp_nft_TradeMode :: None => { } , dpp_nft_TradeMode :: DirectPurchase => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_None_ctor () -> * mut dpp_nft_TradeMode { ferment :: boxed (dpp_nft_TradeMode :: None { }) } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_DirectPurchase_ctor () -> * mut dpp_nft_TradeMode { ferment :: boxed (dpp_nft_TradeMode :: DirectPurchase { }) } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_destroy (ffi : * mut dpp_nft_TradeMode) { ferment :: unbox_any (ffi) ; } } pub mod serialization { use crate as example_nested ; } # [cfg (feature = "system_contracts")] pub mod system_data_contracts { use crate as example_nested ; } pub mod tokens { use crate as example_nested ; pub mod contract_info { use crate as example_nested ; } pub mod emergency_action { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyAction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_emergency_action_TokenEmergencyAction { Pause = 0 , Resume = 1 } impl ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_from_const (ffi : * const dpp_tokens_emergency_action_TokenEmergencyAction) -> dpp :: tokens :: emergency_action :: TokenEmergencyAction { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume } } } impl ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_to_const (obj : dpp :: tokens :: emergency_action :: TokenEmergencyAction) -> * const dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (match obj { dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause => dpp_tokens_emergency_action_TokenEmergencyAction :: Pause , dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume => dpp_tokens_emergency_action_TokenEmergencyAction :: Resume , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_emergency_action_TokenEmergencyAction { fn drop (& mut self) { unsafe { match self { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => { } , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_Pause_ctor () -> * mut dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (dpp_tokens_emergency_action_TokenEmergencyAction :: Pause { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_Resume_ctor () -> * mut dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (dpp_tokens_emergency_action_TokenEmergencyAction :: Resume { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_destroy (ffi : * mut dpp_tokens_emergency_action_TokenEmergencyAction) { ferment :: unbox_any (ffi) ; } } pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_errors_TokenError { TokenNotFoundAtPositionError , TokenNotFoundOnContractVersion , TokenNoMintingRecipient } impl ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_from_const (ffi : * const dpp_tokens_errors_TokenError) -> dpp :: tokens :: errors :: TokenError { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient } } } impl ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_to_const (obj : dpp :: tokens :: errors :: TokenError) -> * const dpp_tokens_errors_TokenError { ferment :: boxed (match obj { dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError => dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError , dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion => dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion , dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient => dpp_tokens_errors_TokenError :: TokenNoMintingRecipient , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_errors_TokenError { fn drop (& mut self) { unsafe { match self { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => { } , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => { } , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNotFoundAtPositionError_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNotFoundOnContractVersion_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNoMintingRecipient_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNoMintingRecipient { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_destroy (ffi : * mut dpp_tokens_errors_TokenError) { ferment :: unbox_any (ffi) ; } } pub mod gas_fees_paid_by { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`GasFeesPaidBy`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { DocumentOwner = 0 , ContractOwner = 1 , PreferContractOwner = 2 } impl ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy > for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { unsafe fn ffi_from_const (ffi : * const dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) -> dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: DocumentOwner , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: ContractOwner , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner => dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: PreferContractOwner } } } impl ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy > for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { unsafe fn ffi_to_const (obj : dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy) -> * const dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { ferment :: boxed (match obj { dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: DocumentOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner , dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: ContractOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner , dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy :: PreferContractOwner => dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { fn drop (& mut self) { unsafe { match self { dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner => { } , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner => { } , dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_gas_fees_paid_by_GasFeesPaidBy_DocumentOwner_ctor () -> * mut dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { ferment :: boxed (dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: DocumentOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_gas_fees_paid_by_GasFeesPaidBy_ContractOwner_ctor () -> * mut dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { ferment :: boxed (dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: ContractOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_gas_fees_paid_by_GasFeesPaidBy_PreferContractOwner_ctor () -> * mut dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { ferment :: boxed (dpp_tokens_gas_fees_paid_by_GasFeesPaidBy :: PreferContractOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_gas_fees_paid_by_GasFeesPaidBy_destroy (ffi : * mut dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) { ferment :: unbox_any (ffi) ; } } pub mod info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_info_v0_IdentityTokenInfoV0 { pub frozen : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { let ffi_ref = & * ffi ; dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { frozen : ffi_ref . frozen } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0) -> * const dpp_tokens_info_v0_IdentityTokenInfoV0 { ferment :: boxed (dpp_tokens_info_v0_IdentityTokenInfoV0 { frozen : obj . frozen }) } } impl Drop for dpp_tokens_info_v0_IdentityTokenInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_ctor (frozen : bool) -> * mut dpp_tokens_info_v0_IdentityTokenInfoV0 { ferment :: boxed (dpp_tokens_info_v0_IdentityTokenInfoV0 { frozen }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_destroy (ffi : * mut dpp_tokens_info_v0_IdentityTokenInfoV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_get_frozen (obj : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> bool { (* obj) . frozen } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_set_frozen (obj : * mut dpp_tokens_info_v0_IdentityTokenInfoV0 , value : bool) { (* obj) . frozen = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTokenInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_info_IdentityTokenInfo { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_IdentityTokenInfo) -> dpp :: tokens :: info :: IdentityTokenInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => dpp :: tokens :: info :: IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: IdentityTokenInfo) -> * const dpp_tokens_info_IdentityTokenInfo { ferment :: boxed (match obj { dpp :: tokens :: info :: IdentityTokenInfo :: V0 (o_0) => dpp_tokens_info_IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_info_IdentityTokenInfo { fn drop (& mut self) { unsafe { match self { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_IdentityTokenInfo_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0) -> * mut dpp_tokens_info_IdentityTokenInfo { ferment :: boxed (dpp_tokens_info_IdentityTokenInfo :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_IdentityTokenInfo_destroy (ffi : * mut dpp_tokens_info_IdentityTokenInfo) { ferment :: unbox_any (ffi) ; } } pub mod status { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenStatusV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_status_v0_TokenStatusV0 { pub paused : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_v0_TokenStatusV0) -> dpp :: tokens :: status :: v0 :: TokenStatusV0 { let ffi_ref = & * ffi ; dpp :: tokens :: status :: v0 :: TokenStatusV0 { paused : ffi_ref . paused } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: v0 :: TokenStatusV0) -> * const dpp_tokens_status_v0_TokenStatusV0 { ferment :: boxed (dpp_tokens_status_v0_TokenStatusV0 { paused : obj . paused }) } } impl Drop for dpp_tokens_status_v0_TokenStatusV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_ctor (paused : bool) -> * mut dpp_tokens_status_v0_TokenStatusV0 { ferment :: boxed (dpp_tokens_status_v0_TokenStatusV0 { paused }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_destroy (ffi : * mut dpp_tokens_status_v0_TokenStatusV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_get_paused (obj : * const dpp_tokens_status_v0_TokenStatusV0) -> bool { (* obj) . paused } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_set_paused (obj : * mut dpp_tokens_status_v0_TokenStatusV0 , value : bool) { (* obj) . paused = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_status_TokenStatus { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_TokenStatus) -> dpp :: tokens :: status :: TokenStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_status_TokenStatus :: V0 (o_0) => dpp :: tokens :: status :: TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: TokenStatus) -> * const dpp_tokens_status_TokenStatus { ferment :: boxed (match obj { dpp :: tokens :: status :: TokenStatus :: V0 (o_0) => dpp_tokens_status_TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_status_TokenStatus { fn drop (& mut self) { unsafe { match self { dpp_tokens_status_TokenStatus :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_TokenStatus_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0) -> * mut dpp_tokens_status_TokenStatus { ferment :: boxed (dpp_tokens_status_TokenStatus :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_TokenStatus_destroy (ffi : * mut dpp_tokens_status_TokenStatus) { ferment :: unbox_any (ffi) ; } } pub mod token_amount_on_contract_token { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentActionTokenEffect`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { TransferTokenToContractOwner , BurnToken } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect) -> dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner => dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: TransferTokenToContractOwner , dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken => dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: BurnToken } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect) -> * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { ferment :: boxed (match obj { dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: TransferTokenToContractOwner => dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner , dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect :: BurnToken => dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner => { } , dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect_TransferTokenToContractOwner_ctor () -> * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { ferment :: boxed (dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: TransferTokenToContractOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect_BurnToken_ctor () -> * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { ferment :: boxed (dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect :: BurnToken { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect_destroy (ffi : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`DocumentActionTokenCost`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { pub contract_id : * mut types :: identifier :: Identifier , pub token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub token_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub effect : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect , pub gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost { let ffi_ref = & * ffi ; dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost { contract_id : ferment :: from_opt_opaque (ffi_ref . contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_contract_position) , token_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . token_amount) , effect : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect as ferment :: FFIConversionFrom < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect >> :: ffi_from (ffi_ref . effect) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_from (ffi_ref . gas_fees_paid_by) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost > for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenCost) -> * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { ferment :: boxed (dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { contract_id : ferment :: to_opt_primitive (obj . contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_contract_position) , token_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . token_amount) , effect : < crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect as ferment :: FFIConversionTo < dpp :: tokens :: token_amount_on_contract_token :: DocumentActionTokenEffect >> :: ffi_to (obj . effect) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_to (obj . gas_fees_paid_by) }) } } impl Drop for dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . token_contract_position) ; ferment :: unbox_any (ffi_ref . token_amount) ; ferment :: unbox_any (ffi_ref . effect) ; ferment :: unbox_any (ffi_ref . gas_fees_paid_by) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_ctor (contract_id : * mut types :: identifier :: Identifier , token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , token_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , effect : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect , gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) -> * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { ferment :: boxed (dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost { contract_id , token_contract_position , token_amount , effect , gas_fees_paid_by }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_destroy (ffi : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_get_contract_id (obj : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_get_token_contract_position (obj : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_get_token_amount (obj : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_get_effect (obj : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect { (* obj) . effect } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_get_gas_fees_paid_by (obj : * const dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost) -> * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { (* obj) . gas_fees_paid_by } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_set_contract_id (obj : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_set_token_contract_position (obj : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . token_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_set_token_amount (obj : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . token_amount = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_set_effect (obj : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , value : * mut crate :: fermented :: types :: dpp :: tokens :: token_amount_on_contract_token :: dpp_tokens_token_amount_on_contract_token_DocumentActionTokenEffect) { (* obj) . effect = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost_set_gas_fees_paid_by (obj : * mut dpp_tokens_token_amount_on_contract_token_DocumentActionTokenCost , value : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) { (* obj) . gas_fees_paid_by = value ; } } pub mod token_payment_info { use crate as example_nested ; pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenPaymentInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { pub payment_token_contract_id : * mut types :: identifier :: Identifier , pub token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub minimum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub maximum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 > for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 { let ffi_ref = & * ffi ; dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 { payment_token_contract_id : ferment :: from_opt_opaque (ffi_ref . payment_token_contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . token_contract_position) , minimum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . minimum_token_cost) , maximum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from_opt (ffi_ref . maximum_token_cost) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionFrom < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_from (ffi_ref . gas_fees_paid_by) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 > for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0) -> * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { ferment :: boxed (dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { payment_token_contract_id : ferment :: to_opt_primitive (obj . payment_token_contract_id) , token_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . token_contract_position) , minimum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . minimum_token_cost) , maximum_token_cost : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to_opt (obj . maximum_token_cost) , gas_fees_paid_by : < crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy as ferment :: FFIConversionTo < dpp :: tokens :: gas_fees_paid_by :: GasFeesPaidBy >> :: ffi_to (obj . gas_fees_paid_by) }) } } impl Drop for dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . payment_token_contract_id) ; ferment :: unbox_any (ffi_ref . token_contract_position) ; ferment :: unbox_any_opt (ffi_ref . minimum_token_cost) ; ferment :: unbox_any_opt (ffi_ref . maximum_token_cost) ; ferment :: unbox_any (ffi_ref . gas_fees_paid_by) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_ctor (payment_token_contract_id : * mut types :: identifier :: Identifier , token_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , minimum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , maximum_token_cost : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , gas_fees_paid_by : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) -> * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { ferment :: boxed (dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 { payment_token_contract_id , token_contract_position , minimum_token_cost , maximum_token_cost , gas_fees_paid_by }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_destroy (ffi : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_get_payment_token_contract_id (obj : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut types :: identifier :: Identifier { (* obj) . payment_token_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_get_token_contract_position (obj : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_get_minimum_token_cost (obj : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . minimum_token_cost } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_get_maximum_token_cost (obj : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . maximum_token_cost } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_get_gas_fees_paid_by (obj : * const dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy { (* obj) . gas_fees_paid_by } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_set_payment_token_contract_id (obj : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 , value : * mut types :: identifier :: Identifier) { (* obj) . payment_token_contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_set_token_contract_position (obj : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) { (* obj) . token_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_set_minimum_token_cost (obj : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . minimum_token_cost = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_set_maximum_token_cost (obj : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { (* obj) . maximum_token_cost = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0_set_gas_fees_paid_by (obj : * mut dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 , value : * mut crate :: fermented :: types :: dpp :: tokens :: gas_fees_paid_by :: dpp_tokens_gas_fees_paid_by_GasFeesPaidBy) { (* obj) . gas_fees_paid_by = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenPaymentInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_payment_info_TokenPaymentInfo { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: TokenPaymentInfo > for dpp_tokens_token_payment_info_TokenPaymentInfo { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_payment_info_TokenPaymentInfo) -> dpp :: tokens :: token_payment_info :: TokenPaymentInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (o_0) => dpp :: tokens :: token_payment_info :: TokenPaymentInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 as ferment :: FFIConversionFrom < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: TokenPaymentInfo > for dpp_tokens_token_payment_info_TokenPaymentInfo { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_payment_info :: TokenPaymentInfo) -> * const dpp_tokens_token_payment_info_TokenPaymentInfo { ferment :: boxed (match obj { dpp :: tokens :: token_payment_info :: TokenPaymentInfo :: V0 (o_0) => dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0 as ferment :: FFIConversionTo < dpp :: tokens :: token_payment_info :: v0 :: TokenPaymentInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_payment_info_TokenPaymentInfo { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_TokenPaymentInfo_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: token_payment_info :: v0 :: dpp_tokens_token_payment_info_v0_TokenPaymentInfoV0) -> * mut dpp_tokens_token_payment_info_TokenPaymentInfo { ferment :: boxed (dpp_tokens_token_payment_info_TokenPaymentInfo :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_payment_info_TokenPaymentInfo_destroy (ffi : * mut dpp_tokens_token_payment_info_TokenPaymentInfo) { ferment :: unbox_any (ffi) ; } } pub mod token_pricing_schedule { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenPricingSchedule`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_token_pricing_schedule_TokenPricingSchedule { SinglePrice (* mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) , SetPrices (* mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) } impl ferment :: FFIConversionFrom < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule > for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { unsafe fn ffi_from_const (ffi : * const dpp_tokens_token_pricing_schedule_TokenPricingSchedule) -> dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (o_0) => dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SinglePrice (< crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (* o_0)) , dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (o_0) => dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SetPrices (< crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule > for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { unsafe fn ffi_to_const (obj : dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule) -> * const dpp_tokens_token_pricing_schedule_TokenPricingSchedule { ferment :: boxed (match obj { dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SinglePrice (o_0) => dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (< crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (o_0)) , dpp :: tokens :: token_pricing_schedule :: TokenPricingSchedule :: SetPrices (o_0) => dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (< crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_token_pricing_schedule_TokenPricingSchedule { fn drop (& mut self) { unsafe { match self { dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_pricing_schedule_TokenPricingSchedule_SinglePrice_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_tokens_token_pricing_schedule_TokenPricingSchedule { ferment :: boxed (dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SinglePrice (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_pricing_schedule_TokenPricingSchedule_SetPrices_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) -> * mut dpp_tokens_token_pricing_schedule_TokenPricingSchedule { ferment :: boxed (dpp_tokens_token_pricing_schedule_TokenPricingSchedule :: SetPrices (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_token_pricing_schedule_TokenPricingSchedule_destroy (ffi : * mut dpp_tokens_token_pricing_schedule_TokenPricingSchedule) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`SharedEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_SharedEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_SharedEncryptedNote) -> dpp :: tokens :: SharedEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: SharedEncryptedNote) -> * const dpp_tokens_SharedEncryptedNote { ferment :: boxed (dpp_tokens_SharedEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_SharedEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_ctor (o_0 : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) -> * mut dpp_tokens_SharedEncryptedNote { ferment :: boxed (dpp_tokens_SharedEncryptedNote (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_destroy (ffi : * mut dpp_tokens_SharedEncryptedNote) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_get_0 (obj : * const dpp_tokens_SharedEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_set_0 (obj : * mut dpp_tokens_SharedEncryptedNote , value : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`PrivateEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_PrivateEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_PrivateEncryptedNote) -> dpp :: tokens :: PrivateEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: PrivateEncryptedNote) -> * const dpp_tokens_PrivateEncryptedNote { ferment :: boxed (dpp_tokens_PrivateEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_PrivateEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_ctor (o_0 : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) -> * mut dpp_tokens_PrivateEncryptedNote { ferment :: boxed (dpp_tokens_PrivateEncryptedNote (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_destroy (ffi : * mut dpp_tokens_PrivateEncryptedNote) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_get_0 (obj : * const dpp_tokens_PrivateEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_set_0 (obj : * mut dpp_tokens_PrivateEncryptedNote , value : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) { (* obj) . 0 = value ; } } pub mod voting { use crate as example_nested ; pub mod contender_structs { use crate as example_nested ; pub mod contender { use crate as example_nested ; } # [doc = "FFI-representation of the [`FinalizedResourceVoteChoicesWithVoterInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice , pub voters : * mut crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { let ffi_ref = & * ffi ; dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8 as ferment :: FFIConversionFrom < Vec < (types :: identifier :: Identifier , u8) > >> :: ffi_from (ffi_ref . voters) } } } impl ferment :: FFIConversionTo < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo) -> * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8 as ferment :: FFIConversionTo < Vec < (types :: identifier :: Identifier , u8) > >> :: ffi_to (obj . voters) }) } } impl Drop for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; ferment :: unbox_any (ffi_ref . voters) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_ctor (resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice , voters : * mut crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8) -> * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice , voters }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_destroy (ffi : * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_get_resource_vote_choice (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_get_voters (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8 { (* obj) . voters } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_set_resource_vote_choice (obj : * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) { (* obj) . resource_vote_choice = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_set_voters (obj : * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , value : * mut crate :: fermented :: generics :: Vec_Tuple_types_identifier_Identifier_u8) { (* obj) . voters = value ; } } pub mod vote_choices { use crate as example_nested ; pub mod resource_vote_choice { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVoteChoice`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { TowardsIdentity (* mut types :: identifier :: Identifier) , Abstain , Lock } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) -> dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (std :: ptr :: read (* o_0)) , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice) -> * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (match obj { dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (o_0) => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (ferment :: boxed (o_0)) , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => { } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_TowardsIdentity_ctor (o_o_0 : * mut types :: identifier :: Identifier) -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_Abstain_ctor () -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_Lock_ctor () -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_destroy (ffi : * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) { ferment :: unbox_any (ffi) ; } } } pub mod vote_info_storage { use crate as example_nested ; pub mod contested_document_vote_poll_stored_info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoVoteEventV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub resource_vote_choices : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , pub start_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub finalization_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub winner : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_from (ffi_ref . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_from (ffi_ref . winner) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_to (obj . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_to (obj . winner) }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choices) ; ferment :: unbox_any (ffi_ref . start_block) ; ferment :: unbox_any (ffi_ref . finalization_block) ; ferment :: unbox_any (ffi_ref . winner) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_ctor (resource_vote_choices : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , start_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , finalization_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , winner : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices , start_block , finalization_block , winner }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_destroy (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_resource_vote_choices (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { (* obj) . resource_vote_choices } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_start_block (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . start_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_finalization_block (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . finalization_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_winner (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { (* obj) . winner } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_resource_vote_choices (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { (* obj) . resource_vote_choices = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_start_block (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , value : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) { (* obj) . start_block = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_finalization_block (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , value : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) { (* obj) . finalization_block = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_winner (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) { (* obj) . winner = value ; } # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { pub finalized_events : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , pub vote_poll_status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus , pub locked_count : u16 } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_from (ffi_ref . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . vote_poll_status) , locked_count : ffi_ref . locked_count } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_to (obj . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . vote_poll_status) , locked_count : obj . locked_count }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . finalized_events) ; ferment :: unbox_any (ffi_ref . vote_poll_status) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_ctor (finalized_events : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , vote_poll_status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus , locked_count : u16) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { finalized_events , vote_poll_status , locked_count }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_destroy (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_finalized_events (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { (* obj) . finalized_events } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_vote_poll_status (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . vote_poll_status } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_locked_count (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> u16 { (* obj) . locked_count } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_finalized_events (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 , value : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { (* obj) . finalized_events = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_vote_poll_status (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) { (* obj) . vote_poll_status = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_locked_count (obj : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 , value : u16) { (* obj) . locked_count = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { NotStarted , Awarded (* mut types :: identifier :: Identifier) , Locked , Started (* mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (std :: ptr :: read (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (ferment :: boxed (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_NotStarted_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Awarded_ctor (o_o_0 : * mut types :: identifier :: Identifier) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Locked_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Started_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_destroy (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStoredInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { V0 (* mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo_destroy (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) { ferment :: unbox_any (ffi) ; } } pub mod contested_document_vote_poll_winner_info { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollWinnerInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { NoWinner , WonByIdentity (* mut types :: identifier :: Identifier) , Locked } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (std :: ptr :: read (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (ferment :: boxed (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_NoWinner_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_WonByIdentity_ctor (o_o_0 : * mut types :: identifier :: Identifier) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_Locked_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_destroy (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) { ferment :: unbox_any (ffi) ; } } } pub mod vote_polls { use crate as example_nested ; pub mod contested_document_resource_vote_poll { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentResourceVotePoll`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { pub contract_id : * mut types :: identifier :: Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub index_values : * mut crate :: fermented :: generics :: Vec_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { let ffi_ref = & * ffi ; dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { contract_id : std :: ptr :: read (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (ffi_ref . index_values) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll) -> * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { ferment :: boxed (dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { contract_id : ferment :: boxed (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (obj . index_values) }) } } impl Drop for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_any (ffi_ref . index_values) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_ctor (contract_id : * mut types :: identifier :: Identifier , document_type_name : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , index_values : * mut crate :: fermented :: generics :: Vec_platform_value_Value) -> * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { ferment :: boxed (dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { contract_id , document_type_name , index_name , index_values }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_destroy (ffi : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_contract_id (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut types :: identifier :: Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_document_type_name (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_index_name (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_index_values (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut crate :: fermented :: generics :: Vec_platform_value_Value { (* obj) . index_values } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_contract_id (obj : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , value : * mut types :: identifier :: Identifier) { (* obj) . contract_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_document_type_name (obj : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , value : * mut std :: os :: raw :: c_char) { (* obj) . document_type_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_index_name (obj : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , value : * mut std :: os :: raw :: c_char) { (* obj) . index_name = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_index_values (obj : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , value : * mut crate :: fermented :: generics :: Vec_platform_value_Value) { (* obj) . index_values = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VotePoll`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_polls_VotePoll { ContestedDocumentResourceVotePoll (* mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_VotePoll) -> dpp :: voting :: vote_polls :: VotePoll { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: VotePoll) -> * const dpp_voting_vote_polls_VotePoll { ferment :: boxed (match obj { dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_polls_VotePoll { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_VotePoll_ContestedDocumentResourceVotePoll_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut dpp_voting_vote_polls_VotePoll { ferment :: boxed (dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_VotePoll_destroy (ffi : * mut dpp_voting_vote_polls_VotePoll) { ferment :: unbox_any (ffi) ; } } pub mod votes { use crate as example_nested ; pub mod resource_vote { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ResourceVoteV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { let ffi_ref = & * ffi ; dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0) -> * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { ferment :: boxed (dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) }) } } impl Drop for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_ctor (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) -> * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { ferment :: boxed (dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { vote_poll , resource_vote_choice }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_destroy (ffi : * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_get_vote_poll (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_get_resource_vote_choice (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_set_vote_poll (obj : * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0 , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) { (* obj) . vote_poll = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_set_resource_vote_choice (obj : * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0 , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) { (* obj) . resource_vote_choice = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_resource_vote_ResourceVote { V0 (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_ResourceVote) -> dpp :: voting :: votes :: resource_vote :: ResourceVote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: ResourceVote) -> * const dpp_voting_votes_resource_vote_ResourceVote { ferment :: boxed (match obj { dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (o_0) => dpp_voting_votes_resource_vote_ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_resource_vote_ResourceVote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_ResourceVote_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut dpp_voting_votes_resource_vote_ResourceVote { ferment :: boxed (dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_ResourceVote_destroy (ffi : * mut dpp_voting_votes_resource_vote_ResourceVote) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Vote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_Vote { ResourceVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_Vote) -> dpp :: voting :: votes :: Vote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_Vote :: ResourceVote (o_0) => dpp :: voting :: votes :: Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: Vote) -> * const dpp_voting_votes_Vote { ferment :: boxed (match obj { dpp :: voting :: votes :: Vote :: ResourceVote (o_0) => dpp_voting_votes_Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_Vote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_Vote :: ResourceVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_Vote_ResourceVote_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote) -> * mut dpp_voting_votes_Vote { ferment :: boxed (dpp_voting_votes_Vote :: ResourceVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_Vote_destroy (ffi : * mut dpp_voting_votes_Vote) { ferment :: unbox_any (ffi) ; } } } # [cfg (feature = "core-types")] pub mod core_types { use crate as example_nested ; pub mod validator { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod validator_set { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod group { use crate as example_nested ; pub mod group_action { use crate as example_nested ; } pub mod group_action_status { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`GroupActionStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_group_group_action_status_GroupActionStatus { ActionActive , ActionClosed } impl ferment :: FFIConversionFrom < dpp :: group :: group_action_status :: GroupActionStatus > for dpp_group_group_action_status_GroupActionStatus { unsafe fn ffi_from_const (ffi : * const dpp_group_group_action_status_GroupActionStatus) -> dpp :: group :: group_action_status :: GroupActionStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_group_group_action_status_GroupActionStatus :: ActionActive => dpp :: group :: group_action_status :: GroupActionStatus :: ActionActive , dpp_group_group_action_status_GroupActionStatus :: ActionClosed => dpp :: group :: group_action_status :: GroupActionStatus :: ActionClosed } } } impl ferment :: FFIConversionTo < dpp :: group :: group_action_status :: GroupActionStatus > for dpp_group_group_action_status_GroupActionStatus { unsafe fn ffi_to_const (obj : dpp :: group :: group_action_status :: GroupActionStatus) -> * const dpp_group_group_action_status_GroupActionStatus { ferment :: boxed (match obj { dpp :: group :: group_action_status :: GroupActionStatus :: ActionActive => dpp_group_group_action_status_GroupActionStatus :: ActionActive , dpp :: group :: group_action_status :: GroupActionStatus :: ActionClosed => dpp_group_group_action_status_GroupActionStatus :: ActionClosed , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_group_group_action_status_GroupActionStatus { fn drop (& mut self) { unsafe { match self { dpp_group_group_action_status_GroupActionStatus :: ActionActive => { } , dpp_group_group_action_status_GroupActionStatus :: ActionClosed => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_group_group_action_status_GroupActionStatus_ActionActive_ctor () -> * mut dpp_group_group_action_status_GroupActionStatus { ferment :: boxed (dpp_group_group_action_status_GroupActionStatus :: ActionActive { }) } # [no_mangle] pub unsafe extern "C" fn dpp_group_group_action_status_GroupActionStatus_ActionClosed_ctor () -> * mut dpp_group_group_action_status_GroupActionStatus { ferment :: boxed (dpp_group_group_action_status_GroupActionStatus :: ActionClosed { }) } # [no_mangle] pub unsafe extern "C" fn dpp_group_group_action_status_GroupActionStatus_destroy (ffi : * mut dpp_group_group_action_status_GroupActionStatus) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`GroupStateTransitionInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_group_GroupStateTransitionInfo { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut types :: identifier :: Identifier , pub action_is_proposer : bool } impl ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_from_const (ffi : * const dpp_group_GroupStateTransitionInfo) -> dpp :: group :: GroupStateTransitionInfo { let ffi_ref = & * ffi ; dpp :: group :: GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : std :: ptr :: read (ffi_ref . action_id) , action_is_proposer : ffi_ref . action_is_proposer } } } impl ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_to_const (obj : dpp :: group :: GroupStateTransitionInfo) -> * const dpp_group_GroupStateTransitionInfo { ferment :: boxed (dpp_group_GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : ferment :: boxed (obj . action_id) , action_is_proposer : obj . action_is_proposer }) } } impl Drop for dpp_group_GroupStateTransitionInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_ctor (group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut types :: identifier :: Identifier , action_is_proposer : bool) -> * mut dpp_group_GroupStateTransitionInfo { ferment :: boxed (dpp_group_GroupStateTransitionInfo { group_contract_position , action_id , action_is_proposer }) } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_destroy (ffi : * mut dpp_group_GroupStateTransitionInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_group_contract_position (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_action_id (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut types :: identifier :: Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_action_is_proposer (obj : * const dpp_group_GroupStateTransitionInfo) -> bool { (* obj) . action_is_proposer } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_group_contract_position (obj : * mut dpp_group_GroupStateTransitionInfo , value : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) { (* obj) . group_contract_position = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_action_id (obj : * mut dpp_group_GroupStateTransitionInfo , value : * mut types :: identifier :: Identifier) { (* obj) . action_id = value ; } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_action_is_proposer (obj : * mut dpp_group_GroupStateTransitionInfo , value : bool) { (* obj) . action_is_proposer = value ; } } pub mod withdrawal { use crate as example_nested ; pub mod daily_withdrawal_limit { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [cfg (all (feature = "withdrawals-contract" , feature = "system_contracts"))] pub mod document_try_into_asset_unlock_base_transaction_info { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Pooling`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_withdrawal_Pooling { Never = 0 , IfAvailable = 1 , Standard = 2 } impl ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_from_const (ffi : * const dpp_withdrawal_Pooling) -> dpp :: withdrawal :: Pooling { let ffi_ref = & * ffi ; match ffi_ref { dpp_withdrawal_Pooling :: Never => dpp :: withdrawal :: Pooling :: Never , dpp_withdrawal_Pooling :: IfAvailable => dpp :: withdrawal :: Pooling :: IfAvailable , dpp_withdrawal_Pooling :: Standard => dpp :: withdrawal :: Pooling :: Standard } } } impl ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_to_const (obj : dpp :: withdrawal :: Pooling) -> * const dpp_withdrawal_Pooling { ferment :: boxed (match obj { dpp :: withdrawal :: Pooling :: Never => dpp_withdrawal_Pooling :: Never , dpp :: withdrawal :: Pooling :: IfAvailable => dpp_withdrawal_Pooling :: IfAvailable , dpp :: withdrawal :: Pooling :: Standard => dpp_withdrawal_Pooling :: Standard , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_withdrawal_Pooling { fn drop (& mut self) { unsafe { match self { dpp_withdrawal_Pooling :: Never => { } , dpp_withdrawal_Pooling :: IfAvailable => { } , dpp_withdrawal_Pooling :: Standard => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_Never_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: Never { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_IfAvailable_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: IfAvailable { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_Standard_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: Standard { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_destroy (ffi : * mut dpp_withdrawal_Pooling) { ferment :: unbox_any (ffi) ; } } pub mod prelude { use crate as example_nested ; # [doc = "FFI-representation of the [`EpochInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_EpochInterval (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_EpochInterval) -> dpp :: prelude :: EpochInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: EpochInterval) -> * const dpp_prelude_EpochInterval { ferment :: boxed (dpp_prelude_EpochInterval (obj)) } } impl Drop for dpp_prelude_EpochInterval { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_ctor (o_0 : u16) -> * mut dpp_prelude_EpochInterval { ferment :: boxed (dpp_prelude_EpochInterval (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_destroy (ffi : * mut dpp_prelude_EpochInterval) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_get_0 (obj : * const dpp_prelude_EpochInterval) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_set_0 (obj : * mut dpp_prelude_EpochInterval , value : u16) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`BlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_BlockHeight (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_BlockHeight) -> dpp :: prelude :: BlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: BlockHeight) -> * const dpp_prelude_BlockHeight { ferment :: boxed (dpp_prelude_BlockHeight (obj)) } } impl Drop for dpp_prelude_BlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_ctor (o_0 : u64) -> * mut dpp_prelude_BlockHeight { ferment :: boxed (dpp_prelude_BlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_destroy (ffi : * mut dpp_prelude_BlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_get_0 (obj : * const dpp_prelude_BlockHeight) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_set_0 (obj : * mut dpp_prelude_BlockHeight , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`FeeMultiplier`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_FeeMultiplier (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_from_const (ffi : * const dpp_prelude_FeeMultiplier) -> dpp :: prelude :: FeeMultiplier { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_to_const (obj : dpp :: prelude :: FeeMultiplier) -> * const dpp_prelude_FeeMultiplier { ferment :: boxed (dpp_prelude_FeeMultiplier (obj)) } } impl Drop for dpp_prelude_FeeMultiplier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_ctor (o_0 : u64) -> * mut dpp_prelude_FeeMultiplier { ferment :: boxed (dpp_prelude_FeeMultiplier (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_destroy (ffi : * mut dpp_prelude_FeeMultiplier) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_get_0 (obj : * const dpp_prelude_FeeMultiplier) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_set_0 (obj : * mut dpp_prelude_FeeMultiplier , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_CoreBlockHeight) -> dpp :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: CoreBlockHeight) -> * const dpp_prelude_CoreBlockHeight { ferment :: boxed (dpp_prelude_CoreBlockHeight (obj)) } } impl Drop for dpp_prelude_CoreBlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_ctor (o_0 : u32) -> * mut dpp_prelude_CoreBlockHeight { ferment :: boxed (dpp_prelude_CoreBlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_destroy (ffi : * mut dpp_prelude_CoreBlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_get_0 (obj : * const dpp_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_set_0 (obj : * mut dpp_prelude_CoreBlockHeight , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillis) -> dpp :: prelude :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillis) -> * const dpp_prelude_TimestampMillis { ferment :: boxed (dpp_prelude_TimestampMillis (obj)) } } impl Drop for dpp_prelude_TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_ctor (o_0 : u64) -> * mut dpp_prelude_TimestampMillis { ferment :: boxed (dpp_prelude_TimestampMillis (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_destroy (ffi : * mut dpp_prelude_TimestampMillis) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_get_0 (obj : * const dpp_prelude_TimestampMillis) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_set_0 (obj : * mut dpp_prelude_TimestampMillis , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TimestampMillisInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillisInterval (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillisInterval) -> dpp :: prelude :: TimestampMillisInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillisInterval) -> * const dpp_prelude_TimestampMillisInterval { ferment :: boxed (dpp_prelude_TimestampMillisInterval (obj)) } } impl Drop for dpp_prelude_TimestampMillisInterval { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_ctor (o_0 : u64) -> * mut dpp_prelude_TimestampMillisInterval { ferment :: boxed (dpp_prelude_TimestampMillisInterval (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_destroy (ffi : * mut dpp_prelude_TimestampMillisInterval) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_get_0 (obj : * const dpp_prelude_TimestampMillisInterval) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_set_0 (obj : * mut dpp_prelude_TimestampMillisInterval , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`StartAtIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_StartAtIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_StartAtIncluded) -> dpp :: prelude :: StartAtIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: StartAtIncluded) -> * const dpp_prelude_StartAtIncluded { ferment :: boxed (dpp_prelude_StartAtIncluded (obj)) } } impl Drop for dpp_prelude_StartAtIncluded { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_ctor (o_0 : bool) -> * mut dpp_prelude_StartAtIncluded { ferment :: boxed (dpp_prelude_StartAtIncluded (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_destroy (ffi : * mut dpp_prelude_StartAtIncluded) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_get_0 (obj : * const dpp_prelude_StartAtIncluded) -> bool { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_set_0 (obj : * mut dpp_prelude_StartAtIncluded , value : bool) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`TimestampIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampIncluded) -> dpp :: prelude :: TimestampIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampIncluded) -> * const dpp_prelude_TimestampIncluded { ferment :: boxed (dpp_prelude_TimestampIncluded (obj)) } } impl Drop for dpp_prelude_TimestampIncluded { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_ctor (o_0 : bool) -> * mut dpp_prelude_TimestampIncluded { ferment :: boxed (dpp_prelude_TimestampIncluded (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_destroy (ffi : * mut dpp_prelude_TimestampIncluded) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_get_0 (obj : * const dpp_prelude_TimestampIncluded) -> bool { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_set_0 (obj : * mut dpp_prelude_TimestampIncluded , value : bool) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`Revision`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_Revision (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_from_const (ffi : * const dpp_prelude_Revision) -> dpp :: prelude :: Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_to_const (obj : dpp :: prelude :: Revision) -> * const dpp_prelude_Revision { ferment :: boxed (dpp_prelude_Revision (obj)) } } impl Drop for dpp_prelude_Revision { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_ctor (o_0 : u64) -> * mut dpp_prelude_Revision { ferment :: boxed (dpp_prelude_Revision (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_destroy (ffi : * mut dpp_prelude_Revision) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_get_0 (obj : * const dpp_prelude_Revision) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_set_0 (obj : * mut dpp_prelude_Revision , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`IdentityNonce`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_IdentityNonce (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_from_const (ffi : * const dpp_prelude_IdentityNonce) -> dpp :: prelude :: IdentityNonce { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_to_const (obj : dpp :: prelude :: IdentityNonce) -> * const dpp_prelude_IdentityNonce { ferment :: boxed (dpp_prelude_IdentityNonce (obj)) } } impl Drop for dpp_prelude_IdentityNonce { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_ctor (o_0 : u64) -> * mut dpp_prelude_IdentityNonce { ferment :: boxed (dpp_prelude_IdentityNonce (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_destroy (ffi : * mut dpp_prelude_IdentityNonce) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_get_0 (obj : * const dpp_prelude_IdentityNonce) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_set_0 (obj : * mut dpp_prelude_IdentityNonce , value : u64) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`SenderKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_SenderKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_SenderKeyIndex) -> dpp :: prelude :: SenderKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: SenderKeyIndex) -> * const dpp_prelude_SenderKeyIndex { ferment :: boxed (dpp_prelude_SenderKeyIndex (obj)) } } impl Drop for dpp_prelude_SenderKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_ctor (o_0 : u32) -> * mut dpp_prelude_SenderKeyIndex { ferment :: boxed (dpp_prelude_SenderKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_destroy (ffi : * mut dpp_prelude_SenderKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_get_0 (obj : * const dpp_prelude_SenderKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_set_0 (obj : * mut dpp_prelude_SenderKeyIndex , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`RecipientKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RecipientKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RecipientKeyIndex) -> dpp :: prelude :: RecipientKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RecipientKeyIndex) -> * const dpp_prelude_RecipientKeyIndex { ferment :: boxed (dpp_prelude_RecipientKeyIndex (obj)) } } impl Drop for dpp_prelude_RecipientKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_ctor (o_0 : u32) -> * mut dpp_prelude_RecipientKeyIndex { ferment :: boxed (dpp_prelude_RecipientKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_destroy (ffi : * mut dpp_prelude_RecipientKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_get_0 (obj : * const dpp_prelude_RecipientKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_set_0 (obj : * mut dpp_prelude_RecipientKeyIndex , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`RootEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RootEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RootEncryptionKeyIndex) -> dpp :: prelude :: RootEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RootEncryptionKeyIndex) -> * const dpp_prelude_RootEncryptionKeyIndex { ferment :: boxed (dpp_prelude_RootEncryptionKeyIndex (obj)) } } impl Drop for dpp_prelude_RootEncryptionKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_ctor (o_0 : u32) -> * mut dpp_prelude_RootEncryptionKeyIndex { ferment :: boxed (dpp_prelude_RootEncryptionKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_destroy (ffi : * mut dpp_prelude_RootEncryptionKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_get_0 (obj : * const dpp_prelude_RootEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_set_0 (obj : * mut dpp_prelude_RootEncryptionKeyIndex , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`DerivationEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_DerivationEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_DerivationEncryptionKeyIndex) -> dpp :: prelude :: DerivationEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: DerivationEncryptionKeyIndex) -> * const dpp_prelude_DerivationEncryptionKeyIndex { ferment :: boxed (dpp_prelude_DerivationEncryptionKeyIndex (obj)) } } impl Drop for dpp_prelude_DerivationEncryptionKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_ctor (o_0 : u32) -> * mut dpp_prelude_DerivationEncryptionKeyIndex { ferment :: boxed (dpp_prelude_DerivationEncryptionKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_destroy (ffi : * mut dpp_prelude_DerivationEncryptionKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_get_0 (obj : * const dpp_prelude_DerivationEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_set_0 (obj : * mut dpp_prelude_DerivationEncryptionKeyIndex , value : u32) { (* obj) . 0 = value ; } # [doc = "FFI-representation of the [`UserFeeIncrease`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_UserFeeIncrease (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_from_const (ffi : * const dpp_prelude_UserFeeIncrease) -> dpp :: prelude :: UserFeeIncrease { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_to_const (obj : dpp :: prelude :: UserFeeIncrease) -> * const dpp_prelude_UserFeeIncrease { ferment :: boxed (dpp_prelude_UserFeeIncrease (obj)) } } impl Drop for dpp_prelude_UserFeeIncrease { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_ctor (o_0 : u16) -> * mut dpp_prelude_UserFeeIncrease { ferment :: boxed (dpp_prelude_UserFeeIncrease (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_destroy (ffi : * mut dpp_prelude_UserFeeIncrease) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_get_0 (obj : * const dpp_prelude_UserFeeIncrease) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_set_0 (obj : * mut dpp_prelude_UserFeeIncrease , value : u16) { (* obj) . 0 = value ; } } } pub mod example_nested { use crate as example_nested ; pub mod model { use crate as example_nested ; pub mod snapshot { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQSnapshotSkipMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_snapshot_LLMQSnapshotSkipMode { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > for example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_LLMQSnapshotSkipMode) -> example_nested :: model :: snapshot :: LLMQSnapshotSkipMode { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: NoSkipping , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipFirst , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipExcept , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipAll } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > for example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: LLMQSnapshotSkipMode) -> * const example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (match obj { example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: NoSkipping => example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipFirst => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipExcept => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipAll => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_snapshot_LLMQSnapshotSkipMode { fn drop (& mut self) { unsafe { match self { example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_NoSkipping_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipFirst_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipExcept_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipAll_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_destroy (ffi : * mut example_nested_model_snapshot_LLMQSnapshotSkipMode) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`LLMQSnapshot`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_snapshot_LLMQSnapshot { pub member_list : * mut crate :: fermented :: generics :: Vec_u8 , pub skip_list : * mut crate :: fermented :: generics :: Vec_i32 , pub skip_list_mode : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode , pub option_vec : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot > for example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_LLMQSnapshot) -> example_nested :: model :: snapshot :: LLMQSnapshot { let ffi_ref = & * ffi ; example_nested :: model :: snapshot :: LLMQSnapshot { member_list : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . member_list) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionFrom < Vec < i32 > >> :: ffi_from (ffi_ref . skip_list) , skip_list_mode : < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_from (ffi_ref . skip_list_mode) , option_vec : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (ffi_ref . option_vec) } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshot > for example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: LLMQSnapshot) -> * const example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshot { member_list : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . member_list) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionTo < Vec < i32 > >> :: ffi_to (obj . skip_list) , skip_list_mode : < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_to (obj . skip_list_mode) , option_vec : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (obj . option_vec) }) } } impl Drop for example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_list) ; ferment :: unbox_any (ffi_ref . skip_list) ; ferment :: unbox_any (ffi_ref . skip_list_mode) ; ferment :: unbox_any_opt (ffi_ref . option_vec) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_ctor (member_list : * mut crate :: fermented :: generics :: Vec_u8 , skip_list : * mut crate :: fermented :: generics :: Vec_i32 , skip_list_mode : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode , option_vec : * mut crate :: fermented :: generics :: Vec_u8) -> * mut example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshot { member_list , skip_list , skip_list_mode , option_vec }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_member_list (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . member_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_skip_list (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_i32 { (* obj) . skip_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_skip_list_mode (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_option_vec (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . option_vec } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_member_list (obj : * mut example_nested_model_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . member_list = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_skip_list (obj : * mut example_nested_model_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: Vec_i32) { (* obj) . skip_list = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_skip_list_mode (obj : * mut example_nested_model_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) { (* obj) . skip_list_mode = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_option_vec (obj : * mut example_nested_model_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: Vec_u8) { (* obj) . option_vec = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VerifyingChainLockSignaturesType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_snapshot_VerifyingChainLockSignaturesType { Rotating (* mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) , NonRotating (* mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType > for example_nested_model_snapshot_VerifyingChainLockSignaturesType { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_VerifyingChainLockSignaturesType) -> example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_0) => example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_from (* o_0)) , example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_0) => example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType > for example_nested_model_snapshot_VerifyingChainLockSignaturesType { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType) -> * const example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (match obj { example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: Rotating (o_0) => example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_to (o_0)) , example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: NonRotating (o_0) => example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_snapshot_VerifyingChainLockSignaturesType { fn drop (& mut self) { unsafe { match self { example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_0) => { ferment :: unbox_any (* o_0) ; } , example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_Rotating_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) -> * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_NonRotating_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_destroy (ffi : * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType) { ferment :: unbox_any (ffi) ; } } pub mod quorum { use crate as example_nested ; pub mod quorum_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`QuorumType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_quorum_quorum_type_QuorumType { Normal , Rotated } impl ferment :: FFIConversionFrom < example_nested :: model :: quorum :: quorum_type :: QuorumType > for example_nested_model_quorum_quorum_type_QuorumType { unsafe fn ffi_from_const (ffi : * const example_nested_model_quorum_quorum_type_QuorumType) -> example_nested :: model :: quorum :: quorum_type :: QuorumType { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_quorum_quorum_type_QuorumType :: Normal => example_nested :: model :: quorum :: quorum_type :: QuorumType :: Normal , example_nested_model_quorum_quorum_type_QuorumType :: Rotated => example_nested :: model :: quorum :: quorum_type :: QuorumType :: Rotated } } } impl ferment :: FFIConversionTo < example_nested :: model :: quorum :: quorum_type :: QuorumType > for example_nested_model_quorum_quorum_type_QuorumType { unsafe fn ffi_to_const (obj : example_nested :: model :: quorum :: quorum_type :: QuorumType) -> * const example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (match obj { example_nested :: model :: quorum :: quorum_type :: QuorumType :: Normal => example_nested_model_quorum_quorum_type_QuorumType :: Normal , example_nested :: model :: quorum :: quorum_type :: QuorumType :: Rotated => example_nested_model_quorum_quorum_type_QuorumType :: Rotated , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_quorum_quorum_type_QuorumType { fn drop (& mut self) { unsafe { match self { example_nested_model_quorum_quorum_type_QuorumType :: Normal => { } , example_nested_model_quorum_quorum_type_QuorumType :: Rotated => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_Normal_ctor () -> * mut example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (example_nested_model_quorum_quorum_type_QuorumType :: Normal { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_Rotated_ctor () -> * mut example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (example_nested_model_quorum_quorum_type_QuorumType :: Rotated { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_destroy (ffi : * mut example_nested_model_quorum_quorum_type_QuorumType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`OBJCEnumTest`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_quorum_quorum_type_OBJCEnumTest { Regular , UnnamedEx (* mut std :: os :: raw :: c_char) , NamedEx { qtype : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest > for example_nested_model_quorum_quorum_type_OBJCEnumTest { unsafe fn ffi_from_const (ffi : * const example_nested_model_quorum_quorum_type_OBJCEnumTest) -> example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: Regular , example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_0) => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: UnnamedEx (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype } => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: NamedEx { qtype : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* qtype) } } } } impl ferment :: FFIConversionTo < example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest > for example_nested_model_quorum_quorum_type_OBJCEnumTest { unsafe fn ffi_to_const (obj : example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest) -> * const example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (match obj { example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: Regular => example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular , example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: UnnamedEx (o_0) => example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: NamedEx { qtype } => example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (qtype) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_quorum_quorum_type_OBJCEnumTest { fn drop (& mut self) { unsafe { match self { example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular => { } , example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_0) => { ferment :: unbox_string (* o_0) ; } , example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype } => { ferment :: unbox_string (* qtype) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_Regular_ctor () -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_UnnamedEx_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_NamedEx_ctor (qtype : * mut std :: os :: raw :: c_char) -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_destroy (ffi : * mut example_nested_model_quorum_quorum_type_OBJCEnumTest) { ferment :: unbox_any (ffi) ; } } } pub mod callback { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_desc`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_desc (_callback : crate :: fermented :: generics :: Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String) { let obj = example_nested :: model :: callback :: find_current_block_desc (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_classic`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_classic (_callback : example_nested :: model :: callback :: ClassicCallback) { let obj = example_nested :: model :: callback :: find_current_block_classic (_callback) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_desc_mut`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_desc_mut (_callback : crate :: fermented :: generics :: FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String) { let obj = example_nested :: model :: callback :: find_current_block_desc_mut (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::lookup_block_hash_by_height`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_lookup_block_hash_by_height (_callback : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Option_u8_32) { let obj = example_nested :: model :: callback :: lookup_block_hash_by_height (move | o_0 | unsafe { _callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::lookup_merkle_root_by_hash`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_lookup_merkle_root_by_hash (_callback : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32) { let obj = example_nested :: model :: callback :: lookup_merkle_root_by_hash (move | o_0 | unsafe { _callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::should_process_diff_in_range2`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_should_process_diff_in_range2 (_callback : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { let obj = example_nested :: model :: callback :: should_process_diff_in_range2 (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::setup_two_callbacks`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_setup_two_callbacks (_callback1 : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , _callback2 : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { let obj = example_nested :: model :: callback :: setup_two_callbacks (move | o_0 , o_1 | unsafe { _callback1 . call (o_0 , o_1) } , move | o_0 | unsafe { _callback2 . call (o_0) }) ; ; } } pub mod tuples { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::tuples::get_hash_id_form_snapshot`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_hash_id_form_snapshot (_snapshot : * mut example_nested :: model :: LLMQSnapshot) -> * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID { let obj = example_nested :: model :: tuples :: get_hash_id_form_snapshot (std :: ptr :: read (_snapshot)) ; < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`StructWithTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_StructWithTuple { pub tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: StructWithTuple > for example_nested_model_tuples_StructWithTuple { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_StructWithTuple) -> example_nested :: model :: tuples :: StructWithTuple { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (ffi_ref . tuple) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: StructWithTuple > for example_nested_model_tuples_StructWithTuple { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: StructWithTuple) -> * const example_nested_model_tuples_StructWithTuple { ferment :: boxed (example_nested_model_tuples_StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj . tuple) }) } } impl Drop for example_nested_model_tuples_StructWithTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_ctor (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) -> * mut example_nested_model_tuples_StructWithTuple { ferment :: boxed (example_nested_model_tuples_StructWithTuple { tuple }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_destroy (ffi : * mut example_nested_model_tuples_StructWithTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_get_tuple (obj : * const example_nested_model_tuples_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { (* obj) . tuple } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_set_tuple (obj : * mut example_nested_model_tuples_StructWithTuple , value : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) { (* obj) . tuple = value ; } # [doc = "FFI-representation of the [`StructWithTupleWithOptional`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_StructWithTupleWithOptional { pub tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: StructWithTupleWithOptional > for example_nested_model_tuples_StructWithTupleWithOptional { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_StructWithTupleWithOptional) -> example_nested :: model :: tuples :: StructWithTupleWithOptional { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: StructWithTupleWithOptional { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >) >> :: ffi_from (ffi_ref . tuple) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: StructWithTupleWithOptional > for example_nested_model_tuples_StructWithTupleWithOptional { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: StructWithTupleWithOptional) -> * const example_nested_model_tuples_StructWithTupleWithOptional { ferment :: boxed (example_nested_model_tuples_StructWithTupleWithOptional { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >) >> :: ffi_to (obj . tuple) }) } } impl Drop for example_nested_model_tuples_StructWithTupleWithOptional { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_ctor (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot) -> * mut example_nested_model_tuples_StructWithTupleWithOptional { ferment :: boxed (example_nested_model_tuples_StructWithTupleWithOptional { tuple }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_destroy (ffi : * mut example_nested_model_tuples_StructWithTupleWithOptional) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_get_tuple (obj : * const example_nested_model_tuples_StructWithTupleWithOptional) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { (* obj) . tuple } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_set_tuple (obj : * mut example_nested_model_tuples_StructWithTupleWithOptional , value : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot) { (* obj) . tuple = value ; } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_simple`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_simple () -> * mut crate :: fermented :: generics :: Tuple_u32_u32 { let obj = example_nested :: model :: tuples :: get_tuple_simple () ; < crate :: fermented :: generics :: Tuple_u32_u32 as ferment :: FFIConversionTo < (u32 , u32) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_simple_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_simple_complex () -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { let obj = example_nested :: model :: tuples :: get_tuple_simple_complex () ; < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_complex_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_complex_complex (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) -> u32 { let obj = example_nested :: model :: tuples :: get_tuple_complex_complex (< crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (tuple)) ; obj } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_complex_complex_opt`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_complex_complex_opt (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot) -> u32 { let obj = example_nested :: model :: tuples :: get_tuple_complex_complex_opt (< crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: LLMQSnapshot >) >> :: ffi_from (tuple)) ; obj } # [doc = "FFI-representation of the [`TransUser`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_TransUser { pub transition : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: TransUser > for example_nested_model_tuples_TransUser { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_TransUser) -> example_nested :: model :: tuples :: TransUser { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: TransUser { transition : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (ffi_ref . transition) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: TransUser > for example_nested_model_tuples_TransUser { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: TransUser) -> * const example_nested_model_tuples_TransUser { ferment :: boxed (example_nested_model_tuples_TransUser { transition : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (obj . transition) }) } } impl Drop for example_nested_model_tuples_TransUser { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transition) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_ctor (transition : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_model_tuples_TransUser { ferment :: boxed (example_nested_model_tuples_TransUser { transition }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_destroy (ffi : * mut example_nested_model_tuples_TransUser) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_get_transition (obj : * const example_nested_model_tuples_TransUser) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . transition } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_set_transition (obj : * mut example_nested_model_tuples_TransUser , value : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { (* obj) . transition = value ; } # [doc = "FFI-representation of the [`VecofArr`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_VecofArr { pub v : * mut crate :: fermented :: generics :: Vec_u8_32 } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: VecofArr > for example_nested_model_tuples_VecofArr { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_VecofArr) -> example_nested :: model :: tuples :: VecofArr { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: VecofArr { v : < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: VecofArr > for example_nested_model_tuples_VecofArr { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: VecofArr) -> * const example_nested_model_tuples_VecofArr { ferment :: boxed (example_nested_model_tuples_VecofArr { v : < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionTo < Vec < [u8 ; 32] > >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_VecofArr { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_ctor (v : * mut crate :: fermented :: generics :: Vec_u8_32) -> * mut example_nested_model_tuples_VecofArr { ferment :: boxed (example_nested_model_tuples_VecofArr { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_destroy (ffi : * mut example_nested_model_tuples_VecofArr) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_get_v (obj : * const example_nested_model_tuples_VecofArr) -> * mut crate :: fermented :: generics :: Vec_u8_32 { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_set_v (obj : * mut example_nested_model_tuples_VecofArr , value : * mut crate :: fermented :: generics :: Vec_u8_32) { (* obj) . v = value ; } # [doc = "FFI-representation of the [`ExampleWithOptPrimitive`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithOptPrimitive { pub v : * mut u32 } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithOptPrimitive > for example_nested_model_tuples_ExampleWithOptPrimitive { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithOptPrimitive) -> example_nested :: model :: tuples :: ExampleWithOptPrimitive { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithOptPrimitive { v : ferment :: from_opt_primitive (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithOptPrimitive > for example_nested_model_tuples_ExampleWithOptPrimitive { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithOptPrimitive) -> * const example_nested_model_tuples_ExampleWithOptPrimitive { ferment :: boxed (example_nested_model_tuples_ExampleWithOptPrimitive { v : ferment :: to_opt_primitive (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithOptPrimitive { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_ctor (v : * mut u32) -> * mut example_nested_model_tuples_ExampleWithOptPrimitive { ferment :: boxed (example_nested_model_tuples_ExampleWithOptPrimitive { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_destroy (ffi : * mut example_nested_model_tuples_ExampleWithOptPrimitive) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_get_v (obj : * const example_nested_model_tuples_ExampleWithOptPrimitive) -> * mut u32 { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_set_v (obj : * mut example_nested_model_tuples_ExampleWithOptPrimitive , value : * mut u32) { (* obj) . v = value ; } # [doc = "FFI-representation of the [`ExampleWithCustomGeneric`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithCustomGeneric { pub v : * mut crate :: fermented :: generics :: Vec_BlockHash } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithCustomGeneric > for example_nested_model_tuples_ExampleWithCustomGeneric { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithCustomGeneric) -> example_nested :: model :: tuples :: ExampleWithCustomGeneric { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithCustomGeneric { v : < crate :: fermented :: generics :: Vec_BlockHash as ferment :: FFIConversionFrom < Vec < BlockHash > >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithCustomGeneric > for example_nested_model_tuples_ExampleWithCustomGeneric { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithCustomGeneric) -> * const example_nested_model_tuples_ExampleWithCustomGeneric { ferment :: boxed (example_nested_model_tuples_ExampleWithCustomGeneric { v : < crate :: fermented :: generics :: Vec_BlockHash as ferment :: FFIConversionTo < Vec < BlockHash > >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithCustomGeneric { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_ctor (v : * mut crate :: fermented :: generics :: Vec_BlockHash) -> * mut example_nested_model_tuples_ExampleWithCustomGeneric { ferment :: boxed (example_nested_model_tuples_ExampleWithCustomGeneric { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_destroy (ffi : * mut example_nested_model_tuples_ExampleWithCustomGeneric) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_get_v (obj : * const example_nested_model_tuples_ExampleWithCustomGeneric) -> * mut crate :: fermented :: generics :: Vec_BlockHash { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_set_v (obj : * mut example_nested_model_tuples_ExampleWithCustomGeneric , value : * mut crate :: fermented :: generics :: Vec_BlockHash) { (* obj) . v = value ; } # [doc = "FFI-representation of the [`ExampleWithGenericTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithGenericTuple { pub v : * mut crate :: fermented :: generics :: Tuple_BlockHash_BlockHash } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithGenericTuple > for example_nested_model_tuples_ExampleWithGenericTuple { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithGenericTuple) -> example_nested :: model :: tuples :: ExampleWithGenericTuple { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithGenericTuple { v : < crate :: fermented :: generics :: Tuple_BlockHash_BlockHash as ferment :: FFIConversionFrom < (BlockHash , BlockHash) >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithGenericTuple > for example_nested_model_tuples_ExampleWithGenericTuple { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithGenericTuple) -> * const example_nested_model_tuples_ExampleWithGenericTuple { ferment :: boxed (example_nested_model_tuples_ExampleWithGenericTuple { v : < crate :: fermented :: generics :: Tuple_BlockHash_BlockHash as ferment :: FFIConversionTo < (BlockHash , BlockHash) >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithGenericTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_ctor (v : * mut crate :: fermented :: generics :: Tuple_BlockHash_BlockHash) -> * mut example_nested_model_tuples_ExampleWithGenericTuple { ferment :: boxed (example_nested_model_tuples_ExampleWithGenericTuple { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_destroy (ffi : * mut example_nested_model_tuples_ExampleWithGenericTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_get_v (obj : * const example_nested_model_tuples_ExampleWithGenericTuple) -> * mut crate :: fermented :: generics :: Tuple_BlockHash_BlockHash { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_set_v (obj : * mut example_nested_model_tuples_ExampleWithGenericTuple , value : * mut crate :: fermented :: generics :: Tuple_BlockHash_BlockHash) { (* obj) . v = value ; } } pub mod many_scopes { use crate as example_nested ; # [repr (C)] # [derive (Clone)] pub struct example_nested_model_many_scopes_Trait111 { object : * const () , vtable : * const example_nested_model_many_scopes_Trait111_VTable } # [repr (C)] # [derive (Clone)] pub struct example_nested_model_many_scopes_Trait111_VTable { # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Trait111::method1`]"] pub method1 : unsafe extern "C" fn (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char } # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::new`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_new () -> * mut example_nested :: model :: many_scopes :: Struct111 { let obj = example_nested :: model :: many_scopes :: Struct111 :: new () ; ferment :: boxed (obj) } # [no_mangle] pub static example_nested_model_many_scopes_Struct111_example_nested_model_many_scopes_Trait111 : crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111_VTable = { # [no_mangle] unsafe extern "C" fn example_nested_model_many_scopes_Trait111_example_nested_model_many_scopes_Struct111_method1 (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * ((* self_) . object as * const example_nested :: model :: many_scopes :: Struct111)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111_VTable { method1 : example_nested_model_many_scopes_Trait111_example_nested_model_many_scopes_Struct111_method1 } } ; # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_as_crate_fermented_types_example_nested_model_many_scopes_example_nested_model_many_scopes_Trait111 (obj : * const example_nested :: model :: many_scopes :: Struct111) -> crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111 { crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111 { object : obj as * const () , vtable : & example_nested_model_many_scopes_Struct111_example_nested_model_many_scopes_Trait111 } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_as_crate_fermented_types_example_nested_model_many_scopes_example_nested_model_many_scopes_Trait111_destroy (obj : crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) { ferment :: unbox_any (obj . object as * mut example_nested :: model :: many_scopes :: Struct111) ; } # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::method1`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_Trait111_method1 (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * ((* self_) . object as * const example_nested :: model :: many_scopes :: Struct111)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::method1`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_method1 (self_ : * mut example_nested :: model :: many_scopes :: Struct111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * self_) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } } pub mod indexmap { use crate as example_nested ; # [doc = "FFI-representation of the [`IndexMapExample`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_indexmap_IndexMapExample { pub set : * mut crate :: fermented :: generics :: indexmap_IndexSet_String , pub map : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String } impl ferment :: FFIConversionFrom < example_nested :: model :: indexmap :: IndexMapExample > for example_nested_model_indexmap_IndexMapExample { unsafe fn ffi_from_const (ffi : * const example_nested_model_indexmap_IndexMapExample) -> example_nested :: model :: indexmap :: IndexMapExample { let ffi_ref = & * ffi ; example_nested :: model :: indexmap :: IndexMapExample { set : < crate :: fermented :: generics :: indexmap_IndexSet_String as ferment :: FFIConversionFrom < indexmap :: IndexSet < String > >> :: ffi_from (ffi_ref . set) , map : < crate :: fermented :: generics :: indexmap_IndexMap_String_String as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , String > >> :: ffi_from (ffi_ref . map) } } } impl ferment :: FFIConversionTo < example_nested :: model :: indexmap :: IndexMapExample > for example_nested_model_indexmap_IndexMapExample { unsafe fn ffi_to_const (obj : example_nested :: model :: indexmap :: IndexMapExample) -> * const example_nested_model_indexmap_IndexMapExample { ferment :: boxed (example_nested_model_indexmap_IndexMapExample { set : < crate :: fermented :: generics :: indexmap_IndexSet_String as ferment :: FFIConversionTo < indexmap :: IndexSet < String > >> :: ffi_to (obj . set) , map : < crate :: fermented :: generics :: indexmap_IndexMap_String_String as ferment :: FFIConversionTo < indexmap :: IndexMap < String , String > >> :: ffi_to (obj . map) }) } } impl Drop for example_nested_model_indexmap_IndexMapExample { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . set) ; ferment :: unbox_any (ffi_ref . map) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_ctor (set : * mut crate :: fermented :: generics :: indexmap_IndexSet_String , map : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String) -> * mut example_nested_model_indexmap_IndexMapExample { ferment :: boxed (example_nested_model_indexmap_IndexMapExample { set , map }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_destroy (ffi : * mut example_nested_model_indexmap_IndexMapExample) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_get_set (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexSet_String { (* obj) . set } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_get_map (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String { (* obj) . map } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_set_set (obj : * mut example_nested_model_indexmap_IndexMapExample , value : * mut crate :: fermented :: generics :: indexmap_IndexSet_String) { (* obj) . set = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_set_map (obj : * mut example_nested_model_indexmap_IndexMapExample , value : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String) { (* obj) . map = value ; } } pub mod feat_dep { use crate as example_nested ; # [doc = "FFI-representation of the [`Validatorrr`]"] # [cfg (feature = "validation")] # [repr (C)] # [derive (Clone)] # [cfg (feature = "validation")] pub struct example_nested_model_feat_dep_Validatorrr { } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: Validatorrr > for example_nested_model_feat_dep_Validatorrr { unsafe fn ffi_from_const (ffi : * const example_nested_model_feat_dep_Validatorrr) -> example_nested :: model :: feat_dep :: Validatorrr { let ffi_ref = & * ffi ; example_nested :: model :: feat_dep :: Validatorrr { } } } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: Validatorrr > for example_nested_model_feat_dep_Validatorrr { unsafe fn ffi_to_const (obj : example_nested :: model :: feat_dep :: Validatorrr) -> * const example_nested_model_feat_dep_Validatorrr { ferment :: boxed (example_nested_model_feat_dep_Validatorrr { }) } } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl Drop for example_nested_model_feat_dep_Validatorrr { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_Validatorrr_ctor () -> * mut example_nested_model_feat_dep_Validatorrr { ferment :: boxed (example_nested_model_feat_dep_Validatorrr { }) } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_Validatorrr_destroy (ffi : * mut example_nested_model_feat_dep_Validatorrr) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`FeatureDependentField`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_feat_dep_FeatureDependentField { pub field_name : * mut std :: os :: raw :: c_char , # [cfg (feature = "validation")] pub field_type : * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr } impl ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: FeatureDependentField > for example_nested_model_feat_dep_FeatureDependentField { unsafe fn ffi_from_const (ffi : * const example_nested_model_feat_dep_FeatureDependentField) -> example_nested :: model :: feat_dep :: FeatureDependentField { let ffi_ref = & * ffi ; example_nested :: model :: feat_dep :: FeatureDependentField { field_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_name) , # [cfg (feature = "validation")] field_type : < crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr as ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: Validatorrr >> :: ffi_from (ffi_ref . field_type) } } } impl ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: FeatureDependentField > for example_nested_model_feat_dep_FeatureDependentField { unsafe fn ffi_to_const (obj : example_nested :: model :: feat_dep :: FeatureDependentField) -> * const example_nested_model_feat_dep_FeatureDependentField { ferment :: boxed (example_nested_model_feat_dep_FeatureDependentField { field_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_name) , # [cfg (feature = "validation")] field_type : < crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr as ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: Validatorrr >> :: ffi_to (obj . field_type) }) } } impl Drop for example_nested_model_feat_dep_FeatureDependentField { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . field_name) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . field_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_ctor (field_name : * mut std :: os :: raw :: c_char , # [cfg (feature = "validation")] field_type : * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr) -> * mut example_nested_model_feat_dep_FeatureDependentField { ferment :: boxed (example_nested_model_feat_dep_FeatureDependentField { field_name , # [cfg (feature = "validation")] field_type }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_destroy (ffi : * mut example_nested_model_feat_dep_FeatureDependentField) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_get_field_name (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut std :: os :: raw :: c_char { (* obj) . field_name } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_get_field_type (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr { (* obj) . field_type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_set_field_name (obj : * mut example_nested_model_feat_dep_FeatureDependentField , value : * mut std :: os :: raw :: c_char) { (* obj) . field_name = value ; } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_set_field_type (obj : * mut example_nested_model_feat_dep_FeatureDependentField , value : * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr) { (* obj) . field_type = value ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelSnapshot { VO (* mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelSnapshot > for example_nested_model_TestModLevelSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelSnapshot) -> example_nested :: model :: TestModLevelSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelSnapshot > for example_nested_model_TestModLevelSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelSnapshot) -> * const example_nested_model_TestModLevelSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelSnapshot :: VO (o_0) => example_nested_model_TestModLevelSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelSnapshot :: VO (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut example_nested_model_TestModLevelSnapshot { ferment :: boxed (example_nested_model_TestModLevelSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelSnapshot_destroy (ffi : * mut example_nested_model_TestModLevelSnapshot) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelVecSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelVecSnapshot { VO (* mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelVecSnapshot > for example_nested_model_TestModLevelVecSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelVecSnapshot) -> example_nested :: model :: TestModLevelVecSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelVecSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelVecSnapshot :: VO (< crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelVecSnapshot > for example_nested_model_TestModLevelVecSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelVecSnapshot) -> * const example_nested_model_TestModLevelVecSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelVecSnapshot :: VO (o_0) => example_nested_model_TestModLevelVecSnapshot :: VO (< crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelVecSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelVecSnapshot :: VO (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelVecSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut example_nested_model_TestModLevelVecSnapshot { ferment :: boxed (example_nested_model_TestModLevelVecSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelVecSnapshot_destroy (ffi : * mut example_nested_model_TestModLevelVecSnapshot) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelOptSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelOptSnapshot { VO (* mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelOptSnapshot > for example_nested_model_TestModLevelOptSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelOptSnapshot) -> example_nested :: model :: TestModLevelOptSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelOptSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelOptSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_from_opt (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelOptSnapshot > for example_nested_model_TestModLevelOptSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelOptSnapshot) -> * const example_nested_model_TestModLevelOptSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelOptSnapshot :: VO (o_0) => example_nested_model_TestModLevelOptSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_to_opt (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelOptSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelOptSnapshot :: VO (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelOptSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut example_nested_model_TestModLevelOptSnapshot { ferment :: boxed (example_nested_model_TestModLevelOptSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelOptSnapshot_destroy (ffi : * mut example_nested_model_TestModLevelOptSnapshot) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`Quorum`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_Quorum { pub llmq_type : * mut quorum :: QuorumType } impl ferment :: FFIConversionFrom < example_nested :: model :: Quorum > for example_nested_model_Quorum { unsafe fn ffi_from_const (ffi : * const example_nested_model_Quorum) -> example_nested :: model :: Quorum { let ffi_ref = & * ffi ; example_nested :: model :: Quorum { llmq_type : std :: ptr :: read (ffi_ref . llmq_type) } } } impl ferment :: FFIConversionTo < example_nested :: model :: Quorum > for example_nested_model_Quorum { unsafe fn ffi_to_const (obj : example_nested :: model :: Quorum) -> * const example_nested_model_Quorum { ferment :: boxed (example_nested_model_Quorum { llmq_type : ferment :: boxed (obj . llmq_type) }) } } impl Drop for example_nested_model_Quorum { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . llmq_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_ctor (llmq_type : * mut quorum :: QuorumType) -> * mut example_nested_model_Quorum { ferment :: boxed (example_nested_model_Quorum { llmq_type }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_destroy (ffi : * mut example_nested_model_Quorum) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_get_llmq_type (obj : * const example_nested_model_Quorum) -> * mut quorum :: QuorumType { (* obj) . llmq_type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_set_llmq_type (obj : * mut example_nested_model_Quorum , value : * mut quorum :: QuorumType) { (* obj) . llmq_type = value ; } # [doc = "FFI-representation of the [`LLMQParams`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_LLMQParams { pub r#type : * mut std :: os :: raw :: c_char , pub known_confirmed_at_height : * mut u32 } impl ferment :: FFIConversionFrom < example_nested :: model :: LLMQParams > for example_nested_model_LLMQParams { unsafe fn ffi_from_const (ffi : * const example_nested_model_LLMQParams) -> example_nested :: model :: LLMQParams { let ffi_ref = & * ffi ; example_nested :: model :: LLMQParams { r#type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . r#type) , known_confirmed_at_height : ferment :: from_opt_primitive (ffi_ref . known_confirmed_at_height) } } } impl ferment :: FFIConversionTo < example_nested :: model :: LLMQParams > for example_nested_model_LLMQParams { unsafe fn ffi_to_const (obj : example_nested :: model :: LLMQParams) -> * const example_nested_model_LLMQParams { ferment :: boxed (example_nested_model_LLMQParams { r#type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . r#type) , known_confirmed_at_height : ferment :: to_opt_primitive (obj . known_confirmed_at_height) }) } } impl Drop for example_nested_model_LLMQParams { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . r#type) ; ferment :: unbox_any_opt (ffi_ref . known_confirmed_at_height) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_ctor (r#type : * mut std :: os :: raw :: c_char , known_confirmed_at_height : * mut u32) -> * mut example_nested_model_LLMQParams { ferment :: boxed (example_nested_model_LLMQParams { r#type , known_confirmed_at_height }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_destroy (ffi : * mut example_nested_model_LLMQParams) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_get_type (obj : * const example_nested_model_LLMQParams) -> * mut std :: os :: raw :: c_char { (* obj) . r#type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_get_known_confirmed_at_height (obj : * const example_nested_model_LLMQParams) -> * mut u32 { (* obj) . known_confirmed_at_height } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_set_type (obj : * mut example_nested_model_LLMQParams , value : * mut std :: os :: raw :: c_char) { (* obj) . r#type = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_set_known_confirmed_at_height (obj : * mut example_nested_model_LLMQParams , value : * mut u32) { (* obj) . known_confirmed_at_height = value ; } pub mod ferment_example { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::ferment_example::get_rotated_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_ferment_example_get_rotated_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: ferment_example :: get_rotated_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::ferment_example::get_crazy_case`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_ferment_example_get_crazy_case () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: ferment_example :: get_crazy_case () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } pub mod some_inner { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::some_inner::get_normal_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_some_inner_get_normal_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: some_inner :: get_normal_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } pub mod some_inner_2 { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::some_inner_2::get_normal_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_some_inner_2_get_normal_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: some_inner_2 :: get_normal_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } } pub mod gen { use crate as example_nested ; pub mod dict { use crate as example_nested ; # [doc = "FFI-representation of the [`AllMapExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllMapExamples { pub k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , pub k_simple_v_opt_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 , pub k_simple_v_opt_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String , pub k_simple_v_opt_generic_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 , pub k_simple_v_opt_generic_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String , pub opt_map_k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , pub opt_map_k_simple_v_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String , pub opt_map_k_simple_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 , pub opt_map_k_generic_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 , pub map_k_opt_generic_v_opt_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMapExamples > for example_nested_gen_dict_AllMapExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllMapExamples) -> example_nested :: gen :: dict :: AllMapExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllMapExamples { k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_from (ffi_ref . k_simple_v_simple) , k_simple_v_opt_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < u32 > > >> :: ffi_from (ffi_ref . k_simple_v_opt_simple) , k_simple_v_opt_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < String > > >> :: ffi_from (ffi_ref . k_simple_v_opt_complex) , k_simple_v_opt_generic_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > >> :: ffi_from (ffi_ref . k_simple_v_opt_generic_simple) , k_simple_v_opt_generic_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > >> :: ffi_from (ffi_ref . k_simple_v_opt_generic_complex) , opt_map_k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_simple) , opt_map_k_simple_v_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , String > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_complex) , opt_map_k_simple_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Vec < u8 > > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_generic) , opt_map_k_generic_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > >> :: ffi_from_opt (ffi_ref . opt_map_k_generic_v_generic) , map_k_opt_generic_v_opt_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . map_k_opt_generic_v_opt_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMapExamples > for example_nested_gen_dict_AllMapExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllMapExamples) -> * const example_nested_gen_dict_AllMapExamples { ferment :: boxed (example_nested_gen_dict_AllMapExamples { k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_to (obj . k_simple_v_simple) , k_simple_v_opt_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < u32 > > >> :: ffi_to (obj . k_simple_v_opt_simple) , k_simple_v_opt_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < String > > >> :: ffi_to (obj . k_simple_v_opt_complex) , k_simple_v_opt_generic_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > >> :: ffi_to (obj . k_simple_v_opt_generic_simple) , k_simple_v_opt_generic_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > >> :: ffi_to (obj . k_simple_v_opt_generic_complex) , opt_map_k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_to_opt (obj . opt_map_k_simple_v_simple) , opt_map_k_simple_v_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , String > >> :: ffi_to_opt (obj . opt_map_k_simple_v_complex) , opt_map_k_simple_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Vec < u8 > > >> :: ffi_to_opt (obj . opt_map_k_simple_v_generic) , opt_map_k_generic_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > >> :: ffi_to_opt (obj . opt_map_k_generic_v_generic) , map_k_opt_generic_v_opt_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > >> :: ffi_to (obj . map_k_opt_generic_v_opt_generic) }) } } impl Drop for example_nested_gen_dict_AllMapExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . k_simple_v_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_complex) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_generic_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_generic_complex) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_simple) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_complex) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_generic_v_generic) ; ferment :: unbox_any (ffi_ref . map_k_opt_generic_v_opt_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_ctor (k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , k_simple_v_opt_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 , k_simple_v_opt_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String , k_simple_v_opt_generic_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 , k_simple_v_opt_generic_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String , opt_map_k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , opt_map_k_simple_v_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String , opt_map_k_simple_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 , opt_map_k_generic_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 , map_k_opt_generic_v_opt_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) -> * mut example_nested_gen_dict_AllMapExamples { ferment :: boxed (example_nested_gen_dict_AllMapExamples { k_simple_v_simple , k_simple_v_opt_simple , k_simple_v_opt_complex , k_simple_v_opt_generic_simple , k_simple_v_opt_generic_complex , opt_map_k_simple_v_simple , opt_map_k_simple_v_complex , opt_map_k_simple_v_generic , opt_map_k_generic_v_generic , map_k_opt_generic_v_opt_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_destroy (ffi : * mut example_nested_gen_dict_AllMapExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_simple (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_simple (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 { (* obj) . k_simple_v_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_complex (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String { (* obj) . k_simple_v_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_generic_simple (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 { (* obj) . k_simple_v_opt_generic_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_generic_complex (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String { (* obj) . k_simple_v_opt_generic_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_simple (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . opt_map_k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_complex (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String { (* obj) . opt_map_k_simple_v_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_generic (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 { (* obj) . opt_map_k_simple_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_generic_v_generic (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 { (* obj) . opt_map_k_generic_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_map_k_opt_generic_v_opt_generic (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { (* obj) . map_k_opt_generic_v_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_simple (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32) { (* obj) . k_simple_v_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_simple (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32) { (* obj) . k_simple_v_opt_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_complex (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String) { (* obj) . k_simple_v_opt_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_generic_simple (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32) { (* obj) . k_simple_v_opt_generic_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_generic_complex (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String) { (* obj) . k_simple_v_opt_generic_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_simple (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32) { (* obj) . opt_map_k_simple_v_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_complex (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String) { (* obj) . opt_map_k_simple_v_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_generic (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8) { (* obj) . opt_map_k_simple_v_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_generic_v_generic (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8) { (* obj) . opt_map_k_generic_v_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_map_k_opt_generic_v_opt_generic (obj : * mut example_nested_gen_dict_AllMapExamples , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) { (* obj) . map_k_opt_generic_v_opt_generic = value ; } # [doc = "FFI-representation of the [`AllResultExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllResultExamples { pub result_ok_simple_err_simple : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , pub result_ok_complex_err_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_String , pub result_ok_complex_2_err_complex : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot , pub result_ok_complex_err_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 , pub result_ok_complex_err_opt_simple : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 , pub result_ok_complex_err_opt_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String , pub result_ok_complex_err_opt_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 , pub crazy_type : * mut crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , pub crazy_type_2 : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllResultExamples > for example_nested_gen_dict_AllResultExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllResultExamples) -> example_nested :: gen :: dict :: AllResultExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllResultExamples { result_ok_simple_err_simple : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionFrom < Result < u32 , u32 > >> :: ffi_from (ffi_ref . result_ok_simple_err_simple) , result_ok_complex_err_complex : < crate :: fermented :: generics :: Result_ok_String_err_String as ferment :: FFIConversionFrom < Result < String , String > >> :: ffi_from (ffi_ref . result_ok_complex_err_complex) , result_ok_complex_2_err_complex : < crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < Result < snapshot :: LLMQSnapshot , snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . result_ok_complex_2_err_complex) , result_ok_complex_err_generic : < crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 as ferment :: FFIConversionFrom < Result < String , Vec < u8 > > >> :: ffi_from (ffi_ref . result_ok_complex_err_generic) , result_ok_complex_err_opt_simple : < crate :: fermented :: generics :: Result_ok_String_err_Option_u32 as ferment :: FFIConversionFrom < Result < String , Option < u32 > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_simple) , result_ok_complex_err_opt_complex : < crate :: fermented :: generics :: Result_ok_String_err_Option_String as ferment :: FFIConversionFrom < Result < String , Option < String > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_complex) , result_ok_complex_err_opt_generic : < crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 as ferment :: FFIConversionFrom < Result < String , Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_generic) , crazy_type : < crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type) , crazy_type_2 : < crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_from (ffi_ref . crazy_type_2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllResultExamples > for example_nested_gen_dict_AllResultExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllResultExamples) -> * const example_nested_gen_dict_AllResultExamples { ferment :: boxed (example_nested_gen_dict_AllResultExamples { result_ok_simple_err_simple : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj . result_ok_simple_err_simple) , result_ok_complex_err_complex : < crate :: fermented :: generics :: Result_ok_String_err_String as ferment :: FFIConversionTo < Result < String , String > >> :: ffi_to (obj . result_ok_complex_err_complex) , result_ok_complex_2_err_complex : < crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < Result < snapshot :: LLMQSnapshot , snapshot :: LLMQSnapshot > >> :: ffi_to (obj . result_ok_complex_2_err_complex) , result_ok_complex_err_generic : < crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 as ferment :: FFIConversionTo < Result < String , Vec < u8 > > >> :: ffi_to (obj . result_ok_complex_err_generic) , result_ok_complex_err_opt_simple : < crate :: fermented :: generics :: Result_ok_String_err_Option_u32 as ferment :: FFIConversionTo < Result < String , Option < u32 > > >> :: ffi_to (obj . result_ok_complex_err_opt_simple) , result_ok_complex_err_opt_complex : < crate :: fermented :: generics :: Result_ok_String_err_Option_String as ferment :: FFIConversionTo < Result < String , Option < String > > >> :: ffi_to (obj . result_ok_complex_err_opt_complex) , result_ok_complex_err_opt_generic : < crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 as ferment :: FFIConversionTo < Result < String , Option < Vec < u8 > > > >> :: ffi_to (obj . result_ok_complex_err_opt_generic) , crazy_type : < crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type) , crazy_type_2 : < crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_to (obj . crazy_type_2) }) } } impl Drop for example_nested_gen_dict_AllResultExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . result_ok_simple_err_simple) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_2_err_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_generic) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_simple) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_generic) ; ferment :: unbox_any (ffi_ref . crazy_type) ; ferment :: unbox_any (ffi_ref . crazy_type_2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_ctor (result_ok_simple_err_simple : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , result_ok_complex_err_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_String , result_ok_complex_2_err_complex : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot , result_ok_complex_err_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 , result_ok_complex_err_opt_simple : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 , result_ok_complex_err_opt_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String , result_ok_complex_err_opt_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 , crazy_type : * mut crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , crazy_type_2 : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllResultExamples { ferment :: boxed (example_nested_gen_dict_AllResultExamples { result_ok_simple_err_simple , result_ok_complex_err_complex , result_ok_complex_2_err_complex , result_ok_complex_err_generic , result_ok_complex_err_opt_simple , result_ok_complex_err_opt_complex , result_ok_complex_err_opt_generic , crazy_type , crazy_type_2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_destroy (ffi : * mut example_nested_gen_dict_AllResultExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_simple_err_simple (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { (* obj) . result_ok_simple_err_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_complex (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_String { (* obj) . result_ok_complex_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_2_err_complex (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot { (* obj) . result_ok_complex_2_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_generic (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 { (* obj) . result_ok_complex_err_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_simple (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 { (* obj) . result_ok_complex_err_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_complex (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String { (* obj) . result_ok_complex_err_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_generic (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 { (* obj) . result_ok_complex_err_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_crazy_type (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_crazy_type_2 (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_simple_err_simple (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32) { (* obj) . result_ok_simple_err_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_complex (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_String_err_String) { (* obj) . result_ok_complex_err_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_2_err_complex (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_snapshot_LLMQSnapshot) { (* obj) . result_ok_complex_2_err_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_generic (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8) { (* obj) . result_ok_complex_err_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_simple (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32) { (* obj) . result_ok_complex_err_opt_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_complex (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String) { (* obj) . result_ok_complex_err_opt_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_generic (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8) { (* obj) . result_ok_complex_err_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_crazy_type (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { (* obj) . crazy_type = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_crazy_type_2 (obj : * mut example_nested_gen_dict_AllResultExamples , value : * mut crate :: fermented :: generics :: Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) { (* obj) . crazy_type_2 = value ; } # [doc = "FFI-representation of the [`AllSetExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllSetExamples { pub btreeset_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 , pub btreeset_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub btreeset_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 , pub btreeset_opt_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 , pub btreeset_opt_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String , pub btreeset_opt_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 , pub hashset_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_u32 , pub hashset_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_String , pub hashset_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 , pub hashset_opt_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 , pub hashset_opt_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String , pub hashset_opt_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 , pub hashset_opt_complex_external : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllSetExamples > for example_nested_gen_dict_AllSetExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllSetExamples) -> example_nested :: gen :: dict :: AllSetExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllSetExamples { btreeset_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < u32 > >> :: ffi_from (ffi_ref . btreeset_simple) , btreeset_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . btreeset_complex) , btreeset_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Vec < u8 > > >> :: ffi_from (ffi_ref . btreeset_generic) , btreeset_opt_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < u32 > > >> :: ffi_from (ffi_ref . btreeset_opt_simple) , btreeset_opt_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < String > > >> :: ffi_from (ffi_ref . btreeset_opt_complex) , btreeset_opt_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . btreeset_opt_generic) , hashset_simple : < crate :: fermented :: generics :: std_collections_HashSet_u32 as ferment :: FFIConversionFrom < std :: collections :: HashSet < u32 > >> :: ffi_from (ffi_ref . hashset_simple) , hashset_complex : < crate :: fermented :: generics :: std_collections_HashSet_String as ferment :: FFIConversionFrom < std :: collections :: HashSet < String > >> :: ffi_from (ffi_ref . hashset_complex) , hashset_generic : < crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Vec < u8 > > >> :: ffi_from (ffi_ref . hashset_generic) , hashset_opt_simple : < crate :: fermented :: generics :: std_collections_HashSet_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < u32 > > >> :: ffi_from (ffi_ref . hashset_opt_simple) , hashset_opt_complex : < crate :: fermented :: generics :: std_collections_HashSet_Option_String as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < String > > >> :: ffi_from (ffi_ref . hashset_opt_complex) , hashset_opt_generic : < crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . hashset_opt_generic) , hashset_opt_complex_external : < crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_from (ffi_ref . hashset_opt_complex_external) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllSetExamples > for example_nested_gen_dict_AllSetExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllSetExamples) -> * const example_nested_gen_dict_AllSetExamples { ferment :: boxed (example_nested_gen_dict_AllSetExamples { btreeset_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < u32 > >> :: ffi_to (obj . btreeset_simple) , btreeset_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . btreeset_complex) , btreeset_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Vec < u8 > > >> :: ffi_to (obj . btreeset_generic) , btreeset_opt_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < u32 > > >> :: ffi_to (obj . btreeset_opt_simple) , btreeset_opt_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < String > > >> :: ffi_to (obj . btreeset_opt_complex) , btreeset_opt_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < Vec < u8 > > > >> :: ffi_to (obj . btreeset_opt_generic) , hashset_simple : < crate :: fermented :: generics :: std_collections_HashSet_u32 as ferment :: FFIConversionTo < std :: collections :: HashSet < u32 > >> :: ffi_to (obj . hashset_simple) , hashset_complex : < crate :: fermented :: generics :: std_collections_HashSet_String as ferment :: FFIConversionTo < std :: collections :: HashSet < String > >> :: ffi_to (obj . hashset_complex) , hashset_generic : < crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: HashSet < Vec < u8 > > >> :: ffi_to (obj . hashset_generic) , hashset_opt_simple : < crate :: fermented :: generics :: std_collections_HashSet_Option_u32 as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < u32 > > >> :: ffi_to (obj . hashset_opt_simple) , hashset_opt_complex : < crate :: fermented :: generics :: std_collections_HashSet_Option_String as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < String > > >> :: ffi_to (obj . hashset_opt_complex) , hashset_opt_generic : < crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < Vec < u8 > > > >> :: ffi_to (obj . hashset_opt_generic) , hashset_opt_complex_external : < crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_to (obj . hashset_opt_complex_external) }) } } impl Drop for example_nested_gen_dict_AllSetExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . btreeset_simple) ; ferment :: unbox_any (ffi_ref . btreeset_complex) ; ferment :: unbox_any (ffi_ref . btreeset_generic) ; ferment :: unbox_any (ffi_ref . btreeset_opt_simple) ; ferment :: unbox_any (ffi_ref . btreeset_opt_complex) ; ferment :: unbox_any (ffi_ref . btreeset_opt_generic) ; ferment :: unbox_any (ffi_ref . hashset_simple) ; ferment :: unbox_any (ffi_ref . hashset_complex) ; ferment :: unbox_any (ffi_ref . hashset_generic) ; ferment :: unbox_any (ffi_ref . hashset_opt_simple) ; ferment :: unbox_any (ffi_ref . hashset_opt_complex) ; ferment :: unbox_any (ffi_ref . hashset_opt_generic) ; ferment :: unbox_any (ffi_ref . hashset_opt_complex_external) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_ctor (btreeset_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 , btreeset_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , btreeset_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 , btreeset_opt_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 , btreeset_opt_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String , btreeset_opt_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 , hashset_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_u32 , hashset_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_String , hashset_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 , hashset_opt_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 , hashset_opt_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String , hashset_opt_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 , hashset_opt_complex_external : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllSetExamples { ferment :: boxed (example_nested_gen_dict_AllSetExamples { btreeset_simple , btreeset_complex , btreeset_generic , btreeset_opt_simple , btreeset_opt_complex , btreeset_opt_generic , hashset_simple , hashset_complex , hashset_generic , hashset_opt_simple , hashset_opt_complex , hashset_opt_generic , hashset_opt_complex_external }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_destroy (ffi : * mut example_nested_gen_dict_AllSetExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_simple (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 { (* obj) . btreeset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_complex (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . btreeset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_generic (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 { (* obj) . btreeset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_simple (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 { (* obj) . btreeset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_complex (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String { (* obj) . btreeset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_generic (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 { (* obj) . btreeset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_simple (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_u32 { (* obj) . hashset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_complex (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_String { (* obj) . hashset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_generic (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 { (* obj) . hashset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_simple (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 { (* obj) . hashset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_complex (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String { (* obj) . hashset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_generic (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 { (* obj) . hashset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_complex_external (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . hashset_opt_complex_external } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_simple (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32) { (* obj) . btreeset_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_complex (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) { (* obj) . btreeset_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_generic (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8) { (* obj) . btreeset_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_simple (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32) { (* obj) . btreeset_opt_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_complex (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String) { (* obj) . btreeset_opt_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_generic (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8) { (* obj) . btreeset_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_simple (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_u32) { (* obj) . hashset_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_complex (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_String) { (* obj) . hashset_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_generic (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8) { (* obj) . hashset_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_simple (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32) { (* obj) . hashset_opt_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_complex (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String) { (* obj) . hashset_opt_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_generic (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8) { (* obj) . hashset_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_complex_external (obj : * mut example_nested_gen_dict_AllSetExamples , value : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) { (* obj) . hashset_opt_complex_external = value ; } # [doc = "FFI-representation of the [`AllVecExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllVecExamples { pub vec_simple : * mut crate :: fermented :: generics :: Vec_u32 , pub vec_complex : * mut crate :: fermented :: generics :: Vec_String , pub vec_generic : * mut crate :: fermented :: generics :: Vec_Vec_u8 , pub vec_opt_simple : * mut crate :: fermented :: generics :: Vec_Option_u32 , pub vec_opt_complex : * mut crate :: fermented :: generics :: Vec_Option_String , pub vec_opt_generic : * mut crate :: fermented :: generics :: Vec_Option_Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllVecExamples > for example_nested_gen_dict_AllVecExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllVecExamples) -> example_nested :: gen :: dict :: AllVecExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllVecExamples { vec_simple : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from (ffi_ref . vec_simple) , vec_complex : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . vec_complex) , vec_generic : < crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionFrom < Vec < Vec < u8 > > >> :: ffi_from (ffi_ref . vec_generic) , vec_opt_simple : < crate :: fermented :: generics :: Vec_Option_u32 as ferment :: FFIConversionFrom < Vec < Option < u32 > > >> :: ffi_from (ffi_ref . vec_opt_simple) , vec_opt_complex : < crate :: fermented :: generics :: Vec_Option_String as ferment :: FFIConversionFrom < Vec < Option < String > > >> :: ffi_from (ffi_ref . vec_opt_complex) , vec_opt_generic : < crate :: fermented :: generics :: Vec_Option_Vec_u8 as ferment :: FFIConversionFrom < Vec < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . vec_opt_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllVecExamples > for example_nested_gen_dict_AllVecExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllVecExamples) -> * const example_nested_gen_dict_AllVecExamples { ferment :: boxed (example_nested_gen_dict_AllVecExamples { vec_simple : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionTo < Vec < u32 > >> :: ffi_to (obj . vec_simple) , vec_complex : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . vec_complex) , vec_generic : < crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionTo < Vec < Vec < u8 > > >> :: ffi_to (obj . vec_generic) , vec_opt_simple : < crate :: fermented :: generics :: Vec_Option_u32 as ferment :: FFIConversionTo < Vec < Option < u32 > > >> :: ffi_to (obj . vec_opt_simple) , vec_opt_complex : < crate :: fermented :: generics :: Vec_Option_String as ferment :: FFIConversionTo < Vec < Option < String > > >> :: ffi_to (obj . vec_opt_complex) , vec_opt_generic : < crate :: fermented :: generics :: Vec_Option_Vec_u8 as ferment :: FFIConversionTo < Vec < Option < Vec < u8 > > > >> :: ffi_to (obj . vec_opt_generic) }) } } impl Drop for example_nested_gen_dict_AllVecExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vec_simple) ; ferment :: unbox_any (ffi_ref . vec_complex) ; ferment :: unbox_any (ffi_ref . vec_generic) ; ferment :: unbox_any (ffi_ref . vec_opt_simple) ; ferment :: unbox_any (ffi_ref . vec_opt_complex) ; ferment :: unbox_any (ffi_ref . vec_opt_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_ctor (vec_simple : * mut crate :: fermented :: generics :: Vec_u32 , vec_complex : * mut crate :: fermented :: generics :: Vec_String , vec_generic : * mut crate :: fermented :: generics :: Vec_Vec_u8 , vec_opt_simple : * mut crate :: fermented :: generics :: Vec_Option_u32 , vec_opt_complex : * mut crate :: fermented :: generics :: Vec_Option_String , vec_opt_generic : * mut crate :: fermented :: generics :: Vec_Option_Vec_u8) -> * mut example_nested_gen_dict_AllVecExamples { ferment :: boxed (example_nested_gen_dict_AllVecExamples { vec_simple , vec_complex , vec_generic , vec_opt_simple , vec_opt_complex , vec_opt_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_destroy (ffi : * mut example_nested_gen_dict_AllVecExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_simple (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_u32 { (* obj) . vec_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_complex (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . vec_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_generic (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Vec_u8 { (* obj) . vec_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_simple (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_u32 { (* obj) . vec_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_complex (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_String { (* obj) . vec_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_generic (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_Vec_u8 { (* obj) . vec_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_simple (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_u32) { (* obj) . vec_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_complex (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_String) { (* obj) . vec_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_generic (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_Vec_u8) { (* obj) . vec_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_simple (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_Option_u32) { (* obj) . vec_opt_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_complex (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_Option_String) { (* obj) . vec_opt_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_generic (obj : * mut example_nested_gen_dict_AllVecExamples , value : * mut crate :: fermented :: generics :: Vec_Option_Vec_u8) { (* obj) . vec_opt_generic = value ; } # [doc = "FFI-representation of the [`AllArrExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllArrExamples { pub arr : * mut crate :: fermented :: generics :: Arr_u8_32 , pub opt_arr : * mut crate :: fermented :: generics :: Arr_u8_32 , pub complex_arr : * mut crate :: fermented :: generics :: Arr_String_32 , pub complex_arr_2 : * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 , pub generic_arr_2 : * mut crate :: fermented :: generics :: Arr_Vec_u8_32 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArrExamples > for example_nested_gen_dict_AllArrExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllArrExamples) -> example_nested :: gen :: dict :: AllArrExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllArrExamples { arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . arr) , opt_arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_ref . opt_arr) , complex_arr : < crate :: fermented :: generics :: Arr_String_32 as ferment :: FFIConversionFrom < [String ; 32] >> :: ffi_from (ffi_ref . complex_arr) , complex_arr_2 : < crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 as ferment :: FFIConversionFrom < [example_nested :: model :: Quorum ; 32] >> :: ffi_from (ffi_ref . complex_arr_2) , generic_arr_2 : < crate :: fermented :: generics :: Arr_Vec_u8_32 as ferment :: FFIConversionFrom < [Vec < u8 > ; 32] >> :: ffi_from (ffi_ref . generic_arr_2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArrExamples > for example_nested_gen_dict_AllArrExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllArrExamples) -> * const example_nested_gen_dict_AllArrExamples { ferment :: boxed (example_nested_gen_dict_AllArrExamples { arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . arr) , opt_arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to_opt (obj . opt_arr) , complex_arr : < crate :: fermented :: generics :: Arr_String_32 as ferment :: FFIConversionTo < [String ; 32] >> :: ffi_to (obj . complex_arr) , complex_arr_2 : < crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 as ferment :: FFIConversionTo < [example_nested :: model :: Quorum ; 32] >> :: ffi_to (obj . complex_arr_2) , generic_arr_2 : < crate :: fermented :: generics :: Arr_Vec_u8_32 as ferment :: FFIConversionTo < [Vec < u8 > ; 32] >> :: ffi_to (obj . generic_arr_2) }) } } impl Drop for example_nested_gen_dict_AllArrExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arr) ; ferment :: unbox_any_opt (ffi_ref . opt_arr) ; ferment :: unbox_any (ffi_ref . complex_arr) ; ferment :: unbox_any (ffi_ref . complex_arr_2) ; ferment :: unbox_any (ffi_ref . generic_arr_2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_ctor (arr : * mut crate :: fermented :: generics :: Arr_u8_32 , opt_arr : * mut crate :: fermented :: generics :: Arr_u8_32 , complex_arr : * mut crate :: fermented :: generics :: Arr_String_32 , complex_arr_2 : * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 , generic_arr_2 : * mut crate :: fermented :: generics :: Arr_Vec_u8_32) -> * mut example_nested_gen_dict_AllArrExamples { ferment :: boxed (example_nested_gen_dict_AllArrExamples { arr , opt_arr , complex_arr , complex_arr_2 , generic_arr_2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_destroy (ffi : * mut example_nested_gen_dict_AllArrExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_arr (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_opt_arr (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . opt_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_complex_arr (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_String_32 { (* obj) . complex_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_complex_arr_2 (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 { (* obj) . complex_arr_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_generic_arr_2 (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_Vec_u8_32 { (* obj) . generic_arr_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_arr (obj : * mut example_nested_gen_dict_AllArrExamples , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . arr = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_opt_arr (obj : * mut example_nested_gen_dict_AllArrExamples , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . opt_arr = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_complex_arr (obj : * mut example_nested_gen_dict_AllArrExamples , value : * mut crate :: fermented :: generics :: Arr_String_32) { (* obj) . complex_arr = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_complex_arr_2 (obj : * mut example_nested_gen_dict_AllArrExamples , value : * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32) { (* obj) . complex_arr_2 = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_generic_arr_2 (obj : * mut example_nested_gen_dict_AllArrExamples , value : * mut crate :: fermented :: generics :: Arr_Vec_u8_32) { (* obj) . generic_arr_2 = value ; } # [doc = "FFI-representation of the [`AllTupleExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllTupleExamples { pub tuple_string : * mut crate :: fermented :: generics :: Tuple_String_String , pub tuple_with_generic : * mut crate :: fermented :: generics :: Tuple_String_Vec_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllTupleExamples > for example_nested_gen_dict_AllTupleExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllTupleExamples) -> example_nested :: gen :: dict :: AllTupleExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllTupleExamples { tuple_string : < crate :: fermented :: generics :: Tuple_String_String as ferment :: FFIConversionFrom < (String , String) >> :: ffi_from (ffi_ref . tuple_string) , tuple_with_generic : < crate :: fermented :: generics :: Tuple_String_Vec_String as ferment :: FFIConversionFrom < (String , Vec < String >) >> :: ffi_from (ffi_ref . tuple_with_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllTupleExamples > for example_nested_gen_dict_AllTupleExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllTupleExamples) -> * const example_nested_gen_dict_AllTupleExamples { ferment :: boxed (example_nested_gen_dict_AllTupleExamples { tuple_string : < crate :: fermented :: generics :: Tuple_String_String as ferment :: FFIConversionTo < (String , String) >> :: ffi_to (obj . tuple_string) , tuple_with_generic : < crate :: fermented :: generics :: Tuple_String_Vec_String as ferment :: FFIConversionTo < (String , Vec < String >) >> :: ffi_to (obj . tuple_with_generic) }) } } impl Drop for example_nested_gen_dict_AllTupleExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple_string) ; ferment :: unbox_any (ffi_ref . tuple_with_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_ctor (tuple_string : * mut crate :: fermented :: generics :: Tuple_String_String , tuple_with_generic : * mut crate :: fermented :: generics :: Tuple_String_Vec_String) -> * mut example_nested_gen_dict_AllTupleExamples { ferment :: boxed (example_nested_gen_dict_AllTupleExamples { tuple_string , tuple_with_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_destroy (ffi : * mut example_nested_gen_dict_AllTupleExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_get_tuple_string (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_String { (* obj) . tuple_string } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_get_tuple_with_generic (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_Vec_String { (* obj) . tuple_with_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_set_tuple_string (obj : * mut example_nested_gen_dict_AllTupleExamples , value : * mut crate :: fermented :: generics :: Tuple_String_String) { (* obj) . tuple_string = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_set_tuple_with_generic (obj : * mut example_nested_gen_dict_AllTupleExamples , value : * mut crate :: fermented :: generics :: Tuple_String_Vec_String) { (* obj) . tuple_with_generic = value ; } # [doc = "FFI-representation of the [`AllOptExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllOptExamples { pub opt_complex : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllOptExamples > for example_nested_gen_dict_AllOptExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllOptExamples) -> example_nested :: gen :: dict :: AllOptExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllOptExamples { opt_complex : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . opt_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllOptExamples > for example_nested_gen_dict_AllOptExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllOptExamples) -> * const example_nested_gen_dict_AllOptExamples { ferment :: boxed (example_nested_gen_dict_AllOptExamples { opt_complex : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . opt_complex) }) } } impl Drop for example_nested_gen_dict_AllOptExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . opt_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_ctor (opt_complex : * mut std :: os :: raw :: c_char) -> * mut example_nested_gen_dict_AllOptExamples { ferment :: boxed (example_nested_gen_dict_AllOptExamples { opt_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_destroy (ffi : * mut example_nested_gen_dict_AllOptExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_get_opt_complex (obj : * const example_nested_gen_dict_AllOptExamples) -> * mut std :: os :: raw :: c_char { (* obj) . opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_set_opt_complex (obj : * mut example_nested_gen_dict_AllOptExamples , value : * mut std :: os :: raw :: c_char) { (* obj) . opt_complex = value ; } # [doc = "FFI-representation of the [`AllArcExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllArcExamples { pub arc_simple : * mut crate :: fermented :: generics :: std_sync_Arc_u32 , pub arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot , pub arc_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 , pub arc_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_Option_String , pub crazy_type1 : * mut crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , pub crazy_type2 : * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArcExamples > for example_nested_gen_dict_AllArcExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllArcExamples) -> example_nested :: gen :: dict :: AllArcExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllArcExamples { arc_simple : < crate :: fermented :: generics :: std_sync_Arc_u32 as ferment :: FFIConversionFrom < std :: sync :: Arc < u32 > >> :: ffi_from (ffi_ref . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_sync_Arc_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Arc < Vec < u8 > > >> :: ffi_from (ffi_ref . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_sync_Arc_Option_String as ferment :: FFIConversionFrom < std :: sync :: Arc < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_arc_complex) , crazy_type1 : < crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type1) , crazy_type2 : < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArcExamples > for example_nested_gen_dict_AllArcExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllArcExamples) -> * const example_nested_gen_dict_AllArcExamples { ferment :: boxed (example_nested_gen_dict_AllArcExamples { arc_simple : < crate :: fermented :: generics :: std_sync_Arc_u32 as ferment :: FFIConversionTo < std :: sync :: Arc < u32 > >> :: ffi_to (obj . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < snapshot :: LLMQSnapshot > >> :: ffi_to (obj . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_sync_Arc_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: Arc < Vec < u8 > > >> :: ffi_to (obj . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_sync_Arc_Option_String as ferment :: FFIConversionTo < std :: sync :: Arc < Option < String > > >> :: ffi_to_opt (obj . opt_arc_complex) , crazy_type1 : < crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type1) , crazy_type2 : < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type2) }) } } impl Drop for example_nested_gen_dict_AllArcExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arc_simple) ; ferment :: unbox_any (ffi_ref . arc_complex) ; ferment :: unbox_any (ffi_ref . arc_generic) ; ferment :: unbox_any (ffi_ref . arc_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_arc_complex) ; ferment :: unbox_any (ffi_ref . crazy_type1) ; ferment :: unbox_any (ffi_ref . crazy_type2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_ctor (arc_simple : * mut crate :: fermented :: generics :: std_sync_Arc_u32 , arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot , arc_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 , arc_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_Option_String , crazy_type1 : * mut crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , crazy_type2 : * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllArcExamples { ferment :: boxed (example_nested_gen_dict_AllArcExamples { arc_simple , arc_complex , arc_generic , arc_opt_generic , opt_arc_complex , crazy_type1 , crazy_type2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_destroy (ffi : * mut example_nested_gen_dict_AllArcExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_simple (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_complex (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_generic (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_opt_generic (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_opt_arc_complex (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_String { (* obj) . opt_arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_crazy_type1 (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type1 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_crazy_type2 (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_simple (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_u32) { (* obj) . arc_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_complex (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot) { (* obj) . arc_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_generic (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8) { (* obj) . arc_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_opt_generic (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . arc_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_opt_arc_complex (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_Option_String) { (* obj) . opt_arc_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_crazy_type1 (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { (* obj) . crazy_type1 = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_crazy_type2 (obj : * mut example_nested_gen_dict_AllArcExamples , value : * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { (* obj) . crazy_type2 = value ; } # [doc = "FFI-representation of the [`AllRcExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRcExamples { pub arc_simple : * mut crate :: fermented :: generics :: std_rc_Rc_u32 , pub arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot , pub arc_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 , pub arc_opt_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_Option_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRcExamples > for example_nested_gen_dict_AllRcExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRcExamples) -> example_nested :: gen :: dict :: AllRcExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRcExamples { arc_simple : < crate :: fermented :: generics :: std_rc_Rc_u32 as ferment :: FFIConversionFrom < std :: rc :: Rc < u32 > >> :: ffi_from (ffi_ref . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: rc :: Rc < snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_rc_Rc_Vec_u8 as ferment :: FFIConversionFrom < std :: rc :: Rc < Vec < u8 > > >> :: ffi_from (ffi_ref . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_rc_Rc_Option_String as ferment :: FFIConversionFrom < std :: rc :: Rc < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_arc_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRcExamples > for example_nested_gen_dict_AllRcExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRcExamples) -> * const example_nested_gen_dict_AllRcExamples { ferment :: boxed (example_nested_gen_dict_AllRcExamples { arc_simple : < crate :: fermented :: generics :: std_rc_Rc_u32 as ferment :: FFIConversionTo < std :: rc :: Rc < u32 > >> :: ffi_to (obj . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: rc :: Rc < snapshot :: LLMQSnapshot > >> :: ffi_to (obj . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_rc_Rc_Vec_u8 as ferment :: FFIConversionTo < std :: rc :: Rc < Vec < u8 > > >> :: ffi_to (obj . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_rc_Rc_Option_String as ferment :: FFIConversionTo < std :: rc :: Rc < Option < String > > >> :: ffi_to_opt (obj . opt_arc_complex) }) } } impl Drop for example_nested_gen_dict_AllRcExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arc_simple) ; ferment :: unbox_any (ffi_ref . arc_complex) ; ferment :: unbox_any (ffi_ref . arc_generic) ; ferment :: unbox_any (ffi_ref . arc_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_arc_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_ctor (arc_simple : * mut crate :: fermented :: generics :: std_rc_Rc_u32 , arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot , arc_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 , arc_opt_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_Option_String) -> * mut example_nested_gen_dict_AllRcExamples { ferment :: boxed (example_nested_gen_dict_AllRcExamples { arc_simple , arc_complex , arc_generic , arc_opt_generic , opt_arc_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_destroy (ffi : * mut example_nested_gen_dict_AllRcExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_simple (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_complex (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_generic (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_opt_generic (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_opt_arc_complex (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_String { (* obj) . opt_arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_simple (obj : * mut example_nested_gen_dict_AllRcExamples , value : * mut crate :: fermented :: generics :: std_rc_Rc_u32) { (* obj) . arc_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_complex (obj : * mut example_nested_gen_dict_AllRcExamples , value : * mut crate :: fermented :: generics :: std_rc_Rc_snapshot_LLMQSnapshot) { (* obj) . arc_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_generic (obj : * mut example_nested_gen_dict_AllRcExamples , value : * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8) { (* obj) . arc_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_opt_generic (obj : * mut example_nested_gen_dict_AllRcExamples , value : * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . arc_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_opt_arc_complex (obj : * mut example_nested_gen_dict_AllRcExamples , value : * mut crate :: fermented :: generics :: std_rc_Rc_Option_String) { (* obj) . opt_arc_complex = value ; } # [doc = "FFI-representation of the [`AllMutexExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllMutexExamples { pub mutex_simple : * mut crate :: fermented :: generics :: std_sync_Mutex_u32 , pub mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot , pub mutex_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 , pub mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String , pub platform_case : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMutexExamples > for example_nested_gen_dict_AllMutexExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllMutexExamples) -> example_nested :: gen :: dict :: AllMutexExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > >> :: ffi_from (ffi_ref . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_from (ffi_ref . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < Box < snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . platform_case) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMutexExamples > for example_nested_gen_dict_AllMutexExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllMutexExamples) -> * const example_nested_gen_dict_AllMutexExamples { ferment :: boxed (example_nested_gen_dict_AllMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionTo < std :: sync :: Mutex < u32 > >> :: ffi_to (obj . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < snapshot :: LLMQSnapshot > >> :: ffi_to (obj . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_to (obj . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < String > > >> :: ffi_to_opt (obj . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < Box < snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . platform_case) }) } } impl Drop for example_nested_gen_dict_AllMutexExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . mutex_simple) ; ferment :: unbox_any (ffi_ref . mutex_complex) ; ferment :: unbox_any (ffi_ref . mutex_generic) ; ferment :: unbox_any (ffi_ref . mutex_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_mutex_complex) ; ferment :: unbox_any (ffi_ref . platform_case) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_ctor (mutex_simple : * mut crate :: fermented :: generics :: std_sync_Mutex_u32 , mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot , mutex_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 , mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String , platform_case : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot) -> * mut example_nested_gen_dict_AllMutexExamples { ferment :: boxed (example_nested_gen_dict_AllMutexExamples { mutex_simple , mutex_complex , mutex_generic , mutex_opt_generic , opt_mutex_complex , platform_case }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_destroy (ffi : * mut example_nested_gen_dict_AllMutexExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_simple (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_u32 { (* obj) . mutex_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_complex (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot { (* obj) . mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_generic (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 { (* obj) . mutex_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_opt_generic (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . mutex_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_opt_mutex_complex (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String { (* obj) . opt_mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_platform_case (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot { (* obj) . platform_case } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_simple (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_u32) { (* obj) . mutex_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_complex (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_snapshot_LLMQSnapshot) { (* obj) . mutex_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_generic (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8) { (* obj) . mutex_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_opt_generic (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . mutex_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_opt_mutex_complex (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String) { (* obj) . opt_mutex_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_platform_case (obj : * mut example_nested_gen_dict_AllMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot) { (* obj) . platform_case = value ; } # [doc = "FFI-representation of the [`ArcMutexExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_ArcMutexExamples { pub mutex_simple : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 , pub mutex_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot , pub mutex_generic : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 , pub mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String , pub platform_case : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: ArcMutexExamples > for example_nested_gen_dict_ArcMutexExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_ArcMutexExamples) -> example_nested :: gen :: dict :: ArcMutexExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: ArcMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < u32 > > >> :: ffi_from (ffi_ref . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < snapshot :: LLMQSnapshot > > >> :: ffi_from (ffi_ref . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > >> :: ffi_from (ffi_ref . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > >> :: ffi_from (ffi_ref . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > >> :: ffi_from_opt (ffi_ref . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < Box < snapshot :: LLMQSnapshot > > > > >> :: ffi_from (ffi_ref . platform_case) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: ArcMutexExamples > for example_nested_gen_dict_ArcMutexExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: ArcMutexExamples) -> * const example_nested_gen_dict_ArcMutexExamples { ferment :: boxed (example_nested_gen_dict_ArcMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < u32 > > >> :: ffi_to (obj . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < snapshot :: LLMQSnapshot > > >> :: ffi_to (obj . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > >> :: ffi_to (obj . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > >> :: ffi_to (obj . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > >> :: ffi_to_opt (obj . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Option < Box < snapshot :: LLMQSnapshot > > > > >> :: ffi_to (obj . platform_case) }) } } impl Drop for example_nested_gen_dict_ArcMutexExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . mutex_simple) ; ferment :: unbox_any (ffi_ref . mutex_complex) ; ferment :: unbox_any (ffi_ref . mutex_generic) ; ferment :: unbox_any (ffi_ref . mutex_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_mutex_complex) ; ferment :: unbox_any (ffi_ref . platform_case) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_ctor (mutex_simple : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 , mutex_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot , mutex_generic : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 , mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String , platform_case : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot) -> * mut example_nested_gen_dict_ArcMutexExamples { ferment :: boxed (example_nested_gen_dict_ArcMutexExamples { mutex_simple , mutex_complex , mutex_generic , mutex_opt_generic , opt_mutex_complex , platform_case }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_destroy (ffi : * mut example_nested_gen_dict_ArcMutexExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_mutex_simple (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 { (* obj) . mutex_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_mutex_complex (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot { (* obj) . mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_mutex_generic (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 { (* obj) . mutex_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_mutex_opt_generic (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . mutex_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_opt_mutex_complex (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String { (* obj) . opt_mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_get_platform_case (obj : * const example_nested_gen_dict_ArcMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot { (* obj) . platform_case } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_mutex_simple (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32) { (* obj) . mutex_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_mutex_complex (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_snapshot_LLMQSnapshot) { (* obj) . mutex_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_mutex_generic (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8) { (* obj) . mutex_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_mutex_opt_generic (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . mutex_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_opt_mutex_complex (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String) { (* obj) . opt_mutex_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_ArcMutexExamples_set_platform_case (obj : * mut example_nested_gen_dict_ArcMutexExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_Box_snapshot_LLMQSnapshot) { (* obj) . platform_case = value ; } # [doc = "FFI-representation of the [`AllRwLockExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRwLockExamples { pub rwlock_simple : * mut crate :: fermented :: generics :: std_sync_RwLock_u32 , pub rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot , pub rwlock_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 , pub rwlock_opt_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String , pub arc_rw_lock_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot , pub arc_rw_lock_complex_opaque : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRwLockExamples > for example_nested_gen_dict_AllRwLockExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRwLockExamples) -> example_nested :: gen :: dict :: AllRwLockExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRwLockExamples { rwlock_simple : < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > >> :: ffi_from (ffi_ref . rwlock_simple) , rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . rwlock_complex) , rwlock_generic : < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_from (ffi_ref . rwlock_generic) , rwlock_opt_generic : < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . rwlock_opt_generic) , opt_rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_rwlock_complex) , arc_rw_lock_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < snapshot :: LLMQSnapshot > > >> :: ffi_from (ffi_ref . arc_rw_lock_complex) , arc_rw_lock_complex_opaque : < crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample as ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > >> :: ffi_from (ffi_ref . arc_rw_lock_complex_opaque) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRwLockExamples > for example_nested_gen_dict_AllRwLockExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRwLockExamples) -> * const example_nested_gen_dict_AllRwLockExamples { ferment :: boxed (example_nested_gen_dict_AllRwLockExamples { rwlock_simple : < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionTo < std :: sync :: RwLock < u32 > >> :: ffi_to (obj . rwlock_simple) , rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: RwLock < snapshot :: LLMQSnapshot > >> :: ffi_to (obj . rwlock_complex) , rwlock_generic : < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_to (obj . rwlock_generic) , rwlock_opt_generic : < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . rwlock_opt_generic) , opt_rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionTo < std :: sync :: RwLock < Option < String > > >> :: ffi_to_opt (obj . opt_rwlock_complex) , arc_rw_lock_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: RwLock < snapshot :: LLMQSnapshot > > >> :: ffi_to (obj . arc_rw_lock_complex) , arc_rw_lock_complex_opaque : < crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample as ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > >> :: ffi_to (obj . arc_rw_lock_complex_opaque) }) } } impl Drop for example_nested_gen_dict_AllRwLockExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . rwlock_simple) ; ferment :: unbox_any (ffi_ref . rwlock_complex) ; ferment :: unbox_any (ffi_ref . rwlock_generic) ; ferment :: unbox_any (ffi_ref . rwlock_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_rwlock_complex) ; ferment :: unbox_any (ffi_ref . arc_rw_lock_complex) ; ferment :: unbox_any (ffi_ref . arc_rw_lock_complex_opaque) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_ctor (rwlock_simple : * mut crate :: fermented :: generics :: std_sync_RwLock_u32 , rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot , rwlock_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 , rwlock_opt_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String , arc_rw_lock_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot , arc_rw_lock_complex_opaque : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample) -> * mut example_nested_gen_dict_AllRwLockExamples { ferment :: boxed (example_nested_gen_dict_AllRwLockExamples { rwlock_simple , rwlock_complex , rwlock_generic , rwlock_opt_generic , opt_rwlock_complex , arc_rw_lock_complex , arc_rw_lock_complex_opaque }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_destroy (ffi : * mut example_nested_gen_dict_AllRwLockExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_simple (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_u32 { (* obj) . rwlock_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_complex (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot { (* obj) . rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_generic (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 { (* obj) . rwlock_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_opt_generic (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . rwlock_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_opt_rwlock_complex (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String { (* obj) . opt_rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_arc_rw_lock_complex (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot { (* obj) . arc_rw_lock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_arc_rw_lock_complex_opaque (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample { (* obj) . arc_rw_lock_complex_opaque } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_simple (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_RwLock_u32) { (* obj) . rwlock_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_complex (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_RwLock_snapshot_LLMQSnapshot) { (* obj) . rwlock_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_generic (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8) { (* obj) . rwlock_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_opt_generic (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . rwlock_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_opt_rwlock_complex (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String) { (* obj) . opt_rwlock_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_arc_rw_lock_complex (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_snapshot_LLMQSnapshot) { (* obj) . arc_rw_lock_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_arc_rw_lock_complex_opaque (obj : * mut example_nested_gen_dict_AllRwLockExamples , value : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample) { (* obj) . arc_rw_lock_complex_opaque = value ; } # [doc = "FFI-representation of the [`AllRefCellExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRefCellExamples { pub refcell_simple : * mut crate :: fermented :: generics :: std_cell_RefCell_u32 , pub refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot , pub refcell_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 , pub refcell_opt_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , pub opt_refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRefCellExamples > for example_nested_gen_dict_AllRefCellExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRefCellExamples) -> example_nested :: gen :: dict :: AllRefCellExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRefCellExamples { refcell_simple : < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > >> :: ffi_from (ffi_ref . refcell_simple) , refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . refcell_complex) , refcell_generic : < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_from (ffi_ref . refcell_generic) , refcell_opt_generic : < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . refcell_opt_generic) , opt_refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_refcell_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRefCellExamples > for example_nested_gen_dict_AllRefCellExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRefCellExamples) -> * const example_nested_gen_dict_AllRefCellExamples { ferment :: boxed (example_nested_gen_dict_AllRefCellExamples { refcell_simple : < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionTo < std :: cell :: RefCell < u32 > >> :: ffi_to (obj . refcell_simple) , refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: cell :: RefCell < snapshot :: LLMQSnapshot > >> :: ffi_to (obj . refcell_complex) , refcell_generic : < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionTo < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_to (obj . refcell_generic) , refcell_opt_generic : < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . refcell_opt_generic) , opt_refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionTo < std :: cell :: RefCell < Option < String > > >> :: ffi_to_opt (obj . opt_refcell_complex) }) } } impl Drop for example_nested_gen_dict_AllRefCellExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . refcell_simple) ; ferment :: unbox_any (ffi_ref . refcell_complex) ; ferment :: unbox_any (ffi_ref . refcell_generic) ; ferment :: unbox_any (ffi_ref . refcell_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_refcell_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_ctor (refcell_simple : * mut crate :: fermented :: generics :: std_cell_RefCell_u32 , refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot , refcell_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 , refcell_opt_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , opt_refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String) -> * mut example_nested_gen_dict_AllRefCellExamples { ferment :: boxed (example_nested_gen_dict_AllRefCellExamples { refcell_simple , refcell_complex , refcell_generic , refcell_opt_generic , opt_refcell_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_destroy (ffi : * mut example_nested_gen_dict_AllRefCellExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_simple (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_u32 { (* obj) . refcell_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_complex (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot { (* obj) . refcell_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_generic (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 { (* obj) . refcell_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_opt_generic (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { (* obj) . refcell_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_opt_refcell_complex (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String { (* obj) . opt_refcell_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_simple (obj : * mut example_nested_gen_dict_AllRefCellExamples , value : * mut crate :: fermented :: generics :: std_cell_RefCell_u32) { (* obj) . refcell_simple = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_complex (obj : * mut example_nested_gen_dict_AllRefCellExamples , value : * mut crate :: fermented :: generics :: std_cell_RefCell_snapshot_LLMQSnapshot) { (* obj) . refcell_complex = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_generic (obj : * mut example_nested_gen_dict_AllRefCellExamples , value : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8) { (* obj) . refcell_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_opt_generic (obj : * mut example_nested_gen_dict_AllRefCellExamples , value : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { (* obj) . refcell_opt_generic = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_opt_refcell_complex (obj : * mut example_nested_gen_dict_AllRefCellExamples , value : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String) { (* obj) . opt_refcell_complex = value ; } # [doc = "FFI-representation of the [`AllExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllExamples { pub name : * mut std :: os :: raw :: c_char , pub all_map_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples , pub all_result_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples , pub all_set_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples , pub all_arr_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples , pub all_tuple_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples , pub all_opt_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllExamples > for example_nested_gen_dict_AllExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllExamples) -> example_nested :: gen :: dict :: AllExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllExamples { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , all_map_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMapExamples >> :: ffi_from (ffi_ref . all_map_examples) , all_result_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllResultExamples >> :: ffi_from (ffi_ref . all_result_examples) , all_set_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllSetExamples >> :: ffi_from (ffi_ref . all_set_examples) , all_arr_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArrExamples >> :: ffi_from (ffi_ref . all_arr_examples) , all_tuple_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllTupleExamples >> :: ffi_from (ffi_ref . all_tuple_examples) , all_opt_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllOptExamples >> :: ffi_from (ffi_ref . all_opt_examples) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllExamples > for example_nested_gen_dict_AllExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllExamples) -> * const example_nested_gen_dict_AllExamples { ferment :: boxed (example_nested_gen_dict_AllExamples { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , all_map_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMapExamples >> :: ffi_to (obj . all_map_examples) , all_result_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllResultExamples >> :: ffi_to (obj . all_result_examples) , all_set_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllSetExamples >> :: ffi_to (obj . all_set_examples) , all_arr_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArrExamples >> :: ffi_to (obj . all_arr_examples) , all_tuple_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllTupleExamples >> :: ffi_to (obj . all_tuple_examples) , all_opt_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllOptExamples >> :: ffi_to (obj . all_opt_examples) }) } } impl Drop for example_nested_gen_dict_AllExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . all_map_examples) ; ferment :: unbox_any (ffi_ref . all_result_examples) ; ferment :: unbox_any (ffi_ref . all_set_examples) ; ferment :: unbox_any (ffi_ref . all_arr_examples) ; ferment :: unbox_any (ffi_ref . all_tuple_examples) ; ferment :: unbox_any (ffi_ref . all_opt_examples) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_ctor (name : * mut std :: os :: raw :: c_char , all_map_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples , all_result_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples , all_set_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples , all_arr_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples , all_tuple_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples , all_opt_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples) -> * mut example_nested_gen_dict_AllExamples { ferment :: boxed (example_nested_gen_dict_AllExamples { name , all_map_examples , all_result_examples , all_set_examples , all_arr_examples , all_tuple_examples , all_opt_examples }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_destroy (ffi : * mut example_nested_gen_dict_AllExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_name (obj : * const example_nested_gen_dict_AllExamples) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_map_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples { (* obj) . all_map_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_result_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples { (* obj) . all_result_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_set_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples { (* obj) . all_set_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_arr_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples { (* obj) . all_arr_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_tuple_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples { (* obj) . all_tuple_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_opt_examples (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples { (* obj) . all_opt_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_name (obj : * mut example_nested_gen_dict_AllExamples , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_map_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples) { (* obj) . all_map_examples = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_result_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples) { (* obj) . all_result_examples = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_set_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples) { (* obj) . all_set_examples = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_arr_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples) { (* obj) . all_arr_examples = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_tuple_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples) { (* obj) . all_tuple_examples = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_opt_examples (obj : * mut example_nested_gen_dict_AllExamples , value : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples) { (* obj) . all_opt_examples = value ; } } } pub mod entry { use crate as example_nested ; pub mod core { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_with_pointers (block_hash_by_height : example_nested :: entry :: BlockHashByHeight , model_by_height : example_nested :: entry :: ModelByHeight , _context : * const std :: os :: raw :: c_void) -> * mut example_nested :: entry :: core :: DashSharedCore { let obj = example_nested :: entry :: core :: DashSharedCore :: with_pointers (block_hash_by_height , model_by_height , _context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel , _context : * const std :: os :: raw :: c_void) -> * mut example_nested :: entry :: core :: DashSharedCore { let obj = example_nested :: entry :: core :: DashSharedCore :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , _context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::test_by_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_test_by_ref (self_ : * mut example_nested :: entry :: core :: DashSharedCore , data : * mut crate :: fermented :: generics :: Slice_u8) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_nested :: entry :: core :: DashSharedCore :: test_by_ref (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (data)))) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::test_vec_by_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_test_vec_by_ref (self_ : * mut example_nested :: entry :: core :: DashSharedCore , data : * mut crate :: fermented :: generics :: Vec_u8) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_nested :: entry :: core :: DashSharedCore :: test_vec_by_ref (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (data)))) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } } pub mod processor { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::entry::processor::Processor::register_initial_usernames`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_processor_Processor_register_initial_usernames (self_ : * mut example_nested :: entry :: processor :: Processor , _model : * mut example_nested :: entry :: processor :: Cache , _context : * const std :: os :: raw :: c_void) { let obj = example_nested :: entry :: processor :: Processor :: register_initial_usernames (& mut * self_ , & mut * _model , _context) ; ; } } pub mod provider { use crate as example_nested ; } # [doc = "FFI-representation of the [`SomeModel`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_entry_SomeModel { pub hash : * mut crate :: fermented :: generics :: Arr_u8_32 , pub desc : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: entry :: SomeModel > for example_nested_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const example_nested_entry_SomeModel) -> example_nested :: entry :: SomeModel { let ffi_ref = & * ffi ; example_nested :: entry :: SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . desc) } } } impl ferment :: FFIConversionTo < example_nested :: entry :: SomeModel > for example_nested_entry_SomeModel { unsafe fn ffi_to_const (obj : example_nested :: entry :: SomeModel) -> * const example_nested_entry_SomeModel { ferment :: boxed (example_nested_entry_SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . desc) }) } } impl Drop for example_nested_entry_SomeModel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . hash) ; ferment :: unbox_string (ffi_ref . desc) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_ctor (hash : * mut crate :: fermented :: generics :: Arr_u8_32 , desc : * mut std :: os :: raw :: c_char) -> * mut example_nested_entry_SomeModel { ferment :: boxed (example_nested_entry_SomeModel { hash , desc }) } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_destroy (ffi : * mut example_nested_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_get_hash (obj : * const example_nested_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_get_desc (obj : * const example_nested_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_set_hash (obj : * mut example_nested_entry_SomeModel , value : * mut crate :: fermented :: generics :: Arr_u8_32) { (* obj) . hash = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_set_desc (obj : * mut example_nested_entry_SomeModel , value : * mut std :: os :: raw :: c_char) { (* obj) . desc = value ; } # [doc = "FFI-representation of the [`SomeModel2`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_entry_SomeModel2 { pub hash : * mut crate :: fermented :: generics :: Arr_u8_2 } impl ferment :: FFIConversionFrom < example_nested :: entry :: SomeModel2 > for example_nested_entry_SomeModel2 { unsafe fn ffi_from_const (ffi : * const example_nested_entry_SomeModel2) -> example_nested :: entry :: SomeModel2 { let ffi_ref = & * ffi ; example_nested :: entry :: SomeModel2 { hash : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionFrom < [u8 ; 2] >> :: ffi_from (ffi_ref . hash) } } } impl ferment :: FFIConversionTo < example_nested :: entry :: SomeModel2 > for example_nested_entry_SomeModel2 { unsafe fn ffi_to_const (obj : example_nested :: entry :: SomeModel2) -> * const example_nested_entry_SomeModel2 { ferment :: boxed (example_nested_entry_SomeModel2 { hash : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionTo < [u8 ; 2] >> :: ffi_to (obj . hash) }) } } impl Drop for example_nested_entry_SomeModel2 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . hash) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel2_ctor (hash : * mut crate :: fermented :: generics :: Arr_u8_2) -> * mut example_nested_entry_SomeModel2 { ferment :: boxed (example_nested_entry_SomeModel2 { hash }) } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel2_destroy (ffi : * mut example_nested_entry_SomeModel2) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel2_get_hash (obj : * const example_nested_entry_SomeModel2) -> * mut crate :: fermented :: generics :: Arr_u8_2 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel2_set_hash (obj : * mut example_nested_entry_SomeModel2 , value : * mut crate :: fermented :: generics :: Arr_u8_2) { (* obj) . hash = value ; } } pub mod state_transition { use crate as example_nested ; pub mod state_transitions { use crate as example_nested ; pub mod contract { use crate as example_nested ; pub mod data_contract_create_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { } impl ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { let ffi_ref = & * ffi ; example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { } } } impl ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_ctor () -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_destroy (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { V0 (* mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) } impl ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (match obj { example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (o_0) => example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { fn drop (& mut self) { unsafe { match self { example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_destroy (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`ExampleStructLif`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { pub varik : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition } impl < 'a , > ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > { let ffi_ref = & * ffi ; example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif { varik : Box :: leak (Box :: new (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (ffi_ref . varik))) } } } impl < 'a , > ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a >) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { varik : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (obj . varik . clone ()) }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . varik) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_ctor < 'a > (varik : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { varik }) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_destroy < 'a > (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_get_varik < 'a > (obj : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . varik } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_set_varik < 'a > (obj : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif , value : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { (* obj) . varik = value ; } } } } # [doc = "FFI-representation of the [`example_nested::state_transition::ContractsManager::contract_registration_transition`]"] # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_ContractsManager_contract_registration_transition (self_ : * mut example_nested :: state_transition :: ContractsManager , contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut crate :: fermented :: generics :: Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { let obj = example_nested :: state_transition :: ContractsManager :: contract_registration_transition (& * self_ , < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (contract)) ; < crate :: fermented :: generics :: Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError as ferment :: FFIConversionTo < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: ProtocolError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::state_transition::ContractsManager::basic_errror`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_ContractsManager_basic_errror (self_ : * mut example_nested :: state_transition :: ContractsManager) -> * mut dpp :: errors :: consensus :: basic :: BasicError { let obj = example_nested :: state_transition :: ContractsManager :: basic_errror (& * self_) ; ferment :: boxed (obj) } } pub mod custom { use crate as example_nested ; } # [doc = "FFI-representation of the [`SomeStruct`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_SomeStruct { pub name : * mut std :: os :: raw :: c_char , pub names : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: SomeStruct > for example_nested_SomeStruct { unsafe fn ffi_from_const (ffi : * const example_nested_SomeStruct) -> example_nested :: SomeStruct { let ffi_ref = & * ffi ; example_nested :: SomeStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , names : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (ffi_ref . names))) } } } impl ferment :: FFIConversionTo < example_nested :: SomeStruct > for example_nested_SomeStruct { unsafe fn ffi_to_const (obj : example_nested :: SomeStruct) -> * const example_nested_SomeStruct { ferment :: boxed (example_nested_SomeStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , names : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (obj . names) }) } } impl Drop for example_nested_SomeStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_string (ffi_ref . names) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_ctor (name : * mut std :: os :: raw :: c_char , names : * mut std :: os :: raw :: c_char) -> * mut example_nested_SomeStruct { ferment :: boxed (example_nested_SomeStruct { name , names }) } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_destroy (ffi : * mut example_nested_SomeStruct) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_get_name (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_get_names (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . names } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_set_name (obj : * mut example_nested_SomeStruct , value : * mut std :: os :: raw :: c_char) { (* obj) . name = value ; } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_set_names (obj : * mut example_nested_SomeStruct , value : * mut std :: os :: raw :: c_char) { (* obj) . names = value ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ExampleEnumLif`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_ExampleEnumLif { Varik (* mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) } impl < 'a , > ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > > for example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const example_nested_ExampleEnumLif) -> example_nested :: ExampleEnumLif < 'a > { let ffi_ref = & * ffi ; match ffi_ref { example_nested_ExampleEnumLif :: Varik (o_0) => example_nested :: ExampleEnumLif :: Varik (Box :: leak (Box :: new (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (* o_0)))) } } } impl < 'a , > ferment :: FFIConversionTo < example_nested :: ExampleEnumLif < 'a > > for example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : example_nested :: ExampleEnumLif < 'a >) -> * const example_nested_ExampleEnumLif { ferment :: boxed (match obj { example_nested :: ExampleEnumLif :: Varik (o_0) => example_nested_ExampleEnumLif :: Varik (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (o_0 . clone ())) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { match self { example_nested_ExampleEnumLif :: Varik (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_ExampleEnumLif_Varik_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_ExampleEnumLif { ferment :: boxed (example_nested_ExampleEnumLif :: Varik (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_ExampleEnumLif_destroy < 'a > (ffi : * mut example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`example_nested::test_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_test_lifetime < 'a > (_example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: test_lifetime (< crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_lifetime_support`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_lifetime_support < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_lifetime_support (& * self_ , < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_staticlifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_staticlifetime (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_staticlifetime (& * self_ , < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'static > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_generic_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_generic_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: Vec_example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_generic_lifetime (& * self_ , < crate :: fermented :: generics :: Vec_example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < Vec < example_nested :: ExampleEnumLif < 'a > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_map_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_map_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_map_lifetime (& * self_ , < crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_map_deep_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_map_deep_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { let obj = example_nested :: Manager :: check_map_deep_lifetime (& * self_ , < crate :: fermented :: generics :: std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionFrom < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::identity_public_key_test`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_identity_public_key_test (identity : * mut dpp :: identity :: Identity) -> * mut dpp :: identity :: IdentityPublicKey { let obj = example_nested :: identity_public_key_test (std :: ptr :: read (identity)) ; ferment :: boxed (obj) } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as example_nested ; # [repr (C)] # [derive (Clone)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Vec_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_ctor (count : usize , values : * mut u8) -> * mut Vec_u8 { ferment :: boxed (Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_destroy (ffi : * mut Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_u8_value_at_index (ffi : * const Vec_u8 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_set_value_at_index (ffi : * mut Vec_u8 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_i32 { pub count : usize , pub values : * mut i32 } impl ferment :: FFIConversionFrom < Vec < i32 > > for Vec_i32 { unsafe fn ffi_from_const (ffi : * const Vec_i32) -> Vec < i32 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < i32 > > for Vec_i32 { unsafe fn ffi_to_const (obj : Vec < i32 >) -> * const Vec_i32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_i32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_i32_ctor (count : usize , values : * mut i32) -> * mut Vec_i32 { ferment :: boxed (Vec_i32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_i32_destroy (ffi : * mut Vec_i32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_i32_value_at_index (ffi : * const Vec_i32 , index : usize) -> i32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_i32_set_value_at_index (ffi : * mut Vec_i32 , index : usize , value : i32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Arr_dashcore_bls_sig_utils_BLSSignature_4 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_from_const (ffi : * const Arr_dashcore_bls_sig_utils_BLSSignature_4) -> [dashcore :: bls_sig_utils :: BLSSignature ; 4] { let ffi_ref = & * ffi ; TryFrom :: < Vec < dashcore :: bls_sig_utils :: BLSSignature >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o))) . unwrap () } } impl ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_to_const (obj : [dashcore :: bls_sig_utils :: BLSSignature ; 4]) -> * const Arr_dashcore_bls_sig_utils_BLSSignature_4 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o)) }) } } impl Drop for Arr_dashcore_bls_sig_utils_BLSSignature_4 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut Arr_dashcore_bls_sig_utils_BLSSignature_4 { ferment :: boxed (Arr_dashcore_bls_sig_utils_BLSSignature_4 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_destroy (ffi : * mut Arr_dashcore_bls_sig_utils_BLSSignature_4) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_value_at_index (ffi : * const Arr_dashcore_bls_sig_utils_BLSSignature_4 , index : usize) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_set_value_at_index (ffi : * mut Arr_dashcore_bls_sig_utils_BLSSignature_4 , index : usize , value : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_20 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_from_const (ffi : * const Arr_u8_20) -> [u8 ; 20] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_to_const (obj : [u8 ; 20]) -> * const Arr_u8_20 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_20 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_20 { ferment :: boxed (Arr_u8_20 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_destroy (ffi : * mut Arr_u8_20) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_value_at_index (ffi : * const Arr_u8_20 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_set_value_at_index (ffi : * mut Arr_u8_20 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { pub ok : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition , pub error : * mut dpp :: errors :: ProtocolError } impl ferment :: FFIConversionFrom < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: ProtocolError > > for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError) -> Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_from (o) , ffi_ref . error , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: ProtocolError > > for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { unsafe fn ffi_to_const (obj : Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: ProtocolError >) -> * const Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_to (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError_ctor (ok : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition , error : * mut dpp :: errors :: ProtocolError) -> * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ferment :: boxed (Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError_destroy (ffi : * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError_Ok_ctor (ok : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) -> * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ferment :: boxed (Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError_Error_ctor (error : * mut dpp :: errors :: ProtocolError) -> * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ferment :: boxed (Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionFrom < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >) -> * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionTo < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_destroy (ffi : * mut Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_value_at_index (ffi : * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , index : usize) -> * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_set_value_at_index (ffi : * mut Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , index : usize , value : * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >) -> * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_destroy (ffi : * mut Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_value_at_index (ffi : * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , index : usize) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_value_at_index (ffi : * mut Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , index : usize , value : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { pub count : usize , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueCloneableType > > for std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType) -> std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueCloneableType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueCloneableType > > for std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueCloneableType >) -> * const std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType_ctor (count : usize , values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType_destroy (ffi : * mut std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType_value_at_index (ffi : * const std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType , index : usize) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType_set_value_at_index (ffi : * mut std_collections_HashSet_example_simple_types_opaque_OpaqueCloneableType , index : usize , value : * mut example_simple :: types :: opaque :: OpaqueCloneableType) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < u32 > > for std_rc_Rc_u32 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_u32) -> std :: rc :: Rc < u32 > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < u32 > > for std_rc_Rc_u32 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < u32 >) -> * const std_rc_Rc_u32 { ferment :: boxed (Self { obj : * obj }) } } impl Drop for std_rc_Rc_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_u32_ctor (obj : u32) -> * mut std_rc_Rc_u32 { ferment :: boxed (std_rc_Rc_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_u32_destroy (ffi : * mut std_rc_Rc_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Vec < u8 > > > for std_rc_Rc_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Vec_u8) -> std :: rc :: Rc < Vec < u8 > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Vec < u8 > > > for std_rc_Rc_Vec_u8 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Vec < u8 > >) -> * const std_rc_Rc_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_rc_Rc_Vec_u8 { ferment :: boxed (std_rc_Rc_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Vec_u8_destroy (ffi : * mut std_rc_Rc_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_rc_Rc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut snapshot :: LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > for std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > for std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot >) -> * const std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (count : usize , keys : * mut u32 , values : * mut * mut snapshot :: LLMQSnapshot) -> * mut std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_value_by_key (ffi : * const std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , key : u32) -> * mut snapshot :: LLMQSnapshot { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , key : u32 , value : * mut snapshot :: LLMQSnapshot) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Option < String > > > for std_rc_Rc_Option_String { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Option_String) -> std :: rc :: Rc < Option < String > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Option < String > > > for std_rc_Rc_Option_String { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Option < String > >) -> * const std_rc_Rc_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_rc_Rc_Option_String { ferment :: boxed (std_rc_Rc_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_String_destroy (ffi : * mut std_rc_Rc_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_example_simple_nested_HashID { pub o_0 : u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) > for Tuple_u32_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Tuple_u32_example_simple_nested_HashID) -> (u32 , example_simple :: nested :: HashID) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) > for Tuple_u32_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : (u32 , example_simple :: nested :: HashID)) -> * const Tuple_u32_example_simple_nested_HashID { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_u32_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_ctor (o_0 : u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut Tuple_u32_example_simple_nested_HashID { ferment :: boxed (Tuple_u32_example_simple_nested_HashID { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_destroy (ffi : * mut Tuple_u32_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_Option_u32_example_simple_nested_HashID { pub o_0 : * mut u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < (Option < u32 > , example_simple :: nested :: HashID) > for Tuple_Option_u32_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Tuple_Option_u32_example_simple_nested_HashID) -> (Option < u32 > , example_simple :: nested :: HashID) { let ffi_ref = & * ffi ; (ferment :: from_opt_primitive (ffi_ref . o_0) , < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (Option < u32 > , example_simple :: nested :: HashID) > for Tuple_Option_u32_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : (Option < u32 > , example_simple :: nested :: HashID)) -> * const Tuple_Option_u32_example_simple_nested_HashID { ferment :: boxed (Self { o_0 : ferment :: to_opt_primitive (obj . 0) , o_1 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_Option_u32_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_Option_u32_example_simple_nested_HashID_ctor (o_0 : * mut u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut Tuple_Option_u32_example_simple_nested_HashID { ferment :: boxed (Tuple_Option_u32_example_simple_nested_HashID { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_Option_u32_example_simple_nested_HashID_destroy (ffi : * mut Tuple_Option_u32_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_Option_u32_Vec_example_simple_nested_HashID { pub o_0 : * mut u32 , pub o_1 : * mut crate :: fermented :: generics :: Vec_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < (Option < u32 > , Vec < example_simple :: nested :: HashID >) > for Tuple_Option_u32_Vec_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Tuple_Option_u32_Vec_example_simple_nested_HashID) -> (Option < u32 > , Vec < example_simple :: nested :: HashID >) { let ffi_ref = & * ffi ; (ferment :: from_opt_primitive (ffi_ref . o_0) , < crate :: fermented :: generics :: Vec_example_simple_nested_HashID as ferment :: FFIConversionFrom < Vec < example_simple :: nested :: HashID > >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (Option < u32 > , Vec < example_simple :: nested :: HashID >) > for Tuple_Option_u32_Vec_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : (Option < u32 > , Vec < example_simple :: nested :: HashID >)) -> * const Tuple_Option_u32_Vec_example_simple_nested_HashID { ferment :: boxed (Self { o_0 : ferment :: to_opt_primitive (obj . 0) , o_1 : < crate :: fermented :: generics :: Vec_example_simple_nested_HashID as ferment :: FFIConversionTo < Vec < example_simple :: nested :: HashID > >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_Option_u32_Vec_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_Option_u32_Vec_example_simple_nested_HashID_ctor (o_0 : * mut u32 , o_1 : * mut crate :: fermented :: generics :: Vec_example_simple_nested_HashID) -> * mut Tuple_Option_u32_Vec_example_simple_nested_HashID { ferment :: boxed (Tuple_Option_u32_Vec_example_simple_nested_HashID { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_Option_u32_Vec_example_simple_nested_HashID_destroy (ffi : * mut Tuple_Option_u32_Vec_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_example_simple_nested_HashID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < Vec < example_simple :: nested :: HashID > > for Vec_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Vec_example_simple_nested_HashID) -> Vec < example_simple :: nested :: HashID > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < example_simple :: nested :: HashID > > for Vec_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : Vec < example_simple :: nested :: HashID >) -> * const Vec_example_simple_nested_HashID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o)) }) } } impl Drop for Vec_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_nested_HashID_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut Vec_example_simple_nested_HashID { ferment :: boxed (Vec_example_simple_nested_HashID { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_nested_HashID_destroy (ffi : * mut Vec_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_nested_HashID_value_at_index (ffi : * const Vec_example_simple_nested_HashID , index : usize) -> * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_nested_HashID_set_value_at_index (ffi : * mut Vec_example_simple_nested_HashID , index : usize , value : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Tuple_std_time_Duration_std_time_Duration { pub o_0 : * mut example_nested :: std_time_Duration2 , pub o_1 : * mut example_nested :: std_time_Duration2 } impl ferment :: FFIConversionFrom < (std :: time :: Duration , std :: time :: Duration) > for Tuple_std_time_Duration_std_time_Duration { unsafe fn ffi_from_const (ffi : * const Tuple_std_time_Duration_std_time_Duration) -> (std :: time :: Duration , std :: time :: Duration) { let ffi_ref = & * ffi ; (< example_nested :: std_time_Duration2 as ferment :: FFIConversionFrom < std :: time :: Duration >> :: ffi_from (ffi_ref . o_0) , < example_nested :: std_time_Duration2 as ferment :: FFIConversionFrom < std :: time :: Duration >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (std :: time :: Duration , std :: time :: Duration) > for Tuple_std_time_Duration_std_time_Duration { unsafe fn ffi_to_const (obj : (std :: time :: Duration , std :: time :: Duration)) -> * const Tuple_std_time_Duration_std_time_Duration { ferment :: boxed (Self { o_0 : < example_nested :: std_time_Duration2 as ferment :: FFIConversionTo < std :: time :: Duration >> :: ffi_to (obj . 0) , o_1 : < example_nested :: std_time_Duration2 as ferment :: FFIConversionTo < std :: time :: Duration >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_std_time_Duration_std_time_Duration { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_std_time_Duration_std_time_Duration_ctor (o_0 : * mut example_nested :: std_time_Duration2 , o_1 : * mut example_nested :: std_time_Duration2) -> * mut Tuple_std_time_Duration_std_time_Duration { ferment :: boxed (Tuple_std_time_Duration_std_time_Duration { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_std_time_Duration_std_time_Duration_destroy (ffi : * mut Tuple_std_time_Duration_std_time_Duration) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_std_time_Duration { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut example_nested :: std_time_Duration2 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , std :: time :: Duration > > for std_collections_Map_keys_String_values_std_time_Duration { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_std_time_Duration) -> std :: collections :: BTreeMap < String , std :: time :: Duration > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < example_nested :: std_time_Duration2 as ferment :: FFIConversionFrom < std :: time :: Duration >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , std :: time :: Duration > > for std_collections_Map_keys_String_values_std_time_Duration { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , std :: time :: Duration >) -> * const std_collections_Map_keys_String_values_std_time_Duration { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < example_nested :: std_time_Duration2 as ferment :: FFIConversionTo < std :: time :: Duration >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_std_time_Duration { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut example_nested :: std_time_Duration2) -> * mut std_collections_Map_keys_String_values_std_time_Duration { ferment :: boxed (std_collections_Map_keys_String_values_std_time_Duration { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_destroy (ffi : * mut std_collections_Map_keys_String_values_std_time_Duration) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_value_by_key (ffi : * const std_collections_Map_keys_String_values_std_time_Duration , key : * mut std :: os :: raw :: c_char) -> * mut example_nested :: std_time_Duration2 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_std_time_Duration , key : * mut std :: os :: raw :: c_char , value : * mut example_nested :: std_time_Duration2) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_u32 { pub obj : * mut std :: sync :: Mutex < u32 > } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > > for std_sync_Mutex_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_u32) -> std :: sync :: Mutex < u32 > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < u32 > > for std_sync_Mutex_u32 { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < u32 >) -> * const std_sync_Mutex_u32 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Mutex_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_ctor (obj : u32) -> * mut std_sync_Mutex_u32 { ferment :: boxed (std_sync_Mutex_u32 { obj : ferment :: boxed (std :: sync :: Mutex :: new (obj)) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_destroy (ffi : * mut std_sync_Mutex_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_read (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_u32) -> u32 { let lock = < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; obj . clone () } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_write (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_u32 , value : u32) { let lock = < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = value ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_Mutex_u32 { pub obj : * mut std :: sync :: Arc < std :: sync :: Mutex < u32 > > } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < u32 > > > for std_sync_Arc_std_sync_Mutex_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_Mutex_u32) -> std :: sync :: Arc < std :: sync :: Mutex < u32 > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: clone (& * ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < u32 > > > for std_sync_Arc_std_sync_Mutex_u32 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: Mutex < u32 > >) -> * const std_sync_Arc_std_sync_Mutex_u32 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Arc_std_sync_Mutex_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_u32_ctor (obj : u32) -> * mut std_sync_Arc_std_sync_Mutex_u32 { ferment :: boxed (std_sync_Arc_std_sync_Mutex_u32 { obj : ferment :: boxed (std :: sync :: Arc :: new (std :: sync :: Mutex :: new (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_u32_destroy (ffi : * mut std_sync_Arc_std_sync_Mutex_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_u32_read (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32) -> u32 { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < u32 > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; obj . clone () } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_u32_write (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 , value : u32) { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < u32 > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = value ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_Mutex_Vec_u8 { pub obj : * mut std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > > for std_sync_Arc_std_sync_Mutex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_Mutex_Vec_u8) -> std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: clone (& * ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > > for std_sync_Arc_std_sync_Mutex_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > >) -> * const std_sync_Arc_std_sync_Mutex_Vec_u8 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Arc_std_sync_Mutex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_Arc_std_sync_Mutex_Vec_u8 { ferment :: boxed (std_sync_Arc_std_sync_Mutex_Vec_u8 { obj : ferment :: boxed (std :: sync :: Arc :: new (std :: sync :: Mutex :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (obj)))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Vec_u8_destroy (ffi : * mut std_sync_Arc_std_sync_Mutex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Vec_u8_read (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Vec_u8_write (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Vec < u8 > > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Vec_u8 { pub obj : * mut std :: sync :: Mutex < Vec < u8 > > } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > > for std_sync_Mutex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Vec_u8) -> std :: sync :: Mutex < Vec < u8 > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Vec < u8 > > > for std_sync_Mutex_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Vec < u8 > >) -> * const std_sync_Mutex_Vec_u8 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Mutex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_Mutex_Vec_u8 { ferment :: boxed (std_sync_Mutex_Vec_u8 { obj : ferment :: boxed (std :: sync :: Mutex :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_destroy (ffi : * mut std_sync_Mutex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_read (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_write (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: sync :: Mutex :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > > for std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: clone (& * ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > > for std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >) -> * const std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: sync :: Arc :: new (std :: sync :: Mutex :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (obj)))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_Mutex_Option_String { pub obj : * mut std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > > for std_sync_Arc_std_sync_Mutex_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_Mutex_Option_String) -> std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: clone (& * ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > > for std_sync_Arc_std_sync_Mutex_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: Mutex < Option < String > > >) -> * const std_sync_Arc_std_sync_Mutex_Option_String { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Arc_std_sync_Mutex_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_Arc_std_sync_Mutex_Option_String { ferment :: boxed (std_sync_Arc_std_sync_Mutex_Option_String { obj : ferment :: boxed (std :: sync :: Arc :: new (std :: sync :: Mutex :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (obj)))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_String_destroy (ffi : * mut std_sync_Arc_std_sync_Mutex_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_String_read (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String) -> * mut std :: os :: raw :: c_char { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_Mutex_Option_String_write (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String , value : * mut std :: os :: raw :: c_char) { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: Mutex < Option < String > > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Option_String { pub obj : * mut std :: sync :: Mutex < Option < String > > } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > > for std_sync_Mutex_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Option_String) -> std :: sync :: Mutex < Option < String > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Option < String > > > for std_sync_Mutex_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Option < String > >) -> * const std_sync_Mutex_Option_String { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Mutex_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_Mutex_Option_String { ferment :: boxed (std_sync_Mutex_Option_String { obj : ferment :: boxed (std :: sync :: Mutex :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_destroy (ffi : * mut std_sync_Mutex_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_read (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String) -> * mut std :: os :: raw :: c_char { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > >> :: ffi_from (obj) ; let obj = lock . lock () . unwrap () ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_write (obj : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String , value : * mut std :: os :: raw :: c_char) { let lock = < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > >> :: ffi_from (obj) ; let mut obj = lock . lock () . unwrap () ; * obj = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_String) -> std :: collections :: BTreeMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , String >) -> * const std_collections_Map_keys_String_values_String { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_String_values_String { ferment :: boxed (std_collections_Map_keys_String_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_destroy (ffi : * mut std_collections_Map_keys_String_values_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_value_by_key (ffi : * const std_collections_Map_keys_String_values_String , key : * mut std :: os :: raw :: c_char) -> * mut std :: os :: raw :: c_char { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_String , key : * mut std :: os :: raw :: c_char , value : * mut std :: os :: raw :: c_char) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentType >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType) -> * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_value_by_key (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName as ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName as ferment :: FFIConversionTo < dpp :: data_contract :: DefinitionName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_value_by_key (ffi : * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) -> std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group >) -> * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group as ferment :: FFIConversionTo < dpp :: data_contract :: group :: Group >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group) -> * mut std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_value_by_key (ffi : * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub values : * mut * mut data_contract } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract) -> std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (o) , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , data_contract >) -> * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , values : * mut * mut data_contract) -> * mut std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract_value_by_key (ffi : * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut data_contract { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_data_contract , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , value : * mut data_contract) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < String > > for Vec_String { unsafe fn ffi_from_const (ffi : * const Vec_String) -> Vec < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < String > > for Vec_String { unsafe fn ffi_to_const (obj : Vec < String >) -> * const Vec_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Vec_String { ferment :: boxed (Vec_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_String_destroy (ffi : * mut Vec_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_String_value_at_index (ffi : * const Vec_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_String_set_value_at_index (ffi : * mut Vec_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Tuple_example_simple_nested_HashID_example_simple_nested_HashID { pub o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > for Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Tuple_example_simple_nested_HashID_example_simple_nested_HashID) -> (example_simple :: nested :: HashID , example_simple :: nested :: HashID) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > for Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : (example_simple :: nested :: HashID , example_simple :: nested :: HashID)) -> * const Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_example_simple_nested_HashID_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_nested_HashID_example_simple_nested_HashID_ctor (o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Tuple_example_simple_nested_HashID_example_simple_nested_HashID { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_nested_HashID_example_simple_nested_HashID_destroy (ffi : * mut Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > > for Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) -> Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionFrom < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > > for Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >) -> * const Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionTo < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID) -> * mut Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_destroy (ffi : * mut Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_value_at_index (ffi : * const Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID , index : usize) -> * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_set_value_at_index (ffi : * mut Vec_Tuple_example_simple_nested_HashID_example_simple_nested_HashID , index : usize , value : * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) -> (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: RootEncryptionKeyIndex >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: DerivationEncryptionKeyIndex >> :: ffi_from (ffi_ref . o_1) , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,)) -> * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: RootEncryptionKeyIndex >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: DerivationEncryptionKeyIndex >> :: ffi_to (obj . 1) , o_2 : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8_ctor (o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex , o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex , o_2 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { ferment :: boxed (Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8_destroy (ffi : * mut Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > > for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) -> std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits > > for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: balances :: credits :: TokenAmount , dpp :: balances :: credits :: Credits >) -> * const std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { ferment :: boxed (std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits_destroy (ffi : * mut std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits_value_by_key (ffi : * const std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits , key : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_balances_credits_TokenAmount_values_dpp_balances_credits_Credits , key : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_32 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_u8_32) -> [u8 ; 32] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_to_const (obj : [u8 ; 32]) -> * const Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_32 { ferment :: boxed (Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_destroy (ffi : * mut Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_value_at_index (ffi : * const Arr_u8_32 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_set_value_at_index (ffi : * mut Arr_u8_32 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_48 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_from_const (ffi : * const Arr_u8_48) -> [u8 ; 48] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_to_const (obj : [u8 ; 48]) -> * const Arr_u8_48 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_48 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_48 { ferment :: boxed (Arr_u8_48 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_destroy (ffi : * mut Arr_u8_48) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_value_at_index (ffi : * const Arr_u8_48 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_set_value_at_index (ffi : * mut Arr_u8_48 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_48 , u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } unsafe impl Send for Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { } impl Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : u32 , o_1 : [u8 ; 48] , o_2 : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionTo < [u8 ; 48] >> :: ffi_to (o_1) , o_2) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_48 , u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_u32_Arr_u8_48_u32_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { caller : unsafe extern "C" fn (* mut example_simple :: types :: opaque :: OpaqueNonCloneableType) } unsafe impl Send for Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { } unsafe impl Sync for Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { } impl Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { pub unsafe fn call (& self , o_0 : example_simple :: types :: opaque :: OpaqueNonCloneableType) { let ffi_result = (self . caller) (ferment :: boxed (o_0)) ; ffi_result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN__ctor (caller : unsafe extern "C" fn (* mut example_simple :: types :: opaque :: OpaqueNonCloneableType)) -> * mut Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { ferment :: boxed (Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN__destroy (ffi : * mut Fn_ARGS_example_simple_types_opaque_OpaqueNonCloneableType_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_platform_value_Value { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_platform_value_Value) -> std :: collections :: BTreeMap < String , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , platform_value :: Value >) -> * const std_collections_Map_keys_String_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_String_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_String_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_String_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_value_by_key (ffi : * const std_collections_Map_keys_String_values_platform_value_Value , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_platform_value_Value , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_platform_value_Value_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value } impl ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_platform_value_Value_platform_value_Value) -> Vec < (platform_value :: Value , platform_value :: Value) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionFrom < (platform_value :: Value , platform_value :: Value) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < (platform_value :: Value , platform_value :: Value) >) -> * const Vec_Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionTo < (platform_value :: Value , platform_value :: Value) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value) -> * mut Vec_Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Vec_Tuple_platform_value_Value_platform_value_Value { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_destroy (ffi : * mut Vec_Tuple_platform_value_Value_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_value_at_index (ffi : * const Vec_Tuple_platform_value_Value_platform_value_Value , index : usize) -> * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_set_value_at_index (ffi : * mut Vec_Tuple_platform_value_Value_platform_value_Value , index : usize , value : * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Tuple_platform_value_Value_platform_value_Value { pub o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub o_1 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Tuple_platform_value_Value_platform_value_Value) -> (platform_value :: Value , platform_value :: Value) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : (platform_value :: Value , platform_value :: Value)) -> * const Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_Value_platform_value_Value_ctor (o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , o_1 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Tuple_platform_value_Value_platform_value_Value { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_Value_platform_value_Value_destroy (ffi : * mut Tuple_platform_value_Value_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_String_32 { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < [String ; 32] > for Arr_String_32 { unsafe fn ffi_from_const (ffi : * const Arr_String_32) -> [String ; 32] { let ffi_ref = & * ffi ; TryFrom :: < Vec < String >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o))) . unwrap () } } impl ferment :: FFIConversionTo < [String ; 32] > for Arr_String_32 { unsafe fn ffi_to_const (obj : [String ; 32]) -> * const Arr_String_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for Arr_String_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Arr_String_32 { ferment :: boxed (Arr_String_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_destroy (ffi : * mut Arr_String_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_value_at_index (ffi : * const Arr_String_32 , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_set_value_at_index (ffi : * mut Arr_String_32 , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Arr_example_nested_model_Quorum_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum } impl ferment :: FFIConversionFrom < [example_nested :: model :: Quorum ; 32] > for Arr_example_nested_model_Quorum_32 { unsafe fn ffi_from_const (ffi : * const Arr_example_nested_model_Quorum_32) -> [example_nested :: model :: Quorum ; 32] { let ffi_ref = & * ffi ; TryFrom :: < Vec < example_nested :: model :: Quorum >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionFrom < example_nested :: model :: Quorum >> :: ffi_from (* o))) . unwrap () } } impl ferment :: FFIConversionTo < [example_nested :: model :: Quorum ; 32] > for Arr_example_nested_model_Quorum_32 { unsafe fn ffi_to_const (obj : [example_nested :: model :: Quorum ; 32]) -> * const Arr_example_nested_model_Quorum_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (o)) }) } } impl Drop for Arr_example_nested_model_Quorum_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum) -> * mut Arr_example_nested_model_Quorum_32 { ferment :: boxed (Arr_example_nested_model_Quorum_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_destroy (ffi : * mut Arr_example_nested_model_Quorum_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_value_at_index (ffi : * const Arr_example_nested_model_Quorum_32 , index : usize) -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_set_value_at_index (ffi : * mut Arr_example_nested_model_Quorum_32 , index : usize , value : * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Arr_Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < [Vec < u8 > ; 32] > for Arr_Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_Vec_u8_32) -> [Vec < u8 > ; 32] { let ffi_ref = & * ffi ; TryFrom :: < Vec < Vec < u8 > >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o))) . unwrap () } } impl ferment :: FFIConversionTo < [Vec < u8 > ; 32] > for Arr_Vec_u8_32 { unsafe fn ffi_to_const (obj : [Vec < u8 > ; 32]) -> * const Arr_Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) }) } } impl Drop for Arr_Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Arr_Vec_u8_32 { ferment :: boxed (Arr_Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_destroy (ffi : * mut Arr_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_value_at_index (ffi : * const Arr_Vec_u8_32 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_set_value_at_index (ffi : * mut Arr_Vec_u8_32 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { pub ok : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < example_simple :: types :: opaque :: OpaqueNonCloneableType , u32 > > for Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32) -> Result < example_simple :: types :: opaque :: OpaqueNonCloneableType , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_result_prefer_ok (ffi_ref . ok , | o | std :: ptr :: read (o) , ffi_ref . error , | o | * o) } } impl ferment :: FFIConversionTo < Result < example_simple :: types :: opaque :: OpaqueNonCloneableType , u32 > > for Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { unsafe fn ffi_to_const (obj : Result < example_simple :: types :: opaque :: OpaqueNonCloneableType , u32 >) -> * const Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . ok) ; ferment :: black_hole (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32_ctor (ok : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , error : * mut u32) -> * mut Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32_destroy (ffi : * mut Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32_Ok_ctor (ok : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32_Error_ctor (error : * mut u32) -> * mut Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueNonCloneableType_err_u32 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_example_simple_nested_HashID { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > > for std_collections_Map_keys_String_values_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_example_simple_nested_HashID) -> std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > > for std_collections_Map_keys_String_values_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , example_simple :: nested :: HashID >) -> * const std_collections_Map_keys_String_values_example_simple_nested_HashID { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut std_collections_Map_keys_String_values_example_simple_nested_HashID { ferment :: boxed (std_collections_Map_keys_String_values_example_simple_nested_HashID { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_destroy (ffi : * mut std_collections_Map_keys_String_values_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_value_by_key (ffi : * const std_collections_Map_keys_String_values_example_simple_nested_HashID , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_example_simple_nested_HashID , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Slice_Vec_example_simple_errors_context_ContextProviderError { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError } impl ferment :: FFIConversionFrom < Vec < Vec < example_simple :: errors :: context :: ContextProviderError > > > for Slice_Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const Slice_Vec_example_simple_errors_context_ContextProviderError) -> Vec < Vec < example_simple :: errors :: context :: ContextProviderError > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Vec < example_simple :: errors :: context :: ContextProviderError > >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < Vec < example_simple :: errors :: context :: ContextProviderError > > > for Slice_Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : Vec < Vec < example_simple :: errors :: context :: ContextProviderError > >) -> * const Slice_Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Vec < example_simple :: errors :: context :: ContextProviderError > >> :: ffi_to (o)) }) } } impl Drop for Slice_Vec_example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_Vec_example_simple_errors_context_ContextProviderError_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError) -> * mut Slice_Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Slice_Vec_example_simple_errors_context_ContextProviderError { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_Vec_example_simple_errors_context_ContextProviderError_destroy (ffi : * mut Slice_Vec_example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Slice_Vec_example_simple_errors_context_ContextProviderError_value_at_index (ffi : * const Slice_Vec_example_simple_errors_context_ContextProviderError , index : usize) -> * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Slice_Vec_example_simple_errors_context_ContextProviderError_set_value_at_index (ffi : * mut Slice_Vec_example_simple_errors_context_ContextProviderError , index : usize , value : * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_example_simple_errors_context_ContextProviderError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError } impl ferment :: FFIConversionFrom < Vec < example_simple :: errors :: context :: ContextProviderError > > for Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const Vec_example_simple_errors_context_ContextProviderError) -> Vec < example_simple :: errors :: context :: ContextProviderError > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < example_simple :: errors :: context :: ContextProviderError >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < example_simple :: errors :: context :: ContextProviderError > > for Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : Vec < example_simple :: errors :: context :: ContextProviderError >) -> * const Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < example_simple :: errors :: context :: ContextProviderError >> :: ffi_to (o)) }) } } impl Drop for Vec_example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_errors_context_ContextProviderError_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) -> * mut Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Vec_example_simple_errors_context_ContextProviderError { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_errors_context_ContextProviderError_destroy (ffi : * mut Vec_example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_errors_context_ContextProviderError_value_at_index (ffi : * const Vec_example_simple_errors_context_ContextProviderError , index : usize) -> * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_errors_context_ContextProviderError_set_value_at_index (ffi : * mut Vec_example_simple_errors_context_ContextProviderError , index : usize , value : * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) { * (* ffi) . values . add (index) = value } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >) -> * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (o)) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { count , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_destroy (ffi : * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_value_at_index (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , index : usize) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { * (* ffi) . values . add (index) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_set_value_at_index (ffi : * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , index : usize , value : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > > for std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_u32) -> std :: collections :: BTreeMap < u32 , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > > for std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , u32 >) -> * const std_collections_Map_keys_u32_values_u32 { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | o) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_ctor (count : usize , keys : * mut u32 , values : * mut u32) -> * mut std_collections_Map_keys_u32_values_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_value_by_key (ffi : * const std_collections_Map_keys_u32_values_u32 , key : u32) -> * mut u32 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return ferment :: boxed (* ffi_ref . values . add (i)) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_u32 , key : u32 , value : u32) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < u32 > > > for std_collections_Map_keys_u32_values_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_u32) -> std :: collections :: BTreeMap < u32 , Option < u32 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | ferment :: from_opt_primitive (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < u32 > > > for std_collections_Map_keys_u32_values_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < u32 > >) -> * const std_collections_Map_keys_u32_values_Option_u32 { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | ferment :: to_opt_primitive (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_ctor (count : usize , keys : * mut u32 , values : * mut * mut u32) -> * mut std_collections_Map_keys_u32_values_Option_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_Option_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Option_u32 , key : u32) -> * mut u32 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Option_u32 , key : u32 , value : * mut u32) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < String > > > for std_collections_Map_keys_u32_values_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_String) -> std :: collections :: BTreeMap < u32 , Option < String > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < String > > > for std_collections_Map_keys_u32_values_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < String > >) -> * const std_collections_Map_keys_u32_values_Option_String { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_u32_values_Option_String { ferment :: boxed (std_collections_Map_keys_u32_values_Option_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Option_String , key : u32) -> * mut std :: os :: raw :: c_char { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Option_String , key : u32 , value : * mut std :: os :: raw :: c_char) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < Vec < u32 > > for Vec_u32 { unsafe fn ffi_from_const (ffi : * const Vec_u32) -> Vec < u32 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < u32 > > for Vec_u32 { unsafe fn ffi_to_const (obj : Vec < u32 >) -> * const Vec_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u32_ctor (count : usize , values : * mut u32) -> * mut Vec_u32 { ferment :: boxed (Vec_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u32_destroy (ffi : * mut Vec_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_u32_value_at_index (ffi : * const Vec_u32 , index : usize) -> u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_u32_set_value_at_index (ffi : * mut Vec_u32 , index : usize , value : u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_Vec_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > > for std_collections_Map_keys_u32_values_Option_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_u32) -> std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > > for std_collections_Map_keys_u32_values_Option_Vec_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > >) -> * const std_collections_Map_keys_u32_values_Option_Vec_u32 { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionTo < Vec < u32 > >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Option_Vec_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_u32) -> * mut std_collections_Map_keys_u32_values_Option_Vec_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_Option_Vec_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_u32 , key : u32) -> * mut crate :: fermented :: generics :: Vec_u32 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_u32 , key : u32 , value : * mut crate :: fermented :: generics :: Vec_u32) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_Vec_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > > for std_collections_Map_keys_u32_values_Option_Vec_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_String) -> std :: collections :: BTreeMap < u32 , Option < Vec < String > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > > for std_collections_Map_keys_u32_values_Option_Vec_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < Vec < String > > >) -> * const std_collections_Map_keys_u32_values_Option_Vec_String { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Option_Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_String) -> * mut std_collections_Map_keys_u32_values_Option_Vec_String { ferment :: boxed (std_collections_Map_keys_u32_values_Option_Vec_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_String , key : u32) -> * mut crate :: fermented :: generics :: Vec_String { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_String , key : u32 , value : * mut crate :: fermented :: generics :: Vec_String) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , String > > for std_collections_Map_keys_u32_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_String) -> std :: collections :: BTreeMap < u32 , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , String > > for std_collections_Map_keys_u32_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , String >) -> * const std_collections_Map_keys_u32_values_String { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_u32_values_String { ferment :: boxed (std_collections_Map_keys_u32_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_value_by_key (ffi : * const std_collections_Map_keys_u32_values_String , key : u32) -> * mut std :: os :: raw :: c_char { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_String , key : u32 , value : * mut std :: os :: raw :: c_char) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Vec_u8 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Vec < u8 > > > for std_collections_Map_keys_u32_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Vec_u8) -> std :: collections :: BTreeMap < u32 , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Vec < u8 > > > for std_collections_Map_keys_u32_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Vec < u8 > >) -> * const std_collections_Map_keys_u32_values_Vec_u8 { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_u32_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_u32_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_u32_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Vec_u8 , key : u32) -> * mut crate :: fermented :: generics :: Vec_u8 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Vec_u8 , key : u32 , value : * mut crate :: fermented :: generics :: Vec_u8) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_Vec_u8_values_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > > for std_collections_Map_keys_Vec_u8_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_Vec_u8_values_Vec_u8) -> std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > > for std_collections_Map_keys_Vec_u8_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > >) -> * const std_collections_Map_keys_Vec_u8_values_Vec_u8 { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_Vec_u8_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_Vec_u8_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_Vec_u8_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_Vec_u8_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_value_by_key (ffi : * const std_collections_Map_keys_Vec_u8_values_Vec_u8 , key : * mut crate :: fermented :: generics :: Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_set_value_for_key (ffi : * mut std_collections_Map_keys_Vec_u8_values_Vec_u8 , key : * mut crate :: fermented :: generics :: Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > > for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) -> std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > > for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > >) -> * const std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any_opt (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { ferment :: boxed (std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_value_by_key (ffi : * const std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 , key : * mut crate :: fermented :: generics :: Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_set_value_for_key (ffi : * mut std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 , key : * mut crate :: fermented :: generics :: Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_2 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_from_const (ffi : * const Arr_u8_2) -> [u8 ; 2] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_to_const (obj : [u8 ; 2]) -> * const Arr_u8_2 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_2 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_2 { ferment :: boxed (Arr_u8_2 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_destroy (ffi : * mut Arr_u8_2) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_value_at_index (ffi : * const Arr_u8_2 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_set_value_at_index (ffi : * mut Arr_u8_2 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_value_by_key (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { pub count : usize , pub keys : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > > for std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32) -> std :: collections :: BTreeMap < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > > for std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < example_simple :: types :: opaque :: OpaqueCloneableType , u32 >) -> * const std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | o) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32_ctor (count : usize , keys : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType , values : * mut u32) -> * mut std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { ferment :: boxed (std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32_destroy (ffi : * mut std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32_value_by_key (ffi : * const std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 , key : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut u32 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return ferment :: boxed (* ffi_ref . values . add (i)) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32_set_value_for_key (ffi : * mut std_collections_Map_keys_example_simple_types_opaque_OpaqueCloneableType_values_u32 , key : * mut example_simple :: types :: opaque :: OpaqueCloneableType , value : u32) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { pub o_0 : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , pub o_1 : u32 } impl ferment :: FFIConversionFrom < (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32) > for Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { unsafe fn ffi_from_const (ffi : * const Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32) -> (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32) { let ffi_ref = & * ffi ; (std :: ptr :: read (ffi_ref . o_0) , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32) > for Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { unsafe fn ffi_to_const (obj : (example_simple :: types :: opaque :: OpaqueNonCloneableType , u32)) -> * const Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { ferment :: boxed (Self { o_0 : ferment :: boxed (obj . 0) , o_1 : obj . 1 }) } } impl Drop for Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32_ctor (o_0 : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType , o_1 : u32) -> * mut Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { ferment :: boxed (Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32_destroy (ffi : * mut Tuple_example_simple_types_opaque_OpaqueNonCloneableType_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionFrom < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) >> :: ffi_from (* o)) } } impl < 'a > ferment :: FFIConversionTo < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) >) -> * const Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionTo < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> * mut Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_value_at_index (ffi : * const Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 , index : usize) -> * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_set_value_at_index (ffi : * mut Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 , index : usize , value : * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > > for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > >> :: ffi_from (o)) } } impl < 'a > ferment :: FFIConversionTo < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > > for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > >) -> * const std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> * mut std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_value_by_key (ffi : * const std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif , pub o_2 : * mut crate :: fermented :: generics :: Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (ffi_ref . o_1) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . o_2)) } } impl < 'a > ferment :: FFIConversionTo < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32])) -> * const Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionTo < example_nested :: ExampleEnumLif < 'a > >> :: ffi_to (obj . 1) , o_2 : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 2) }) } } impl Drop for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif , o_2 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) } unsafe impl Send for Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } impl Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub unsafe fn call (& self , o_0 : [u8 ; 32] , o_1 : [u8 ; 32]) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError)) -> * mut Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut u32 , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut u32 , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) } unsafe impl Send for Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } impl Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub unsafe fn call (& self , o_0 : u32) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError)) -> * mut Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } unsafe impl Send for Fn_ARGS_u32_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Arr_u8_32 { } impl Fn_ARGS_u32_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel) } unsafe impl Send for Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { } unsafe impl Sync for Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { } impl Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { pub unsafe fn call (& self , o_0 : u32) -> example_nested :: entry :: SomeModel { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel as ferment :: FFIConversionFrom < example_nested :: entry :: SomeModel >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel)) -> * mut Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { ferment :: boxed (Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel_destroy (ffi : * mut Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_u32 { pub ok : * mut u32 , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < u32 , u32 > > for Result_ok_u32_err_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_u32) -> Result < u32 , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_result_prefer_ok (ffi_ref . ok , | o | * o , ffi_ref . error , | o | * o) } } impl ferment :: FFIConversionTo < Result < u32 , u32 > > for Result_ok_u32_err_u32 { unsafe fn ffi_to_const (obj : Result < u32 , u32 >) -> * const Result_ok_u32_err_u32 { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_u32 { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: black_hole (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_ctor (ok : * mut u32 , error : * mut u32) -> * mut Result_ok_u32_err_u32 { ferment :: boxed (Result_ok_u32_err_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_destroy (ffi : * mut Result_ok_u32_err_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_u32 { ferment :: boxed (Result_ok_u32_err_u32 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_Error_ctor (error : * mut u32) -> * mut Result_ok_u32_err_u32 { ferment :: boxed (Result_ok_u32_err_u32 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Slice_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Slice_u8 { unsafe fn ffi_from_const (ffi : * const Slice_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Slice_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Slice_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Slice_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_u8_ctor (count : usize , values : * mut u8) -> * mut Slice_u8 { ferment :: boxed (Slice_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_u8_destroy (ffi : * mut Slice_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Slice_u8_value_at_index (ffi : * const Slice_u8 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Slice_u8_set_value_at_index (ffi : * mut Slice_u8 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Slice_example_simple_errors_context_ContextProviderError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError } impl ferment :: FFIConversionFrom < Vec < example_simple :: errors :: context :: ContextProviderError > > for Slice_example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const Slice_example_simple_errors_context_ContextProviderError) -> Vec < example_simple :: errors :: context :: ContextProviderError > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < example_simple :: errors :: context :: ContextProviderError >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < example_simple :: errors :: context :: ContextProviderError > > for Slice_example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : Vec < example_simple :: errors :: context :: ContextProviderError >) -> * const Slice_example_simple_errors_context_ContextProviderError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < example_simple :: errors :: context :: ContextProviderError >> :: ffi_to (o)) }) } } impl Drop for Slice_example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_example_simple_errors_context_ContextProviderError_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) -> * mut Slice_example_simple_errors_context_ContextProviderError { ferment :: boxed (Slice_example_simple_errors_context_ContextProviderError { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_example_simple_errors_context_ContextProviderError_destroy (ffi : * mut Slice_example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Slice_example_simple_errors_context_ContextProviderError_value_at_index (ffi : * const Slice_example_simple_errors_context_ContextProviderError , index : usize) -> * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Slice_example_simple_errors_context_ContextProviderError_set_value_at_index (ffi : * mut Slice_example_simple_errors_context_ContextProviderError , index : usize , value : * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Slice_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < String > > for Slice_String { unsafe fn ffi_from_const (ffi : * const Slice_String) -> Vec < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < String > > for Slice_String { unsafe fn ffi_to_const (obj : Vec < String >) -> * const Slice_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for Slice_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Slice_String { ferment :: boxed (Slice_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_String_destroy (ffi : * mut Slice_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Slice_String_value_at_index (ffi : * const Slice_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Slice_String_set_value_at_index (ffi : * mut Slice_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } unsafe impl Send for Fn_ARGS_u32_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Option_u8_32 { } impl Fn_ARGS_u32_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueCloneableType > > for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType) -> std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueCloneableType > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueCloneableType > > for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueCloneableType >) -> * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType_ctor (count : usize , keys : * mut u32 , values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType_destroy (ffi : * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType_value_by_key (ffi : * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType , key : u32) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueCloneableType , key : u32 , value : * mut example_simple :: types :: opaque :: OpaqueCloneableType) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName >> :: ffi_to (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_value_by_key (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_set_value_for_key (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , key : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < indexmap :: IndexSet < String > > for indexmap_IndexSet_String { unsafe fn ffi_from_const (ffi : * const indexmap_IndexSet_String) -> indexmap :: IndexSet < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexSet < String > > for indexmap_IndexSet_String { unsafe fn ffi_to_const (obj : indexmap :: IndexSet < String >) -> * const indexmap_IndexSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for indexmap_IndexSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut indexmap_IndexSet_String { ferment :: boxed (indexmap_IndexSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_destroy (ffi : * mut indexmap_IndexSet_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_value_at_index (ffi : * const indexmap_IndexSet_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_set_value_at_index (ffi : * mut indexmap_IndexSet_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexMap_String_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < indexmap :: IndexMap < String , String > > for indexmap_IndexMap_String_String { unsafe fn ffi_from_const (ffi : * const indexmap_IndexMap_String_String) -> indexmap :: IndexMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexMap < String , String > > for indexmap_IndexMap_String_String { unsafe fn ffi_to_const (obj : indexmap :: IndexMap < String , String >) -> * const indexmap_IndexMap_String_String { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for indexmap_IndexMap_String_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut indexmap_IndexMap_String_String { ferment :: boxed (indexmap_IndexMap_String_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_destroy (ffi : * mut indexmap_IndexMap_String_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_value_by_key (ffi : * const indexmap_IndexMap_String_String , key : * mut std :: os :: raw :: c_char) -> * mut std :: os :: raw :: c_char { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_set_value_for_key (ffi : * mut indexmap_IndexMap_String_String , key : * mut std :: os :: raw :: c_char , value : * mut std :: os :: raw :: c_char) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_Arr_u8_32 { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Tuple_String_Arr_u8_32) -> (String , [u8 ; 32]) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : (String , [u8 ; 32])) -> * const Tuple_String_Arr_u8_32 { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Arr_u8_32_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Tuple_String_Arr_u8_32 { ferment :: boxed (Tuple_String_Arr_u8_32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Arr_u8_32_destroy (ffi : * mut Tuple_String_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_String_Arr_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_String_Arr_u8_32) -> Vec < (String , [u8 ; 32]) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < (String , [u8 ; 32]) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : Vec < (String , [u8 ; 32]) >) -> * const Vec_Tuple_String_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < (String , [u8 ; 32]) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32) -> * mut Vec_Tuple_String_Arr_u8_32 { ferment :: boxed (Vec_Tuple_String_Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_destroy (ffi : * mut Vec_Tuple_String_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_value_at_index (ffi : * const Vec_Tuple_String_Arr_u8_32 , index : usize) -> * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_set_value_at_index (ffi : * mut Vec_Tuple_String_Arr_u8_32 , index : usize , value : * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode } impl ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > > for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_from_const (ffi : * const Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) -> Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > > for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_to_const (obj : Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >) -> * const Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_to (o)) }) } } impl Drop for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_destroy (ffi : * mut Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_value_at_index (ffi : * const Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode , index : usize) -> * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_set_value_at_index (ffi : * mut Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode , index : usize , value : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { caller : unsafe extern "C" fn (* mut example_simple :: types :: opaque :: OpaqueCloneableType) } unsafe impl Send for Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { } unsafe impl Sync for Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { } impl Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { pub unsafe fn call (& self , o_0 : example_simple :: types :: opaque :: OpaqueCloneableType) { let ffi_result = (self . caller) (ferment :: boxed (o_0)) ; ffi_result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN__ctor (caller : unsafe extern "C" fn (* mut example_simple :: types :: opaque :: OpaqueCloneableType)) -> * mut Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { ferment :: boxed (Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_ { caller }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN__destroy (ffi : * mut Fn_ARGS_example_simple_types_opaque_OpaqueCloneableType_RTRN_) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_u32 { pub o_0 : u32 , pub o_1 : u32 } impl ferment :: FFIConversionFrom < (u32 , u32) > for Tuple_u32_u32 { unsafe fn ffi_from_const (ffi : * const Tuple_u32_u32) -> (u32 , u32) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (u32 , u32) > for Tuple_u32_u32 { unsafe fn ffi_to_const (obj : (u32 , u32)) -> * const Tuple_u32_u32 { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : obj . 1 }) } } impl Drop for Tuple_u32_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_u32_ctor (o_0 : u32 , o_1 : u32) -> * mut Tuple_u32_u32 { ferment :: boxed (Tuple_u32_u32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_u32_destroy (ffi : * mut Tuple_u32_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > > for Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) -> Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionFrom < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) > > for Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : Vec < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >) -> * const Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID as ferment :: FFIConversionTo < (example_simple :: nested :: HashID , example_simple :: nested :: HashID) >> :: ffi_to (o)) }) } } impl Drop for Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID) -> * mut Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { ferment :: boxed (Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_destroy (ffi : * mut Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_value_at_index (ffi : * const Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID , index : usize) -> * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID_set_value_at_index (ffi : * mut Slice_Tuple_example_simple_nested_HashID_example_simple_nested_HashID , index : usize , value : * mut crate :: fermented :: generics :: Tuple_example_simple_nested_HashID_example_simple_nested_HashID) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { pub count : usize , pub keys : * mut * mut types :: identifier :: Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) -> std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower >) -> * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_ctor (count : usize , keys : * mut * mut types :: identifier :: Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { ferment :: boxed (std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_destroy (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_value_by_key (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , key : * mut types :: identifier :: Identifier) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_set_value_for_key (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , key : * mut types :: identifier :: Identifier , value : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_types_identifier_Identifier_u8 { pub o_0 : * mut types :: identifier :: Identifier , pub o_1 : u8 } impl ferment :: FFIConversionFrom < (types :: identifier :: Identifier , u8) > for Tuple_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_types_identifier_Identifier_u8) -> (types :: identifier :: Identifier , u8) { let ffi_ref = & * ffi ; (std :: ptr :: read (ffi_ref . o_0) , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (types :: identifier :: Identifier , u8) > for Tuple_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : (types :: identifier :: Identifier , u8)) -> * const Tuple_types_identifier_Identifier_u8 { ferment :: boxed (Self { o_0 : ferment :: boxed (obj . 0) , o_1 : obj . 1 }) } } impl Drop for Tuple_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_types_identifier_Identifier_u8_ctor (o_0 : * mut types :: identifier :: Identifier , o_1 : u8) -> * mut Tuple_types_identifier_Identifier_u8 { ferment :: boxed (Tuple_types_identifier_Identifier_u8 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_types_identifier_Identifier_u8_destroy (ffi : * mut Tuple_types_identifier_Identifier_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_types_identifier_Identifier_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < Vec < (types :: identifier :: Identifier , u8) > > for Vec_Tuple_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_types_identifier_Identifier_u8) -> Vec < (types :: identifier :: Identifier , u8) > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8 as ferment :: FFIConversionFrom < (types :: identifier :: Identifier , u8) >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < (types :: identifier :: Identifier , u8) > > for Vec_Tuple_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : Vec < (types :: identifier :: Identifier , u8) >) -> * const Vec_Tuple_types_identifier_Identifier_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8 as ferment :: FFIConversionTo < (types :: identifier :: Identifier , u8) >> :: ffi_to (o)) }) } } impl Drop for Vec_Tuple_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_types_identifier_Identifier_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8) -> * mut Vec_Tuple_types_identifier_Identifier_u8 { ferment :: boxed (Vec_Tuple_types_identifier_Identifier_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_types_identifier_Identifier_u8_destroy (ffi : * mut Vec_Tuple_types_identifier_Identifier_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_types_identifier_Identifier_u8_value_at_index (ffi : * const Vec_Tuple_types_identifier_Identifier_u8 , index : usize) -> * mut crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_types_identifier_Identifier_u8_set_value_at_index (ffi : * mut Vec_Tuple_types_identifier_Identifier_u8 , index : usize , value : * mut crate :: fermented :: generics :: Tuple_types_identifier_Identifier_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } unsafe impl Send for Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { } unsafe impl Sync for Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { } impl Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32 , o_1 : [u8 ; 32]) -> Option < String > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { ferment :: boxed (Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String_destroy (ffi : * mut Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } unsafe impl Send for FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { } unsafe impl Sync for FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { } impl FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32 , o_1 : [u8 ; 32]) -> Option < String > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } # [no_mangle] pub unsafe extern "C" fn FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { ferment :: boxed (FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String_destroy (ffi : * mut FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } unsafe impl Send for Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { } impl Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : [u8 ; 32]) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_36 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_from_const (ffi : * const Arr_u8_36) -> [u8 ; 36] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_to_const (obj : [u8 ; 36]) -> * const Arr_u8_36 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_36 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_36 { ferment :: boxed (Arr_u8_36 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_destroy (ffi : * mut Arr_u8_36) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_value_at_index (ffi : * const Arr_u8_36 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_set_value_at_index (ffi : * mut Arr_u8_36 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_platform_value_Value) -> Vec < platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < platform_value :: Value >) -> * const Vec_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (o)) }) } } impl Drop for Vec_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut Vec_platform_value_Value { ferment :: boxed (Vec_platform_value_Value { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_destroy (ffi : * mut Vec_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_value_at_index (ffi : * const Vec_platform_value_Value , index : usize) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_set_value_at_index (ffi : * mut Vec_platform_value_Value , index : usize , value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty } impl ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) -> indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty >) -> * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentProperty >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty) -> * mut indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_destroy (ffi : * mut indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_value_by_key (ffi : * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_set_value_for_key (ffi : * mut indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_property_array_ArrayItemType { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType) -> Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >) -> * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut Vec_dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (Vec_dpp_data_contract_document_type_property_array_ArrayItemType { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_destroy (ffi : * mut Vec_dpp_data_contract_document_type_property_array_ArrayItemType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_value_at_index (ffi : * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType , index : usize) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_set_value_at_index (ffi : * mut Vec_dpp_data_contract_document_type_property_array_ArrayItemType , index : usize , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_vec_Vec_dashcore_transaction_outpoint_OutPoint { pub count : usize , pub values : * mut * mut dashcore :: transaction :: outpoint :: OutPoint } impl ferment :: FFIConversionFrom < std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint > > for std_vec_Vec_dashcore_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const std_vec_Vec_dashcore_transaction_outpoint_OutPoint) -> std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint > > for std_vec_Vec_dashcore_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : std :: vec :: Vec < dashcore :: transaction :: outpoint :: OutPoint >) -> * const std_vec_Vec_dashcore_transaction_outpoint_OutPoint { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for std_vec_Vec_dashcore_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_vec_Vec_dashcore_transaction_outpoint_OutPoint_ctor (count : usize , values : * mut * mut dashcore :: transaction :: outpoint :: OutPoint) -> * mut std_vec_Vec_dashcore_transaction_outpoint_OutPoint { ferment :: boxed (std_vec_Vec_dashcore_transaction_outpoint_OutPoint { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_vec_Vec_dashcore_transaction_outpoint_OutPoint_destroy (ffi : * mut std_vec_Vec_dashcore_transaction_outpoint_OutPoint) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_vec_Vec_dashcore_transaction_outpoint_OutPoint_value_at_index (ffi : * const std_vec_Vec_dashcore_transaction_outpoint_OutPoint , index : usize) -> * mut dashcore :: transaction :: outpoint :: OutPoint { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_vec_Vec_dashcore_transaction_outpoint_OutPoint_set_value_at_index (ffi : * mut std_vec_Vec_dashcore_transaction_outpoint_OutPoint , index : usize , value : * mut dashcore :: transaction :: outpoint :: OutPoint) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_transaction_txout_TxOut { pub count : usize , pub values : * mut * mut dashcore :: transaction :: txout :: TxOut } impl ferment :: FFIConversionFrom < Vec < dashcore :: transaction :: txout :: TxOut > > for Vec_dashcore_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_transaction_txout_TxOut) -> Vec < dashcore :: transaction :: txout :: TxOut > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: transaction :: txout :: TxOut > > for Vec_dashcore_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : Vec < dashcore :: transaction :: txout :: TxOut >) -> * const Vec_dashcore_transaction_txout_TxOut { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for Vec_dashcore_transaction_txout_TxOut { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_transaction_txout_TxOut_ctor (count : usize , values : * mut * mut dashcore :: transaction :: txout :: TxOut) -> * mut Vec_dashcore_transaction_txout_TxOut { ferment :: boxed (Vec_dashcore_transaction_txout_TxOut { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_transaction_txout_TxOut_destroy (ffi : * mut Vec_dashcore_transaction_txout_TxOut) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_transaction_txout_TxOut_value_at_index (ffi : * const Vec_dashcore_transaction_txout_TxOut , index : usize) -> * mut dashcore :: transaction :: txout :: TxOut { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_transaction_txout_TxOut_set_value_at_index (ffi : * mut Vec_dashcore_transaction_txout_TxOut , index : usize , value : * mut dashcore :: transaction :: txout :: TxOut) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_String { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < String , String > > for Result_ok_String_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_String) -> Result < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < String , String > > for Result_ok_String_err_String { unsafe fn ffi_to_const (obj : Result < String , String >) -> * const Result_ok_String_err_String { let (ok , error) = ferment :: to_result (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_String_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . ok) ; ferment :: unbox_string (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_String { ferment :: boxed (Result_ok_String_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_destroy (ffi : * mut Result_ok_String_err_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_Ok_ctor (ok : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_String { ferment :: boxed (Result_ok_String_err_String { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_Error_ctor (error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_String { ferment :: boxed (Result_ok_String_err_String { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Vec_u8 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Result < String , Vec < u8 > > > for Result_ok_String_err_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Vec_u8) -> Result < String , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < String , Vec < u8 > > > for Result_ok_String_err_Vec_u8 { unsafe fn ffi_to_const (obj : Result < String , Vec < u8 > >) -> * const Result_ok_String_err_Vec_u8 { let (ok , error) = ferment :: to_result (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_String_err_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Vec_u8 { ferment :: boxed (Result_ok_String_err_Vec_u8 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_destroy (ffi : * mut Result_ok_String_err_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_Ok_ctor (ok : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Vec_u8 { ferment :: boxed (Result_ok_String_err_Vec_u8 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_Error_ctor (error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Vec_u8 { ferment :: boxed (Result_ok_String_err_Vec_u8 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_u32 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < String , Option < u32 > > > for Result_ok_String_err_Option_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_u32) -> Result < String , Option < u32 > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | ferment :: from_opt_primitive (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < u32 > > > for Result_ok_String_err_Option_u32 { unsafe fn ffi_to_const (obj : Result < String , Option < u32 > >) -> * const Result_ok_String_err_Option_u32 { let (ok , error) = ferment :: to_result (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | ferment :: to_opt_primitive (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_String_err_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . ok) ; ferment :: unbox_any_opt (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut u32) -> * mut Result_ok_String_err_Option_u32 { ferment :: boxed (Result_ok_String_err_Option_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_destroy (ffi : * mut Result_ok_String_err_Option_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_Ok_ctor (ok : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_u32 { ferment :: boxed (Result_ok_String_err_Option_u32 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_Error_ctor (error : * mut u32) -> * mut Result_ok_String_err_Option_u32 { ferment :: boxed (Result_ok_String_err_Option_u32 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_String { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < String , Option < String > > > for Result_ok_String_err_Option_String { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_String) -> Result < String , Option < String > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < String > > > for Result_ok_String_err_Option_String { unsafe fn ffi_to_const (obj : Result < String , Option < String > >) -> * const Result_ok_String_err_Option_String { let (ok , error) = ferment :: to_result (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_String_err_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . ok) ; ferment :: unbox_any_opt (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_String { ferment :: boxed (Result_ok_String_err_Option_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_destroy (ffi : * mut Result_ok_String_err_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_Ok_ctor (ok : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_String { ferment :: boxed (Result_ok_String_err_Option_String { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_Error_ctor (error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_String { ferment :: boxed (Result_ok_String_err_Option_String { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_Vec_u8 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Result < String , Option < Vec < u8 > > > > for Result_ok_String_err_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_Vec_u8) -> Result < String , Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < Vec < u8 > > > > for Result_ok_String_err_Option_Vec_u8 { unsafe fn ffi_to_const (obj : Result < String , Option < Vec < u8 > > >) -> * const Result_ok_String_err_Option_Vec_u8 { let (ok , error) = ferment :: to_result (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_String_err_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . ok) ; ferment :: unbox_any_opt (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Option_Vec_u8 { ferment :: boxed (Result_ok_String_err_Option_Vec_u8 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_destroy (ffi : * mut Result_ok_String_err_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_Ok_ctor (ok : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_Vec_u8 { ferment :: boxed (Result_ok_String_err_Option_Vec_u8 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_Error_ctor (error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Option_Vec_u8 { ferment :: boxed (Result_ok_String_err_Option_Vec_u8 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut snapshot :: LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | ferment :: from_opt_opaque (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | ferment :: to_opt_primitive (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut snapshot :: LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Ok_ctor (ok : * mut snapshot :: LLMQSnapshot) -> * mut Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut snapshot :: LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) -> Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | std :: ptr :: read (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > >) -> * const Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . ok) ; ferment :: unbox_any_opt (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut snapshot :: LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_Ok_ctor (ok : * mut snapshot :: LLMQSnapshot) -> * mut Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub count : usize , pub keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: ProTxHash >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { let (count , keys , values) = ferment :: to_map (obj , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash as ferment :: FFIConversionTo < dashcore :: hash_types :: ProTxHash >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_ctor (count : usize , keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_value_by_key (ffi : * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , key : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash) -> * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_value_for_key (ffi : * mut std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , key : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , value : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >) -> * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let (count , keys , values) = ferment :: to_map (obj , | o | < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (o) , | o | < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_value_by_key (ffi : * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , key : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_value_for_key (ffi : * mut std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , key : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let (count , keys , values) = ferment :: to_map (obj , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor (count : usize , keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_value_by_key (ffi : * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , key : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) -> * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_value_for_key (ffi : * mut std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry , key : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , value : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_example_simple_types_opaque_OpaqueNonCloneableType { pub count : usize , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType } impl ferment :: FFIConversionFrom < Vec < example_simple :: types :: opaque :: OpaqueNonCloneableType > > for Vec_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_from_const (ffi : * const Vec_example_simple_types_opaque_OpaqueNonCloneableType) -> Vec < example_simple :: types :: opaque :: OpaqueNonCloneableType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < Vec < example_simple :: types :: opaque :: OpaqueNonCloneableType > > for Vec_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_to_const (obj : Vec < example_simple :: types :: opaque :: OpaqueNonCloneableType >) -> * const Vec_example_simple_types_opaque_OpaqueNonCloneableType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for Vec_example_simple_types_opaque_OpaqueNonCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueNonCloneableType_ctor (count : usize , values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut Vec_example_simple_types_opaque_OpaqueNonCloneableType { ferment :: boxed (Vec_example_simple_types_opaque_OpaqueNonCloneableType { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueNonCloneableType_destroy (ffi : * mut Vec_example_simple_types_opaque_OpaqueNonCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueNonCloneableType_value_at_index (ffi : * const Vec_example_simple_types_opaque_OpaqueNonCloneableType , index : usize) -> * mut example_simple :: types :: opaque :: OpaqueNonCloneableType { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueNonCloneableType_set_value_at_index (ffi : * mut Vec_example_simple_types_opaque_OpaqueNonCloneableType , index : usize , value : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut u64 , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_ctor (count : usize , keys : * mut u64 , values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { ferment :: boxed (std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_destroy (ffi : * mut std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_value_by_key (ffi : * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount , key : u64) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_set_value_for_key (ffi : * mut std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount , key : u64 , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_String { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < (String , String) > for Tuple_String_String { unsafe fn ffi_from_const (ffi : * const Tuple_String_String) -> (String , String) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , String) > for Tuple_String_String { unsafe fn ffi_to_const (obj : (String , String)) -> * const Tuple_String_String { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_String { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_string (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_String_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut std :: os :: raw :: c_char) -> * mut Tuple_String_String { ferment :: boxed (Tuple_String_String { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_String_destroy (ffi : * mut Tuple_String_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_Vec_String { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < (String , Vec < String >) > for Tuple_String_Vec_String { unsafe fn ffi_from_const (ffi : * const Tuple_String_Vec_String) -> (String , Vec < String >) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , Vec < String >) > for Tuple_String_Vec_String { unsafe fn ffi_to_const (obj : (String , Vec < String >)) -> * const Tuple_String_Vec_String { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Vec_String_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: generics :: Vec_String) -> * mut Tuple_String_Vec_String { ferment :: boxed (Tuple_String_Vec_String { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Vec_String_destroy (ffi : * mut Tuple_String_Vec_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) -> (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) { let ffi_ref = & * ffi ; (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: SenderKeyIndex >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex as ferment :: FFIConversionFrom < dpp :: prelude :: RecipientKeyIndex >> :: ffi_from (ffi_ref . o_1) , < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >)) -> * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: SenderKeyIndex >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex as ferment :: FFIConversionTo < dpp :: prelude :: RecipientKeyIndex >> :: ffi_to (obj . 1) , o_2 : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8_ctor (o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex , o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex , o_2 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { ferment :: boxed (Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8_destroy (ffi : * mut Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_example_simple_errors_context_ContextProviderError { pub ok : * mut u32 , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError } impl ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: context :: ContextProviderError > > for Result_ok_u32_err_example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_example_simple_errors_context_ContextProviderError) -> Result < u32 , example_simple :: errors :: context :: ContextProviderError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < example_simple :: errors :: context :: ContextProviderError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: context :: ContextProviderError > > for Result_ok_u32_err_example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : Result < u32 , example_simple :: errors :: context :: ContextProviderError >) -> * const Result_ok_u32_err_example_simple_errors_context_ContextProviderError { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < example_simple :: errors :: context :: ContextProviderError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderError_ctor (ok : * mut u32 , error : * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderError_destroy (ffi : * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderError_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: context :: example_simple_errors_context_ContextProviderError) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_u32 { pub obj : * mut std :: sync :: RwLock < u32 > } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > > for std_sync_RwLock_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_u32) -> std :: sync :: RwLock < u32 > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < u32 > > for std_sync_RwLock_u32 { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < u32 >) -> * const std_sync_RwLock_u32 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_RwLock_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_ctor (obj : u32) -> * mut std_sync_RwLock_u32 { ferment :: boxed (std_sync_RwLock_u32 { obj : ferment :: boxed (std :: sync :: RwLock :: new (obj)) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_destroy (ffi : * mut std_sync_RwLock_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_read (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_u32) -> u32 { let lock = < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; obj . clone () } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_write (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_u32 , value : u32) { let lock = < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = value ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Vec_u8 { pub obj : * mut std :: sync :: RwLock < Vec < u8 > > } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > > for std_sync_RwLock_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Vec_u8) -> std :: sync :: RwLock < Vec < u8 > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Vec < u8 > > > for std_sync_RwLock_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Vec < u8 > >) -> * const std_sync_RwLock_Vec_u8 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_RwLock_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_RwLock_Vec_u8 { ferment :: boxed (std_sync_RwLock_Vec_u8 { obj : ferment :: boxed (std :: sync :: RwLock :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_destroy (ffi : * mut std_sync_RwLock_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_read (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_write (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: sync :: RwLock :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Option_String { pub obj : * mut std :: sync :: RwLock < Option < String > > } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > > for std_sync_RwLock_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Option_String) -> std :: sync :: RwLock < Option < String > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Option < String > > > for std_sync_RwLock_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Option < String > >) -> * const std_sync_RwLock_Option_String { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_RwLock_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_RwLock_Option_String { ferment :: boxed (std_sync_RwLock_Option_String { obj : ferment :: boxed (std :: sync :: RwLock :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_destroy (ffi : * mut std_sync_RwLock_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_read (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String) -> * mut std :: os :: raw :: c_char { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_write (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String , value : * mut std :: os :: raw :: c_char) { let lock = < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_nested_gen_dict_CacheExample { pub obj : * mut example_nested :: gen :: dict :: CacheExample } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > > for std_sync_Arc_example_nested_gen_dict_CacheExample { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_nested_gen_dict_CacheExample) -> std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > > for std_sync_Arc_example_nested_gen_dict_CacheExample { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample >) -> * const std_sync_Arc_example_nested_gen_dict_CacheExample { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_nested_gen_dict_CacheExample { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_gen_dict_CacheExample_ctor (obj : * mut example_nested :: gen :: dict :: CacheExample) -> * mut std_sync_Arc_example_nested_gen_dict_CacheExample { ferment :: boxed (std_sync_Arc_example_nested_gen_dict_CacheExample { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_gen_dict_CacheExample_destroy (ffi : * mut std_sync_Arc_example_nested_gen_dict_CacheExample) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_String) -> std :: collections :: BTreeSet < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < String >) -> * const std_collections_BTreeSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for std_collections_BTreeSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_BTreeSet_String { ferment :: boxed (std_collections_BTreeSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_destroy (ffi : * mut std_collections_BTreeSet_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_value_at_index (ffi : * const std_collections_BTreeSet_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_set_value_at_index (ffi : * mut std_collections_BTreeSet_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_String { pub ok : * mut u32 , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < u32 , String > > for Result_ok_u32_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_String) -> Result < u32 , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < u32 , String > > for Result_ok_u32_err_String { unsafe fn ffi_to_const (obj : Result < u32 , String >) -> * const Result_ok_u32_err_String { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_String { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: unbox_string (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_String_ctor (ok : * mut u32 , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_u32_err_String { ferment :: boxed (Result_ok_u32_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_String_destroy (ffi : * mut Result_ok_u32_err_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_String_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_String { ferment :: boxed (Result_ok_u32_err_String { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_String_Error_ctor (error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_u32_err_String { ferment :: boxed (Result_ok_u32_err_String { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_value_by_key (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Vec_u8) -> Vec < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Vec < u8 > >) -> * const Vec_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) }) } } impl Drop for Vec_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Vec_u8 { ferment :: boxed (Vec_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_destroy (ffi : * mut Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_value_at_index (ffi : * const Vec_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_set_value_at_index (ffi : * mut Vec_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < Vec < Option < u32 > > > for Vec_Option_u32 { unsafe fn ffi_from_const (ffi : * const Vec_Option_u32) -> Vec < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | ferment :: from_opt_primitive (* o)) } } impl ferment :: FFIConversionTo < Vec < Option < u32 > > > for Vec_Option_u32 { unsafe fn ffi_to_const (obj : Vec < Option < u32 > >) -> * const Vec_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: to_opt_primitive (o)) }) } } impl Drop for Vec_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut Vec_Option_u32 { ferment :: boxed (Vec_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_destroy (ffi : * mut Vec_Option_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_value_at_index (ffi : * const Vec_Option_u32 , index : usize) -> * mut u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_set_value_at_index (ffi : * mut Vec_Option_u32 , index : usize , value : * mut u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < Option < String > > > for Vec_Option_String { unsafe fn ffi_from_const (ffi : * const Vec_Option_String) -> Vec < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < Vec < Option < String > > > for Vec_Option_String { unsafe fn ffi_to_const (obj : Vec < Option < String > >) -> * const Vec_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (o)) }) } } impl Drop for Vec_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Vec_Option_String { ferment :: boxed (Vec_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_destroy (ffi : * mut Vec_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_value_at_index (ffi : * const Vec_Option_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_set_value_at_index (ffi : * mut Vec_Option_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Option < Vec < u8 > > > > for Vec_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Option_Vec_u8) -> Vec < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < Vec < Option < Vec < u8 > > > > for Vec_Option_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Option < Vec < u8 > > >) -> * const Vec_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o)) }) } } impl Drop for Vec_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Option_Vec_u8 { ferment :: boxed (Vec_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_destroy (ffi : * mut Vec_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_value_at_index (ffi : * const Vec_Option_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_set_value_at_index (ffi : * mut Vec_Option_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < u32 > > for std_sync_Arc_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_u32) -> std :: sync :: Arc < u32 > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < u32 > > for std_sync_Arc_u32 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < u32 >) -> * const std_sync_Arc_u32 { ferment :: boxed (Self { obj : * obj }) } } impl Drop for std_sync_Arc_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_u32_ctor (obj : u32) -> * mut std_sync_Arc_u32 { ferment :: boxed (std_sync_Arc_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_u32_destroy (ffi : * mut std_sync_Arc_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Vec < u8 > > > for std_sync_Arc_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Vec_u8) -> std :: sync :: Arc < Vec < u8 > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Vec < u8 > > > for std_sync_Arc_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Vec < u8 > >) -> * const std_sync_Arc_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_Arc_Vec_u8 { ferment :: boxed (std_sync_Arc_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Vec_u8_destroy (ffi : * mut std_sync_Arc_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Option < String > > > for std_sync_Arc_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Option_String) -> std :: sync :: Arc < Option < String > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Option < String > > > for std_sync_Arc_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Option < String > >) -> * const std_sync_Arc_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_Arc_Option_String { ferment :: boxed (std_sync_Arc_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_String_destroy (ffi : * mut std_sync_Arc_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: generics :: Vec_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: Vec_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < Vec < snapshot :: LLMQSnapshot > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < Vec < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | < crate :: fermented :: generics :: Vec_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < Vec < snapshot :: LLMQSnapshot > >> :: ffi_to_opt (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: generics :: Vec_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Ok_ctor (ok : * mut crate :: fermented :: generics :: Vec_snapshot_LLMQSnapshot) -> * mut Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_Vec_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < snapshot :: LLMQSnapshot > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < std :: sync :: Arc < snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { let (ok , error) = ferment :: to_result (obj , | o | < crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < snapshot :: LLMQSnapshot > >> :: ffi_to_opt (o) , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Ok_ctor (ok : * mut crate :: fermented :: generics :: std_sync_Arc_snapshot_LLMQSnapshot) -> * mut Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_Error_ctor (error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_std_sync_Arc_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { pub o_0 : u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , pub o_2 : * mut snapshot :: LLMQSnapshot } impl ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot) -> (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_1) , ferment :: from_opt_opaque (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : (u32 , example_simple :: nested :: HashID , Option < snapshot :: LLMQSnapshot >)) -> * const Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 1) , o_2 : ferment :: to_opt_primitive (obj . 2) }) } } impl Drop for Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_1) ; ferment :: unbox_any_opt (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot_ctor (o_0 : u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_2 : * mut snapshot :: LLMQSnapshot) -> * mut Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { ferment :: boxed (Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot_destroy (ffi : * mut Tuple_u32_example_simple_nested_HashID_Option_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_u32 { pub obj : * mut std :: cell :: RefCell < u32 > } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > > for std_cell_RefCell_u32 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_u32) -> std :: cell :: RefCell < u32 > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < u32 > > for std_cell_RefCell_u32 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < u32 >) -> * const std_cell_RefCell_u32 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_cell_RefCell_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_ctor (obj : u32) -> * mut std_cell_RefCell_u32 { ferment :: boxed (std_cell_RefCell_u32 { obj : ferment :: boxed (std :: cell :: RefCell :: new (obj)) }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_destroy (ffi : * mut std_cell_RefCell_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_read (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u32) -> u32 { let lock = < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > >> :: ffi_from (obj) ; let obj = lock . borrow () ; obj . clone () } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_write (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_u32 , value : u32) { let lock = < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > >> :: ffi_from (obj) ; match lock . try_borrow_mut () { Ok (mut obj) => { * obj = value ; } , Err (_) => { } , } ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Vec_u8 { pub obj : * mut std :: cell :: RefCell < Vec < u8 > > } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > > for std_cell_RefCell_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Vec_u8) -> std :: cell :: RefCell < Vec < u8 > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Vec < u8 > > > for std_cell_RefCell_Vec_u8 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Vec < u8 > >) -> * const std_cell_RefCell_Vec_u8 { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_cell_RefCell_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_cell_RefCell_Vec_u8 { ferment :: boxed (std_cell_RefCell_Vec_u8 { obj : ferment :: boxed (std :: cell :: RefCell :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_destroy (ffi : * mut std_cell_RefCell_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_read (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8) -> * mut crate :: fermented :: generics :: Vec_u8 { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_from (obj) ; let obj = lock . borrow () ; < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_write (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 , value : * mut crate :: fermented :: generics :: Vec_u8) { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_from (obj) ; match lock . try_borrow_mut () { Ok (mut obj) => { * obj = < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (value) ; } , Err (_) => { } , } ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: cell :: RefCell :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let obj = lock . borrow () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; match lock . try_borrow_mut () { Ok (mut obj) => { * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from_opt (value) ; } , Err (_) => { } , } ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Option_String { pub obj : * mut std :: cell :: RefCell < Option < String > > } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > > for std_cell_RefCell_Option_String { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Option_String) -> std :: cell :: RefCell < Option < String > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Option < String > > > for std_cell_RefCell_Option_String { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Option < String > >) -> * const std_cell_RefCell_Option_String { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_cell_RefCell_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_cell_RefCell_Option_String { ferment :: boxed (std_cell_RefCell_Option_String { obj : ferment :: boxed (std :: cell :: RefCell :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_destroy (ffi : * mut std_cell_RefCell_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_read (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String) -> * mut std :: os :: raw :: c_char { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > >> :: ffi_from (obj) ; let obj = lock . borrow () ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_write (obj : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String , value : * mut std :: os :: raw :: c_char) { let lock = < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > >> :: ffi_from (obj) ; match lock . try_borrow_mut () { Ok (mut obj) => { * obj = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (value) ; } , Err (_) => { } , } ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { pub ok : * mut example_simple :: types :: opaque :: OpaqueCloneableType , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > > for Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32) -> Result < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_result_prefer_ok (ffi_ref . ok , | o | std :: ptr :: read (o) , ffi_ref . error , | o | * o) } } impl ferment :: FFIConversionTo < Result < example_simple :: types :: opaque :: OpaqueCloneableType , u32 > > for Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { unsafe fn ffi_to_const (obj : Result < example_simple :: types :: opaque :: OpaqueCloneableType , u32 >) -> * const Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . ok) ; ferment :: black_hole (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32_ctor (ok : * mut example_simple :: types :: opaque :: OpaqueCloneableType , error : * mut u32) -> * mut Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32_destroy (ffi : * mut Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32_Ok_ctor (ok : * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32_Error_ctor (error : * mut u32) -> * mut Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ferment :: boxed (Result_ok_example_simple_types_opaque_OpaqueCloneableType_err_u32 { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Vec_bool { pub count : usize , pub values : * mut bool } impl ferment :: FFIConversionFrom < Vec < bool > > for Vec_bool { unsafe fn ffi_from_const (ffi : * const Vec_bool) -> Vec < bool > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < Vec < bool > > for Vec_bool { unsafe fn ffi_to_const (obj : Vec < bool >) -> * const Vec_bool { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Vec_bool { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_bool_ctor (count : usize , values : * mut bool) -> * mut Vec_bool { ferment :: boxed (Vec_bool { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_bool_destroy (ffi : * mut Vec_bool) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_bool_value_at_index (ffi : * const Vec_bool , index : usize) -> bool { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_bool_set_value_at_index (ffi : * mut Vec_bool , index : usize , value : bool) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < u32 > > for std_collections_BTreeSet_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_u32) -> std :: collections :: BTreeSet < u32 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < u32 > > for std_collections_BTreeSet_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < u32 >) -> * const std_collections_BTreeSet_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for std_collections_BTreeSet_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_ctor (count : usize , values : * mut u32) -> * mut std_collections_BTreeSet_u32 { ferment :: boxed (std_collections_BTreeSet_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_destroy (ffi : * mut std_collections_BTreeSet_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_value_at_index (ffi : * const std_collections_BTreeSet_u32 , index : usize) -> u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_set_value_at_index (ffi : * mut std_collections_BTreeSet_u32 , index : usize , value : u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Vec < u8 > > > for std_collections_BTreeSet_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Vec_u8) -> std :: collections :: BTreeSet < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Vec < u8 > > > for std_collections_BTreeSet_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Vec < u8 > >) -> * const std_collections_BTreeSet_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) }) } } impl Drop for std_collections_BTreeSet_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_BTreeSet_Vec_u8 { ferment :: boxed (std_collections_BTreeSet_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_destroy (ffi : * mut std_collections_BTreeSet_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_value_at_index (ffi : * const std_collections_BTreeSet_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_set_value_at_index (ffi : * mut std_collections_BTreeSet_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < u32 > > > for std_collections_BTreeSet_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_u32) -> std :: collections :: BTreeSet < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | ferment :: from_opt_primitive (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < u32 > > > for std_collections_BTreeSet_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < u32 > >) -> * const std_collections_BTreeSet_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: to_opt_primitive (o)) }) } } impl Drop for std_collections_BTreeSet_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut std_collections_BTreeSet_Option_u32 { ferment :: boxed (std_collections_BTreeSet_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_destroy (ffi : * mut std_collections_BTreeSet_Option_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_value_at_index (ffi : * const std_collections_BTreeSet_Option_u32 , index : usize) -> * mut u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_set_value_at_index (ffi : * mut std_collections_BTreeSet_Option_u32 , index : usize , value : * mut u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < String > > > for std_collections_BTreeSet_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_String) -> std :: collections :: BTreeSet < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < String > > > for std_collections_BTreeSet_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < String > >) -> * const std_collections_BTreeSet_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (o)) }) } } impl Drop for std_collections_BTreeSet_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_BTreeSet_Option_String { ferment :: boxed (std_collections_BTreeSet_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_destroy (ffi : * mut std_collections_BTreeSet_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_value_at_index (ffi : * const std_collections_BTreeSet_Option_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_set_value_at_index (ffi : * mut std_collections_BTreeSet_Option_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < Vec < u8 > > > > for std_collections_BTreeSet_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_Vec_u8) -> std :: collections :: BTreeSet < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < Vec < u8 > > > > for std_collections_BTreeSet_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < Vec < u8 > > >) -> * const std_collections_BTreeSet_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o)) }) } } impl Drop for std_collections_BTreeSet_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_BTreeSet_Option_Vec_u8 { ferment :: boxed (std_collections_BTreeSet_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_destroy (ffi : * mut std_collections_BTreeSet_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_value_at_index (ffi : * const std_collections_BTreeSet_Option_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_set_value_at_index (ffi : * mut std_collections_BTreeSet_Option_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < u32 > > for std_collections_HashSet_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_u32) -> std :: collections :: HashSet < u32 > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < u32 > > for std_collections_HashSet_u32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < u32 >) -> * const std_collections_HashSet_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for std_collections_HashSet_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_ctor (count : usize , values : * mut u32) -> * mut std_collections_HashSet_u32 { ferment :: boxed (std_collections_HashSet_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_destroy (ffi : * mut std_collections_HashSet_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_value_at_index (ffi : * const std_collections_HashSet_u32 , index : usize) -> u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_set_value_at_index (ffi : * mut std_collections_HashSet_u32 , index : usize , value : u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < String > > for std_collections_HashSet_String { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_String) -> std :: collections :: HashSet < String > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < String > > for std_collections_HashSet_String { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < String >) -> * const std_collections_HashSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o)) }) } } impl Drop for std_collections_HashSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_string (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_HashSet_String { ferment :: boxed (std_collections_HashSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_destroy (ffi : * mut std_collections_HashSet_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_value_at_index (ffi : * const std_collections_HashSet_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_set_value_at_index (ffi : * mut std_collections_HashSet_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Vec < u8 > > > for std_collections_HashSet_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Vec_u8) -> std :: collections :: HashSet < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Vec < u8 > > > for std_collections_HashSet_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Vec < u8 > >) -> * const std_collections_HashSet_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o)) }) } } impl Drop for std_collections_HashSet_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_HashSet_Vec_u8 { ferment :: boxed (std_collections_HashSet_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_destroy (ffi : * mut std_collections_HashSet_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_value_at_index (ffi : * const std_collections_HashSet_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_set_value_at_index (ffi : * mut std_collections_HashSet_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < u32 > > > for std_collections_HashSet_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_u32) -> std :: collections :: HashSet < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | ferment :: from_opt_primitive (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < u32 > > > for std_collections_HashSet_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < u32 > >) -> * const std_collections_HashSet_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: to_opt_primitive (o)) }) } } impl Drop for std_collections_HashSet_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut std_collections_HashSet_Option_u32 { ferment :: boxed (std_collections_HashSet_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_destroy (ffi : * mut std_collections_HashSet_Option_u32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_value_at_index (ffi : * const std_collections_HashSet_Option_u32 , index : usize) -> * mut u32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_set_value_at_index (ffi : * mut std_collections_HashSet_Option_u32 , index : usize , value : * mut u32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < String > > > for std_collections_HashSet_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_String) -> std :: collections :: HashSet < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < String > > > for std_collections_HashSet_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < String > >) -> * const std_collections_HashSet_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (o)) }) } } impl Drop for std_collections_HashSet_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_HashSet_Option_String { ferment :: boxed (std_collections_HashSet_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_destroy (ffi : * mut std_collections_HashSet_Option_String) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_value_at_index (ffi : * const std_collections_HashSet_Option_String , index : usize) -> * mut std :: os :: raw :: c_char { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_set_value_at_index (ffi : * mut std_collections_HashSet_Option_String , index : usize , value : * mut std :: os :: raw :: c_char) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < Vec < u8 > > > > for std_collections_HashSet_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_Vec_u8) -> std :: collections :: HashSet < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < Vec < u8 > > > > for std_collections_HashSet_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < Vec < u8 > > >) -> * const std_collections_HashSet_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (o)) }) } } impl Drop for std_collections_HashSet_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_HashSet_Option_Vec_u8 { ferment :: boxed (std_collections_HashSet_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_destroy (ffi : * mut std_collections_HashSet_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_value_at_index (ffi : * const std_collections_HashSet_Option_Vec_u8 , index : usize) -> * mut crate :: fermented :: generics :: Vec_u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_set_value_at_index (ffi : * mut std_collections_HashSet_Option_Vec_u8 , index : usize , value : * mut crate :: fermented :: generics :: Vec_u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) -> std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from_opt (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > >) -> * const std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_to_opt (o)) }) } } impl Drop for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_value_at_index (ffi : * const std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError , index : usize) -> * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_set_value_at_index (ffi : * mut std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError , index : usize , value : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueNonCloneableType > > for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType) -> std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueNonCloneableType > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueNonCloneableType > > for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , example_simple :: types :: opaque :: OpaqueNonCloneableType >) -> * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType_ctor (count : usize , keys : * mut u32 , values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { ferment :: boxed (std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType_destroy (ffi : * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType_value_by_key (ffi : * const std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType , key : u32) -> * mut example_simple :: types :: opaque :: OpaqueNonCloneableType { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_example_simple_types_opaque_OpaqueNonCloneableType , key : u32 , value : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < example_simple :: types :: opaque :: OpaqueCloneableType > > > for std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType) -> std :: collections :: BTreeMap < u32 , Option < example_simple :: types :: opaque :: OpaqueCloneableType > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | ferment :: from_opt_opaque (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < example_simple :: types :: opaque :: OpaqueCloneableType > > > for std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < example_simple :: types :: opaque :: OpaqueCloneableType > >) -> * const std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { let (count , keys , values) = ferment :: to_map (obj , | o | o , | o | ferment :: to_opt_primitive (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: black_hole (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType_ctor (count : usize , keys : * mut u32 , values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType_value_by_key (ffi : * const std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType , key : u32) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType_set_value_for_key (ffi : * mut std_collections_Map_keys_u32_values_Option_example_simple_types_opaque_OpaqueCloneableType , key : u32 , value : * mut example_simple :: types :: opaque :: OpaqueCloneableType) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_96 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_from_const (ffi : * const Arr_u8_96) -> [u8 ; 96] { let ffi_ref = & * ffi ; TryFrom :: < Vec < u8 >> :: try_from (ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | * o)) . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_to_const (obj : [u8 ; 96]) -> * const Arr_u8_96 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | o) }) } } impl Drop for Arr_u8_96 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: black_hole (o)) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_96 { ferment :: boxed (Arr_u8_96 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_destroy (ffi : * mut Arr_u8_96) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_value_at_index (ffi : * const Arr_u8_96 , index : usize) -> u8 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_set_value_at_index (ffi : * mut Arr_u8_96 , index : usize , value : u8) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_example_nested_ExampleEnumLif { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif } impl < 'a > ferment :: FFIConversionFrom < Vec < example_nested :: ExampleEnumLif < 'a > > > for Vec_example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const Vec_example_nested_ExampleEnumLif) -> Vec < example_nested :: ExampleEnumLif < 'a > > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (* o)) } } impl < 'a > ferment :: FFIConversionTo < Vec < example_nested :: ExampleEnumLif < 'a > > > for Vec_example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : Vec < example_nested :: ExampleEnumLif < 'a > >) -> * const Vec_example_nested_ExampleEnumLif { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionTo < example_nested :: ExampleEnumLif < 'a > >> :: ffi_to (o)) }) } } impl Drop for Vec_example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) -> * mut Vec_example_nested_ExampleEnumLif { ferment :: boxed (Vec_example_nested_ExampleEnumLif { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_destroy (ffi : * mut Vec_example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_value_at_index (ffi : * const Vec_example_nested_ExampleEnumLif , index : usize) -> * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_set_value_at_index (ffi : * mut Vec_example_nested_ExampleEnumLif , index : usize , value : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif } impl < 'a > ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > > for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) -> std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (o)) } } impl < 'a > ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > > for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > >) -> * const std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionTo < example_nested :: ExampleEnumLif < 'a > >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) -> * mut std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { ferment :: boxed (std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_destroy (ffi : * mut std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_value_by_key (ffi : * const std_collections_Map_keys_String_values_example_nested_ExampleEnumLif , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_example_nested_ExampleEnumLif , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_index_IndexProperty { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_index_IndexProperty) -> Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: IndexProperty >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: index :: IndexProperty >) -> * const Vec_dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: IndexProperty >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty) -> * mut Vec_dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (Vec_dpp_data_contract_document_type_index_IndexProperty { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_destroy (ffi : * mut Vec_dpp_data_contract_document_type_index_IndexProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_value_at_index (ffi : * const Vec_dpp_data_contract_document_type_index_IndexProperty , index : usize) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_set_value_at_index (ffi : * mut Vec_dpp_data_contract_document_type_index_IndexProperty , index : usize , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { pub count : usize , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueNonCloneableType > > for std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType) -> std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueNonCloneableType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueNonCloneableType > > for std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < example_simple :: types :: opaque :: OpaqueNonCloneableType >) -> * const std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType_ctor (count : usize , values : * mut * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) -> * mut std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { ferment :: boxed (std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType_destroy (ffi : * mut std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType_value_at_index (ffi : * const std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType , index : usize) -> * mut example_simple :: types :: opaque :: OpaqueNonCloneableType { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType_set_value_at_index (ffi : * mut std_collections_HashSet_example_simple_types_opaque_OpaqueNonCloneableType , index : usize , value : * mut example_simple :: types :: opaque :: OpaqueNonCloneableType) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_u8_32) -> Vec < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_to_const (obj : Vec < [u8 ; 32] >) -> * const Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o)) }) } } impl Drop for Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Vec_u8_32 { ferment :: boxed (Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_destroy (ffi : * mut Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_value_at_index (ffi : * const Vec_u8_32 , index : usize) -> * mut crate :: fermented :: generics :: Arr_u8_32 { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_set_value_at_index (ffi : * mut Vec_u8_32 , index : usize , value : * mut crate :: fermented :: generics :: Arr_u8_32) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > for std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > { let ffi_ref = & * ffi ; std :: ptr :: read (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > for std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >) -> * const std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: sync :: RwLock :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from (obj))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from (value) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { pub obj : * mut std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: clone (& * ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > > for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > >) -> * const std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: boxed (obj) }) } } impl Drop for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { obj : ferment :: boxed (std :: sync :: Arc :: new (std :: sync :: RwLock :: new (< crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from (obj)))) }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_read (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let obj = lock . read () . unwrap () ; < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_to (obj . clone ()) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot_write (obj : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot , value : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot) { let lock = < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > > > >> :: ffi_from (obj) ; let mut obj = lock . write () . unwrap () ; * obj = < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , snapshot :: LLMQSnapshot > >> :: ffi_from (value) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_document_Document { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } impl ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const Vec_dpp_document_Document) -> Vec < dpp :: document :: Document > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_to_const (obj : Vec < dpp :: document :: Document >) -> * const Vec_dpp_document_Document { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (o)) }) } } impl Drop for Vec_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut Vec_dpp_document_Document { ferment :: boxed (Vec_dpp_document_Document { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_destroy (ffi : * mut Vec_dpp_document_Document) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_value_at_index (ffi : * const Vec_dpp_document_Document , index : usize) -> * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_set_value_at_index (ffi : * mut Vec_dpp_document_Document , index : usize , value : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_value_by_key (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Tuple_String_dpp_balances_credits_Credits { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const Tuple_String_dpp_balances_credits_Credits) -> (String , dpp :: balances :: credits :: Credits) { let ffi_ref = & * ffi ; (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . o_1)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : (String , dpp :: balances :: credits :: Credits)) -> * const Tuple_String_dpp_balances_credits_Credits { ferment :: boxed (Self { o_0 : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . 0) , o_1 : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . 1) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Tuple_String_dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { ferment :: unbox_string (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Tuple_String_dpp_balances_credits_Credits_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut Tuple_String_dpp_balances_credits_Credits { ferment :: boxed (Tuple_String_dpp_balances_credits_Credits { o_0 , o_1 }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Tuple_String_dpp_balances_credits_Credits_destroy (ffi : * mut Tuple_String_dpp_balances_credits_Credits) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { pub o_0 : u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , pub o_2 : * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_LLMQSnapshot } impl ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot) -> (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: LLMQSnapshot >) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (ffi_ref . o_1) , ferment :: from_opt_opaque (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { unsafe fn ffi_to_const (obj : (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: LLMQSnapshot >)) -> * const Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj . 1) , o_2 : ferment :: to_opt_primitive (obj . 2) }) } } impl Drop for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_1) ; ferment :: unbox_any_opt (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot_ctor (o_0 : u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_2 : * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_LLMQSnapshot) -> * mut Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { ferment :: boxed (Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot_destroy (ffi : * mut Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { pub ok : * mut u32 , pub error : * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError } impl ferment :: FFIConversionFrom < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > > for Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError) -> Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionFrom < Vec < example_simple :: errors :: context :: ContextProviderError > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > > > for Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : Result < u32 , Vec < example_simple :: errors :: context :: ContextProviderError > >) -> * const Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError as ferment :: FFIConversionTo < Vec < example_simple :: errors :: context :: ContextProviderError > >> :: ffi_to (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError_ctor (ok : * mut u32 , error : * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError) -> * mut Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError_destroy (ffi : * mut Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError_Error_ctor (error : * mut crate :: fermented :: generics :: Vec_example_simple_errors_context_ContextProviderError) -> * mut Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ferment :: boxed (Result_ok_u32_err_Vec_example_simple_errors_context_ContextProviderError { ok : std :: ptr :: null_mut () , error }) } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { pub ok : * mut u32 , pub error : * mut example_simple :: errors :: context :: ContextProviderErrorOpaque } impl ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque > > for Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque) -> Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | std :: ptr :: read (o)) } } impl ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque > > for Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { unsafe fn ffi_to_const (obj : Result < u32 , example_simple :: errors :: context :: ContextProviderErrorOpaque >) -> * const Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: boxed (o)) ; ferment :: boxed (Self { ok , error }) } } impl Drop for Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { fn drop (& mut self) { unsafe { ferment :: black_hole (self . ok) ; ferment :: unbox_any (self . error) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque_ctor (ok : * mut u32 , error : * mut example_simple :: errors :: context :: ContextProviderErrorOpaque) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque_destroy (ffi : * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque_Ok_ctor (ok : * mut u32) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ok , error : std :: ptr :: null_mut () }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque_Error_ctor (error : * mut example_simple :: errors :: context :: ContextProviderErrorOpaque) -> * mut Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ferment :: boxed (Result_ok_u32_err_example_simple_errors_context_ContextProviderErrorOpaque { ok : std :: ptr :: null_mut () , error }) } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut * mut types :: identifier :: Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_ctor (count : usize , keys : * mut * mut types :: identifier :: Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { ferment :: boxed (std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { count , keys , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_destroy (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_value_by_key (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount , key : * mut types :: identifier :: Identifier) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_set_value_for_key (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount , key : * mut types :: identifier :: Identifier , value : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { pub count : usize , pub keys : * mut * mut types :: identifier :: Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document) -> std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | std :: ptr :: read (o) , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from_opt (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < types :: identifier :: Identifier , Option < dpp :: document :: Document > >) -> * const std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { let (count , keys , values) = ferment :: to_map (obj , | o | ferment :: boxed (o) , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to_opt (o)) ; ferment :: boxed (Self { count , keys , values }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_any (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any_opt (o)) ; ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document_ctor (count : usize , keys : * mut * mut types :: identifier :: Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { ferment :: boxed (std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document { count , keys , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document_destroy (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document_value_by_key (ffi : * const std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document , key : * mut types :: identifier :: Identifier) -> * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document_set_value_for_key (ffi : * mut std_collections_Map_keys_types_identifier_Identifier_values_Option_dpp_document_Document , key : * mut types :: identifier :: Identifier , value : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } # [repr (C)] # [derive (Clone)] pub struct Vec_example_simple_types_opaque_OpaqueCloneableType { pub count : usize , pub values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType } impl ferment :: FFIConversionFrom < Vec < example_simple :: types :: opaque :: OpaqueCloneableType > > for Vec_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_from_const (ffi : * const Vec_example_simple_types_opaque_OpaqueCloneableType) -> Vec < example_simple :: types :: opaque :: OpaqueCloneableType > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | std :: ptr :: read (* o)) } } impl ferment :: FFIConversionTo < Vec < example_simple :: types :: opaque :: OpaqueCloneableType > > for Vec_example_simple_types_opaque_OpaqueCloneableType { unsafe fn ffi_to_const (obj : Vec < example_simple :: types :: opaque :: OpaqueCloneableType >) -> * const Vec_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | ferment :: boxed (o)) }) } } impl Drop for Vec_example_simple_types_opaque_OpaqueCloneableType { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueCloneableType_ctor (count : usize , values : * mut * mut example_simple :: types :: opaque :: OpaqueCloneableType) -> * mut Vec_example_simple_types_opaque_OpaqueCloneableType { ferment :: boxed (Vec_example_simple_types_opaque_OpaqueCloneableType { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueCloneableType_destroy (ffi : * mut Vec_example_simple_types_opaque_OpaqueCloneableType) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueCloneableType_value_at_index (ffi : * const Vec_example_simple_types_opaque_OpaqueCloneableType , index : usize) -> * mut example_simple :: types :: opaque :: OpaqueCloneableType { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_example_simple_types_opaque_OpaqueCloneableType_set_value_at_index (ffi : * mut Vec_example_simple_types_opaque_OpaqueCloneableType , index : usize , value : * mut example_simple :: types :: opaque :: OpaqueCloneableType) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { pub o_0 : * mut example_simple :: types :: opaque :: OpaqueCloneableType , pub o_1 : u32 } impl ferment :: FFIConversionFrom < (example_simple :: types :: opaque :: OpaqueCloneableType , u32) > for Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { unsafe fn ffi_from_const (ffi : * const Tuple_example_simple_types_opaque_OpaqueCloneableType_u32) -> (example_simple :: types :: opaque :: OpaqueCloneableType , u32) { let ffi_ref = & * ffi ; (std :: ptr :: read (ffi_ref . o_0) , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (example_simple :: types :: opaque :: OpaqueCloneableType , u32) > for Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { unsafe fn ffi_to_const (obj : (example_simple :: types :: opaque :: OpaqueCloneableType , u32)) -> * const Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { ferment :: boxed (Self { o_0 : ferment :: boxed (obj . 0) , o_1 : obj . 1 }) } } impl Drop for Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_types_opaque_OpaqueCloneableType_u32_ctor (o_0 : * mut example_simple :: types :: opaque :: OpaqueCloneableType , o_1 : u32) -> * mut Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { ferment :: boxed (Tuple_example_simple_types_opaque_OpaqueCloneableType_u32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_example_simple_types_opaque_OpaqueCloneableType_u32_destroy (ffi : * mut Tuple_example_simple_types_opaque_OpaqueCloneableType_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txin_TxIn { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txin_TxIn) -> Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txin :: TxIn >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txin :: TxIn >) -> * const Vec_dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txin :: TxIn >> :: ffi_to (o)) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn) -> * mut Vec_dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (Vec_dashcore_blockdata_transaction_txin_TxIn { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_destroy (ffi : * mut Vec_dashcore_blockdata_transaction_txin_TxIn) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_value_at_index (ffi : * const Vec_dashcore_blockdata_transaction_txin_TxIn , index : usize) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_set_value_at_index (ffi : * mut Vec_dashcore_blockdata_transaction_txin_TxIn , index : usize , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txout_TxOut { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txout_TxOut) -> Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > { let ffi_ref = & * ffi ; ferment :: from_group (ffi_ref . count , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txout :: TxOut >> :: ffi_from (* o)) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txout :: TxOut >) -> * const Vec_dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_group (obj . into_iter () , | o | < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txout :: TxOut >> :: ffi_to (o)) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut) -> * mut Vec_dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (Vec_dashcore_blockdata_transaction_txout_TxOut { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_destroy (ffi : * mut Vec_dashcore_blockdata_transaction_txout_TxOut) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_value_at_index (ffi : * const Vec_dashcore_blockdata_transaction_txout_TxOut , index : usize) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut { * (* ffi) . values . add (index) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_set_value_at_index (ffi : * mut Vec_dashcore_blockdata_transaction_txout_TxOut , index : usize , value : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut) { * (* ffi) . values . add (index) = value } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { let (count , keys , values) = ferment :: to_map (obj , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: Index >> :: ffi_to (o)) ; ferment :: boxed (Self { count , keys , values }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { ferment :: unbox_group (self . keys , self . count , | o | ferment :: unbox_string (o)) ; ferment :: unbox_group (self . values , self . count , | o | ferment :: unbox_any (o)) ; ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_value_by_key (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , key : * mut std :: os :: raw :: c_char) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index { let ffi_ref = & * ffi ; let key = key ; for i in 0 .. ffi_ref . count { if key == * ffi_ref . keys . add (i) { return * ffi_ref . values . add (i) ; } } std :: ptr :: null_mut () } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_set_value_for_key (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , key : * mut std :: os :: raw :: c_char , value : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index) { let ffi_ref = & * ffi ; let target_key = key ; for i in 0 .. ffi_ref . count { let candidate_key = * ffi_ref . keys . add (i) ; if candidate_key . eq (& target_key) { let new_value = (* ffi) . values . add (i) ; let old_value = * new_value ; if (! (old_value) . is_null ()) { ferment :: unbox_any (old_value) ; } * new_value = value ; break ; } } } }