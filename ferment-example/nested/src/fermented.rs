# [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod types { pub mod dpp { use crate as example_nested ; pub mod util { use crate as example_nested ; pub mod json_value { use crate as example_nested ; pub mod remove_path { use crate as example_nested ; } pub mod insert_with_path { use crate as example_nested ; } } # [cfg (feature = "cbor")] pub mod cbor_value { use crate as example_nested ; pub mod convert { use crate as example_nested ; } pub mod canonical { use crate as example_nested ; } } pub mod deserializer { use crate as example_nested ; # [doc = "FFI-representation of the [`ProtocolVersion`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_util_deserializer_ProtocolVersion (u32) ; impl ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_from_const (ffi : * const dpp_util_deserializer_ProtocolVersion) -> dpp :: util :: deserializer :: ProtocolVersion { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion > for dpp_util_deserializer_ProtocolVersion { unsafe fn ffi_to_const (obj : dpp :: util :: deserializer :: ProtocolVersion) -> * const dpp_util_deserializer_ProtocolVersion { ferment :: boxed (dpp_util_deserializer_ProtocolVersion (obj)) } } impl Drop for dpp_util_deserializer_ProtocolVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_ctor < > (o_0 : u32) -> * mut dpp_util_deserializer_ProtocolVersion { ferment :: boxed (dpp_util_deserializer_ProtocolVersion (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_destroy < > (ffi : * mut dpp_util_deserializer_ProtocolVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_get_0 < > (obj : * const dpp_util_deserializer_ProtocolVersion) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_util_deserializer_ProtocolVersion_set_0 < > (obj : * const dpp_util_deserializer_ProtocolVersion) -> u32 { (* obj) . 0 } } pub mod strings { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod json_schema { use crate as example_nested ; } pub mod json_path { use crate as example_nested ; } } pub mod nft { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TradeMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_nft_TradeMode { None = 0 , DirectPurchase = 1 } impl ferment :: FFIConversionFrom < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_from_const (ffi : * const dpp_nft_TradeMode) -> dpp :: nft :: TradeMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_nft_TradeMode :: None => dpp :: nft :: TradeMode :: None , dpp_nft_TradeMode :: DirectPurchase => dpp :: nft :: TradeMode :: DirectPurchase } } } impl ferment :: FFIConversionTo < dpp :: nft :: TradeMode > for dpp_nft_TradeMode { unsafe fn ffi_to_const (obj : dpp :: nft :: TradeMode) -> * const dpp_nft_TradeMode { ferment :: boxed (match obj { dpp :: nft :: TradeMode :: None => dpp_nft_TradeMode :: None , dpp :: nft :: TradeMode :: DirectPurchase => dpp_nft_TradeMode :: DirectPurchase , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_nft_TradeMode { fn drop (& mut self) { unsafe { match self { dpp_nft_TradeMode :: None => { } , dpp_nft_TradeMode :: DirectPurchase => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_None_ctor () -> * mut dpp_nft_TradeMode { ferment :: boxed (dpp_nft_TradeMode :: None { }) } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_DirectPurchase_ctor () -> * mut dpp_nft_TradeMode { ferment :: boxed (dpp_nft_TradeMode :: DirectPurchase { }) } # [no_mangle] pub unsafe extern "C" fn dpp_nft_TradeMode_destroy < > (ffi : * mut dpp_nft_TradeMode) { ferment :: unbox_any (ffi) ; } } # [cfg (feature = "core-types")] pub mod core_types { use crate as example_nested ; pub mod validator_set { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod validator { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod fee { use crate as example_nested ; pub mod epoch { use crate as example_nested ; # [cfg (feature = "fee-distribution")] pub mod distribution { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } pub mod default_costs { use crate as example_nested ; } # [cfg (feature = "fee-distribution")] pub mod fee_result { use crate as example_nested ; pub mod refunds { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod withdrawal { use crate as example_nested ; # [cfg (feature = "system_contracts")] pub mod document_try_into_asset_unlock_base_transaction_info { use crate as example_nested ; } pub mod daily_withdrawal_limit { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Pooling`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_withdrawal_Pooling { Never = 0 , IfAvailable = 1 , Standard = 2 } impl ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_from_const (ffi : * const dpp_withdrawal_Pooling) -> dpp :: withdrawal :: Pooling { let ffi_ref = & * ffi ; match ffi_ref { dpp_withdrawal_Pooling :: Never => dpp :: withdrawal :: Pooling :: Never , dpp_withdrawal_Pooling :: IfAvailable => dpp :: withdrawal :: Pooling :: IfAvailable , dpp_withdrawal_Pooling :: Standard => dpp :: withdrawal :: Pooling :: Standard } } } impl ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling > for dpp_withdrawal_Pooling { unsafe fn ffi_to_const (obj : dpp :: withdrawal :: Pooling) -> * const dpp_withdrawal_Pooling { ferment :: boxed (match obj { dpp :: withdrawal :: Pooling :: Never => dpp_withdrawal_Pooling :: Never , dpp :: withdrawal :: Pooling :: IfAvailable => dpp_withdrawal_Pooling :: IfAvailable , dpp :: withdrawal :: Pooling :: Standard => dpp_withdrawal_Pooling :: Standard , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_withdrawal_Pooling { fn drop (& mut self) { unsafe { match self { dpp_withdrawal_Pooling :: Never => { } , dpp_withdrawal_Pooling :: IfAvailable => { } , dpp_withdrawal_Pooling :: Standard => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_Never_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: Never { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_IfAvailable_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: IfAvailable { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_Standard_ctor () -> * mut dpp_withdrawal_Pooling { ferment :: boxed (dpp_withdrawal_Pooling :: Standard { }) } # [no_mangle] pub unsafe extern "C" fn dpp_withdrawal_Pooling_destroy < > (ffi : * mut dpp_withdrawal_Pooling) { ferment :: unbox_any (ffi) ; } } pub mod balances { use crate as example_nested ; pub mod credits { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenAmount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_TokenAmount (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_TokenAmount) -> dpp :: balances :: credits :: TokenAmount { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount > for dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: TokenAmount) -> * const dpp_balances_credits_TokenAmount { ferment :: boxed (dpp_balances_credits_TokenAmount (obj)) } } impl Drop for dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_ctor < > (o_0 : u64) -> * mut dpp_balances_credits_TokenAmount { ferment :: boxed (dpp_balances_credits_TokenAmount (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_destroy < > (ffi : * mut dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_get_0 < > (obj : * const dpp_balances_credits_TokenAmount) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_TokenAmount_set_0 < > (obj : * const dpp_balances_credits_TokenAmount) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`SignedCredits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_SignedCredits (i64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_SignedCredits) -> dpp :: balances :: credits :: SignedCredits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: SignedCredits > for dpp_balances_credits_SignedCredits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: SignedCredits) -> * const dpp_balances_credits_SignedCredits { ferment :: boxed (dpp_balances_credits_SignedCredits (obj)) } } impl Drop for dpp_balances_credits_SignedCredits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_ctor < > (o_0 : i64) -> * mut dpp_balances_credits_SignedCredits { ferment :: boxed (dpp_balances_credits_SignedCredits (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_destroy < > (ffi : * mut dpp_balances_credits_SignedCredits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_get_0 < > (obj : * const dpp_balances_credits_SignedCredits) -> i64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_SignedCredits_set_0 < > (obj : * const dpp_balances_credits_SignedCredits) -> i64 { (* obj) . 0 } # [doc = "FFI-representation of the [`Credits`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_balances_credits_Credits (u64) ; impl ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const dpp_balances_credits_Credits) -> dpp :: balances :: credits :: Credits { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits > for dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : dpp :: balances :: credits :: Credits) -> * const dpp_balances_credits_Credits { ferment :: boxed (dpp_balances_credits_Credits (obj)) } } impl Drop for dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_ctor < > (o_0 : u64) -> * mut dpp_balances_credits_Credits { ferment :: boxed (dpp_balances_credits_Credits (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_destroy < > (ffi : * mut dpp_balances_credits_Credits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_get_0 < > (obj : * const dpp_balances_credits_Credits) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_balances_credits_Credits_set_0 < > (obj : * const dpp_balances_credits_Credits) -> u64 { (* obj) . 0 } } } pub mod core_subsidy { use crate as example_nested ; pub mod epoch_core_reward_credits_for_distribution { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod tokens { use crate as example_nested ; # [doc = "FFI-representation of the [`SharedEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_SharedEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_SharedEncryptedNote) -> dpp :: tokens :: SharedEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote > for dpp_tokens_SharedEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: SharedEncryptedNote) -> * const dpp_tokens_SharedEncryptedNote { ferment :: boxed (dpp_tokens_SharedEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_SharedEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_ctor < > (o_0 : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) -> * mut dpp_tokens_SharedEncryptedNote { ferment :: boxed (dpp_tokens_SharedEncryptedNote (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_destroy < > (ffi : * mut dpp_tokens_SharedEncryptedNote) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_get_0 < > (obj : * const dpp_tokens_SharedEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_SharedEncryptedNote_set_0 < > (obj : * const dpp_tokens_SharedEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { (* obj) . 0 } pub mod info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_info_v0_IdentityTokenInfoV0 { pub frozen : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { let ffi_ref = & * ffi ; dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 { frozen : ffi_ref . frozen } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 > for dpp_tokens_info_v0_IdentityTokenInfoV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0) -> * const dpp_tokens_info_v0_IdentityTokenInfoV0 { ferment :: boxed (dpp_tokens_info_v0_IdentityTokenInfoV0 { frozen : obj . frozen }) } } impl Drop for dpp_tokens_info_v0_IdentityTokenInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_ctor < > (frozen : bool) -> * mut dpp_tokens_info_v0_IdentityTokenInfoV0 { ferment :: boxed (dpp_tokens_info_v0_IdentityTokenInfoV0 { frozen }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_destroy < > (ffi : * mut dpp_tokens_info_v0_IdentityTokenInfoV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_get_frozen < > (obj : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> bool { (* obj) . frozen } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_v0_IdentityTokenInfoV0_set_frozen < > (obj : * const dpp_tokens_info_v0_IdentityTokenInfoV0) -> bool { (* obj) . frozen } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTokenInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_info_IdentityTokenInfo { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_from_const (ffi : * const dpp_tokens_info_IdentityTokenInfo) -> dpp :: tokens :: info :: IdentityTokenInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => dpp :: tokens :: info :: IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionFrom < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo > for dpp_tokens_info_IdentityTokenInfo { unsafe fn ffi_to_const (obj : dpp :: tokens :: info :: IdentityTokenInfo) -> * const dpp_tokens_info_IdentityTokenInfo { ferment :: boxed (match obj { dpp :: tokens :: info :: IdentityTokenInfo :: V0 (o_0) => dpp_tokens_info_IdentityTokenInfo :: V0 (< crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0 as ferment :: FFIConversionTo < dpp :: tokens :: info :: v0 :: IdentityTokenInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_info_IdentityTokenInfo { fn drop (& mut self) { unsafe { match self { dpp_tokens_info_IdentityTokenInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_IdentityTokenInfo_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: info :: v0 :: dpp_tokens_info_v0_IdentityTokenInfoV0) -> * mut dpp_tokens_info_IdentityTokenInfo { ferment :: boxed (dpp_tokens_info_IdentityTokenInfo :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_info_IdentityTokenInfo_destroy < > (ffi : * mut dpp_tokens_info_IdentityTokenInfo) { ferment :: unbox_any (ffi) ; } } pub mod status { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_status_TokenStatus { V0 (* mut crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0) } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_TokenStatus) -> dpp :: tokens :: status :: TokenStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_status_TokenStatus :: V0 (o_0) => dpp :: tokens :: status :: TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus > for dpp_tokens_status_TokenStatus { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: TokenStatus) -> * const dpp_tokens_status_TokenStatus { ferment :: boxed (match obj { dpp :: tokens :: status :: TokenStatus :: V0 (o_0) => dpp_tokens_status_TokenStatus :: V0 (< crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0 as ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_status_TokenStatus { fn drop (& mut self) { unsafe { match self { dpp_tokens_status_TokenStatus :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_TokenStatus_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: status :: v0 :: dpp_tokens_status_v0_TokenStatusV0) -> * mut dpp_tokens_status_TokenStatus { ferment :: boxed (dpp_tokens_status_TokenStatus :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_TokenStatus_destroy < > (ffi : * mut dpp_tokens_status_TokenStatus) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenStatusV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_status_v0_TokenStatusV0 { pub paused : bool } impl ferment :: FFIConversionFrom < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_from_const (ffi : * const dpp_tokens_status_v0_TokenStatusV0) -> dpp :: tokens :: status :: v0 :: TokenStatusV0 { let ffi_ref = & * ffi ; dpp :: tokens :: status :: v0 :: TokenStatusV0 { paused : ffi_ref . paused } } } impl ferment :: FFIConversionTo < dpp :: tokens :: status :: v0 :: TokenStatusV0 > for dpp_tokens_status_v0_TokenStatusV0 { unsafe fn ffi_to_const (obj : dpp :: tokens :: status :: v0 :: TokenStatusV0) -> * const dpp_tokens_status_v0_TokenStatusV0 { ferment :: boxed (dpp_tokens_status_v0_TokenStatusV0 { paused : obj . paused }) } } impl Drop for dpp_tokens_status_v0_TokenStatusV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_ctor < > (paused : bool) -> * mut dpp_tokens_status_v0_TokenStatusV0 { ferment :: boxed (dpp_tokens_status_v0_TokenStatusV0 { paused }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_destroy < > (ffi : * mut dpp_tokens_status_v0_TokenStatusV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_get_paused < > (obj : * const dpp_tokens_status_v0_TokenStatusV0) -> bool { (* obj) . paused } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_status_v0_TokenStatusV0_set_paused < > (obj : * const dpp_tokens_status_v0_TokenStatusV0) -> bool { (* obj) . paused } } } pub mod emergency_action { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyAction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_emergency_action_TokenEmergencyAction { Pause = 0 , Resume = 1 } impl ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_from_const (ffi : * const dpp_tokens_emergency_action_TokenEmergencyAction) -> dpp :: tokens :: emergency_action :: TokenEmergencyAction { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume } } } impl ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction > for dpp_tokens_emergency_action_TokenEmergencyAction { unsafe fn ffi_to_const (obj : dpp :: tokens :: emergency_action :: TokenEmergencyAction) -> * const dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (match obj { dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Pause => dpp_tokens_emergency_action_TokenEmergencyAction :: Pause , dpp :: tokens :: emergency_action :: TokenEmergencyAction :: Resume => dpp_tokens_emergency_action_TokenEmergencyAction :: Resume , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_emergency_action_TokenEmergencyAction { fn drop (& mut self) { unsafe { match self { dpp_tokens_emergency_action_TokenEmergencyAction :: Pause => { } , dpp_tokens_emergency_action_TokenEmergencyAction :: Resume => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_Pause_ctor () -> * mut dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (dpp_tokens_emergency_action_TokenEmergencyAction :: Pause { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_Resume_ctor () -> * mut dpp_tokens_emergency_action_TokenEmergencyAction { ferment :: boxed (dpp_tokens_emergency_action_TokenEmergencyAction :: Resume { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_emergency_action_TokenEmergencyAction_destroy < > (ffi : * mut dpp_tokens_emergency_action_TokenEmergencyAction) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`PrivateEncryptedNote`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_tokens_PrivateEncryptedNote (* mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) ; impl ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_from_const (ffi : * const dpp_tokens_PrivateEncryptedNote) -> dpp :: tokens :: PrivateEncryptedNote { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote > for dpp_tokens_PrivateEncryptedNote { unsafe fn ffi_to_const (obj : dpp :: tokens :: PrivateEncryptedNote) -> * const dpp_tokens_PrivateEncryptedNote { ferment :: boxed (dpp_tokens_PrivateEncryptedNote (< crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 as ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) >> :: ffi_to (obj))) } } impl Drop for dpp_tokens_PrivateEncryptedNote { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_ctor < > (o_0 : * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) -> * mut dpp_tokens_PrivateEncryptedNote { ferment :: boxed (dpp_tokens_PrivateEncryptedNote (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_destroy < > (ffi : * mut dpp_tokens_PrivateEncryptedNote) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_get_0 < > (obj : * const dpp_tokens_PrivateEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_PrivateEncryptedNote_set_0 < > (obj : * const dpp_tokens_PrivateEncryptedNote) -> * mut crate :: fermented :: generics :: Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { (* obj) . 0 } pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_tokens_errors_TokenError { TokenNotFoundAtPositionError , TokenNotFoundOnContractVersion , TokenNoMintingRecipient } impl ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_from_const (ffi : * const dpp_tokens_errors_TokenError) -> dpp :: tokens :: errors :: TokenError { let ffi_ref = & * ffi ; match ffi_ref { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient } } } impl ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError > for dpp_tokens_errors_TokenError { unsafe fn ffi_to_const (obj : dpp :: tokens :: errors :: TokenError) -> * const dpp_tokens_errors_TokenError { ferment :: boxed (match obj { dpp :: tokens :: errors :: TokenError :: TokenNotFoundAtPositionError => dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError , dpp :: tokens :: errors :: TokenError :: TokenNotFoundOnContractVersion => dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion , dpp :: tokens :: errors :: TokenError :: TokenNoMintingRecipient => dpp_tokens_errors_TokenError :: TokenNoMintingRecipient , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_tokens_errors_TokenError { fn drop (& mut self) { unsafe { match self { dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError => { } , dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion => { } , dpp_tokens_errors_TokenError :: TokenNoMintingRecipient => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNotFoundAtPositionError_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNotFoundAtPositionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNotFoundOnContractVersion_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNotFoundOnContractVersion { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_TokenNoMintingRecipient_ctor () -> * mut dpp_tokens_errors_TokenError { ferment :: boxed (dpp_tokens_errors_TokenError :: TokenNoMintingRecipient { }) } # [no_mangle] pub unsafe extern "C" fn dpp_tokens_errors_TokenError_destroy < > (ffi : * mut dpp_tokens_errors_TokenError) { ferment :: unbox_any (ffi) ; } } } # [cfg (feature = "fixtures-and-mocks")] pub mod tests { use crate as example_nested ; pub mod utils { use crate as example_nested ; } pub mod fixtures { use crate as example_nested ; } } pub mod serialization { use crate as example_nested ; } pub mod metadata { use crate as example_nested ; # [doc = "FFI-representation of the [`Metadata`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_metadata_Metadata { pub block_height : u64 , pub core_chain_locked_height : u64 , pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion } impl ferment :: FFIConversionFrom < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_from_const (ffi : * const dpp_metadata_Metadata) -> dpp :: metadata :: Metadata { let ffi_ref = & * ffi ; dpp :: metadata :: Metadata { block_height : ffi_ref . block_height , core_chain_locked_height : ffi_ref . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionFrom < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_from (ffi_ref . protocol_version) } } } impl ferment :: FFIConversionTo < dpp :: metadata :: Metadata > for dpp_metadata_Metadata { unsafe fn ffi_to_const (obj : dpp :: metadata :: Metadata) -> * const dpp_metadata_Metadata { ferment :: boxed (dpp_metadata_Metadata { block_height : obj . block_height , core_chain_locked_height : obj . core_chain_locked_height , time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , protocol_version : < crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion as ferment :: FFIConversionTo < dpp :: util :: deserializer :: ProtocolVersion >> :: ffi_to (obj . protocol_version) }) } } impl Drop for dpp_metadata_Metadata { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . protocol_version) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_ctor < > (block_height : u64 , core_chain_locked_height : u64 , time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , protocol_version : * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion) -> * mut dpp_metadata_Metadata { ferment :: boxed (dpp_metadata_Metadata { block_height , core_chain_locked_height , time_ms , protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_destroy < > (ffi : * mut dpp_metadata_Metadata) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_block_height < > (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_core_chain_locked_height < > (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_time_ms < > (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_get_protocol_version < > (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion { (* obj) . protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_block_height < > (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_core_chain_locked_height < > (obj : * const dpp_metadata_Metadata) -> u64 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_time_ms < > (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_metadata_Metadata_set_protocol_version < > (obj : * const dpp_metadata_Metadata) -> * mut crate :: fermented :: types :: dpp :: util :: deserializer :: dpp_util_deserializer_ProtocolVersion { (* obj) . protocol_version } } pub mod identity { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod create_basic_identity { use crate as example_nested ; } } pub mod core_script { use crate as example_nested ; # [doc = "FFI-representation of the [`CoreScript`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_core_script_CoreScript (* mut dashcore :: blockdata :: script :: ScriptBuf) ; impl ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_from_const (ffi : * const dpp_identity_core_script_CoreScript) -> dpp :: identity :: core_script :: CoreScript { let ffi_ref = & * ffi ; dpp :: identity :: core_script :: CoreScript ((& * ffi_ref . 0) . clone ()) } } impl ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript > for dpp_identity_core_script_CoreScript { unsafe fn ffi_to_const (obj : dpp :: identity :: core_script :: CoreScript) -> * const dpp_identity_core_script_CoreScript { ferment :: boxed (dpp_identity_core_script_CoreScript (ferment :: boxed (obj . 0))) } } impl Drop for dpp_identity_core_script_CoreScript { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_ctor < > (o_0 : * mut dashcore :: blockdata :: script :: ScriptBuf) -> * mut dpp_identity_core_script_CoreScript { ferment :: boxed (dpp_identity_core_script_CoreScript (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_destroy < > (ffi : * mut dpp_identity_core_script_CoreScript) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_get_0 < > (obj : * const dpp_identity_core_script_CoreScript) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_core_script_CoreScript_set_0 < > (obj : * const dpp_identity_core_script_CoreScript) -> * mut dashcore :: blockdata :: script :: ScriptBuf { (* obj) . 0 } } pub mod accessors { use crate as example_nested ; } pub mod conversion { use crate as example_nested ; # [cfg (feature = "identity-json-conversion")] pub mod json { use crate as example_nested ; } # [cfg (feature = "identity-cbor-conversion")] pub mod cbor { use crate as example_nested ; } # [cfg (feature = "identity-value-conversion")] pub mod platform_value { use crate as example_nested ; } } pub mod state_transition { use crate as example_nested ; pub mod asset_lock_proof { use crate as example_nested ; pub mod validate_asset_lock_transaction_structure { use crate as example_nested ; } pub mod instant { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod validate_structure { use crate as example_nested ; } } pub mod instant_asset_lock_proof { use crate as example_nested ; # [doc = "FFI-representation of the [`InstantAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { pub instant_lock : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock , pub transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction , pub output_index : u32 } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_from (ffi_ref . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_from (ffi_ref . transaction) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { instant_lock : < crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock as ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock >> :: ffi_to (obj . instant_lock) , transaction : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction >> :: ffi_to (obj . transaction) , output_index : obj . output_index }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock) ; ferment :: unbox_any (ffi_ref . transaction) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_ctor < > (instant_lock : * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock , transaction : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction , output_index : u32) -> * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof { instant_lock , transaction , output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_destroy < > (ffi : * mut dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_instant_lock < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock { (* obj) . instant_lock } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_transaction < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction { (* obj) . transaction } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_get_output_index < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> u32 { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_instant_lock < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: ephemerealdata :: instant_lock :: dashcore_ephemerealdata_instant_lock_InstantLock { (* obj) . instant_lock } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_transaction < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: dashcore_blockdata_transaction_Transaction { (* obj) . transaction } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof_set_output_index < > (obj : * const dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> u32 { (* obj) . output_index } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AssetLockProof`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_state_transition_asset_lock_proof_AssetLockProof { Instant (* mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) , Chain (* mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof >> :: ffi_from (* o_0)) , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof > for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (match obj { dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Instant (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: InstantAssetLockProof >> :: ffi_to (o_0)) , dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof :: Chain (o_0) => dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (< crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_AssetLockProof { fn drop (& mut self) { unsafe { match self { dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_Instant_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: instant :: instant_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_instant_instant_asset_lock_proof_InstantAssetLockProof) -> * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Instant (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_Chain_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_AssetLockProof :: Chain (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_AssetLockProof_destroy < > (ffi : * mut dpp_identity_state_transition_asset_lock_proof_AssetLockProof) { ferment :: unbox_any (ffi) ; } pub mod chain { use crate as example_nested ; pub mod chain_asset_lock_proof { use crate as example_nested ; # [doc = "FFI-representation of the [`ChainAssetLockProof`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { pub core_chain_locked_height : u32 , pub out_point : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint } impl ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_from_const (ffi : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { let ffi_ref = & * ffi ; dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof { core_chain_locked_height : ffi_ref . core_chain_locked_height , out_point : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . out_point) } } } impl ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof > for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { unsafe fn ffi_to_const (obj : dpp :: identity :: state_transition :: asset_lock_proof :: chain :: chain_asset_lock_proof :: ChainAssetLockProof) -> * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { core_chain_locked_height : obj . core_chain_locked_height , out_point : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . out_point) }) } } impl Drop for dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . out_point) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_ctor < > (core_chain_locked_height : u32 , out_point : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint) -> * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { ferment :: boxed (dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof { core_chain_locked_height , out_point }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_destroy < > (ffi : * mut dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_get_core_chain_locked_height < > (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> u32 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_get_out_point < > (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . out_point } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_set_core_chain_locked_height < > (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> u32 { (* obj) . core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof_set_out_point < > (obj : * const dpp_identity_state_transition_asset_lock_proof_chain_chain_asset_lock_proof_ChainAssetLockProof) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . out_point } } } } } pub mod identity_public_key { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , pub key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , pub read_only : bool , pub data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub disabled_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { let ffi_ref = & * ffi ; dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_from_opt (ffi_ref . contract_bounds) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . key_type) , read_only : ffi_ref . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . data) , disabled_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . disabled_at) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 > for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0) -> * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { ferment :: boxed (dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_to_opt (obj . contract_bounds) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . key_type) , read_only : obj . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . data) , disabled_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . disabled_at) }) } } impl Drop for dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ferment :: unbox_any (ffi_ref . key_type) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . disabled_at) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_ctor < > (id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , read_only : bool , data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , disabled_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis) -> * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { ferment :: boxed (dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 { id , purpose , security_level , contract_bounds , key_type , read_only , data , disabled_at }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_destroy < > (ffi : * mut dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_id < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_purpose < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_security_level < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_contract_bounds < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_key_type < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_read_only < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_data < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_get_disabled_at < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . disabled_at } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_id < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_purpose < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_security_level < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_contract_bounds < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_key_type < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_read_only < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_data < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_v0_IdentityPublicKeyV0_set_disabled_at < > (obj : * const dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . disabled_at } pub mod methods { use crate as example_nested ; } pub mod conversion { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKey`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_IdentityPublicKey { V0 (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_IdentityPublicKey) -> dpp :: identity :: identity_public_key :: IdentityPublicKey { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey > for dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: IdentityPublicKey) -> * const dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: IdentityPublicKey :: V0 (o_0) => dpp_identity_identity_public_key_IdentityPublicKey :: V0 (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0 as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: v0 :: IdentityPublicKeyV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_IdentityPublicKey { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_IdentityPublicKey_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: v0 :: dpp_identity_identity_public_key_v0_IdentityPublicKeyV0) -> * mut dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (dpp_identity_identity_public_key_IdentityPublicKey :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_IdentityPublicKey_destroy < > (ffi : * mut dpp_identity_identity_public_key_IdentityPublicKey) { ferment :: unbox_any (ffi) ; } pub mod purpose { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Purpose`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_purpose_Purpose { AUTHENTICATION = 0 , ENCRYPTION = 1 , DECRYPTION = 2 , TRANSFER = 3 , SYSTEM = 4 , VOTING = 5 , OWNER = 6 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_purpose_Purpose) -> dpp :: identity :: identity_public_key :: purpose :: Purpose { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose > for dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: purpose :: Purpose) -> * const dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: purpose :: Purpose :: AUTHENTICATION => dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: ENCRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: DECRYPTION => dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION , dpp :: identity :: identity_public_key :: purpose :: Purpose :: TRANSFER => dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER , dpp :: identity :: identity_public_key :: purpose :: Purpose :: SYSTEM => dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM , dpp :: identity :: identity_public_key :: purpose :: Purpose :: VOTING => dpp_identity_identity_public_key_purpose_Purpose :: VOTING , dpp :: identity :: identity_public_key :: purpose :: Purpose :: OWNER => dpp_identity_identity_public_key_purpose_Purpose :: OWNER , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_purpose_Purpose { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION => { } , dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION => { } , dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER => { } , dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM => { } , dpp_identity_identity_public_key_purpose_Purpose :: VOTING => { } , dpp_identity_identity_public_key_purpose_Purpose :: OWNER => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_AUTHENTICATION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: AUTHENTICATION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_ENCRYPTION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: ENCRYPTION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_DECRYPTION_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: DECRYPTION { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_TRANSFER_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: TRANSFER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_SYSTEM_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: SYSTEM { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_VOTING_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: VOTING { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_OWNER_ctor () -> * mut dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (dpp_identity_identity_public_key_purpose_Purpose :: OWNER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_purpose_Purpose_destroy < > (ffi : * mut dpp_identity_identity_public_key_purpose_Purpose) { ferment :: unbox_any (ffi) ; } } pub mod methods { use crate as example_nested ; pub mod hash { use crate as example_nested ; } } pub mod contract_bounds { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContractBounds`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_contract_bounds_ContractBounds { SingleContract { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } , SingleContractDocumentType { id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_contract_bounds_ContractBounds) -> dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* document_type_name) } } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds > for dpp_identity_identity_public_key_contract_bounds_ContractBounds { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds) -> * const dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContract { id } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) } , dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds :: SingleContractDocumentType { id , document_type_name } => dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (document_type_name) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_contract_bounds_ContractBounds { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id } => { ferment :: unbox_any (* id) ; } , dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name } => { ferment :: unbox_any (* id) ; ; ferment :: unbox_string (* document_type_name) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_SingleContract_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContract { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_SingleContractDocumentType_ctor (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds { ferment :: boxed (dpp_identity_identity_public_key_contract_bounds_ContractBounds :: SingleContractDocumentType { id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_contract_bounds_ContractBounds_destroy < > (ffi : * mut dpp_identity_identity_public_key_contract_bounds_ContractBounds) { ferment :: unbox_any (ffi) ; } } pub mod key_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`KeyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_key_type_KeyType { ECDSA_SECP256K1 = 0 , BLS12_381 = 1 , ECDSA_HASH160 = 2 , BIP13_SCRIPT_HASH = 3 , EDDSA_25519_HASH160 = 4 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_key_type_KeyType) -> dpp :: identity :: identity_public_key :: key_type :: KeyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType > for dpp_identity_identity_public_key_key_type_KeyType { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: key_type :: KeyType) -> * const dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_SECP256K1 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BLS12_381 => dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: ECDSA_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 , dpp :: identity :: identity_public_key :: key_type :: KeyType :: BIP13_SCRIPT_HASH => dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH , dpp :: identity :: identity_public_key :: key_type :: KeyType :: EDDSA_25519_HASH160 => dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_key_type_KeyType { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 => { } , dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 => { } , dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH => { } , dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_ECDSA_SECP256K1_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_SECP256K1 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_BLS12_381_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: BLS12_381 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_ECDSA_HASH160_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: ECDSA_HASH160 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_BIP13_SCRIPT_HASH_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: BIP13_SCRIPT_HASH { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_EDDSA_25519_HASH160_ctor () -> * mut dpp_identity_identity_public_key_key_type_KeyType { ferment :: boxed (dpp_identity_identity_public_key_key_type_KeyType :: EDDSA_25519_HASH160 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_key_type_KeyType_destroy < > (ffi : * mut dpp_identity_identity_public_key_key_type_KeyType) { ferment :: unbox_any (ffi) ; } } pub mod conversion { use crate as example_nested ; # [cfg (feature = "platform-value")] pub mod platform_value { use crate as example_nested ; } # [cfg (feature = "json-object")] pub mod json { use crate as example_nested ; } } # [doc = "FFI-representation of the [`KeyID`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyID (u32) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyID) -> dpp :: identity :: identity_public_key :: KeyID { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID > for dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyID) -> * const dpp_identity_identity_public_key_KeyID { ferment :: boxed (dpp_identity_identity_public_key_KeyID (obj)) } } impl Drop for dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_ctor < > (o_0 : u32) -> * mut dpp_identity_identity_public_key_KeyID { ferment :: boxed (dpp_identity_identity_public_key_KeyID (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_destroy < > (ffi : * mut dpp_identity_identity_public_key_KeyID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_get_0 < > (obj : * const dpp_identity_identity_public_key_KeyID) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyID_set_0 < > (obj : * const dpp_identity_identity_public_key_KeyID) -> u32 { (* obj) . 0 } pub mod security_level { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SecurityLevel`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_public_key_security_level_SecurityLevel { MASTER = 0 , CRITICAL = 1 , HIGH = 2 , MEDIUM = 3 } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_security_level_SecurityLevel) -> dpp :: identity :: identity_public_key :: security_level :: SecurityLevel { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > for dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: security_level :: SecurityLevel) -> * const dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (match obj { dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MASTER => dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: CRITICAL => dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: HIGH => dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH , dpp :: identity :: identity_public_key :: security_level :: SecurityLevel :: MEDIUM => dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_public_key_security_level_SecurityLevel { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH => { } , dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_MASTER_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: MASTER { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_CRITICAL_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: CRITICAL { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_HIGH_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: HIGH { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_MEDIUM_ctor () -> * mut dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (dpp_identity_identity_public_key_security_level_SecurityLevel :: MEDIUM { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_security_level_SecurityLevel_destroy < > (ffi : * mut dpp_identity_identity_public_key_security_level_SecurityLevel) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_TimestampMillis) -> dpp :: identity :: identity_public_key :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis > for dpp_identity_identity_public_key_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: TimestampMillis) -> * const dpp_identity_identity_public_key_TimestampMillis { ferment :: boxed (dpp_identity_identity_public_key_TimestampMillis (obj)) } } impl Drop for dpp_identity_identity_public_key_TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_ctor < > (o_0 : u64) -> * mut dpp_identity_identity_public_key_TimestampMillis { ferment :: boxed (dpp_identity_identity_public_key_TimestampMillis (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_destroy < > (ffi : * mut dpp_identity_identity_public_key_TimestampMillis) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_get_0 < > (obj : * const dpp_identity_identity_public_key_TimestampMillis) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_TimestampMillis_set_0 < > (obj : * const dpp_identity_identity_public_key_TimestampMillis) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`KeyCount`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_public_key_KeyCount (* mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) ; impl ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_public_key_KeyCount) -> dpp :: identity :: identity_public_key :: KeyCount { let ffi_ref = & * ffi ; < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyCount > for dpp_identity_identity_public_key_KeyCount { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_public_key :: KeyCount) -> * const dpp_identity_identity_public_key_KeyCount { ferment :: boxed (dpp_identity_identity_public_key_KeyCount (< crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj))) } } impl Drop for dpp_identity_identity_public_key_KeyCount { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_ctor < > (o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_identity_identity_public_key_KeyCount { ferment :: boxed (dpp_identity_identity_public_key_KeyCount (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_destroy < > (ffi : * mut dpp_identity_identity_public_key_KeyCount) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_get_0 < > (obj : * const dpp_identity_identity_public_key_KeyCount) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_public_key_KeyCount_set_0 < > (obj : * const dpp_identity_identity_public_key_KeyCount) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . 0 } pub mod accessors { use crate as example_nested ; } } pub mod identity { use crate as example_nested ; # [doc = "FFI-representation of the [`PartialIdentity`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_identity_PartialIdentity { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub loaded_public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub not_found_public_keys : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_PartialIdentity) -> dpp :: identity :: identity :: PartialIdentity { let ffi_ref = & * ffi ; dpp :: identity :: identity :: PartialIdentity { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_from (ffi_ref . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from_opt (ffi_ref . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . not_found_public_keys) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity > for dpp_identity_identity_PartialIdentity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: PartialIdentity) -> * const dpp_identity_identity_PartialIdentity { ferment :: boxed (dpp_identity_identity_PartialIdentity { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , loaded_public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_to (obj . loaded_public_keys) , balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to_opt (obj . balance) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , not_found_public_keys : < crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . not_found_public_keys) }) } } impl Drop for dpp_identity_identity_PartialIdentity { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . loaded_public_keys) ; ferment :: unbox_any_opt (ffi_ref . balance) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . not_found_public_keys) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , loaded_public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , not_found_public_keys : * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID) -> * mut dpp_identity_identity_PartialIdentity { ferment :: boxed (dpp_identity_identity_PartialIdentity { id , loaded_public_keys , balance , revision , not_found_public_keys }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_destroy < > (ffi : * mut dpp_identity_identity_PartialIdentity) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_id < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_loaded_public_keys < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . loaded_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_balance < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_revision < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_get_not_found_public_keys < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { (* obj) . not_found_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_id < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_loaded_public_keys < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . loaded_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_balance < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_revision < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_PartialIdentity_set_not_found_public_keys < > (obj : * const dpp_identity_identity_PartialIdentity) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { (* obj) . not_found_public_keys } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Identity`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_Identity { V0 (* mut crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_Identity) -> dpp :: identity :: identity :: Identity { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_Identity :: V0 (o_0) => dpp :: identity :: identity :: Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity > for dpp_identity_identity_Identity { unsafe fn ffi_to_const (obj : dpp :: identity :: identity :: Identity) -> * const dpp_identity_identity_Identity { ferment :: boxed (match obj { dpp :: identity :: identity :: Identity :: V0 (o_0) => dpp_identity_identity_Identity :: V0 (< crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0 as ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_Identity { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_Identity :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_Identity_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: v0 :: dpp_identity_v0_IdentityV0) -> * mut dpp_identity_identity_Identity { ferment :: boxed (dpp_identity_identity_Identity :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_Identity_destroy < > (ffi : * mut dpp_identity_identity_Identity) { ferment :: unbox_any (ffi) ; } } pub mod errors { use crate as example_nested ; pub mod unknown_asset_lock_proof_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownAssetLockProofTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { pub asset_lock_type : * mut u8 } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError { asset_lock_type : ferment :: from_opt_primitive (ffi_ref . asset_lock_type) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError > for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: unknown_asset_lock_proof_type_error :: UnknownAssetLockProofTypeError) -> * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { ferment :: boxed (dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { asset_lock_type : ferment :: to_opt_primitive (obj . asset_lock_type) }) } } impl Drop for dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: destroy_opt_primitive (ffi_ref . asset_lock_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_ctor < > (asset_lock_type : * mut u8) -> * mut dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { ferment :: boxed (dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError { asset_lock_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_destroy < > (ffi : * mut dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_get_asset_lock_type < > (obj : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> * mut u8 { (* obj) . asset_lock_type } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError_set_asset_lock_type < > (obj : * const dpp_identity_errors_unknown_asset_lock_proof_type_error_UnknownAssetLockProofTypeError) -> * mut u8 { (* obj) . asset_lock_type } } pub mod asset_lock_output_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) -> dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError { } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError > for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError) -> * const dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { }) } } impl Drop for dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError_ctor < > () -> * mut dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError_destroy < > (ffi : * mut dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) { ferment :: unbox_any (ffi) ; } } pub mod asset_lock_transaction_is_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid } impl ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError > for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError) -> * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) }) } } impl Drop for dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_ctor < > (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) -> * mut dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError { transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_destroy < > (ffi : * mut dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_get_transaction_id < > (obj : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError_set_transaction_id < > (obj : * const dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } } } pub mod identity_nonce { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MergeIdentityNonceResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_identity_identity_nonce_MergeIdentityNonceResult { InvalidNonce , NonceTooFarInFuture , NonceTooFarInPast , NonceAlreadyPresentAtTip , NonceAlreadyPresentInPast (u64) , MergeIdentityNonceSuccess (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) } impl ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_from_const (ffi : * const dpp_identity_identity_nonce_MergeIdentityNonceResult) -> dpp :: identity :: identity_nonce :: MergeIdentityNonceResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (* o_0) , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult > for dpp_identity_identity_nonce_MergeIdentityNonceResult { unsafe fn ffi_to_const (obj : dpp :: identity :: identity_nonce :: MergeIdentityNonceResult) -> * const dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (match obj { dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: InvalidNonce => dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInFuture => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceTooFarInPast => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) , dpp :: identity :: identity_nonce :: MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_identity_identity_nonce_MergeIdentityNonceResult { fn drop (& mut self) { unsafe { match self { dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip => { } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_0) => { ; } , dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_InvalidNonce_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: InvalidNonce { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceTooFarInFuture_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInFuture { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceTooFarInPast_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceTooFarInPast { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceAlreadyPresentAtTip_ctor () -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentAtTip { }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_NonceAlreadyPresentInPast_ctor (o_o_0 : u64) -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: NonceAlreadyPresentInPast (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_MergeIdentityNonceSuccess_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) -> * mut dpp_identity_identity_nonce_MergeIdentityNonceResult { ferment :: boxed (dpp_identity_identity_nonce_MergeIdentityNonceResult :: MergeIdentityNonceSuccess (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_identity_nonce_MergeIdentityNonceResult_destroy < > (ffi : * mut dpp_identity_identity_nonce_MergeIdentityNonceResult) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; pub mod conversion { use crate as example_nested ; } # [doc = "FFI-representation of the [`IdentityV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_identity_v0_IdentityV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , pub balance : u64 , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_from_const (ffi : * const dpp_identity_v0_IdentityV0) -> dpp :: identity :: v0 :: IdentityV0 { let ffi_ref = & * ffi ; dpp :: identity :: v0 :: IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_from (ffi_ref . public_keys) , balance : ffi_ref . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) } } } impl ferment :: FFIConversionTo < dpp :: identity :: v0 :: IdentityV0 > for dpp_identity_v0_IdentityV0 { unsafe fn ffi_to_const (obj : dpp :: identity :: v0 :: IdentityV0) -> * const dpp_identity_v0_IdentityV0 { ferment :: boxed (dpp_identity_v0_IdentityV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , public_keys : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > >> :: ffi_to (obj . public_keys) , balance : obj . balance , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) }) } } impl Drop for dpp_identity_v0_IdentityV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . public_keys) ; ; ferment :: unbox_any (ffi_ref . revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_keys : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey , balance : u64 , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_identity_v0_IdentityV0 { ferment :: boxed (dpp_identity_v0_IdentityV0 { id , public_keys , balance , revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_destroy < > (ffi : * mut dpp_identity_v0_IdentityV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_id < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_public_keys < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_balance < > (obj : * const dpp_identity_v0_IdentityV0) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_get_revision < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_id < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_public_keys < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_balance < > (obj : * const dpp_identity_v0_IdentityV0) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_identity_v0_IdentityV0_set_revision < > (obj : * const dpp_identity_v0_IdentityV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } } pub mod fields { use crate as example_nested ; } pub mod credits_converter { use crate as example_nested ; } } pub mod errors { use crate as example_nested ; pub mod dpp_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DPPError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_error_DPPError { AssetLockOutputNotFoundError (* mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) , AssetLockTransactionIsNotFoundError (* mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) , WrongPublicKeyHashSize , WrongBurnOutputType , InvalidAssetLockTransaction , CoreMessageCorruption (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_error_DPPError) -> dpp :: errors :: dpp_error :: DPPError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError as ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError as ferment :: FFIConversionFrom < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_error :: DPPError > for dpp_errors_dpp_error_DPPError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_error :: DPPError) -> * const dpp_errors_dpp_error_DPPError { ferment :: boxed (match obj { dpp :: errors :: dpp_error :: DPPError :: AssetLockOutputNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError as ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_output_not_found_error :: AssetLockOutputNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: dpp_error :: DPPError :: AssetLockTransactionIsNotFoundError (o_0) => dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError as ferment :: FFIConversionTo < dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: AssetLockTransactionIsNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: dpp_error :: DPPError :: WrongPublicKeyHashSize => dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize , dpp :: errors :: dpp_error :: DPPError :: WrongBurnOutputType => dpp_errors_dpp_error_DPPError :: WrongBurnOutputType , dpp :: errors :: dpp_error :: DPPError :: InvalidAssetLockTransaction => dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction , dpp :: errors :: dpp_error :: DPPError :: CoreMessageCorruption (o_0) => dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_error_DPPError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize => { } , dpp_errors_dpp_error_DPPError :: WrongBurnOutputType => { } , dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction => { } , dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_AssetLockOutputNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_output_not_found_error :: dpp_identity_errors_asset_lock_output_not_found_error_AssetLockOutputNotFoundError) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: AssetLockOutputNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_AssetLockTransactionIsNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: errors :: asset_lock_transaction_is_not_found_error :: dpp_identity_errors_asset_lock_transaction_is_not_found_error_AssetLockTransactionIsNotFoundError) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: AssetLockTransactionIsNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_WrongPublicKeyHashSize_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: WrongPublicKeyHashSize { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_WrongBurnOutputType_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: WrongBurnOutputType { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_InvalidAssetLockTransaction_ctor () -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: InvalidAssetLockTransaction { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_CoreMessageCorruption_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_dpp_error_DPPError { ferment :: boxed (dpp_errors_dpp_error_DPPError :: CoreMessageCorruption (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_error_DPPError_destroy < > (ffi : * mut dpp_errors_dpp_error_DPPError) { ferment :: unbox_any (ffi) ; } } pub mod compatible_protocol_version_is_not_defined_error { use crate as example_nested ; # [doc = "FFI-representation of the [`CompatibleProtocolVersionIsNotDefinedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { let ffi_ref = & * ffi ; dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError > for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { unsafe fn ffi_to_const (obj : dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError) -> * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { ferment :: boxed (dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { current_protocol_version : obj . current_protocol_version }) } } impl Drop for dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_ctor < > (current_protocol_version : u32) -> * mut dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { ferment :: boxed (dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError { current_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_destroy < > (ffi : * mut dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_get_current_protocol_version < > (obj : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> u32 { (* obj) . current_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError_set_current_protocol_version < > (obj : * const dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> u32 { (* obj) . current_protocol_version } } pub mod serde_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SerdeParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_serde_parsing_error_SerdeParsingError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> dpp :: errors :: serde_parsing_error :: SerdeParsingError { let ffi_ref = & * ffi ; dpp :: errors :: serde_parsing_error :: SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: serde_parsing_error :: SerdeParsingError > for dpp_errors_serde_parsing_error_SerdeParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: serde_parsing_error :: SerdeParsingError) -> * const dpp_errors_serde_parsing_error_SerdeParsingError { ferment :: boxed (dpp_errors_serde_parsing_error_SerdeParsingError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_serde_parsing_error_SerdeParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_serde_parsing_error_SerdeParsingError { ferment :: boxed (dpp_errors_serde_parsing_error_SerdeParsingError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_destroy < > (ffi : * mut dpp_errors_serde_parsing_error_SerdeParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_get_message < > (obj : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_serde_parsing_error_SerdeParsingError_set_message < > (obj : * const dpp_errors_serde_parsing_error_SerdeParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod non_consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`NonConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_non_consensus_error_NonConsensusError { ValueError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion } , SerdeParsingError (* mut crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError) , CompatibleProtocolVersionIsNotDefinedError (* mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) , SerdeJsonError (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) , StateRepositoryFetchError (* mut std :: os :: raw :: c_char) , WithdrawalError (* mut std :: os :: raw :: c_char) , IdentifierCreateError (* mut std :: os :: raw :: c_char) , StateTransitionCreationError (* mut std :: os :: raw :: c_char) , IdentityPublicKeyCreateError (* mut std :: os :: raw :: c_char) , RequiredPropertyError { property_name : * mut std :: os :: raw :: c_char } , InvalidDataProcessedError (* mut std :: os :: raw :: c_char) , ObjectCreationError { object_name : * mut std :: os :: raw :: c_char , details : * mut std :: os :: raw :: c_char } , DPPError (* mut crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError) , Error (* mut example_nested :: anyhow_Error) , Overflow (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_non_consensus_error_NonConsensusError) -> dpp :: errors :: non_consensus_error :: NonConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_from (* known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (* received) } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (< crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError as ferment :: FFIConversionFrom < dpp :: errors :: serde_parsing_error :: SerdeParsingError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* property_name) } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* object_name))) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* details) } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (< crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError as ferment :: FFIConversionFrom < dpp :: errors :: dpp_error :: DPPError >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionFrom < anyhow :: Error >> :: ffi_from (* o_0)) , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) } } } impl ferment :: FFIConversionTo < dpp :: errors :: non_consensus_error :: NonConsensusError > for dpp_errors_non_consensus_error_NonConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: non_consensus_error :: NonConsensusError) -> * const dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (match obj { dpp :: errors :: non_consensus_error :: NonConsensusError :: ValueError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_to (known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (received) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeParsingError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (< crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError as ferment :: FFIConversionTo < dpp :: errors :: serde_parsing_error :: SerdeParsingError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: SerdeJsonError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidVectorSizeError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateRepositoryFetchError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: WithdrawalError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentifierCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: StateTransitionCreationError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: IdentityPublicKeyCreateError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: RequiredPropertyError { property_name } => dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (property_name) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: InvalidDataProcessedError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: ObjectCreationError { object_name , details } => dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (object_name) , details : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (details) } , dpp :: errors :: non_consensus_error :: NonConsensusError :: DPPError (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: DPPError (< crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError as ferment :: FFIConversionTo < dpp :: errors :: dpp_error :: DPPError >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Error (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionTo < anyhow :: Error >> :: ffi_to (o_0)) , dpp :: errors :: non_consensus_error :: NonConsensusError :: Overflow (o_0) => dpp_errors_non_consensus_error_NonConsensusError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_non_consensus_error_NonConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name } => { ferment :: unbox_string (* property_name) ; } , dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details } => { ferment :: unbox_string (* object_name) ; ; ferment :: unbox_string (* details) ; } , dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_ValueError_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_SerdeParsingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: serde_parsing_error :: dpp_errors_serde_parsing_error_SerdeParsingError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: SerdeParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_CompatibleProtocolVersionIsNotDefinedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: CompatibleProtocolVersionIsNotDefinedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_SerdeJsonError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: SerdeJsonError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_InvalidVectorSizeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: InvalidVectorSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_StateRepositoryFetchError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: StateRepositoryFetchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_WithdrawalError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: WithdrawalError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_IdentifierCreateError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: IdentifierCreateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_StateTransitionCreationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: StateTransitionCreationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_IdentityPublicKeyCreateError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: IdentityPublicKeyCreateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_RequiredPropertyError_ctor (property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: RequiredPropertyError { property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_InvalidDataProcessedError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: InvalidDataProcessedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_ObjectCreationError_ctor (object_name : * mut std :: os :: raw :: c_char , details : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: ObjectCreationError { object_name , details }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_DPPError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: dpp_error :: dpp_errors_dpp_error_DPPError) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: DPPError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_Error_ctor (o_o_0 : * mut example_nested :: anyhow_Error) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: Error (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_Overflow_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_non_consensus_error_NonConsensusError { ferment :: boxed (dpp_errors_non_consensus_error_NonConsensusError :: Overflow (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_non_consensus_error_NonConsensusError_destroy < > (ffi : * mut dpp_errors_non_consensus_error_NonConsensusError) { ferment :: unbox_any (ffi) ; } } pub mod public_key_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_public_key_validation_error_PublicKeyValidationError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { let ffi_ref = & * ffi ; dpp :: errors :: public_key_validation_error :: PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: public_key_validation_error :: PublicKeyValidationError > for dpp_errors_public_key_validation_error_PublicKeyValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: public_key_validation_error :: PublicKeyValidationError) -> * const dpp_errors_public_key_validation_error_PublicKeyValidationError { ferment :: boxed (dpp_errors_public_key_validation_error_PublicKeyValidationError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_public_key_validation_error_PublicKeyValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_public_key_validation_error_PublicKeyValidationError { ferment :: boxed (dpp_errors_public_key_validation_error_PublicKeyValidationError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_destroy < > (ffi : * mut dpp_errors_public_key_validation_error_PublicKeyValidationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_get_message < > (obj : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_public_key_validation_error_PublicKeyValidationError_set_message < > (obj : * const dpp_errors_public_key_validation_error_PublicKeyValidationError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod protocol_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProtocolError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_protocol_error_ProtocolError { IdentifierError (* mut std :: os :: raw :: c_char) , StringDecodeError (* mut std :: os :: raw :: c_char) , EmptyPublicKeyDataError , MaxEncodedBytesReachedError { max_size_kbytes : usize , size_hit : usize } , EncodingError (* mut std :: os :: raw :: c_char) , DecodingError (* mut std :: os :: raw :: c_char) , FileNotFound (* mut std :: os :: raw :: c_char) , UnsupportedVersionMismatch { method : * mut std :: os :: raw :: c_char , allowed_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion } , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion } , CurrentProtocolVersionNotInitialized , UnknownVersionError (* mut std :: os :: raw :: c_char) , UnknownProtocolVersionError (* mut std :: os :: raw :: c_char) , NoProtocolVersionError , ParsingError (* mut std :: os :: raw :: c_char) , ParsingJsonError (* mut example_nested :: serde_json_Error) , Error (* mut example_nested :: anyhow_Error) , InvalidKeyContractBoundsError (* mut std :: os :: raw :: c_char) , UnknownStorageKeyRequirements (* mut std :: os :: raw :: c_char) , UnknownContestedIndexResolution (* mut std :: os :: raw :: c_char) , DataContractError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] StateTransitionError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError) , InvalidStateTransitionType (* mut std :: os :: raw :: c_char) , PlatformVersionError (* mut crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError) , ConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError) , Document (* mut crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError) , Token (* mut crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError) , Generic (* mut std :: os :: raw :: c_char) , NotSupported (* mut std :: os :: raw :: c_char) , # [cfg (feature = "message-signing")] InvalidSigningKeyTypeError (* mut std :: os :: raw :: c_char) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] InvalidIdentityPublicKeyTypeError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) , # [cfg (feature = "state-transition-validation")] StateTransitionIsNotSignedError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) , # [cfg (feature = "state-transition-validation")] PublicKeySecurityLevelNotMetError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] WrongPublicKeyPurposeError (* mut dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) , # [cfg (feature = "state-transition-validation")] PublicKeyMismatchError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) , # [cfg (feature = "state-transition-validation")] InvalidSignaturePublicKeyError (* mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) , NonConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError) , CompatibleProtocolVersionIsNotDefinedError (* mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) , DataContractNotPresentError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) , InvalidSignaturePublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) , InvalidStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) , PublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) , IdentityNotPresentError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) , Overflow (* mut std :: os :: raw :: c_char) , DivideByZero (* mut std :: os :: raw :: c_char) , DesiredKeyWithTypePurposeSecurityLevelMissing (* mut std :: os :: raw :: c_char) , ValueError (* mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) , PlatformSerializationError (* mut std :: os :: raw :: c_char) , PlatformDeserializationError (* mut std :: os :: raw :: c_char) , DashCoreError (* mut example_nested :: custom :: dashcore :: dashcore_consensus_Error) , InvalidIdentityError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_identity : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , VoteError (* mut std :: os :: raw :: c_char) , PublicKeyGenerationError (* mut std :: os :: raw :: c_char) , GroupMemberNotFound (* mut std :: os :: raw :: c_char) , GroupNotFound (* mut std :: os :: raw :: c_char) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , CriticalCorruptedCreditsCodeExecution (* mut std :: os :: raw :: c_char) , InvalidVectorSizeError (* mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) , InvalidCBOR (* mut std :: os :: raw :: c_char) , # [cfg (feature = "bls-signatures")] BlsError (* mut dashcore :: blsful :: BlsError) , PrivateKeySizeError { got : u32 } , InvalidBLSPrivateKeyError (* mut std :: os :: raw :: c_char) , BlsSignatureSizeError { got : u32 } , AddingDifferentTypes (* mut std :: os :: raw :: c_char) , InvalidDistributionStep (* mut std :: os :: raw :: c_char) , MissingEpochInfo (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const dpp_errors_protocol_error_ProtocolError) -> dpp :: errors :: protocol_error :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : * max_size_kbytes , size_hit : * size_hit } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , allowed_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_from (* allowed_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (* received) } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_from (* known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (* received) } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (< example_nested :: serde_json_Error as ferment :: FFIConversionFrom < serde_json :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionFrom < anyhow :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_from (* o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (Box :: new (< crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Document (Box :: new (< crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError as ferment :: FFIConversionFrom < dpp :: document :: errors :: DocumentError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Token (Box :: new (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionFrom < dpp :: tokens :: errors :: TokenError >> :: ffi_from (* o_0))) , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_from (* o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError ((& * * o_0) . clone ()) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError as ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (< crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: non_consensus_error :: NonConsensusError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionFrom < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: Overflow (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionFrom < platform_value :: error :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (< example_nested :: custom :: dashcore :: dashcore_consensus_Error as ferment :: FFIConversionFrom < dashcore :: consensus :: encode :: Error >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_identity) } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: BlsError ((& * * o_0) . clone ()) , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got : * got } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: protocol_error :: ProtocolError > for dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : dpp :: errors :: protocol_error :: ProtocolError) -> * const dpp_errors_protocol_error_ProtocolError { ferment :: boxed (match obj { dpp :: errors :: protocol_error :: ProtocolError :: IdentifierError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentifierError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: StringDecodeError (o_0) => dpp_errors_protocol_error_ProtocolError :: StringDecodeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: EmptyPublicKeyDataError => dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError , dpp :: errors :: protocol_error :: ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes : max_size_kbytes , size_hit : size_hit } , dpp :: errors :: protocol_error :: ProtocolError :: EncodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: EncodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DecodingError (o_0) => dpp_errors_protocol_error_ProtocolError :: DecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: FileNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: FileNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , allowed_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_to (allowed_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (received) } , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_to (known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (received) } , dpp :: errors :: protocol_error :: ProtocolError :: CurrentProtocolVersionNotInitialized => dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized , dpp :: errors :: protocol_error :: ProtocolError :: UnknownVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownProtocolVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NoProtocolVersionError => dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError , dpp :: errors :: protocol_error :: ProtocolError :: ParsingError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ParsingJsonError (o_0) => dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (< example_nested :: serde_json_Error as ferment :: FFIConversionTo < serde_json :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Error (o_0) => dpp_errors_protocol_error_ProtocolError :: Error (< example_nested :: anyhow_Error as ferment :: FFIConversionTo < anyhow :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidKeyContractBoundsError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownStorageKeyRequirements (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: UnknownContestedIndexResolution (o_0) => dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_to (o_0)) , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionType (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformVersionError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (< crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError as ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: ConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Document (o_0) => dpp_errors_protocol_error_ProtocolError :: Document (< crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError as ferment :: FFIConversionTo < dpp :: document :: errors :: DocumentError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Token (o_0) => dpp_errors_protocol_error_ProtocolError :: Token (< crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError as ferment :: FFIConversionTo < dpp :: tokens :: errors :: TokenError >> :: ffi_to (* o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Generic (o_0) => dpp_errors_protocol_error_ProtocolError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NotSupported (o_0) => dpp_errors_protocol_error_ProtocolError :: NotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "message-signing")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSigningKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: StateTransitionIsNotSignedError (o_0) => dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_to (o_0)) , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp :: errors :: protocol_error :: ProtocolError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (ferment :: boxed (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyMismatchError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (< crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError as ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: NonConsensusError (o_0) => dpp_errors_protocol_error_ProtocolError :: NonConsensusError (< crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError as ferment :: FFIConversionTo < dpp :: errors :: non_consensus_error :: NonConsensusError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (< crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError as ferment :: FFIConversionTo < dpp :: errors :: compatible_protocol_version_is_not_defined_error :: CompatibleProtocolVersionIsNotDefinedError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDocumentTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DataContractNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyIsDisabledError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: IdentityNotPresentError (o_0) => dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: Overflow (o_0) => dpp_errors_protocol_error_ProtocolError :: Overflow (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DivideByZero (o_0) => dpp_errors_protocol_error_ProtocolError :: DivideByZero (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: ValueError (o_0) => dpp_errors_protocol_error_ProtocolError :: ValueError (< crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error as ferment :: FFIConversionTo < platform_value :: error :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformSerializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PlatformDeserializationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: DashCoreError (o_0) => dpp_errors_protocol_error_ProtocolError :: DashCoreError (< example_nested :: custom :: dashcore :: dashcore_consensus_Error as ferment :: FFIConversionTo < dashcore :: consensus :: encode :: Error >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidIdentityError { errors , raw_identity } => dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_identity : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_identity) } , dpp :: errors :: protocol_error :: ProtocolError :: VoteError (o_0) => dpp_errors_protocol_error_ProtocolError :: VoteError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PublicKeyGenerationError (o_0) => dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupMemberNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: GroupNotFound (o_0) => dpp_errors_protocol_error_ProtocolError :: GroupNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CorruptedSerialization (o_0) => dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidVectorSizeError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (< crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError as ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidCBOR (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , # [cfg (feature = "bls-signatures")] dpp :: errors :: protocol_error :: ProtocolError :: BlsError (o_0) => dpp_errors_protocol_error_ProtocolError :: BlsError (ferment :: boxed (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: PrivateKeySizeError { got } => dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: InvalidBLSPrivateKeyError (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: BlsSignatureSizeError { got } => dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got : got } , dpp :: errors :: protocol_error :: ProtocolError :: AddingDifferentTypes (o_0) => dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: InvalidDistributionStep (o_0) => dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: protocol_error :: ProtocolError :: MissingEpochInfo (o_0) => dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { match self { dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError => { } , dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit } => { ; ; ; } , dpp_errors_protocol_error_ProtocolError :: EncodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* allowed_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized => { } , dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError => { } , dpp_errors_protocol_error_ProtocolError :: ParsingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Error (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (all (feature = "state-transitions" , feature = "validation"))] dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Generic (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "message-signing")] dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: Overflow (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_identity) ; } , dpp_errors_protocol_error_ProtocolError :: VoteError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_0) => { ferment :: unbox_string (* o_0) ; } , # [cfg (feature = "bls-signatures")] dpp_errors_protocol_error_ProtocolError :: BlsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got } => { ; } , dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_IdentifierError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: IdentifierError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StringDecodeError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StringDecodeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_EmptyPublicKeyDataError_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: EmptyPublicKeyDataError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_MaxEncodedBytesReachedError_ctor (max_size_kbytes : usize , size_hit : usize) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: MaxEncodedBytesReachedError { max_size_kbytes , size_hit }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_EncodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: EncodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_FileNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: FileNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnsupportedVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , allowed_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnsupportedVersionMismatch { method , allowed_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CurrentProtocolVersionNotInitialized_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CurrentProtocolVersionNotInitialized { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownProtocolVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownProtocolVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NoProtocolVersionError_ctor () -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NoProtocolVersionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ParsingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ParsingJsonError_ctor (o_o_0 : * mut example_nested :: serde_json_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ParsingJsonError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Error_ctor (o_o_0 : * mut example_nested :: anyhow_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Error (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidKeyContractBoundsError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidKeyContractBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownStorageKeyRequirements_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownStorageKeyRequirements (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_UnknownContestedIndexResolution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: UnknownContestedIndexResolution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DataContractError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DataContractError (o_o_0)) } # [cfg (all (feature = "state-transitions" , feature = "validation"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StateTransitionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_error :: dpp_state_transition_errors_state_transition_error_StateTransitionError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StateTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidStateTransitionType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_version :: error :: platform_version_error_PlatformVersionError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ConsensusError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Document_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: document :: errors :: dpp_document_errors_DocumentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Document (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Token_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: errors :: dpp_tokens_errors_TokenError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Token (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Generic_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Generic (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NotSupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NotSupported (o_o_0)) } # [cfg (feature = "message-signing")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSigningKeyTypeError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSigningKeyTypeError (o_o_0)) } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidIdentityPublicKeyTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidIdentityPublicKeyTypeError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_StateTransitionIsNotSignedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: StateTransitionIsNotSignedError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeySecurityLevelNotMetError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeySecurityLevelNotMetError (o_o_0)) } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation" , feature = "state-transition-signing" , feature = "state-transition-validation"))] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_WrongPublicKeyPurposeError_ctor (o_o_0 : * mut dpp :: state_transition :: errors :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: WrongPublicKeyPurposeError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyMismatchError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: public_key_mismatch_error :: dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyMismatchError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSignaturePublicKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: errors :: invalid_signature_public_key_error :: dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_NonConsensusError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: non_consensus_error :: dpp_errors_non_consensus_error_NonConsensusError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: NonConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CompatibleProtocolVersionIsNotDefinedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: compatible_protocol_version_is_not_defined_error :: dpp_errors_compatible_protocol_version_is_not_defined_error_CompatibleProtocolVersionIsNotDefinedError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CompatibleProtocolVersionIsNotDefinedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidDocumentTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: invalid_document_type_error :: dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DataContractNotPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: data_contract_not_present_error :: dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DataContractNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidSignaturePublicKeySecurityLevelError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidSignaturePublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidStateTransitionTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyIsDisabledError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_IdentityNotPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: identity_not_present_error :: dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: IdentityNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_Overflow_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: Overflow (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DivideByZero_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DivideByZero (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DesiredKeyWithTypePurposeSecurityLevelMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DesiredKeyWithTypePurposeSecurityLevelMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_ValueError_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: error :: platform_value_error_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PlatformDeserializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PlatformDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_DashCoreError_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_consensus_Error) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: DashCoreError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidIdentityError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_identity : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidIdentityError { errors , raw_identity }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_VoteError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: VoteError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PublicKeyGenerationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PublicKeyGenerationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_GroupMemberNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: GroupMemberNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_GroupNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: GroupNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CorruptedSerialization_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CorruptedSerialization (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_CriticalCorruptedCreditsCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: CriticalCorruptedCreditsCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidVectorSizeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: invalid_vector_size_error :: dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidVectorSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidCBOR_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidCBOR (o_o_0)) } # [cfg (feature = "bls-signatures")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_BlsError_ctor (o_o_0 : * mut dashcore :: blsful :: BlsError) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: BlsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_PrivateKeySizeError_ctor (got : u32) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: PrivateKeySizeError { got }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidBLSPrivateKeyError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidBLSPrivateKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_BlsSignatureSizeError_ctor (got : u32) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: BlsSignatureSizeError { got }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_AddingDifferentTypes_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: AddingDifferentTypes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_InvalidDistributionStep_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: InvalidDistributionStep (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_MissingEpochInfo_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_protocol_error_ProtocolError { ferment :: boxed (dpp_errors_protocol_error_ProtocolError :: MissingEpochInfo (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_protocol_error_ProtocolError_destroy < > (ffi : * mut dpp_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } } pub mod consensus { use crate as example_nested ; pub mod consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ConsensusError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_consensus_error_ConsensusError { DefaultError , BasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError) , StateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError) , SignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError) , FeeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError) , # [cfg (test)] TestConsensusError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_consensus_error_ConsensusError) -> dpp :: errors :: consensus :: consensus_error :: ConsensusError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: basic_error :: BasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: state_error :: StateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: fee_error :: FeeError >> :: ffi_from (* o_0)) , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: consensus_error :: ConsensusError > for dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: consensus_error :: ConsensusError) -> * const dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (match obj { dpp :: errors :: consensus :: consensus_error :: ConsensusError :: DefaultError => dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: BasicError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: StateError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: StateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: state_error :: StateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: SignatureError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: consensus_error :: ConsensusError :: FeeError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: fee_error :: FeeError >> :: ffi_to (o_0)) , # [cfg (test)] dpp :: errors :: consensus :: consensus_error :: ConsensusError :: TestConsensusError (o_0) => dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (< crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_consensus_error_ConsensusError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError => { } , dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (test)] dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_DefaultError_ctor () -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: DefaultError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_BasicError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: BasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_StateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: state_error :: dpp_errors_consensus_state_state_error_StateError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: StateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_SignatureError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_error :: dpp_errors_consensus_signature_signature_error_SignatureError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: SignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_FeeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: fee_error :: dpp_errors_consensus_fee_fee_error_FeeError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: FeeError (o_o_0)) } # [cfg (test)] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_TestConsensusError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: test_consensus_error :: dpp_errors_consensus_test_consensus_error_TestConsensusError) -> * mut dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (dpp_errors_consensus_consensus_error_ConsensusError :: TestConsensusError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_consensus_error_ConsensusError_destroy < > (ffi : * mut dpp_errors_consensus_consensus_error_ConsensusError) { ferment :: unbox_any (ffi) ; } } # [cfg (test)] pub mod test_consensus_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TestConsensusError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_test_consensus_error_TestConsensusError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError > for dpp_errors_consensus_test_consensus_error_TestConsensusError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: test_consensus_error :: TestConsensusError) -> * const dpp_errors_consensus_test_consensus_error_TestConsensusError { ferment :: boxed (dpp_errors_consensus_test_consensus_error_TestConsensusError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_test_consensus_error_TestConsensusError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_test_consensus_error_TestConsensusError { ferment :: boxed (dpp_errors_consensus_test_consensus_error_TestConsensusError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_destroy < > (ffi : * mut dpp_errors_consensus_test_consensus_error_TestConsensusError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_get_message < > (obj : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_test_consensus_error_TestConsensusError_set_message < > (obj : * const dpp_errors_consensus_test_consensus_error_TestConsensusError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod fee { use crate as example_nested ; pub mod fee_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`FeeError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_fee_fee_error_FeeError { BalanceIsNotEnoughError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_fee_error_FeeError) -> dpp :: errors :: consensus :: fee :: fee_error :: FeeError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: fee_error :: FeeError > for dpp_errors_consensus_fee_fee_error_FeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: fee_error :: FeeError) -> * const dpp_errors_consensus_fee_fee_error_FeeError { ferment :: boxed (match obj { dpp :: errors :: consensus :: fee :: fee_error :: FeeError :: BalanceIsNotEnoughError (o_0) => dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (< crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_fee_fee_error_FeeError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_fee_error_FeeError_BalanceIsNotEnoughError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut dpp_errors_consensus_fee_fee_error_FeeError { ferment :: boxed (dpp_errors_consensus_fee_fee_error_FeeError :: BalanceIsNotEnoughError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_fee_error_FeeError_destroy < > (ffi : * mut dpp_errors_consensus_fee_fee_error_FeeError) { ferment :: unbox_any (ffi) ; } } pub mod balance_is_not_enough_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BalanceIsNotEnoughError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { pub balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub fee : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . fee) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError > for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: fee :: balance_is_not_enough_error :: BalanceIsNotEnoughError) -> * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { ferment :: boxed (dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { balance : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . balance) , fee : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . fee) }) } } impl Drop for dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance) ; ferment :: unbox_any (ffi_ref . fee) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_ctor < > (balance : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , fee : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { ferment :: boxed (dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError { balance , fee }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_destroy < > (ffi : * mut dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_get_balance < > (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_get_fee < > (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . fee } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_set_balance < > (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError_set_fee < > (obj : * const dpp_errors_consensus_fee_balance_is_not_enough_error_BalanceIsNotEnoughError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . fee } } } pub mod signature { use crate as example_nested ; pub mod missing_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError > for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError) -> * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { ferment :: boxed (dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_ctor < > (public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { ferment :: boxed (dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_destroy < > (ffi : * mut dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_get_public_key_id < > (obj : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError_set_public_key_id < > (obj : * const dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } } pub mod basic_ecdsa_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BasicECDSAError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError > for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError) -> * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { ferment :: boxed (dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { ferment :: boxed (dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_destroy < > (ffi : * mut dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_get_message < > (obj : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError_set_message < > (obj : * const dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod signature_should_not_be_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SignatureShouldNotBePresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError > for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError) -> * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { ferment :: boxed (dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { ferment :: boxed (dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_destroy < > (ffi : * mut dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_get_message < > (obj : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError_set_message < > (obj : * const dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod invalid_state_transition_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidStateTransitionSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError > for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError) -> * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { ferment :: boxed (dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { ferment :: boxed (dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_destroy < > (ffi : * mut dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_get_message < > (obj : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError_set_message < > (obj : * const dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod public_key_security_level_not_met_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . required_security_level) }) } } impl Drop for dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_ctor < > (public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel) -> * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level , required_security_level }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_destroy < > (ffi : * mut dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_public_key_security_level < > (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_required_security_level < > (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . required_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_public_key_security_level < > (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_required_security_level < > (obj : * const dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . required_security_level } } pub mod invalid_signature_public_key_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub allowed_key_security_levels : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > >> :: ffi_from (ffi_ref . allowed_key_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError > for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , allowed_key_security_levels : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > >> :: ffi_to (obj . allowed_key_security_levels) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . allowed_key_security_levels) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_ctor < > (public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , allowed_key_security_levels : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel) -> * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError { public_key_security_level , allowed_key_security_levels }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_destroy < > (ffi : * mut dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_get_public_key_security_level < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_get_allowed_key_security_levels < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . allowed_key_security_levels } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_set_public_key_security_level < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError_set_allowed_key_security_levels < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . allowed_key_security_levels } } pub mod basic_bls_error { use crate as example_nested ; # [doc = "FFI-representation of the [`BasicBLSError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError > for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError) -> * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { ferment :: boxed (dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { ferment :: boxed (dpp_errors_consensus_signature_basic_bls_error_BasicBLSError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_destroy < > (ffi : * mut dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_get_message < > (obj : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_basic_bls_error_BasicBLSError_set_message < > (obj : * const dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod identity_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError > for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError) -> * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { ferment :: boxed (dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { ferment :: boxed (dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_get_identity_id < > (obj : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError_set_identity_id < > (obj : * const dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod public_key_is_disabled_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError > for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError) -> * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_ctor < > (public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_destroy < > (ffi : * mut dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_get_public_key_id < > (obj : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError_set_public_key_id < > (obj : * const dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } } pub mod invalid_signature_public_key_purpose_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { pub public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError > for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError) -> * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_ctor < > (public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose) -> * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError { public_key_purpose , allowed_key_purposes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_destroy < > (ffi : * mut dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_get_public_key_purpose < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_get_allowed_key_purposes < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose { (* obj) . allowed_key_purposes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_set_public_key_purpose < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError_set_allowed_key_purposes < > (obj : * const dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose { (* obj) . allowed_key_purposes } } pub mod signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SignatureError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_signature_signature_error_SignatureError { IdentityNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) , InvalidIdentityPublicKeyTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) , InvalidStateTransitionSignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) , MissingPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) , InvalidSignaturePublicKeyPurposeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) , InvalidSignaturePublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) , WrongPublicKeyPurposeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) , PublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) , PublicKeySecurityLevelNotMetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) , SignatureShouldNotBePresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) , BasicECDSAError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) , BasicBLSError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_signature_error_SignatureError) -> dpp :: errors :: consensus :: signature :: signature_error :: SignatureError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError >> :: ffi_from (* o_0)) , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_error :: SignatureError > for dpp_errors_consensus_signature_signature_error_SignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: signature_error :: SignatureError) -> * const dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (match obj { dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: IdentityNotFoundError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: identity_not_found_error :: IdentityNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidStateTransitionSignatureError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: InvalidStateTransitionSignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: MissingPublicKeyError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: missing_public_key_error :: MissingPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: InvalidSignaturePublicKeyPurposeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: InvalidSignaturePublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: WrongPublicKeyPurposeError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeyIsDisabledError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: PublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: SignatureShouldNotBePresentError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: SignatureShouldNotBePresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicECDSAError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: BasicECDSAError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: signature :: signature_error :: SignatureError :: BasicBLSError (o_0) => dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (< crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: basic_bls_error :: BasicBLSError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_signature_signature_error_SignatureError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_IdentityNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: identity_not_found_error :: dpp_errors_consensus_signature_identity_not_found_error_IdentityNotFoundError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: IdentityNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidIdentityPublicKeyTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidIdentityPublicKeyTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidStateTransitionSignatureError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_state_transition_signature_error :: dpp_errors_consensus_signature_invalid_state_transition_signature_error_InvalidStateTransitionSignatureError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidStateTransitionSignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_MissingPublicKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: missing_public_key_error :: dpp_errors_consensus_signature_missing_public_key_error_MissingPublicKeyError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: MissingPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidSignaturePublicKeyPurposeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_purpose_error :: dpp_errors_consensus_signature_invalid_signature_public_key_purpose_error_InvalidSignaturePublicKeyPurposeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeyPurposeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_InvalidSignaturePublicKeySecurityLevelError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: invalid_signature_public_key_security_level_error :: dpp_errors_consensus_signature_invalid_signature_public_key_security_level_error_InvalidSignaturePublicKeySecurityLevelError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: InvalidSignaturePublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_WrongPublicKeyPurposeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: WrongPublicKeyPurposeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_PublicKeyIsDisabledError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_is_disabled_error :: dpp_errors_consensus_signature_public_key_is_disabled_error_PublicKeyIsDisabledError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_PublicKeySecurityLevelNotMetError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: public_key_security_level_not_met_error :: dpp_errors_consensus_signature_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: PublicKeySecurityLevelNotMetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_SignatureShouldNotBePresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: signature_should_not_be_present_error :: dpp_errors_consensus_signature_signature_should_not_be_present_error_SignatureShouldNotBePresentError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: SignatureShouldNotBePresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_BasicECDSAError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_ecdsa_error :: dpp_errors_consensus_signature_basic_ecdsa_error_BasicECDSAError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: BasicECDSAError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_BasicBLSError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: signature :: basic_bls_error :: dpp_errors_consensus_signature_basic_bls_error_BasicBLSError) -> * mut dpp_errors_consensus_signature_signature_error_SignatureError { ferment :: boxed (dpp_errors_consensus_signature_signature_error_SignatureError :: BasicBLSError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_signature_error_SignatureError_destroy < > (ffi : * mut dpp_errors_consensus_signature_signature_error_SignatureError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . public_key_type) }) } } impl Drop for dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor < > (public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType) -> * mut dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy < > (ffi : * mut dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type < > (obj : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type < > (obj : * const dpp_errors_consensus_signature_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . public_key_type } } pub mod wrong_public_key_purpose_error { use crate as example_nested ; # [doc = "FFI-representation of the [`WrongPublicKeyPurposeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { pub public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_from (ffi_ref . allowed_key_purposes) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError > for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: signature :: wrong_public_key_purpose_error :: WrongPublicKeyPurposeError) -> * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . public_key_purpose) , allowed_key_purposes : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > >> :: ffi_to (obj . allowed_key_purposes) }) } } impl Drop for dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_purpose) ; ferment :: unbox_any (ffi_ref . allowed_key_purposes) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_ctor < > (public_key_purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , allowed_key_purposes : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose) -> * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { ferment :: boxed (dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError { public_key_purpose , allowed_key_purposes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_destroy < > (ffi : * mut dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_public_key_purpose < > (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_get_allowed_key_purposes < > (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose { (* obj) . allowed_key_purposes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_public_key_purpose < > (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . public_key_purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError_set_allowed_key_purposes < > (obj : * const dpp_errors_consensus_signature_wrong_public_key_purpose_error_WrongPublicKeyPurposeError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_purpose_Purpose { (* obj) . allowed_key_purposes } } } pub mod state { use crate as example_nested ; pub mod state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_state_error_StateError { DataContractAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) , # [cfg (feature = "state-transition-validation")] DataTriggerError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError) , DocumentAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) , DocumentContestCurrentlyLockedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) , DocumentContestNotJoinableError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) , DocumentContestIdentityAlreadyContestantError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) , DocumentContestNotPaidForError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) , DocumentContestDocumentWithSameIdAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) , DocumentNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) , DocumentNotForSaleError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) , DocumentIncorrectPurchasePriceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) , DocumentOwnerIdMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) , DocumentTimestampsMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) , DocumentTimestampWindowViolationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) , DuplicateUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) , InvalidDocumentRevisionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) , IdentityAlreadyExistsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) , IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) , IdentityPublicKeyIsReadOnlyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) , MissingIdentityPublicKeyIdsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) , MissingTransferKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) , NoTransferKeyForCoreWithdrawalAvailableError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) , InvalidIdentityPublicKeyIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) , InvalidIdentityRevisionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) , InvalidIdentityNonceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) , MaxIdentityPublicKeyLimitReachedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) , DuplicatedIdentityPublicKeyStateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) , DuplicatedIdentityPublicKeyIdStateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) , IdentityPublicKeyIsDisabledError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) , IdentityInsufficientBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) , DocumentTimestampsAreEqualError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) , DataContractIsReadonlyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) , DataContractConfigUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) , DocumentTypeUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) , PrefundedSpecializedBalanceInsufficientError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) , PrefundedSpecializedBalanceNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) , DataContractUpdatePermissionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) , MasternodeNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) , MasternodeIncorrectVoterIdentityIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) , MasternodeIncorrectVotingAddressError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) , VotePollNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) , VotePollNotAvailableForVotingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) , MasternodeVotedTooManyTimesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) , MasternodeVoteAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) , RecipientIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) , IdentityDoesNotHaveEnoughTokenBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) , UnauthorizedTokenActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) , IdentityTokenAccountFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) , IdentityTokenAccountNotFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) , IdentityNotMemberOfGroupError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) , GroupActionDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) , GroupActionAlreadyCompletedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) , GroupActionAlreadySignedByIdentityError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) , DataContractUpdateActionNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) , TokenSettingMaxSupplyToLessThanCurrentSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) , TokenMintPastMaxSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) , InvalidTokenClaimPropertyMismatch (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) , InvalidTokenClaimNoCurrentRewards (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) , InvalidTokenClaimWrongClaimant (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) , NewTokensDestinationIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) , NewAuthorizedActionTakerIdentityDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) , NewAuthorizedActionTakerGroupDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) , NewAuthorizedActionTakerMainGroupNotSetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) , InvalidGroupPositionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) , TokenIsPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) , IdentityTokenAccountAlreadyFrozenError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) , TokenAlreadyPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) , TokenNotPausedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_state_error_StateError) -> dpp :: errors :: consensus :: state :: state_error :: StateError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError >> :: ffi_from (* o_0)) , # [cfg (feature = "state-transition-validation")] dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: state_error :: StateError > for dpp_errors_consensus_state_state_error_StateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: state_error :: StateError) -> * const dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError >> :: ffi_to (o_0)) , # [cfg (feature = "state-transition-validation")] dpp :: errors :: consensus :: state :: state_error :: StateError :: DataTriggerError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestCurrentlyLockedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotJoinableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestNotPaidForError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentNotForSaleError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentIncorrectPurchasePriceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentOwnerIdMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsMismatchError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampWindowViolationError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicateUniqueIndexError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidDocumentRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityAlreadyExistsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingIdentityPublicKeyIdsError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MissingTransferKeyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityPublicKeyIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityRevisionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidIdentityNonceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityPublicKeyIsDisabledError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityInsufficientBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTimestampsAreEqualError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractIsReadonlyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractConfigUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DocumentTypeUpdateError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdatePermissionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeIncorrectVotingAddressError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotFoundError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: VotePollNotAvailableForVotingError (o_0) => dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVotedTooManyTimesError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: MasternodeVoteAlreadyPresentError (o_0) => dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: RecipientIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: UnauthorizedTokenActionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountNotFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityNotMemberOfGroupError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadyCompletedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: GroupActionAlreadySignedByIdentityError (o_0) => dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: DataContractUpdateActionNotAllowedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenMintPastMaxSupplyError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimPropertyMismatch (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidTokenClaimWrongClaimant (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: InvalidGroupPositionError (o_0) => dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenIsPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenAlreadyPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: state_error :: StateError :: TokenNotPausedError (o_0) => dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_state_error_StateError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "state-transition-validation")] dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractAlreadyPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractAlreadyPresentError (o_o_0)) } # [cfg (feature = "state-transition-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataTriggerError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: dpp_errors_consensus_state_data_trigger_DataTriggerError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataTriggerError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentAlreadyPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_already_present_error :: dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestCurrentlyLockedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestCurrentlyLockedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestNotJoinableError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotJoinableError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestIdentityAlreadyContestantError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestIdentityAlreadyContestantError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestNotPaidForError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestNotPaidForError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentContestDocumentWithSameIdAlreadyPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentContestDocumentWithSameIdAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_found_error :: dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentNotForSaleError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentNotForSaleError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentIncorrectPurchasePriceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentIncorrectPurchasePriceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentOwnerIdMismatchError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentOwnerIdMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampsMismatchError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampWindowViolationError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampWindowViolationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicateUniqueIndexError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicateUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidDocumentRevisionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidDocumentRevisionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityAlreadyExistsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityAlreadyExistsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyIsReadOnlyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsReadOnlyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MissingIdentityPublicKeyIdsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MissingIdentityPublicKeyIdsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MissingTransferKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MissingTransferKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NoTransferKeyForCoreWithdrawalAvailableError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NoTransferKeyForCoreWithdrawalAvailableError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityPublicKeyIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityPublicKeyIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityRevisionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityRevisionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidIdentityNonceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidIdentityNonceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MaxIdentityPublicKeyLimitReachedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MaxIdentityPublicKeyLimitReachedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicatedIdentityPublicKeyStateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyStateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DuplicatedIdentityPublicKeyIdStateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DuplicatedIdentityPublicKeyIdStateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityPublicKeyIsDisabledError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityPublicKeyIsDisabledError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityInsufficientBalanceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityInsufficientBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTimestampsAreEqualError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTimestampsAreEqualError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractIsReadonlyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractIsReadonlyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractConfigUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractConfigUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DocumentTypeUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DocumentTypeUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_PrefundedSpecializedBalanceInsufficientError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceInsufficientError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_PrefundedSpecializedBalanceNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: PrefundedSpecializedBalanceNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractUpdatePermissionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractUpdatePermissionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeIncorrectVoterIdentityIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVoterIdentityIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeIncorrectVotingAddressError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeIncorrectVotingAddressError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_VotePollNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: VotePollNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_VotePollNotAvailableForVotingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: VotePollNotAvailableForVotingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeVotedTooManyTimesError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeVotedTooManyTimesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_MasternodeVoteAlreadyPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: MasternodeVoteAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_RecipientIdentityDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: RecipientIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityDoesNotHaveEnoughTokenBalanceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityDoesNotHaveEnoughTokenBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_UnauthorizedTokenActionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: UnauthorizedTokenActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountFrozenError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountNotFrozenError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountNotFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityNotMemberOfGroupError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityNotMemberOfGroupError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionAlreadyCompletedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadyCompletedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_GroupActionAlreadySignedByIdentityError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: GroupActionAlreadySignedByIdentityError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_DataContractUpdateActionNotAllowedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: DataContractUpdateActionNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenSettingMaxSupplyToLessThanCurrentSupplyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenSettingMaxSupplyToLessThanCurrentSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenMintPastMaxSupplyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenMintPastMaxSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimPropertyMismatch_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimPropertyMismatch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimNoCurrentRewards_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimNoCurrentRewards (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidTokenClaimWrongClaimant_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidTokenClaimWrongClaimant (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewTokensDestinationIdentityDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewTokensDestinationIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerIdentityDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerIdentityDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerGroupDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerGroupDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_NewAuthorizedActionTakerMainGroupNotSetError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: NewAuthorizedActionTakerMainGroupNotSetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_InvalidGroupPositionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: InvalidGroupPositionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenIsPausedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenIsPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_IdentityTokenAccountAlreadyFrozenError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: IdentityTokenAccountAlreadyFrozenError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenAlreadyPausedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenAlreadyPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_TokenNotPausedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut dpp_errors_consensus_state_state_error_StateError { ferment :: boxed (dpp_errors_consensus_state_state_error_StateError :: TokenNotPausedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_state_error_StateError_destroy < > (ffi : * mut dpp_errors_consensus_state_state_error_StateError) { ferment :: unbox_any (ffi) ; } } pub mod document { use crate as example_nested ; pub mod document_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError > for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_already_present_error :: DocumentAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_already_present_error_DocumentAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_contest_identity_already_contestant { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestIdentityAlreadyContestantError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError > for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_identity_already_contestant :: DocumentContestIdentityAlreadyContestantError) -> * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError { vote_poll , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_get_identity_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError_set_identity_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_identity_already_contestant_DocumentContestIdentityAlreadyContestantError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod document_timestamps_are_equal_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampsAreEqualError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError > for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_are_equal_error :: DocumentTimestampsAreEqualError) -> * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamps_are_equal_error_DocumentTimestampsAreEqualError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_owner_id_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentOwnerIdMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub existing_document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_owner_id) , existing_document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . existing_document_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError > for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_owner_id_mismatch_error :: DocumentOwnerIdMismatchError) -> * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_owner_id) , existing_document_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . existing_document_owner_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . document_owner_id) ; ferment :: unbox_any (ffi_ref . existing_document_owner_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , existing_document_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError { document_id , document_owner_id , existing_document_owner_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_document_owner_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_get_existing_document_owner_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . existing_document_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_document_owner_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError_set_existing_document_owner_id < > (obj : * const dpp_errors_consensus_state_document_document_owner_id_mismatch_error_DocumentOwnerIdMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . existing_document_owner_id } } pub mod document_contest_not_joinable_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestNotJoinableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub start_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub current_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub joinable_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . joinable_time) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError > for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_joinable_error :: DocumentContestNotJoinableError) -> * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , start_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . start_time) , current_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . current_time) , joinable_time : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . joinable_time) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ferment :: unbox_any (ffi_ref . start_time) ; ferment :: unbox_any (ffi_ref . current_time) ; ferment :: unbox_any (ffi_ref . joinable_time) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , start_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , current_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , joinable_time : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) -> * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError { vote_poll , stored_info , start_time , current_time , joinable_time }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_stored_info < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_start_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . start_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_current_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . current_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_get_joinable_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . joinable_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_stored_info < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_start_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . start_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_current_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . current_time } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError_set_joinable_time < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_joinable_error_DocumentContestNotJoinableError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . joinable_time } } pub mod invalid_document_revision_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub previous_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub desired_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . desired_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError > for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: invalid_document_revision_error :: InvalidDocumentRevisionError) -> * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { ferment :: boxed (dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , previous_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . previous_revision) , desired_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . desired_revision) }) } } impl Drop for dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any_opt (ffi_ref . previous_revision) ; ferment :: unbox_any (ffi_ref . desired_revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , previous_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , desired_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { ferment :: boxed (dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError { document_id , previous_revision , desired_revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_previous_revision < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . previous_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_get_desired_revision < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . desired_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_previous_revision < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . previous_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError_set_desired_revision < > (obj : * const dpp_errors_consensus_state_document_invalid_document_revision_error_InvalidDocumentRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . desired_revision } } pub mod document_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError > for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_found_error :: DocumentNotFoundError) -> * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_not_found_error_DocumentNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_timestamps_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampsMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError > for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamps_mismatch_error :: DocumentTimestampsMismatchError) -> * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamps_mismatch_error_DocumentTimestampsMismatchError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_incorrect_purchase_price_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentIncorrectPurchasePriceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub trying_to_purchase_at_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub actual_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . actual_price) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError > for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_incorrect_purchase_price_error :: DocumentIncorrectPurchasePriceError) -> * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { ferment :: boxed (dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , trying_to_purchase_at_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . trying_to_purchase_at_price) , actual_price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . actual_price) }) } } impl Drop for dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . trying_to_purchase_at_price) ; ferment :: unbox_any (ffi_ref . actual_price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , trying_to_purchase_at_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , actual_price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { ferment :: boxed (dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError { document_id , trying_to_purchase_at_price , actual_price }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_trying_to_purchase_at_price < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . trying_to_purchase_at_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_get_actual_price < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . actual_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_trying_to_purchase_at_price < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . trying_to_purchase_at_price } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError_set_actual_price < > (obj : * const dpp_errors_consensus_state_document_document_incorrect_purchase_price_error_DocumentIncorrectPurchasePriceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . actual_price } } pub mod duplicate_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub duplicating_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . duplicating_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError > for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: duplicate_unique_index_error :: DuplicateUniqueIndexError) -> * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { ferment :: boxed (dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , duplicating_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . duplicating_properties) }) } } impl Drop for dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . duplicating_properties) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , duplicating_properties : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { ferment :: boxed (dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError { document_id , duplicating_properties }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_get_duplicating_properties < > (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . duplicating_properties } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError_set_duplicating_properties < > (obj : * const dpp_errors_consensus_state_document_duplicate_unique_index_error_DuplicateUniqueIndexError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . duplicating_properties } } pub mod document_contest_document_with_same_id_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestDocumentWithSameIdAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError > for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_document_with_same_id_already_present_error :: DocumentContestDocumentWithSameIdAlreadyPresentError) -> * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_document_with_same_id_already_present_error_DocumentContestDocumentWithSameIdAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_contest_not_paid_for_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestNotPaidForError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub paid_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . paid_amount) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError > for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_not_paid_for_error :: DocumentContestNotPaidForError) -> * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , expected_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . expected_amount) , paid_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . paid_amount) }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_any (ffi_ref . expected_amount) ; ferment :: unbox_any (ffi_ref . paid_amount) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , expected_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , paid_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError { document_id , expected_amount , paid_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_expected_amount < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . expected_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_get_paid_amount < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . paid_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_expected_amount < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . expected_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError_set_paid_amount < > (obj : * const dpp_errors_consensus_state_document_document_contest_not_paid_for_error_DocumentContestNotPaidForError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . paid_amount } } pub mod document_not_for_sale_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentNotForSaleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError > for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_not_for_sale_error :: DocumentNotForSaleError) -> * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_ctor < > (document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { ferment :: boxed (dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError { document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_not_for_sale_error_DocumentNotForSaleError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod document_timestamp_window_violation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTimestampWindowViolationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { pub timestamp_name : * mut std :: os :: raw :: c_char , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub timestamp : i64 , pub time_window_start : i64 , pub time_window_end : i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . timestamp_name) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , timestamp : ffi_ref . timestamp , time_window_start : ffi_ref . time_window_start , time_window_end : ffi_ref . time_window_end } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError > for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_timestamp_window_violation_error :: DocumentTimestampWindowViolationError) -> * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { timestamp_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . timestamp_name) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , timestamp : obj . timestamp , time_window_start : obj . time_window_start , time_window_end : obj . time_window_end }) } } impl Drop for dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . timestamp_name) ; ferment :: unbox_any (ffi_ref . document_id) ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_ctor < > (timestamp_name : * mut std :: os :: raw :: c_char , document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , timestamp : i64 , time_window_start : i64 , time_window_end : i64) -> * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { ferment :: boxed (dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError { timestamp_name , document_id , timestamp , time_window_start , time_window_end }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_timestamp_name < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut std :: os :: raw :: c_char { (* obj) . timestamp_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_timestamp < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . timestamp } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_time_window_start < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_start } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_get_time_window_end < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_end } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_timestamp_name < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut std :: os :: raw :: c_char { (* obj) . timestamp_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_document_id < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_timestamp < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . timestamp } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_time_window_start < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_start } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError_set_time_window_end < > (obj : * const dpp_errors_consensus_state_document_document_timestamp_window_violation_error_DocumentTimestampWindowViolationError) -> i64 { (* obj) . time_window_end } } pub mod document_contest_currently_locked_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentContestCurrentlyLockedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , pub stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , pub unlock_cost : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (ffi_ref . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_from (ffi_ref . stored_info) , unlock_cost : ffi_ref . unlock_cost } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError > for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: document :: document_contest_currently_locked_error :: DocumentContestCurrentlyLockedError) -> * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (obj . vote_poll) , stored_info : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo >> :: ffi_to (obj . stored_info) , unlock_cost : obj . unlock_cost }) } } impl Drop for dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . stored_info) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll , stored_info : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo , unlock_cost : u64) -> * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { ferment :: boxed (dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError { vote_poll , stored_info , unlock_cost }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_destroy < > (ffi : * mut dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_stored_info < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_get_unlock_cost < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> u64 { (* obj) . unlock_cost } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_stored_info < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { (* obj) . stored_info } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError_set_unlock_cost < > (obj : * const dpp_errors_consensus_state_document_document_contest_currently_locked_error_DocumentContestCurrentlyLockedError) -> u64 { (* obj) . unlock_cost } } } # [cfg (feature = "state-transition-validation")] pub mod data_trigger { use crate as example_nested ; pub mod data_trigger_invalid_result_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerInvalidResultError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError > for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError { data_contract_id , document_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_get_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError_set_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } } pub mod data_trigger_execution_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerExecutionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError > for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError { data_contract_id , document_id , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_get_message < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError_set_message < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataTriggerError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_state_data_trigger_DataTriggerError { DataTriggerConditionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) , DataTriggerExecutionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) , DataTriggerInvalidResultError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_DataTriggerError) -> dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError > for dpp_errors_consensus_state_data_trigger_DataTriggerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError) -> * const dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (match obj { dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerConditionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerExecutionError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: DataTriggerExecutionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: state :: data_trigger :: DataTriggerError :: DataTriggerInvalidResultError (o_0) => dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: DataTriggerInvalidResultError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_state_data_trigger_DataTriggerError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerConditionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerConditionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerExecutionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_execution_error :: dpp_errors_consensus_state_data_trigger_data_trigger_execution_error_DataTriggerExecutionError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerExecutionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_DataTriggerInvalidResultError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_invalid_result_error :: dpp_errors_consensus_state_data_trigger_data_trigger_invalid_result_error_DataTriggerInvalidResultError) -> * mut dpp_errors_consensus_state_data_trigger_DataTriggerError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_DataTriggerError :: DataTriggerInvalidResultError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_DataTriggerError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_trigger_DataTriggerError) { ferment :: unbox_any (ffi) ; } pub mod data_trigger_condition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataTriggerConditionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError > for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_trigger :: data_trigger_condition_error :: DataTriggerConditionError) -> * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . document_id) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . document_id) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { ferment :: boxed (dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError { data_contract_id , document_id , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_get_message < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_document_id < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . document_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError_set_message < > (obj : * const dpp_errors_consensus_state_data_trigger_data_trigger_condition_error_DataTriggerConditionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } } pub mod voting { use crate as example_nested ; pub mod vote_poll_not_available_for_voting_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VotePollNotAvailableForVotingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . status) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError > for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_available_for_voting_error :: VotePollNotAvailableForVotingError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . status) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . status) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) -> * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError { vote_poll , status }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_get_status < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . status } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError_set_status < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_available_for_voting_error_VotePollNotAvailableForVotingError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . status } } pub mod masternode_incorrect_voting_address_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeIncorrectVotingAddressError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 , pub given_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , current_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_from (ffi_ref . current_voting_address) , given_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_from (ffi_ref . given_voting_address) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError > for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voting_address_error :: MasternodeIncorrectVotingAddressError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , current_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_to (obj . current_voting_address) , given_voting_address : < crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 as ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 >> :: ffi_to (obj . given_voting_address) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . current_voting_address) ; ferment :: unbox_any (ffi_ref . given_voting_address) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 , given_voting_address : * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20) -> * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError { pro_tx_hash , current_voting_address , given_voting_address }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_current_voting_address < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 { (* obj) . current_voting_address } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_get_given_voting_address < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 { (* obj) . given_voting_address } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_current_voting_address < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 { (* obj) . current_voting_address } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError_set_given_voting_address < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voting_address_error_MasternodeIncorrectVotingAddressError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_20 :: platform_value_types_bytes_20_Bytes20 { (* obj) . given_voting_address } } pub mod masternode_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError > for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_not_found_error :: MasternodeNotFoundError) -> * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError { pro_tx_hash }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_get_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError_set_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_not_found_error_MasternodeNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } } pub mod vote_poll_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VotePollNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError > for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: vote_poll_not_found_error :: VotePollNotFoundError) -> * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) -> * mut dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { ferment :: boxed (dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError { vote_poll }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_vote_poll_not_found_error_VotePollNotFoundError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } } pub mod masternode_vote_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVoteAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError > for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_vote_already_present_error :: MasternodeVoteAlreadyPresentError) -> * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . vote_poll) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll) -> * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError { pro_tx_hash , vote_poll }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_get_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_get_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_set_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError_set_vote_poll < > (obj : * const dpp_errors_consensus_state_voting_masternode_vote_already_present_error_MasternodeVoteAlreadyPresentError) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } } pub mod masternode_incorrect_voter_identity_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeIncorrectVoterIdentityIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub provided_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , expected_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_voter_identity_id) , provided_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . provided_voter_identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError > for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_incorrect_voter_identity_id_error :: MasternodeIncorrectVoterIdentityIdError) -> * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , expected_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_voter_identity_id) , provided_voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . provided_voter_identity_id) }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . expected_voter_identity_id) ; ferment :: unbox_any (ffi_ref . provided_voter_identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , expected_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , provided_voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError { pro_tx_hash , expected_voter_identity_id , provided_voter_identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_expected_voter_identity_id < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_get_provided_voter_identity_id < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . provided_voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_expected_voter_identity_id < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError_set_provided_voter_identity_id < > (obj : * const dpp_errors_consensus_state_voting_masternode_incorrect_voter_identity_id_error_MasternodeIncorrectVoterIdentityIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . provided_voter_identity_id } } pub mod masternode_voted_too_many_times { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVotedTooManyTimesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub times_already_voted : u16 , pub max_times_allowed : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , times_already_voted : ffi_ref . times_already_voted , max_times_allowed : ffi_ref . max_times_allowed } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError > for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: voting :: masternode_voted_too_many_times :: MasternodeVotedTooManyTimesError) -> * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , times_already_voted : obj . times_already_voted , max_times_allowed : obj . max_times_allowed }) } } impl Drop for dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , times_already_voted : u16 , max_times_allowed : u16) -> * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { ferment :: boxed (dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError { pro_tx_hash , times_already_voted , max_times_allowed }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_destroy < > (ffi : * mut dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_times_already_voted < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . times_already_voted } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_get_max_times_allowed < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . max_times_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_pro_tx_hash < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_times_already_voted < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . times_already_voted } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError_set_max_times_allowed < > (obj : * const dpp_errors_consensus_state_voting_masternode_voted_too_many_times_MasternodeVotedTooManyTimesError) -> u16 { (* obj) . max_times_allowed } } } pub mod prefunded_specialized_balances { use crate as example_nested ; pub mod prefunded_specialized_balance_insufficient_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceInsufficientError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_insufficient_error :: PrefundedSpecializedBalanceInsufficientError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_ctor < > (balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , balance : u64 , required_balance : u64) -> * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError { balance_id , balance , required_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_destroy < > (ffi : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_balance_id < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_balance < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_get_required_balance < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_balance_id < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_balance < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError_set_required_balance < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_insufficient_error_PrefundedSpecializedBalanceInsufficientError) -> u64 { (* obj) . required_balance } } pub mod prefunded_specialized_balance_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PrefundedSpecializedBalanceNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { pub balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . balance_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError > for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: prefunded_specialized_balances :: prefunded_specialized_balance_not_found_error :: PrefundedSpecializedBalanceNotFoundError) -> * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { balance_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . balance_id) }) } } impl Drop for dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . balance_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_ctor < > (balance_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { ferment :: boxed (dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError { balance_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_get_balance_id < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError_set_balance_id < > (obj : * const dpp_errors_consensus_state_prefunded_specialized_balances_prefunded_specialized_balance_not_found_error_PrefundedSpecializedBalanceNotFoundError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . balance_id } } } pub mod token { use crate as example_nested ; pub mod new_authorized_action_taker_main_group_not_set_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerMainGroupNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError > for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_main_group_not_set_error :: NewAuthorizedActionTakerMainGroupNotSetError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError_ctor < > () -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_main_group_not_set_error_NewAuthorizedActionTakerMainGroupNotSetError) { ferment :: unbox_any (ffi) ; } } pub mod unauthorized_token_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnauthorizedTokenActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char , pub authorized_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_action_takers) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError > for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: unauthorized_token_action_error :: UnauthorizedTokenActionError) -> * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { ferment :: boxed (dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) , authorized_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_action_takers) }) } } impl Drop for dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; ferment :: unbox_any (ffi_ref . authorized_action_takers) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char , authorized_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) -> * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { ferment :: boxed (dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError { token_id , identity_id , action , authorized_action_takers }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_action < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_get_authorized_action_takers < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_action_takers } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_action < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError_set_authorized_action_takers < > (obj : * const dpp_errors_consensus_state_token_unauthorized_token_action_error_UnauthorizedTokenActionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_action_takers } } pub mod token_is_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenIsPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError > for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_is_paused_error :: TokenIsPausedError) -> * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_token_is_paused_error_TokenIsPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } } pub mod invalid_token_claim_property_mismatch { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimPropertyMismatch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { pub property : * mut std :: os :: raw :: c_char , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch > for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_property_mismatch :: InvalidTokenClaimPropertyMismatch) -> * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { property : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . property) ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_ctor < > (property : * mut std :: os :: raw :: c_char , token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch { property , token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_destroy < > (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_get_property < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut std :: os :: raw :: c_char { (* obj) . property } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_get_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_set_property < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut std :: os :: raw :: c_char { (* obj) . property } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch_set_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_property_mismatch_InvalidTokenClaimPropertyMismatch) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } } pub mod invalid_token_claim_no_current_rewards { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimNoCurrentRewards`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment , pub last_claimed_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from (ffi_ref . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_from_opt (ffi_ref . last_claimed_moment) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards > for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_no_current_rewards :: InvalidTokenClaimNoCurrentRewards) -> * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , current_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to (obj . current_moment) , last_claimed_moment : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment >> :: ffi_to_opt (obj . last_claimed_moment) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any (ffi_ref . current_moment) ; ferment :: unbox_any_opt (ffi_ref . last_claimed_moment) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment , last_claimed_moment : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards { token_id , recipient_id , current_moment , last_claimed_moment }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_destroy < > (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_recipient_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_current_moment < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . current_moment } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_get_last_claimed_moment < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . last_claimed_moment } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_recipient_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_current_moment < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . current_moment } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards_set_last_claimed_moment < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_no_current_rewards_InvalidTokenClaimNoCurrentRewards) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { (* obj) . last_claimed_moment } } pub mod invalid_token_claim_wrong_claimant { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenClaimWrongClaimant`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub expected_claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . claimant_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant > for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_token_claim_wrong_claimant :: InvalidTokenClaimWrongClaimant) -> * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , expected_claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_claimant_id) , claimant_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . claimant_id) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . expected_claimant_id) ; ferment :: unbox_any (ffi_ref . claimant_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , expected_claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , claimant_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { ferment :: boxed (dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant { token_id , expected_claimant_id , claimant_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_destroy < > (ffi : * mut dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_expected_claimant_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_claimant_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_get_claimant_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . claimant_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_token_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_expected_claimant_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_claimant_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant_set_claimant_id < > (obj : * const dpp_errors_consensus_state_token_invalid_token_claim_wrong_claimant_InvalidTokenClaimWrongClaimant) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . claimant_id } } pub mod token_not_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenNotPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError > for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_not_paused_error :: TokenNotPausedError) -> * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError { token_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_get_action < > (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError_set_action < > (obj : * const dpp_errors_consensus_state_token_token_not_paused_error_TokenNotPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod token_setting_max_supply_to_less_than_current_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenSettingMaxSupplyToLessThanCurrentSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub max_supply : u64 , pub current_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , max_supply : ffi_ref . max_supply , current_supply : ffi_ref . current_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError > for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_setting_max_supply_to_less_than_current_supply_error :: TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , max_supply : obj . max_supply , current_supply : obj . current_supply }) } } impl Drop for dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , max_supply : u64 , current_supply : u64) -> * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError { token_id , max_supply , current_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_max_supply < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . max_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_get_current_supply < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . current_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_max_supply < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . max_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError_set_current_supply < > (obj : * const dpp_errors_consensus_state_token_token_setting_max_supply_to_less_than_current_supply_error_TokenSettingMaxSupplyToLessThanCurrentSupplyError) -> u64 { (* obj) . current_supply } } pub mod token_mint_past_max_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenMintPastMaxSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub current_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , pub max_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (ffi_ref . max_supply) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError > for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_mint_past_max_supply_error :: TokenMintPastMaxSupplyError) -> * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . amount) , current_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . current_supply) , max_supply : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (obj . max_supply) }) } } impl Drop for dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . amount) ; ferment :: unbox_any (ffi_ref . current_supply) ; ferment :: unbox_any (ffi_ref . max_supply) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , current_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max_supply : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { ferment :: boxed (dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError { token_id , amount , current_supply , max_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_amount < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_current_supply < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . current_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_get_max_supply < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . max_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_amount < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_current_supply < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . current_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError_set_max_supply < > (obj : * const dpp_errors_consensus_state_token_token_mint_past_max_supply_error_TokenMintPastMaxSupplyError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount { (* obj) . max_supply } } pub mod identity_does_not_have_enough_token_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityDoesNotHaveEnoughTokenBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub required_balance : u64 , pub actual_balance : u64 , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , required_balance : ffi_ref . required_balance , actual_balance : ffi_ref . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError > for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_does_not_have_enough_token_balance_error :: IdentityDoesNotHaveEnoughTokenBalanceError) -> * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { ferment :: boxed (dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , required_balance : obj . required_balance , actual_balance : obj . actual_balance , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , required_balance : u64 , actual_balance : u64 , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { ferment :: boxed (dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError { token_id , identity_id , required_balance , actual_balance , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_required_balance < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_actual_balance < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . actual_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_get_action < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_required_balance < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_actual_balance < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> u64 { (* obj) . actual_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError_set_action < > (obj : * const dpp_errors_consensus_state_token_identity_does_not_have_enough_token_balance_error_IdentityDoesNotHaveEnoughTokenBalanceError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod invalid_group_position_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidGroupPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { pub max_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub invalid_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from_opt (ffi_ref . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . invalid_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError > for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: invalid_group_position_error :: InvalidGroupPositionError) -> * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { max_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to_opt (obj . max_group_position) , invalid_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . invalid_group_position) }) } } impl Drop for dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . max_group_position) ; ferment :: unbox_any (ffi_ref . invalid_group_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_ctor < > (max_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , invalid_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { ferment :: boxed (dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError { max_group_position , invalid_group_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_get_max_group_position < > (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . max_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_get_invalid_group_position < > (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . invalid_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_set_max_group_position < > (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . max_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError_set_invalid_group_position < > (obj : * const dpp_errors_consensus_state_token_invalid_group_position_error_InvalidGroupPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . invalid_group_position } } pub mod identity_token_account_not_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountNotFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError > for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_not_frozen_error :: IdentityTokenAccountNotFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_get_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError_set_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_not_frozen_error_IdentityTokenAccountNotFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod token_already_paused_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenAlreadyPausedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError > for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: token_already_paused_error :: TokenAlreadyPausedError) -> * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { ferment :: boxed (dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError { token_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_get_action < > (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError_set_action < > (obj : * const dpp_errors_consensus_state_token_token_already_paused_error_TokenAlreadyPausedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod new_tokens_destination_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewTokensDestinationIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_tokens_destination_identity_does_not_exist_error :: NewTokensDestinationIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_new_tokens_destination_identity_does_not_exist_error_NewTokensDestinationIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod new_authorized_action_taker_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_identity_does_not_exist_error :: NewAuthorizedActionTakerIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_identity_does_not_exist_error_NewAuthorizedActionTakerIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod new_authorized_action_taker_group_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NewAuthorizedActionTakerGroupDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError > for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: new_authorized_action_taker_group_does_not_exist_error :: NewAuthorizedActionTakerGroupDoesNotExistError) -> * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_ctor < > (group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError { group_contract_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_get_group_contract_position < > (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError_set_group_contract_position < > (obj : * const dpp_errors_consensus_state_token_new_authorized_action_taker_group_does_not_exist_error_NewAuthorizedActionTakerGroupDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } } pub mod identity_token_account_already_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountAlreadyFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError > for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_already_frozen_error :: IdentityTokenAccountAlreadyFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_get_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError_set_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_already_frozen_error_IdentityTokenAccountAlreadyFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod identity_token_account_frozen_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTokenAccountFrozenError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError > for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: token :: identity_token_account_frozen_error :: IdentityTokenAccountFrozenError) -> * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { ferment :: boxed (dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError { token_id , identity_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_destroy < > (ffi : * mut dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_get_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_token_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_identity_id < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError_set_action < > (obj : * const dpp_errors_consensus_state_token_identity_token_account_frozen_error_IdentityTokenAccountFrozenError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } } pub mod identity { use crate as example_nested ; pub mod recipient_identity_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`RecipientIdentityDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError > for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: recipient_identity_does_not_exist_error :: RecipientIdentityDoesNotExistError) -> * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) }) } } impl Drop for dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . recipient_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_ctor < > (recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError { recipient_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_get_recipient_id < > (obj : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError_set_recipient_id < > (obj : * const dpp_errors_consensus_state_identity_recipient_identity_does_not_exist_error_RecipientIdentityDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } } pub mod invalid_identity_public_key_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError > for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_public_key_id_error :: InvalidIdentityPublicKeyIdError) -> * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_ctor < > (id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_get_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError_set_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_public_key_id_error_InvalidIdentityPublicKeyIdError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } } pub mod missing_transfer_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingTransferKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError > for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_transfer_key_error :: MissingTransferKeyError) -> * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_missing_transfer_key_error_MissingTransferKeyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod invalid_identity_revision_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityRevisionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . current_revision) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError > for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_revision_error :: InvalidIdentityRevisionError) -> * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . current_revision) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . current_revision) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision) -> * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError { identity_id , current_revision }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_get_current_revision < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . current_revision } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError_set_current_revision < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_revision_error_InvalidIdentityRevisionError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . current_revision } } pub mod duplicated_identity_public_key_state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { pub duplicated_public_key_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_public_key_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_state_error :: DuplicatedIdentityPublicKeyStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_public_key_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_public_key_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_ctor < > (duplicated_public_key_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError { duplicated_public_key_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_get_duplicated_public_key_ids < > (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_public_key_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError_set_duplicated_public_key_ids < > (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_state_error_DuplicatedIdentityPublicKeyStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_public_key_ids } } pub mod no_transfer_key_for_core_withdrawal_available_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NoTransferKeyForCoreWithdrawalAvailableError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError > for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: no_transfer_key_for_core_withdrawal_available_error :: NoTransferKeyForCoreWithdrawalAvailableError) -> * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { ferment :: boxed (dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { ferment :: boxed (dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_no_transfer_key_for_core_withdrawal_available_error_NoTransferKeyForCoreWithdrawalAvailableError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod identity_already_exists_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAlreadyExistsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError > for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_already_exists_error :: IdentityAlreadyExistsError) -> * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError { identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_already_exists_error_IdentityAlreadyExistsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod identity_public_key_is_disabled_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsDisabledError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { pub public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError > for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_disabled_error :: IdentityPublicKeyIsDisabledError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_ctor < > (public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError { public_key_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_get_public_key_index < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError_set_public_key_index < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_disabled_error_IdentityPublicKeyIsDisabledError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_index } } pub mod missing_identity_public_key_ids_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingIdentityPublicKeyIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { pub ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError > for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: missing_identity_public_key_ids_error :: MissingIdentityPublicKeyIdsError) -> * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . ids) }) } } impl Drop for dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_ctor < > (ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ferment :: boxed (dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError { ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_get_ids < > (obj : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError_set_ids < > (obj : * const dpp_errors_consensus_state_identity_missing_identity_public_key_ids_error_MissingIdentityPublicKeyIdsError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . ids } } pub mod max_identity_public_key_limit_reached_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MaxIdentityPublicKeyLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { pub max_items : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError { max_items : ffi_ref . max_items } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError > for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: max_identity_public_key_limit_reached_error :: MaxIdentityPublicKeyLimitReachedError) -> * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { ferment :: boxed (dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { max_items : obj . max_items }) } } impl Drop for dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_ctor < > (max_items : usize) -> * mut dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { ferment :: boxed (dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError { max_items }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_get_max_items < > (obj : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> usize { (* obj) . max_items } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError_set_max_items < > (obj : * const dpp_errors_consensus_state_identity_max_identity_public_key_limit_reached_error_MaxIdentityPublicKeyLimitReachedError) -> usize { (* obj) . max_items } } pub mod identity_public_key_is_read_only_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyIsReadOnlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { pub public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_index) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError > for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_is_read_only_error :: IdentityPublicKeyIsReadOnlyError) -> * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { public_key_index : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_index) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_ctor < > (public_key_index : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError { public_key_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_get_public_key_index < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError_set_public_key_index < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_is_read_only_error_IdentityPublicKeyIsReadOnlyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_index } } pub mod invalid_identity_contract_nonce_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityNonceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub current_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub setting_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub error : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from_opt (ffi_ref . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionFrom < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError > for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: invalid_identity_contract_nonce_error :: InvalidIdentityNonceError) -> * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , current_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to_opt (obj . current_identity_nonce) , setting_identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . setting_identity_nonce) , error : < crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult as ferment :: FFIConversionTo < dpp :: identity :: identity_nonce :: MergeIdentityNonceResult >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any_opt (ffi_ref . current_identity_nonce) ; ferment :: unbox_any (ffi_ref . setting_identity_nonce) ; ferment :: unbox_any (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , current_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , setting_identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , error : * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult) -> * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { ferment :: boxed (dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError { identity_id , current_identity_nonce , setting_identity_nonce , error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_current_identity_nonce < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . current_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_setting_identity_nonce < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . setting_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_get_error < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_current_identity_nonce < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . current_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_setting_identity_nonce < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . setting_identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError_set_error < > (obj : * const dpp_errors_consensus_state_identity_invalid_identity_contract_nonce_error_InvalidIdentityNonceError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_nonce :: dpp_identity_identity_nonce_MergeIdentityNonceResult { (* obj) . error } } pub mod identity_public_key_already_exists_for_unique_contract_bounds_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub new_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub old_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , new_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . new_key_id) , old_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . old_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError > for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_public_key_already_exists_for_unique_contract_bounds_error :: IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , new_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . new_key_id) , old_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . old_key_id) }) } } impl Drop for dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . new_key_id) ; ferment :: unbox_any (ffi_ref . old_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , new_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , old_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError { identity_id , contract_id , purpose , new_key_id , old_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_contract_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_purpose < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_new_key_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . new_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_get_old_key_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . old_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_contract_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_purpose < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_new_key_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . new_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError_set_old_key_id < > (obj : * const dpp_errors_consensus_state_identity_identity_public_key_already_exists_for_unique_contract_bounds_error_IdentityPublicKeyAlreadyExistsForUniqueContractBoundsError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . old_key_id } } pub mod master_public_key_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MasterPublicKeyUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { pub adding : usize , pub removing : usize , pub description : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError { adding : ffi_ref . adding , removing : ffi_ref . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . description) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError > for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError) -> * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { ferment :: boxed (dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { adding : obj . adding , removing : obj . removing , description : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . description) }) } } impl Drop for dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_string (ffi_ref . description) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_ctor < > (adding : usize , removing : usize , description : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { ferment :: boxed (dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError { adding , removing , description }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_adding < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . adding } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_removing < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . removing } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_get_description < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . description } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_adding < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . adding } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_removing < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> usize { (* obj) . removing } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError_set_description < > (obj : * const dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . description } } pub mod duplicated_identity_public_key_id_state_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdStateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError > for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: duplicated_identity_public_key_id_state_error :: DuplicatedIdentityPublicKeyIdStateError) -> * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_ctor < > (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { ferment :: boxed (dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_get_duplicated_ids < > (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError_set_duplicated_ids < > (obj : * const dpp_errors_consensus_state_identity_duplicated_identity_public_key_id_state_error_DuplicatedIdentityPublicKeyIdStateError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } } pub mod identity_insufficient_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityInsufficientBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub balance : u64 , pub required_balance : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , balance : ffi_ref . balance , required_balance : ffi_ref . required_balance } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError > for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: identity :: identity_insufficient_balance_error :: IdentityInsufficientBalanceError) -> * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , balance : obj . balance , required_balance : obj . required_balance }) } } impl Drop for dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , balance : u64 , required_balance : u64) -> * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { ferment :: boxed (dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError { identity_id , balance , required_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_destroy < > (ffi : * mut dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_balance < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_get_required_balance < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . required_balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_identity_id < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_balance < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . balance } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError_set_required_balance < > (obj : * const dpp_errors_consensus_state_identity_identity_insufficient_balance_error_IdentityInsufficientBalanceError) -> u64 { (* obj) . required_balance } } } pub mod group { use crate as example_nested ; pub mod group_action_already_completed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionAlreadyCompletedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError > for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_completed_error :: GroupActionAlreadyCompletedError) -> * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError { data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_destroy < > (ffi : * mut dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_get_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError_set_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_completed_error_GroupActionAlreadyCompletedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } } pub mod identity_not_member_of_group_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotMemberOfGroupError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError > for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: identity_not_member_of_group_error :: IdentityNotMemberOfGroupError) -> * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { ferment :: boxed (dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) }) } } impl Drop for dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { ferment :: boxed (dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError { identity_id , data_contract_id , group_contract_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_destroy < > (ffi : * mut dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_identity_id < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_get_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_identity_id < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError_set_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_identity_not_member_of_group_error_IdentityNotMemberOfGroupError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } } pub mod group_action_already_signed_by_identity_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionAlreadySignedByIdentityError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError > for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_already_signed_by_identity_error :: GroupActionAlreadySignedByIdentityError) -> * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError { identity_id , data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_destroy < > (ffi : * mut dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_identity_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_get_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_identity_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError_set_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_already_signed_by_identity_error_GroupActionAlreadySignedByIdentityError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } } pub mod group_action_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError > for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: group :: group_action_does_not_exist_error :: GroupActionDoesNotExistError) -> * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) }) } } impl Drop for dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError { data_contract_id , group_contract_position , action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_get_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_group_contract_position < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError_set_action_id < > (obj : * const dpp_errors_consensus_state_group_group_action_does_not_exist_error_GroupActionDoesNotExistError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } } } pub mod data_contract { use crate as example_nested ; pub mod data_contract_config_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError > for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_config_update_error :: DataContractConfigUpdateError) -> * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , additional_message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError { data_contract_id , additional_message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_get_additional_message < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError_set_additional_message < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_config_update_error_DataContractConfigUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } } pub mod data_contract_update_action_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdateActionNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError > for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_action_not_allowed_error :: DataContractUpdateActionNotAllowedError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError { data_contract_id , action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_get_action < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError_set_action < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_action_not_allowed_error_DataContractUpdateActionNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod data_contract_is_readonly_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractIsReadonlyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError > for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_is_readonly_error :: DataContractIsReadonlyError) -> * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_is_readonly_error_DataContractIsReadonlyError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod document_type_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub additional_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . additional_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError > for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: document_type_update_error :: DocumentTypeUpdateError) -> * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , additional_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . additional_message) }) } } impl Drop for dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . additional_message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char , additional_message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { ferment :: boxed (dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError { data_contract_id , document_type_name , additional_message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_document_type_name < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_get_additional_message < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_document_type_name < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError_set_additional_message < > (obj : * const dpp_errors_consensus_state_data_contract_document_type_update_error_DocumentTypeUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . additional_message } } pub mod data_contract_update_permission_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdatePermissionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError > for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_update_permission_error :: DataContractUpdatePermissionError) -> * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError { data_contract_id , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_get_identity_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError_set_identity_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_update_permission_error_DataContractUpdatePermissionError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } pub mod data_contract_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError > for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: state :: data_contract :: data_contract_already_present_error :: DataContractAlreadyPresentError) -> * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_destroy < > (ffi : * mut dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_get_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError_set_data_contract_id < > (obj : * const dpp_errors_consensus_state_data_contract_data_contract_already_present_error_DataContractAlreadyPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } } } pub mod basic { use crate as example_nested ; pub mod document { use crate as example_nested ; pub mod duplicate_document_transitions_with_indices_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIndicesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_ctor < > (references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) -> * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError { references }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_get_references < > (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError_set_references < > (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } } pub mod duplicate_document_transitions_with_ids_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateDocumentTransitionsWithIdsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { pub references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > >> :: ffi_from (ffi_ref . references) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError > for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError) -> * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { references : < crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 as ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > >> :: ffi_to (obj . references) }) } } impl Drop for dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . references) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_ctor < > (references : * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32) -> * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { ferment :: boxed (dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError { references }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_get_references < > (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError_set_references < > (obj : * const dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> * mut crate :: fermented :: generics :: Vec_Tuple_String_Arr_u8_32 { (* obj) . references } } pub mod missing_document_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError > for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError_ctor < > () -> * mut dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) { ferment :: unbox_any (ffi) ; } } pub mod inconsistent_compound_index_data_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InconsistentCompoundIndexDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { pub document_type : * mut std :: os :: raw :: c_char , pub index_properties : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . index_properties) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError > for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError) -> * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { ferment :: boxed (dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_properties : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . index_properties) }) } } impl Drop for dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . index_properties) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_properties : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { ferment :: boxed (dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError { document_type , index_properties }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_get_document_type < > (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_get_index_properties < > (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . index_properties } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_set_document_type < > (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError_set_index_properties < > (obj : * const dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . index_properties } } pub mod data_contract_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod document_creation_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentCreationNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError > for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError) -> * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) }) } } impl Drop for dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char , creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) -> * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError { data_contract_id , document_type_name , creation_restriction_mode }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_document_type_name < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_get_creation_restriction_mode < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_document_type_name < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError_set_creation_restriction_mode < > (obj : * const dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } } pub mod identity_contract_nonce_out_of_bounds_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonceOutOfBoundsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError > for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError) -> * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { ferment :: boxed (dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) }) } } impl Drop for dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . nonce) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_ctor < > (nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce) -> * mut dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { ferment :: boxed (dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError { nonce }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_get_nonce < > (obj : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError_set_nonce < > (obj : * const dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } } pub mod invalid_document_transition_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { pub expected_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError > for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { expected_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_ctor < > (expected_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError { expected_id , invalid_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_get_expected_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_get_invalid_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_set_expected_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError_set_invalid_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_id } } pub mod invalid_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_ctor < > (document_type : * mut std :: os :: raw :: c_char , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError { document_type , data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_get_document_type < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_set_document_type < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod contested_documents_temporarily_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentsTemporarilyNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { pub current_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub target_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . target_epoch) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError > for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError) -> * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { current_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . current_epoch) , target_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . target_epoch) }) } } impl Drop for dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . current_epoch) ; ferment :: unbox_any (ffi_ref . target_epoch) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_ctor < > (current_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , target_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) -> * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError { current_epoch , target_epoch }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_get_current_epoch < > (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . current_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_get_target_epoch < > (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . target_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_set_current_epoch < > (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . current_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError_set_target_epoch < > (obj : * const dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . target_epoch } } pub mod missing_positions_in_document_type_properties_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingPositionsInDocumentTypePropertiesError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { pub missing_position : u32 , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError { missing_position : ffi_ref . missing_position , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError > for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError) -> * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { missing_position : obj . missing_position , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_ctor < > (missing_position : u32 , contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError { missing_position , contract_id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_missing_position < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> u32 { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_contract_id < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_get_document_type_name < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_missing_position < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> u32 { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_contract_id < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError_set_document_type_name < > (obj : * const dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } } pub mod missing_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError > for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError) -> * const dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError_ctor < > () -> * mut dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) { ferment :: unbox_any (ffi) ; } } pub mod document_transitions_are_absent_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTransitionsAreAbsentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) -> dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError > for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError) -> * const dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { ferment :: boxed (dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { }) } } impl Drop for dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError_ctor < > () -> * mut dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { ferment :: boxed (dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) { ferment :: unbox_any (ffi) ; } } pub mod document_field_max_size_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentFieldMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { pub field : * mut std :: os :: raw :: c_char , pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field) , actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError > for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError) -> * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { field : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field) , actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } impl Drop for dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . field) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_ctor < > (field : * mut std :: os :: raw :: c_char , actual_size_bytes : u64 , max_size_bytes : u64) -> * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError { field , actual_size_bytes , max_size_bytes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_field < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> * mut std :: os :: raw :: c_char { (* obj) . field } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_actual_size_bytes < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_get_max_size_bytes < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_field < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> * mut std :: os :: raw :: c_char { (* obj) . field } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_actual_size_bytes < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError_set_max_size_bytes < > (obj : * const dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } } pub mod missing_data_contract_id_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDataContractIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) -> dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError > for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError) -> * const dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError_ctor < > () -> * mut dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) { ferment :: unbox_any (ffi) ; } } pub mod missing_document_transition_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError > for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { }) } } impl Drop for dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError_ctor < > () -> * mut dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_document_transition_action_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTransitionActionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { pub action : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . action) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError > for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError) -> * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { action : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . action) }) } } impl Drop for dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . action) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_ctor < > (action : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { ferment :: boxed (dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError { action }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_get_action < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError_set_action < > (obj : * const dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> * mut std :: os :: raw :: c_char { (* obj) . action } } pub mod max_documents_transitions_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MaxDocumentsTransitionsExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { pub max_transitions : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError { max_transitions : ffi_ref . max_transitions } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError > for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError) -> * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { max_transitions : obj . max_transitions }) } } impl Drop for dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_ctor < > (max_transitions : u16) -> * mut dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { ferment :: boxed (dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError { max_transitions }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_destroy < > (ffi : * mut dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_get_max_transitions < > (obj : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> u16 { (* obj) . max_transitions } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError_set_max_transitions < > (obj : * const dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> u16 { (* obj) . max_transitions } } } pub mod data_contract { use crate as example_nested ; pub mod non_contiguous_contract_group_positions_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonContiguousContractGroupPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_ctor < > (missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError { missing_position , followed_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_get_missing_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_get_followed_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . followed_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_set_missing_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError_set_followed_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . followed_position } } pub mod unknown_transferable_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownTransferableTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError > for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_ctor < > (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_get_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_get_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_set_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError_set_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> u8 { (* obj) . received } } pub mod incompatible_data_contract_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleDataContractSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError { data_contract_id , operation , field_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_get_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError_set_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } } pub mod invalid_data_contract_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDataContractVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { pub expected_version : u32 , pub version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError { expected_version : ffi_ref . expected_version , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { expected_version : obj . expected_version , version : obj . version }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_ctor < > (expected_version : u32 , version : u32) -> * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError { expected_version , version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_get_expected_version < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . expected_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_get_version < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_set_expected_version < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . expected_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError_set_version < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> u32 { (* obj) . version } } pub mod duplicate_index_name_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateIndexNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { pub document_type : * mut std :: os :: raw :: c_char , pub duplicate_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . duplicate_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError > for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , duplicate_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . duplicate_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . duplicate_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_ctor < > (document_type : * mut std :: os :: raw :: c_char , duplicate_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError { document_type , duplicate_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_get_duplicate_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . duplicate_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError_set_duplicate_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut std :: os :: raw :: c_char { (* obj) . duplicate_index_name } } pub mod incompatible_re2_pattern_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleRe2PatternError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pub pattern : * mut std :: os :: raw :: c_char , pub path : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError > for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pattern : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . pattern) , path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . path) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . pattern) ; ferment :: unbox_string (ffi_ref . path) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_ctor < > (pattern : * mut std :: os :: raw :: c_char , path : * mut std :: os :: raw :: c_char , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError { pattern , path , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_pattern < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . pattern } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_get_message < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_pattern < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . pattern } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError_set_message < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod unknown_storage_key_requirements_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownStorageKeyRequirementsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : * mut [u8 ; 16] } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (ffi_ref . received) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError > for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError) -> * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : < [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (obj . received) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ferment :: unbox_any_opt (ffi_ref . received) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_ctor < > (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : * mut [u8 ; 16]) -> * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_get_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_get_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut [u8 ; 16] { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_set_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError_set_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut [u8 ; 16] { (* obj) . received } } pub mod unique_indices_limit_reached_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UniqueIndicesLimitReachedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_limit : u16 , pub is_contested_limit : bool } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_limit : ffi_ref . index_limit , is_contested_limit : ffi_ref . is_contested_limit } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError > for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError) -> * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_limit : obj . index_limit , is_contested_limit : obj . is_contested_limit }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_limit : u16 , is_contested_limit : bool) -> * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError { document_type , index_limit , is_contested_limit }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_index_limit < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> u16 { (* obj) . index_limit } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_get_is_contested_limit < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> bool { (* obj) . is_contested_limit } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_index_limit < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> u16 { (* obj) . index_limit } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError_set_is_contested_limit < > (obj : * const dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> bool { (* obj) . is_contested_limit } } pub mod group_non_unilateral_member_power_has_less_than_required_power_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError > for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_ctor < > (total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError { total_power , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_get_total_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_get_required_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_set_total_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_set_required_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } } pub mod unknown_document_creation_restriction_mode_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownDocumentCreationRestrictionModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError > for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_ctor < > (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_get_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_get_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_set_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError_set_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> u8 { (* obj) . received } } pub mod invalid_document_type_name_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeNameError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { pub name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_ctor < > (name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError { name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_get_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError_set_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> * mut std :: os :: raw :: c_char { (* obj) . name } } pub mod contested_unique_index_on_mutable_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedUniqueIndexOnMutableDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_ctor < > (document_type : * mut std :: os :: raw :: c_char , contested_unique_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError { document_type , contested_unique_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_get_contested_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError_set_contested_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } } pub mod group_member_has_power_over_limit_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOverLimitError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . max_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) , power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . power) , max_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . max_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; ferment :: unbox_any (ffi_ref . power) ; ferment :: unbox_any (ffi_ref . max_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_ctor < > (member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , max_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError { member_id , power , max_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_member_id < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_get_max_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . max_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_member_id < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError_set_max_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . max_power } } pub mod group_position_does_not_exist_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupPositionDoesNotExistError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { pub missing_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . missing_group_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError > for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError) -> * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { missing_group_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . missing_group_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_group_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_ctor < > (missing_group_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError { missing_group_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_get_missing_group_position < > (obj : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_group_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError_set_missing_group_position < > (obj : * const dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . missing_group_position } } pub mod unknown_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError > for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_ctor < > (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_get_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_get_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_set_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError_set_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> u8 { (* obj) . received } } pub mod invalid_document_type_required_security_level { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeRequiredSecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError { security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError > for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError) -> * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_ctor < > (security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError { security_level , contract_id , document_type_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_security_level < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_get_document_type_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_security_level < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError_set_document_type_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } } pub mod system_property_index_already_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemPropertyIndexAlreadyPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError > for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError) -> * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError { document_type , index_name , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_get_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError_set_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } } pub mod incompatible_document_type_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleDocumentTypeSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { pub document_type_name : * mut std :: os :: raw :: c_char , pub operation : * mut std :: os :: raw :: c_char , pub property_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError > for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError) -> * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , property_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . property_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_ctor < > (document_type_name : * mut std :: os :: raw :: c_char , operation : * mut std :: os :: raw :: c_char , property_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError { document_type_name , operation , property_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_document_type_name < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_get_property_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_document_type_name < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError_set_property_path < > (obj : * const dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_path } } pub mod invalid_index_property_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIndexPropertyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub property_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError > for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError) -> * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , property_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_type) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . property_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char , property_type : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError { document_type , index_name , property_name , property_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_get_property_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError_set_property_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . property_type } } pub mod data_contract_max_depth_exceed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractMaxDepthExceedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { pub max_depth : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError { max_depth : ffi_ref . max_depth } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError > for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { max_depth : obj . max_depth }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_ctor < > (max_depth : usize) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError { max_depth }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_get_max_depth < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> usize { (* obj) . max_depth } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError_set_max_depth < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> usize { (* obj) . max_depth } } pub mod contested_unique_index_with_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedUniqueIndexWithUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub contested_unique_index_name : * mut std :: os :: raw :: c_char , pub unique_index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . unique_index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError > for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , contested_unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . contested_unique_index_name) , unique_index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . unique_index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . contested_unique_index_name) ; ferment :: unbox_string (ffi_ref . unique_index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_ctor < > (document_type : * mut std :: os :: raw :: c_char , contested_unique_index_name : * mut std :: os :: raw :: c_char , unique_index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError { document_type , contested_unique_index_name , unique_index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_contested_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_get_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_contested_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . contested_unique_index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError_set_unique_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . unique_index_name } } pub mod undefined_index_property_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UndefinedIndexPropertyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError > for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError) -> * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError { document_type , index_name , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_get_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError_set_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } } pub mod invalid_indexed_property_constraint_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIndexedPropertyConstraintError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub property_name : * mut std :: os :: raw :: c_char , pub constraint_name : * mut std :: os :: raw :: c_char , pub reason : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . reason) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError > for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError) -> * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , constraint_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . constraint_name) , reason : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . reason) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . constraint_name) ; ferment :: unbox_string (ffi_ref . reason) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , property_name : * mut std :: os :: raw :: c_char , constraint_name : * mut std :: os :: raw :: c_char , reason : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError { document_type , index_name , property_name , constraint_name , reason }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_constraint_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . constraint_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_get_reason < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . reason } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_property_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_constraint_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . constraint_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError_set_reason < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut std :: os :: raw :: c_char { (* obj) . reason } } pub mod data_contract_immutable_properties_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractImmutablePropertiesUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub new_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . new_value) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . old_value) , new_value : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . new_value) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_value) ; ferment :: unbox_any (ffi_ref . new_value) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_ctor < > (operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char , old_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , new_value : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError { operation , field_path , old_value , new_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_old_value < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . old_value } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_get_new_value < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . new_value } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_old_value < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . old_value } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError_set_new_value < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . new_value } } pub mod invalid_compound_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidCompoundIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError > for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError) -> * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } } pub mod invalid_token_base_supply_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenBaseSupplyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { pub base_supply : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError { base_supply : ffi_ref . base_supply } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError > for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { base_supply : obj . base_supply }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_ctor < > (base_supply : u64) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError { base_supply }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_get_base_supply < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> u64 { (* obj) . base_supply } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError_set_base_supply < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> u64 { (* obj) . base_supply } } pub mod data_contract_token_configuration_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractTokenConfigurationUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { pub operation : * mut std :: os :: raw :: c_char , pub field_path : * mut std :: os :: raw :: c_char , pub old_config : * mut example_nested :: custom :: dpp :: TokenConfigurationFFI , pub new_config : * mut example_nested :: custom :: dpp :: TokenConfigurationFFI } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_path) , old_config : < example_nested :: custom :: dpp :: TokenConfigurationFFI as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >> :: ffi_from (ffi_ref . old_config) , new_config : < example_nested :: custom :: dpp :: TokenConfigurationFFI as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >> :: ffi_from (ffi_ref . new_config) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { operation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . operation) , field_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_path) , old_config : < example_nested :: custom :: dpp :: TokenConfigurationFFI as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >> :: ffi_to (obj . old_config) , new_config : < example_nested :: custom :: dpp :: TokenConfigurationFFI as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >> :: ffi_to (obj . new_config) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . operation) ; ferment :: unbox_string (ffi_ref . field_path) ; ferment :: unbox_any (ffi_ref . old_config) ; ferment :: unbox_any (ffi_ref . new_config) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_ctor < > (operation : * mut std :: os :: raw :: c_char , field_path : * mut std :: os :: raw :: c_char , old_config : * mut example_nested :: custom :: dpp :: TokenConfigurationFFI , new_config : * mut example_nested :: custom :: dpp :: TokenConfigurationFFI) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError { operation , field_path , old_config , new_config }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_old_config < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut example_nested :: custom :: dpp :: TokenConfigurationFFI { (* obj) . old_config } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_get_new_config < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut example_nested :: custom :: dpp :: TokenConfigurationFFI { (* obj) . new_config } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_operation < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . operation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_field_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . field_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_old_config < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut example_nested :: custom :: dpp :: TokenConfigurationFFI { (* obj) . old_config } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError_set_new_config < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut example_nested :: custom :: dpp :: TokenConfigurationFFI { (* obj) . new_config } } pub mod data_contract_invalid_index_definition_update_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInvalidIndexDefinitionUpdateError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { pub document_type : * mut std :: os :: raw :: c_char , pub index_path : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_path) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError > for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_path) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_path) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_path : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError { document_type , index_path }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_get_index_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . index_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError_set_index_path < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut std :: os :: raw :: c_char { (* obj) . index_path } } pub mod unknown_trade_mode_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnknownTradeModeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { pub allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , pub received : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . allowed_values) , received : ffi_ref . received } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError > for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError) -> * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { allowed_values : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . allowed_values) , received : obj . received }) } } impl Drop for dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . allowed_values) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_ctor < > (allowed_values : * mut crate :: fermented :: generics :: Vec_u8 , received : u8) -> * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError { allowed_values , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_get_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_get_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> u8 { (* obj) . received } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_set_allowed_values < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . allowed_values } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError_set_received < > (obj : * const dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> u8 { (* obj) . received } } pub mod data_contract_have_new_unique_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractHaveNewUniqueIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError > for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } } pub mod document_types_are_missing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypesAreMissingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError > for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError) -> * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod invalid_token_distribution_function_invalid_parameter_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { pub parameter : * mut std :: os :: raw :: c_char , pub min : i64 , pub max : i64 , pub not_valid : * mut i64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parameter) , min : ffi_ref . min , max : ffi_ref . max , not_valid : ferment :: from_opt_primitive (ffi_ref . not_valid) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parameter) , min : obj . min , max : obj . max , not_valid : ferment :: to_opt_primitive (obj . not_valid) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parameter) ; ; ; ferment :: destroy_opt_primitive (ffi_ref . not_valid) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_ctor < > (parameter : * mut std :: os :: raw :: c_char , min : i64 , max : i64 , not_valid : * mut i64) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError { parameter , min , max , not_valid }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut std :: os :: raw :: c_char { (* obj) . parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_min < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . min } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_max < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . max } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_get_not_valid < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut i64 { (* obj) . not_valid } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut std :: os :: raw :: c_char { (* obj) . parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_min < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . min } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_max < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> i64 { (* obj) . max } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError_set_not_valid < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut i64 { (* obj) . not_valid } } pub mod invalid_token_distribution_function_divide_by_zero_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionDivideByZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { pub distribution_function : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_from (ffi_ref . distribution_function) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { distribution_function : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction >> :: ffi_to (obj . distribution_function) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . distribution_function) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_ctor < > (distribution_function : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError { distribution_function }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_get_distribution_function < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { (* obj) . distribution_function } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError_set_distribution_function < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { (* obj) . distribution_function } } pub mod invalid_token_distribution_function_invalid_parameter_tuple_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionInvalidParameterTupleError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { pub first_parameter : * mut std :: os :: raw :: c_char , pub second_parameter : * mut std :: os :: raw :: c_char , pub relation : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . relation) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . first_parameter) , second_parameter : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . second_parameter) , relation : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . relation) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . first_parameter) ; ferment :: unbox_string (ffi_ref . second_parameter) ; ferment :: unbox_string (ffi_ref . relation) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_ctor < > (first_parameter : * mut std :: os :: raw :: c_char , second_parameter : * mut std :: os :: raw :: c_char , relation : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError { first_parameter , second_parameter , relation }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_first_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . first_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_second_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . second_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_get_relation < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . relation } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_first_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . first_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_second_parameter < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . second_parameter } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError_set_relation < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut std :: os :: raw :: c_char { (* obj) . relation } } pub mod group_exceeds_max_members_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupExceedsMaxMembersError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { pub max_members : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError { max_members : ffi_ref . max_members } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError > for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError) -> * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { max_members : obj . max_members }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_ctor < > (max_members : u32) -> * mut dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError { max_members }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_get_max_members < > (obj : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> u32 { (* obj) . max_members } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError_set_max_members < > (obj : * const dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> u32 { (* obj) . max_members } } pub mod data_contract_unique_indices_changed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUniqueIndicesChangedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError > for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError) -> * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } } pub mod duplicate_index_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicateIndexError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { pub document_type : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError > for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError) -> * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { document_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . document_type) ; ferment :: unbox_string (ffi_ref . index_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_ctor < > (document_type : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError { document_type , index_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_get_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_get_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_set_document_type < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . document_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError_set_index_name < > (obj : * const dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } } pub mod invalid_token_distribution_function_incoherence_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenDistributionFunctionIncoherenceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError > for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError) -> * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_get_message < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError_set_message < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod non_contiguous_contract_token_positions_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NonContiguousContractTokenPositionsError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { pub missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . followed_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError > for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError) -> * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { missing_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . missing_position) , followed_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . followed_position) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . missing_position) ; ferment :: unbox_any (ffi_ref . followed_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_ctor < > (missing_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , followed_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError { missing_position , followed_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_get_missing_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_get_followed_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . followed_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_set_missing_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . missing_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError_set_followed_position < > (obj : * const dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . followed_position } } # [cfg (feature = "json-schema-validation")] pub mod invalid_json_schema_ref_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidJsonSchemaRefError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError > for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError) -> * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_get_message < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError_set_message < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod group_member_has_power_of_zero_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupMemberHasPowerOfZeroError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { pub member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . member_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError > for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError) -> * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { member_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . member_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_ctor < > (member_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError { member_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_get_member_id < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError_set_member_id < > (obj : * const dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . member_id } } pub mod group_total_power_has_less_than_required_power_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupTotalPowerLessThanRequiredError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { pub total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError > for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError) -> * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { total_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . total_power) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . total_power) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_ctor < > (total_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError { total_power , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_get_total_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_get_required_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_set_total_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . total_power } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError_set_required_power < > (obj : * const dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower { (* obj) . required_power } } pub mod invalid_data_contract_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDataContractIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { pub expected_id : * mut crate :: fermented :: generics :: Vec_u8 , pub invalid_id : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . invalid_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError > for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError) -> * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { expected_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . expected_id) , invalid_id : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . invalid_id) }) } } impl Drop for dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_id) ; ferment :: unbox_any (ffi_ref . invalid_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_ctor < > (expected_id : * mut crate :: fermented :: generics :: Vec_u8 , invalid_id : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { ferment :: boxed (dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError { expected_id , invalid_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_destroy < > (ffi : * mut dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_get_expected_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_get_invalid_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . invalid_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_set_expected_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . expected_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError_set_invalid_id < > (obj : * const dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . invalid_id } } } pub mod decode { use crate as example_nested ; pub mod version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`VersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_version_error_VersionError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError > for dpp_errors_consensus_basic_decode_version_error_VersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError) -> * const dpp_errors_consensus_basic_decode_version_error_VersionError { ferment :: boxed (dpp_errors_consensus_basic_decode_version_error_VersionError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_version_error_VersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_ctor < > (error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_version_error_VersionError { ferment :: boxed (dpp_errors_consensus_basic_decode_version_error_VersionError { error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_decode_version_error_VersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_get_error < > (obj : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> * mut std :: os :: raw :: c_char { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_version_error_VersionError_set_error < > (obj : * const dpp_errors_consensus_basic_decode_version_error_VersionError) -> * mut std :: os :: raw :: c_char { (* obj) . error } } pub mod serialized_object_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`SerializedObjectParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError > for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError) -> * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_ctor < > (parsing_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError { parsing_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_destroy < > (ffi : * mut dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_get_parsing_error < > (obj : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError_set_parsing_error < > (obj : * const dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } } pub mod decoding_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DecodingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_decoding_error_DecodingError { pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError > for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError) -> * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError { ferment :: boxed (dpp_errors_consensus_basic_decode_decoding_error_DecodingError { error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error) }) } } impl Drop for dpp_errors_consensus_basic_decode_decoding_error_DecodingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_ctor < > (error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_decoding_error_DecodingError { ferment :: boxed (dpp_errors_consensus_basic_decode_decoding_error_DecodingError { error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_destroy < > (ffi : * mut dpp_errors_consensus_basic_decode_decoding_error_DecodingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_get_error < > (obj : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> * mut std :: os :: raw :: c_char { (* obj) . error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_decoding_error_DecodingError_set_error < > (obj : * const dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> * mut std :: os :: raw :: c_char { (* obj) . error } } pub mod protocol_version_parsing_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ProtocolVersionParsingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { pub parsing_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . parsing_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError > for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError) -> * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { parsing_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . parsing_error) }) } } impl Drop for dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . parsing_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_ctor < > (parsing_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { ferment :: boxed (dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError { parsing_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_destroy < > (ffi : * mut dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_get_parsing_error < > (obj : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError_set_parsing_error < > (obj : * const dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> * mut std :: os :: raw :: c_char { (* obj) . parsing_error } } } pub mod unsupported_feature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedFeatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { pub feature_name : * mut std :: os :: raw :: c_char , pub current_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . feature_name) , current_protocol_version : ffi_ref . current_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError > for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError) -> * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { feature_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . feature_name) , current_protocol_version : obj . current_protocol_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . feature_name) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_ctor < > (feature_name : * mut std :: os :: raw :: c_char , current_protocol_version : u32) -> * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError { feature_name , current_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_destroy < > (ffi : * mut dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_get_feature_name < > (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> * mut std :: os :: raw :: c_char { (* obj) . feature_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_get_current_protocol_version < > (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> u32 { (* obj) . current_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_set_feature_name < > (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> * mut std :: os :: raw :: c_char { (* obj) . feature_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError_set_current_protocol_version < > (obj : * const dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> u32 { (* obj) . current_protocol_version } } pub mod value_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ValueError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_value_error_ValueError { pub value_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_value_error_ValueError) -> dpp :: errors :: consensus :: basic :: value_error :: ValueError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: value_error :: ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . value_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: value_error :: ValueError > for dpp_errors_consensus_basic_value_error_ValueError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: value_error :: ValueError) -> * const dpp_errors_consensus_basic_value_error_ValueError { ferment :: boxed (dpp_errors_consensus_basic_value_error_ValueError { value_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . value_error) }) } } impl Drop for dpp_errors_consensus_basic_value_error_ValueError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . value_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_ctor < > (value_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_value_error_ValueError { ferment :: boxed (dpp_errors_consensus_basic_value_error_ValueError { value_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_destroy < > (ffi : * mut dpp_errors_consensus_basic_value_error_ValueError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_get_value_error < > (obj : * const dpp_errors_consensus_basic_value_error_ValueError) -> * mut std :: os :: raw :: c_char { (* obj) . value_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_value_error_ValueError_set_value_error < > (obj : * const dpp_errors_consensus_basic_value_error_ValueError) -> * mut std :: os :: raw :: c_char { (* obj) . value_error } } pub mod group { use crate as example_nested ; pub mod group_action_not_allowed_on_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupActionNotAllowedOnTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { pub transition_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . transition_type) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError > for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError) -> * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { ferment :: boxed (dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { transition_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . transition_type) }) } } impl Drop for dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . transition_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_ctor < > (transition_type : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { ferment :: boxed (dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError { transition_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_get_transition_type < > (obj : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> * mut std :: os :: raw :: c_char { (* obj) . transition_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError_set_transition_type < > (obj : * const dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> * mut std :: os :: raw :: c_char { (* obj) . transition_type } } } # [cfg (feature = "json-schema-validation")] pub mod json_schema_compilation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`JsonSchemaCompilationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { pub compilation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . compilation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError > for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError) -> * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { compilation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . compilation_error) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . compilation_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_ctor < > (compilation_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError { compilation_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_destroy < > (ffi : * mut dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_get_compilation_error < > (obj : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> * mut std :: os :: raw :: c_char { (* obj) . compilation_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError_set_compilation_error < > (obj : * const dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> * mut std :: os :: raw :: c_char { (* obj) . compilation_error } } pub mod unsupported_protocol_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { pub parsed_protocol_version : u32 , pub latest_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , latest_version : ffi_ref . latest_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError > for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError) -> * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , latest_version : obj . latest_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_ctor < > (parsed_protocol_version : u32 , latest_version : u32) -> * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError { parsed_protocol_version , latest_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_get_parsed_protocol_version < > (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_get_latest_version < > (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . latest_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_set_parsed_protocol_version < > (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError_set_latest_version < > (obj : * const dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> u32 { (* obj) . latest_version } } pub mod invalid_identifier_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentifierError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { pub identifier_name : * mut std :: os :: raw :: c_char , pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError > for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError) -> * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { ferment :: boxed (dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { identifier_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . identifier_name) , message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . identifier_name) ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_ctor < > (identifier_name : * mut std :: os :: raw :: c_char , message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { ferment :: boxed (dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError { identifier_name , message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_destroy < > (ffi : * mut dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_get_identifier_name < > (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . identifier_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_get_message < > (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_set_identifier_name < > (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . identifier_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError_set_message < > (obj : * const dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } # [cfg (feature = "json-schema-validation")] pub mod json_schema_error { use crate as example_nested ; pub mod json_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`JsonSchemaError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { pub error_summary : * mut std :: os :: raw :: c_char , pub keyword : * mut std :: os :: raw :: c_char , pub instance_path : * mut std :: os :: raw :: c_char , pub schema_path : * mut std :: os :: raw :: c_char , pub params : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub property_name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError > for dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError) -> * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { error_summary : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error_summary) , keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) , instance_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . instance_path) , schema_path : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . schema_path) , params : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . error_summary) ; ferment :: unbox_string (ffi_ref . keyword) ; ferment :: unbox_string (ffi_ref . instance_path) ; ferment :: unbox_string (ffi_ref . schema_path) ; ferment :: unbox_any (ffi_ref . params) ; ferment :: unbox_string (ffi_ref . property_name) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_ctor < > (error_summary : * mut std :: os :: raw :: c_char , keyword : * mut std :: os :: raw :: c_char , instance_path : * mut std :: os :: raw :: c_char , schema_path : * mut std :: os :: raw :: c_char , params : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , property_name : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError { error_summary , keyword , instance_path , schema_path , params , property_name }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_destroy < > (ffi : * mut dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_error_summary < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . error_summary } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_keyword < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_instance_path < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . instance_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_schema_path < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . schema_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_params < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . params } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_get_property_name < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_error_summary < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . error_summary } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_keyword < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_instance_path < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . instance_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_schema_path < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . schema_path } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_params < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . params } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError_set_property_name < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } } pub mod json_schema_error_data { use crate as example_nested ; # [doc = "FFI-representation of the [`JsonSchemaErrorData`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { pub keyword : * mut std :: os :: raw :: c_char , pub params : * mut serde_json :: Map < String , serde_json :: Value > , pub property_name : * mut std :: os :: raw :: c_char , pub error_message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error_data :: JsonSchemaErrorData > for dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error_data :: JsonSchemaErrorData { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error_data :: JsonSchemaErrorData { keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . keyword) , params : (& * ffi_ref . params) . clone () , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . property_name) , error_message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . error_message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error_data :: JsonSchemaErrorData > for dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error_data :: JsonSchemaErrorData) -> * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { keyword : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . keyword) , params : ferment :: boxed (obj . params) , property_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . property_name) , error_message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . error_message) }) } } impl Drop for dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . keyword) ; ferment :: unbox_any (ffi_ref . params) ; ferment :: unbox_string (ffi_ref . property_name) ; ferment :: unbox_string (ffi_ref . error_message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_ctor < > (keyword : * mut std :: os :: raw :: c_char , params : * mut serde_json :: Map < String , serde_json :: Value > , property_name : * mut std :: os :: raw :: c_char , error_message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { ferment :: boxed (dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData { keyword , params , property_name , error_message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_destroy < > (ffi : * mut dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_get_keyword < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_get_params < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut serde_json :: Map < String , serde_json :: Value > { (* obj) . params } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_get_property_name < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_get_error_message < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . error_message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_set_keyword < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . keyword } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_set_params < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut serde_json :: Map < String , serde_json :: Value > { (* obj) . params } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_set_property_name < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . property_name } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData_set_error_message < > (obj : * const dpp_errors_consensus_basic_json_schema_error_json_schema_error_data_JsonSchemaErrorData) -> * mut std :: os :: raw :: c_char { (* obj) . error_message } } } pub mod state_transition { use crate as example_nested ; pub mod invalid_state_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { pub transition_type : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError { transition_type : ffi_ref . transition_type } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { transition_type : obj . transition_type }) } } impl Drop for dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_ctor < > (transition_type : u8) -> * mut dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError { transition_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_get_transition_type < > (obj : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> u8 { (* obj) . transition_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError_set_transition_type < > (obj : * const dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> u8 { (* obj) . transition_type } } pub mod missing_state_transition_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingStateTransitionTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) -> dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError > for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError) -> * const dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { }) } } impl Drop for dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError_ctor < > () -> * mut dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) { ferment :: unbox_any (ffi) ; } } pub mod state_transition_max_size_exceeded_error { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionMaxSizeExceededError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { pub actual_size_bytes : u64 , pub max_size_bytes : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError { actual_size_bytes : ffi_ref . actual_size_bytes , max_size_bytes : ffi_ref . max_size_bytes } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError > for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError) -> * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { actual_size_bytes : obj . actual_size_bytes , max_size_bytes : obj . max_size_bytes }) } } impl Drop for dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_ctor < > (actual_size_bytes : u64 , max_size_bytes : u64) -> * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { ferment :: boxed (dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError { actual_size_bytes , max_size_bytes }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_destroy < > (ffi : * mut dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_get_actual_size_bytes < > (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_get_max_size_bytes < > (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_set_actual_size_bytes < > (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . actual_size_bytes } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError_set_max_size_bytes < > (obj : * const dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> u64 { (* obj) . max_size_bytes } } } pub mod incompatible_protocol_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IncompatibleProtocolVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { pub parsed_protocol_version : u32 , pub minimal_protocol_version : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError { parsed_protocol_version : ffi_ref . parsed_protocol_version , minimal_protocol_version : ffi_ref . minimal_protocol_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError > for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError) -> * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { parsed_protocol_version : obj . parsed_protocol_version , minimal_protocol_version : obj . minimal_protocol_version }) } } impl Drop for dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_ctor < > (parsed_protocol_version : u32 , minimal_protocol_version : u32) -> * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { ferment :: boxed (dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError { parsed_protocol_version , minimal_protocol_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_get_parsed_protocol_version < > (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_get_minimal_protocol_version < > (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . minimal_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_set_parsed_protocol_version < > (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . parsed_protocol_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError_set_minimal_protocol_version < > (obj : * const dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> u32 { (* obj) . minimal_protocol_version } } pub mod basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BasicError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_consensus_basic_basic_error_BasicError { ProtocolVersionParsingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) , VersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError) , ContractError (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) , UnknownSecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) , UnknownStorageKeyRequirementsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) , UnknownTransferableTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) , UnknownTradeModeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) , UnknownDocumentCreationRestrictionModeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) , SerializedObjectParsingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) , UnsupportedProtocolVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) , UnsupportedVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) , IncompatibleProtocolVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) , # [cfg (feature = "json-schema-validation")] JsonSchemaCompilationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) , # [cfg (feature = "json-schema-validation")] JsonSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) , InvalidIdentifierError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) , ValueError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError) , DataContractMaxDepthExceedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) , DuplicateIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) , IncompatibleRe2PatternError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) , InvalidCompoundIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) , InvalidDataContractIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) , InvalidIndexedPropertyConstraintError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) , InvalidIndexPropertyTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) , # [cfg (feature = "json-schema-validation")] InvalidJsonSchemaRefError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) , SystemPropertyIndexAlreadyPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) , UndefinedIndexPropertyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) , UniqueIndicesLimitReachedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) , DuplicateIndexNameError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) , InvalidDataContractVersionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) , IncompatibleDataContractSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) , DataContractImmutablePropertiesUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) , DataContractUniqueIndicesChangedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) , DataContractInvalidIndexDefinitionUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) , DataContractHaveNewUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) , DataContractNotPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) , DocumentCreationNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) , DataContractBoundsNotPresentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) , DuplicateDocumentTransitionsWithIdsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) , DuplicateDocumentTransitionsWithIndicesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) , NonceOutOfBoundsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) , InconsistentCompoundIndexDataError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) , InvalidDocumentTransitionActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) , InvalidDocumentTransitionIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) , MissingPositionsInDocumentTypePropertiesError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) , MissingDataContractIdBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) , MissingDocumentTransitionActionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) , MissingDocumentTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) , MissingDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) , MaxDocumentsTransitionsExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) , DuplicatedIdentityPublicKeyBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) , DuplicatedIdentityPublicKeyIdBasicError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) , DisablingKeyIdAlsoBeingAddedInSameTransitionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) , IdentityAssetLockProofLockedTransactionMismatchError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) , IdentityAssetLockTransactionIsNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) , IdentityAssetLockTransactionOutPointAlreadyConsumedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) , IdentityAssetLockTransactionOutPointNotEnoughBalanceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) , IdentityAssetLockStateTransitionReplayError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) , IdentityAssetLockTransactionOutputNotFoundError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) , InvalidAssetLockProofCoreChainHeightError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) , InvalidIdentityAssetLockProofChainLockValidationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) , InvalidAssetLockProofTransactionHeightError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) , InvalidAssetLockTransactionOutputReturnSizeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) , InvalidIdentityAssetLockTransactionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) , InvalidIdentityAssetLockTransactionOutputError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) , InvalidIdentityPublicKeyDataError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) , InvalidInstantAssetLockProofError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) , InvalidInstantAssetLockProofSignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) , MissingMasterPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) , TooManyMasterPublicKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) , MasterPublicKeyUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) , InvalidDocumentTypeRequiredSecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) , InvalidIdentityPublicKeySecurityLevelError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) , InvalidIdentityKeySignatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) , InvalidIdentityCreditTransferAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) , InvalidIdentityCreditWithdrawalTransitionOutputScriptError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) , WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) , InvalidIdentityCreditWithdrawalTransitionCoreFeeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) , InvalidIdentityCreditWithdrawalTransitionAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) , InvalidIdentityUpdateTransitionEmptyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) , InvalidIdentityUpdateTransitionDisableKeysError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) , NotImplementedIdentityCreditWithdrawalTransitionPoolingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) , InvalidStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) , MissingStateTransitionTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) , DocumentFieldMaxSizeExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) , StateTransitionMaxSizeExceededError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) , DocumentTransitionsAreAbsentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) , IdentityCreditTransferToSelfError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) , InvalidDocumentTypeNameError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) , IncompatibleDocumentTypeSchemaError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) , ContestedUniqueIndexOnMutableDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) , ContestedUniqueIndexWithUniqueIndexError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) , OverflowError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError) , UnsupportedFeatureError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) , ContestedDocumentsTemporarilyNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) , DataContractTokenConfigurationUpdateError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) , NonContiguousContractTokenPositionsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) , NonContiguousContractGroupPositionsError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) , InvalidTokenBaseSupplyError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) , InvalidTokenIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) , InvalidTokenAmountError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) , InvalidTokenPositionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) , InvalidTokenConfigUpdateNoChangeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) , InvalidTokenDistributionFunctionDivideByZeroError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) , InvalidTokenDistributionFunctionInvalidParameterError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) , InvalidTokenDistributionFunctionInvalidParameterTupleError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) , InvalidTokenDistributionFunctionIncoherenceError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) , TokenTransferToOurselfError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) , InvalidTokenNoteTooBigError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) , ContractHasNoTokensError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) , GroupPositionDoesNotExistError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) , InvalidActionIdError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) , DestinationIdentityForTokenMintingNotSetError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) , ChoosingTokenMintRecipientNotAllowedError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) , GroupActionNotAllowedOnTransitionError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) , GroupExceedsMaxMembersError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) , GroupMemberHasPowerOfZeroError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) , GroupMemberHasPowerOverLimitError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) , GroupTotalPowerLessThanRequiredError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) , GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) , MissingDefaultLocalizationError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_basic_error_BasicError) -> dpp :: errors :: consensus :: basic :: basic_error :: BasicError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError >> :: ffi_from (* o_0)) , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError >> :: ffi_from (* o_0)) , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: value_error :: ValueError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError >> :: ffi_from (* o_0)) , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError >> :: ffi_from (* o_0)) , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError > for dpp_errors_consensus_basic_basic_error_BasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: basic_error :: BasicError) -> * const dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (match obj { dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ProtocolVersionParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: ProtocolVersionParsingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: VersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: version_error :: VersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (< crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: UnknownSecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownStorageKeyRequirementsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: UnknownStorageKeyRequirementsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTransferableTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: UnknownTransferableTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownTradeModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: UnknownTradeModeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: UnknownDocumentCreationRestrictionModeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SerializedObjectParsingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: SerializedObjectParsingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: UnsupportedProtocolVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleProtocolVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: IncompatibleProtocolVersionError >> :: ffi_to (o_0)) , # [cfg (feature = "json-schema-validation")] dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaCompilationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: JsonSchemaCompilationError >> :: ffi_to (o_0)) , # [cfg (feature = "json-schema-validation")] dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: JsonSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: JsonSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentifierError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: invalid_identifier_error :: InvalidIdentifierError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ValueError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: value_error :: ValueError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractMaxDepthExceedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: DataContractMaxDepthExceedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: DuplicateIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleRe2PatternError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: IncompatibleRe2PatternError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidCompoundIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: InvalidCompoundIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: InvalidDataContractIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexedPropertyConstraintError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: InvalidIndexedPropertyConstraintError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIndexPropertyTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: InvalidIndexPropertyTypeError >> :: ffi_to (o_0)) , # [cfg (feature = "json-schema-validation")] dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidJsonSchemaRefError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: InvalidJsonSchemaRefError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: SystemPropertyIndexAlreadyPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UndefinedIndexPropertyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: UndefinedIndexPropertyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UniqueIndicesLimitReachedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: UniqueIndicesLimitReachedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateIndexNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: DuplicateIndexNameError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDataContractVersionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: InvalidDataContractVersionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDataContractSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: IncompatibleDataContractSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: DataContractImmutablePropertiesUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractUniqueIndicesChangedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: DataContractUniqueIndicesChangedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: DataContractInvalidIndexDefinitionUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractHaveNewUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: DataContractHaveNewUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: DataContractNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentCreationNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: DocumentCreationNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractBoundsNotPresentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: DuplicateDocumentTransitionsWithIdsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: DuplicateDocumentTransitionsWithIndicesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonceOutOfBoundsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: NonceOutOfBoundsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InconsistentCompoundIndexDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: InconsistentCompoundIndexDataError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: InvalidDocumentTransitionActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTransitionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: InvalidDocumentTransitionIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: MissingPositionsInDocumentTypePropertiesError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDataContractIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: MissingDataContractIdBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionActionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: MissingDocumentTransitionActionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: MissingDocumentTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: MissingDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MaxDocumentsTransitionsExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: MaxDocumentsTransitionsExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeyDataError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TooManyMasterPublicKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MasterPublicKeyUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: MasterPublicKeyUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: InvalidDocumentTypeRequiredSecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityKeySignatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: InvalidStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingStateTransitionTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: MissingStateTransitionTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentFieldMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: DocumentFieldMaxSizeExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: StateTransitionMaxSizeExceededError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: StateTransitionMaxSizeExceededError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DocumentTransitionsAreAbsentError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: DocumentTransitionsAreAbsentError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IdentityCreditTransferToSelfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidDocumentTypeNameError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: InvalidDocumentTypeNameError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: IncompatibleDocumentTypeSchemaError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: ContestedUniqueIndexOnMutableDocumentTypeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: ContestedUniqueIndexWithUniqueIndexError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: OverflowError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: UnsupportedFeatureError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_feature_error :: UnsupportedFeatureError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: ContestedDocumentsTemporarilyNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DataContractTokenConfigurationUpdateError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: DataContractTokenConfigurationUpdateError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractTokenPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: NonContiguousContractTokenPositionsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: NonContiguousContractGroupPositionsError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: NonContiguousContractGroupPositionsError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenBaseSupplyError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: InvalidTokenBaseSupplyError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenAmountError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenPositionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: InvalidTokenDistributionFunctionDivideByZeroError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: InvalidTokenDistributionFunctionInvalidParameterError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: InvalidTokenDistributionFunctionInvalidParameterTupleError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: InvalidTokenDistributionFunctionIncoherenceError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: TokenTransferToOurselfError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidTokenNoteTooBigError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ContractHasNoTokensError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupPositionDoesNotExistError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: GroupPositionDoesNotExistError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: InvalidActionIdError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: GroupActionNotAllowedOnTransitionError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupExceedsMaxMembersError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: GroupExceedsMaxMembersError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOfZeroError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: GroupMemberHasPowerOfZeroError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupMemberHasPowerOverLimitError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: GroupMemberHasPowerOverLimitError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: GroupTotalPowerLessThanRequiredError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError >> :: ffi_to (o_0)) , dpp :: errors :: consensus :: basic :: basic_error :: BasicError :: MissingDefaultLocalizationError (o_0) => dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_consensus_basic_basic_error_BasicError { fn drop (& mut self) { unsafe { match self { dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (feature = "json-schema-validation")] dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ProtocolVersionParsingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: protocol_version_parsing_error :: dpp_errors_consensus_basic_decode_protocol_version_parsing_error_ProtocolVersionParsingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ProtocolVersionParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_VersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: version_error :: dpp_errors_consensus_basic_decode_version_error_VersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: VersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContractError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: contract :: dpp_data_contract_errors_contract_DataContractError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContractError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownSecurityLevelError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_security_level_error :: dpp_errors_consensus_basic_data_contract_unknown_security_level_error_UnknownSecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownSecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownStorageKeyRequirementsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_storage_key_requirements_error :: dpp_errors_consensus_basic_data_contract_unknown_storage_key_requirements_error_UnknownStorageKeyRequirementsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownStorageKeyRequirementsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownTransferableTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_transferable_type_error :: dpp_errors_consensus_basic_data_contract_unknown_transferable_type_error_UnknownTransferableTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTransferableTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownTradeModeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_trade_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_trade_mode_error_UnknownTradeModeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownTradeModeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnknownDocumentCreationRestrictionModeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unknown_document_creation_restriction_mode_error :: dpp_errors_consensus_basic_data_contract_unknown_document_creation_restriction_mode_error_UnknownDocumentCreationRestrictionModeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnknownDocumentCreationRestrictionModeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_SerializedObjectParsingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: serialized_object_parsing_error :: dpp_errors_consensus_basic_decode_serialized_object_parsing_error_SerializedObjectParsingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: SerializedObjectParsingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedProtocolVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_protocol_version_error :: dpp_errors_consensus_basic_unsupported_protocol_version_error_UnsupportedProtocolVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedProtocolVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_version_error :: dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleProtocolVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: incompatible_protocol_version_error :: dpp_errors_consensus_basic_incompatible_protocol_version_error_IncompatibleProtocolVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleProtocolVersionError (o_o_0)) } # [cfg (feature = "json-schema-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_JsonSchemaCompilationError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_compilation_error :: dpp_errors_consensus_basic_json_schema_compilation_error_JsonSchemaCompilationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaCompilationError (o_o_0)) } # [cfg (feature = "json-schema-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_JsonSchemaError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: json_schema_error :: json_schema_error :: dpp_errors_consensus_basic_json_schema_error_json_schema_error_JsonSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: JsonSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentifierError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: invalid_identifier_error :: dpp_errors_consensus_basic_invalid_identifier_error_InvalidIdentifierError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentifierError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ValueError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: value_error :: dpp_errors_consensus_basic_value_error_ValueError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ValueError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractMaxDepthExceedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_max_depth_exceed_error :: dpp_errors_consensus_basic_data_contract_data_contract_max_depth_exceed_error_DataContractMaxDepthExceedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractMaxDepthExceedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateIndexError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_error_DuplicateIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleRe2PatternError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_re2_pattern_error :: dpp_errors_consensus_basic_data_contract_incompatible_re2_pattern_error_IncompatibleRe2PatternError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleRe2PatternError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidCompoundIndexError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_compound_index_error :: dpp_errors_consensus_basic_data_contract_invalid_compound_index_error_InvalidCompoundIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidCompoundIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDataContractIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_id_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_id_error_InvalidDataContractIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIndexedPropertyConstraintError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_indexed_property_constraint_error :: dpp_errors_consensus_basic_data_contract_invalid_indexed_property_constraint_error_InvalidIndexedPropertyConstraintError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexedPropertyConstraintError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIndexPropertyTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_index_property_type_error :: dpp_errors_consensus_basic_data_contract_invalid_index_property_type_error_InvalidIndexPropertyTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIndexPropertyTypeError (o_o_0)) } # [cfg (feature = "json-schema-validation")] # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidJsonSchemaRefError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_json_schema_ref_error :: dpp_errors_consensus_basic_data_contract_invalid_json_schema_ref_error_InvalidJsonSchemaRefError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidJsonSchemaRefError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_SystemPropertyIndexAlreadyPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: system_property_index_already_present_error :: dpp_errors_consensus_basic_data_contract_system_property_index_already_present_error_SystemPropertyIndexAlreadyPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: SystemPropertyIndexAlreadyPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UndefinedIndexPropertyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: undefined_index_property_error :: dpp_errors_consensus_basic_data_contract_undefined_index_property_error_UndefinedIndexPropertyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UndefinedIndexPropertyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UniqueIndicesLimitReachedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: unique_indices_limit_reached_error :: dpp_errors_consensus_basic_data_contract_unique_indices_limit_reached_error_UniqueIndicesLimitReachedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UniqueIndicesLimitReachedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateIndexNameError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: duplicate_index_name_error :: dpp_errors_consensus_basic_data_contract_duplicate_index_name_error_DuplicateIndexNameError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateIndexNameError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDataContractVersionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_data_contract_version_error :: dpp_errors_consensus_basic_data_contract_invalid_data_contract_version_error_InvalidDataContractVersionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDataContractVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleDataContractSchemaError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_data_contract_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_data_contract_schema_error_IncompatibleDataContractSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDataContractSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractImmutablePropertiesUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_immutable_properties_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_immutable_properties_update_error_DataContractImmutablePropertiesUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractImmutablePropertiesUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractUniqueIndicesChangedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_unique_indices_changed_error :: dpp_errors_consensus_basic_data_contract_data_contract_unique_indices_changed_error_DataContractUniqueIndicesChangedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractUniqueIndicesChangedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractInvalidIndexDefinitionUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_invalid_index_definition_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_invalid_index_definition_update_error_DataContractInvalidIndexDefinitionUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractInvalidIndexDefinitionUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractHaveNewUniqueIndexError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_have_new_unique_index_error :: dpp_errors_consensus_basic_data_contract_data_contract_have_new_unique_index_error_DataContractHaveNewUniqueIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractHaveNewUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractNotPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: data_contract_not_present_error :: dpp_errors_consensus_basic_document_data_contract_not_present_error_DataContractNotPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentCreationNotAllowedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_creation_not_allowed_error :: dpp_errors_consensus_basic_document_document_creation_not_allowed_error_DocumentCreationNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentCreationNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractBoundsNotPresentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractBoundsNotPresentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateDocumentTransitionsWithIdsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_ids_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_ids_error_DuplicateDocumentTransitionsWithIdsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIdsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicateDocumentTransitionsWithIndicesError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: duplicate_document_transitions_with_indices_error :: dpp_errors_consensus_basic_document_duplicate_document_transitions_with_indices_error_DuplicateDocumentTransitionsWithIndicesError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicateDocumentTransitionsWithIndicesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonceOutOfBoundsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: identity_contract_nonce_out_of_bounds_error :: dpp_errors_consensus_basic_document_identity_contract_nonce_out_of_bounds_error_NonceOutOfBoundsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonceOutOfBoundsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InconsistentCompoundIndexDataError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: inconsistent_compound_index_data_error :: dpp_errors_consensus_basic_document_inconsistent_compound_index_data_error_InconsistentCompoundIndexDataError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InconsistentCompoundIndexDataError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTransitionActionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_action_error :: dpp_errors_consensus_basic_document_invalid_document_transition_action_error_InvalidDocumentTransitionActionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTransitionIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_transition_id_error :: dpp_errors_consensus_basic_document_invalid_document_transition_id_error_InvalidDocumentTransitionIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTransitionIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingPositionsInDocumentTypePropertiesError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_positions_in_document_type_properties_error :: dpp_errors_consensus_basic_document_missing_positions_in_document_type_properties_error_MissingPositionsInDocumentTypePropertiesError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingPositionsInDocumentTypePropertiesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDataContractIdBasicError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_data_contract_id_basic_error :: dpp_errors_consensus_basic_document_missing_data_contract_id_basic_error_MissingDataContractIdBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDataContractIdBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTransitionActionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_action_error :: dpp_errors_consensus_basic_document_missing_document_transition_action_error_MissingDocumentTransitionActionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTransitionTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_transition_type_error :: dpp_errors_consensus_basic_document_missing_document_transition_type_error_MissingDocumentTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDocumentTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: missing_document_type_error :: dpp_errors_consensus_basic_document_missing_document_type_error_MissingDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MaxDocumentsTransitionsExceededError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: max_documents_transitions_exceeded_error :: dpp_errors_consensus_basic_document_max_documents_transitions_exceeded_error_MaxDocumentsTransitionsExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MaxDocumentsTransitionsExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicatedIdentityPublicKeyBasicError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DuplicatedIdentityPublicKeyIdBasicError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DuplicatedIdentityPublicKeyIdBasicError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DisablingKeyIdAlsoBeingAddedInSameTransitionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DisablingKeyIdAlsoBeingAddedInSameTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockProofLockedTransactionMismatchError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockProofLockedTransactionMismatchError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionIsNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionIsNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutPointAlreadyConsumedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointAlreadyConsumedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockStateTransitionReplayError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockStateTransitionReplayError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityAssetLockTransactionOutputNotFoundError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityAssetLockTransactionOutputNotFoundError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockProofCoreChainHeightError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofCoreChainHeightError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockProofChainLockValidationError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockProofChainLockValidationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockProofTransactionHeightError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockProofTransactionHeightError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidAssetLockTransactionOutputReturnSizeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidAssetLockTransactionOutputReturnSizeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockTransactionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityAssetLockTransactionOutputError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityAssetLockTransactionOutputError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityPublicKeyDataError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeyDataError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidInstantAssetLockProofError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidInstantAssetLockProofSignatureError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidInstantAssetLockProofSignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingMasterPublicKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingMasterPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TooManyMasterPublicKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TooManyMasterPublicKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MasterPublicKeyUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: state :: identity :: master_public_key_update_error :: dpp_errors_consensus_state_identity_master_public_key_update_error_MasterPublicKeyUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MasterPublicKeyUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeRequiredSecurityLevelError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_required_security_level :: dpp_errors_consensus_basic_data_contract_invalid_document_type_required_security_level_InvalidDocumentTypeRequiredSecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeRequiredSecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityPublicKeySecurityLevelError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityPublicKeySecurityLevelError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityKeySignatureError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityKeySignatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditTransferAmountError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditTransferAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityCreditWithdrawalTransitionAmountError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityCreditWithdrawalTransitionAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityUpdateTransitionEmptyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionEmptyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidIdentityUpdateTransitionDisableKeysError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidIdentityUpdateTransitionDisableKeysError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidStateTransitionTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: invalid_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_invalid_state_transition_type_error_InvalidStateTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingStateTransitionTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: missing_state_transition_type_error :: dpp_errors_consensus_basic_state_transition_missing_state_transition_type_error_MissingStateTransitionTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingStateTransitionTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentFieldMaxSizeExceededError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_field_max_size_exceeded_error :: dpp_errors_consensus_basic_document_document_field_max_size_exceeded_error_DocumentFieldMaxSizeExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentFieldMaxSizeExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_StateTransitionMaxSizeExceededError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: state_transition :: state_transition_max_size_exceeded_error :: dpp_errors_consensus_basic_state_transition_state_transition_max_size_exceeded_error_StateTransitionMaxSizeExceededError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: StateTransitionMaxSizeExceededError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DocumentTransitionsAreAbsentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: document_transitions_are_absent_error :: dpp_errors_consensus_basic_document_document_transitions_are_absent_error_DocumentTransitionsAreAbsentError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DocumentTransitionsAreAbsentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IdentityCreditTransferToSelfError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IdentityCreditTransferToSelfError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidDocumentTypeNameError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_document_type_name_error :: dpp_errors_consensus_basic_data_contract_invalid_document_type_name_error_InvalidDocumentTypeNameError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidDocumentTypeNameError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_IncompatibleDocumentTypeSchemaError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: incompatible_document_type_schema_error :: dpp_errors_consensus_basic_data_contract_incompatible_document_type_schema_error_IncompatibleDocumentTypeSchemaError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: IncompatibleDocumentTypeSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedUniqueIndexOnMutableDocumentTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_on_mutable_document_type_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_on_mutable_document_type_error_ContestedUniqueIndexOnMutableDocumentTypeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexOnMutableDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedUniqueIndexWithUniqueIndexError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: contested_unique_index_with_unique_index_error :: dpp_errors_consensus_basic_data_contract_contested_unique_index_with_unique_index_error_ContestedUniqueIndexWithUniqueIndexError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedUniqueIndexWithUniqueIndexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_OverflowError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: overflow_error :: dpp_errors_consensus_basic_overflow_error_OverflowError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: OverflowError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_UnsupportedFeatureError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: unsupported_feature_error :: dpp_errors_consensus_basic_unsupported_feature_error_UnsupportedFeatureError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: UnsupportedFeatureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContestedDocumentsTemporarilyNotAllowedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: contested_documents_temporarily_not_allowed_error :: dpp_errors_consensus_basic_document_contested_documents_temporarily_not_allowed_error_ContestedDocumentsTemporarilyNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContestedDocumentsTemporarilyNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DataContractTokenConfigurationUpdateError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: data_contract_token_configuration_update_error :: dpp_errors_consensus_basic_data_contract_data_contract_token_configuration_update_error_DataContractTokenConfigurationUpdateError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DataContractTokenConfigurationUpdateError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonContiguousContractTokenPositionsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_token_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_token_positions_error_NonContiguousContractTokenPositionsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractTokenPositionsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_NonContiguousContractGroupPositionsError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: non_contiguous_contract_group_positions_error :: dpp_errors_consensus_basic_data_contract_non_contiguous_contract_group_positions_error_NonContiguousContractGroupPositionsError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: NonContiguousContractGroupPositionsError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenBaseSupplyError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_base_supply_error :: dpp_errors_consensus_basic_data_contract_invalid_token_base_supply_error_InvalidTokenBaseSupplyError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenBaseSupplyError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenAmountError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenAmountError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenPositionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenPositionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenConfigUpdateNoChangeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenConfigUpdateNoChangeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionDivideByZeroError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_divide_by_zero_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_divide_by_zero_error_InvalidTokenDistributionFunctionDivideByZeroError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionDivideByZeroError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionInvalidParameterError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_error_InvalidTokenDistributionFunctionInvalidParameterError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionInvalidParameterTupleError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_invalid_parameter_tuple_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_invalid_parameter_tuple_error_InvalidTokenDistributionFunctionInvalidParameterTupleError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionInvalidParameterTupleError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenDistributionFunctionIncoherenceError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: invalid_token_distribution_function_incoherence_error :: dpp_errors_consensus_basic_data_contract_invalid_token_distribution_function_incoherence_error_InvalidTokenDistributionFunctionIncoherenceError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenDistributionFunctionIncoherenceError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_TokenTransferToOurselfError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: TokenTransferToOurselfError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidTokenNoteTooBigError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidTokenNoteTooBigError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ContractHasNoTokensError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ContractHasNoTokensError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupPositionDoesNotExistError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_position_does_not_exist_error :: dpp_errors_consensus_basic_data_contract_group_position_does_not_exist_error_GroupPositionDoesNotExistError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupPositionDoesNotExistError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_InvalidActionIdError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: InvalidActionIdError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_DestinationIdentityForTokenMintingNotSetError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: DestinationIdentityForTokenMintingNotSetError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_ChoosingTokenMintRecipientNotAllowedError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: ChoosingTokenMintRecipientNotAllowedError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupActionNotAllowedOnTransitionError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: group :: group_action_not_allowed_on_transition_error :: dpp_errors_consensus_basic_group_group_action_not_allowed_on_transition_error_GroupActionNotAllowedOnTransitionError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupActionNotAllowedOnTransitionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupExceedsMaxMembersError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_exceeds_max_members_error :: dpp_errors_consensus_basic_data_contract_group_exceeds_max_members_error_GroupExceedsMaxMembersError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupExceedsMaxMembersError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupMemberHasPowerOfZeroError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_of_zero_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_of_zero_error_GroupMemberHasPowerOfZeroError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOfZeroError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupMemberHasPowerOverLimitError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_member_has_power_over_limit_error :: dpp_errors_consensus_basic_data_contract_group_member_has_power_over_limit_error_GroupMemberHasPowerOverLimitError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupMemberHasPowerOverLimitError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupTotalPowerLessThanRequiredError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_total_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_total_power_has_less_than_required_power_error_GroupTotalPowerLessThanRequiredError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupTotalPowerLessThanRequiredError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: group_non_unilateral_member_power_has_less_than_required_power_error :: dpp_errors_consensus_basic_data_contract_group_non_unilateral_member_power_has_less_than_required_power_error_GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: GroupNonUnilateralMemberPowerHasLessThanRequiredPowerError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_MissingDefaultLocalizationError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) -> * mut dpp_errors_consensus_basic_basic_error_BasicError { ferment :: boxed (dpp_errors_consensus_basic_basic_error_BasicError :: MissingDefaultLocalizationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_basic_error_BasicError_destroy < > (ffi : * mut dpp_errors_consensus_basic_basic_error_BasicError) { ferment :: unbox_any (ffi) ; } } pub mod token { use crate as example_nested ; pub mod invalid_token_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { pub max_token_amount : u64 , pub token_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError { max_token_amount : ffi_ref . max_token_amount , token_amount : ffi_ref . token_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError > for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_amount_error :: InvalidTokenAmountError) -> * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { max_token_amount : obj . max_token_amount , token_amount : obj . token_amount }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_ctor < > (max_token_amount : u64 , token_amount : u64) -> * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError { max_token_amount , token_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_get_max_token_amount < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . max_token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_get_token_amount < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_set_max_token_amount < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . max_token_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError_set_token_amount < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_amount_error_InvalidTokenAmountError) -> u64 { (* obj) . token_amount } } pub mod invalid_token_config_update_no_change_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenConfigUpdateNoChangeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError > for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_config_update_no_change_error :: InvalidTokenConfigUpdateNoChangeError) -> * const dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError_ctor < > () -> * mut dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_config_update_no_change_error_InvalidTokenConfigUpdateNoChangeError) { ferment :: unbox_any (ffi) ; } } pub mod choosing_token_mint_recipient_not_allowed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ChoosingTokenMintRecipientNotAllowedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError > for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: choosing_token_mint_recipient_not_allowed_error :: ChoosingTokenMintRecipientNotAllowedError) -> * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { ferment :: boxed (dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_get_token_id < > (obj : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError_set_token_id < > (obj : * const dpp_errors_consensus_basic_token_choosing_token_mint_recipient_not_allowed_error_ChoosingTokenMintRecipientNotAllowedError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } } pub mod invalid_token_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { pub expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError > for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_id_error :: InvalidTokenIdError) -> * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { expected_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_token_id) , invalid_token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_token_id) ; ferment :: unbox_any (ffi_ref . invalid_token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_ctor < > (expected_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError { expected_token_id , invalid_token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_get_expected_token_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_get_invalid_token_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_set_expected_token_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError_set_invalid_token_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_id_error_InvalidTokenIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_token_id } } pub mod missing_default_localization { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingDefaultLocalizationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) -> dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError > for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: missing_default_localization :: MissingDefaultLocalizationError) -> * const dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { ferment :: boxed (dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { }) } } impl Drop for dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError_ctor < > () -> * mut dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { ferment :: boxed (dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_missing_default_localization_MissingDefaultLocalizationError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_token_position_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenPositionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { pub max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (ffi_ref . invalid_token_position) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError > for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_position_error :: InvalidTokenPositionError) -> * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { max_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . max_token_position) , invalid_token_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition >> :: ffi_to (obj . invalid_token_position) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . max_token_position) ; ferment :: unbox_any (ffi_ref . invalid_token_position) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_ctor < > (max_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , invalid_token_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition) -> * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError { max_token_position , invalid_token_position }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_get_max_token_position < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . max_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_get_invalid_token_position < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . invalid_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_set_max_token_position < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . max_token_position } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError_set_invalid_token_position < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_position_error_InvalidTokenPositionError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition { (* obj) . invalid_token_position } } pub mod invalid_action_id_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidActionIdError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { pub expected_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub invalid_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . invalid_action_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError > for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_action_id_error :: InvalidActionIdError) -> * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { expected_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . expected_action_id) , invalid_action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . invalid_action_id) }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . expected_action_id) ; ferment :: unbox_any (ffi_ref . invalid_action_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_ctor < > (expected_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , invalid_action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError { expected_action_id , invalid_action_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_get_expected_action_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_get_invalid_action_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_set_expected_action_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . expected_action_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError_set_invalid_action_id < > (obj : * const dpp_errors_consensus_basic_token_invalid_action_id_error_InvalidActionIdError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . invalid_action_id } } pub mod invalid_token_note_too_big_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidTokenNoteTooBigError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { pub max_note_length : u32 , pub note_type : * mut std :: os :: raw :: c_char , pub note_length : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError { max_note_length : ffi_ref . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . note_type) , note_length : ffi_ref . note_length } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError > for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: invalid_token_note_too_big_error :: InvalidTokenNoteTooBigError) -> * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { max_note_length : obj . max_note_length , note_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . note_type) , note_length : obj . note_length }) } } impl Drop for dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . note_type) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_ctor < > (max_note_length : u32 , note_type : * mut std :: os :: raw :: c_char , note_length : u32) -> * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { ferment :: boxed (dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError { max_note_length , note_type , note_length }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_max_note_length < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . max_note_length } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_note_type < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> * mut std :: os :: raw :: c_char { (* obj) . note_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_get_note_length < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . note_length } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_max_note_length < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . max_note_length } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_note_type < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> * mut std :: os :: raw :: c_char { (* obj) . note_type } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError_set_note_length < > (obj : * const dpp_errors_consensus_basic_token_invalid_token_note_too_big_error_InvalidTokenNoteTooBigError) -> u32 { (* obj) . note_length } } pub mod contract_has_no_tokens_error { use crate as example_nested ; # [doc = "FFI-representation of the [`ContractHasNoTokensError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError > for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: contract_has_no_tokens_error :: ContractHasNoTokensError) -> * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { ferment :: boxed (dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) }) } } impl Drop for dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_ctor < > (contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { ferment :: boxed (dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError { contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_get_contract_id < > (obj : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError_set_contract_id < > (obj : * const dpp_errors_consensus_basic_token_contract_has_no_tokens_error_ContractHasNoTokensError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } } pub mod destination_identity_for_token_minting_not_set_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DestinationIdentityForTokenMintingNotSetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError > for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: destination_identity_for_token_minting_not_set_error :: DestinationIdentityForTokenMintingNotSetError) -> * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { ferment :: boxed (dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) }) } } impl Drop for dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { ferment :: boxed (dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError { token_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_get_token_id < > (obj : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError_set_token_id < > (obj : * const dpp_errors_consensus_basic_token_destination_identity_for_token_minting_not_set_error_DestinationIdentityForTokenMintingNotSetError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } } pub mod token_transfer_to_ourselves_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenTransferToOurselfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError > for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: token :: token_transfer_to_ourselves_error :: TokenTransferToOurselfError) -> * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { ferment :: boxed (dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_ctor < > (token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { ferment :: boxed (dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError { token_id , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_destroy < > (ffi : * mut dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_get_token_id < > (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_get_identity_id < > (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_set_token_id < > (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError_set_identity_id < > (obj : * const dpp_errors_consensus_basic_token_token_transfer_to_ourselves_error_TokenTransferToOurselfError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } } pub mod identity { use crate as example_nested ; pub mod too_many_master_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`TooManyMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError > for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: too_many_master_public_key_error :: TooManyMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_too_many_master_public_key_error_TooManyMasterPublicKeyError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_identity_public_key_data_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyDataError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub validation_error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . validation_error) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_data_error :: InvalidIdentityPublicKeyDataError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) , validation_error : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . validation_error) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_string (ffi_ref . validation_error) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_ctor < > (public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , validation_error : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError { public_key_id , validation_error }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_get_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_get_validation_error < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut std :: os :: raw :: c_char { (* obj) . validation_error } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_set_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError_set_validation_error < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_data_error_InvalidIdentityPublicKeyDataError) -> * mut std :: os :: raw :: c_char { (* obj) . validation_error } } pub mod invalid_identity_asset_lock_proof_chain_lock_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockProofChainLockValidationError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub height_reported_not_locked : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , height_reported_not_locked : ffi_ref . height_reported_not_locked } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_proof_chain_lock_validation_error :: InvalidIdentityAssetLockProofChainLockValidationError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , height_reported_not_locked : obj . height_reported_not_locked }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_ctor < > (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , height_reported_not_locked : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError { transaction_id , height_reported_not_locked }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_get_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_get_height_reported_not_locked < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> u32 { (* obj) . height_reported_not_locked } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_set_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError_set_height_reported_not_locked < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_proof_chain_lock_validation_error_InvalidIdentityAssetLockProofChainLockValidationError) -> u32 { (* obj) . height_reported_not_locked } } pub mod invalid_asset_lock_transaction_output_return_size { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockTransactionOutputReturnSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_transaction_output_return_size :: InvalidAssetLockTransactionOutputReturnSizeError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_ctor < > (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_transaction_output_return_size_InvalidAssetLockTransactionOutputReturnSizeError) -> usize { (* obj) . output_index } } pub mod invalid_identity_update_transition_empty_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionEmptyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_empty_error :: InvalidIdentityUpdateTransitionEmptyError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_empty_error_InvalidIdentityUpdateTransitionEmptyError) { ferment :: unbox_any (ffi) ; } } pub mod duplicated_identity_public_key_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_basic_error :: DuplicatedIdentityPublicKeyBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_ctor < > (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_get_duplicated_ids < > (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError_set_duplicated_ids < > (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_basic_error_DuplicatedIdentityPublicKeyBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } } pub mod invalid_identity_asset_lock_transaction_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_error :: InvalidIdentityAssetLockTransactionError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_get_message < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError_set_message < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_error_InvalidIdentityAssetLockTransactionError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod identity_asset_lock_transaction_out_point_already_consumed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointAlreadyConsumedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_already_consumed_error :: IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_ctor < > (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError { transaction_id , output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_get_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_set_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_already_consumed_error_IdentityAssetLockTransactionOutPointAlreadyConsumedError) -> usize { (* obj) . output_index } } pub mod invalid_identity_asset_lock_transaction_output_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityAssetLockTransactionOutputError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError > for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_asset_lock_transaction_output_error :: InvalidIdentityAssetLockTransactionOutputError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_ctor < > (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_asset_lock_transaction_output_error_InvalidIdentityAssetLockTransactionOutputError) -> usize { (* obj) . output_index } } pub mod identity_asset_lock_transaction_is_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionIsNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { pub transaction_id : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_is_not_found_error :: IdentityAssetLockTransactionIsNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { transaction_id : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_ctor < > (transaction_id : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError { transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_get_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError_set_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_is_not_found_error_IdentityAssetLockTransactionIsNotFoundError) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . transaction_id } } pub mod invalid_identity_update_transition_disable_keys_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityUpdateTransitionDisableKeysError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError > for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_update_transition_disable_keys_error :: InvalidIdentityUpdateTransitionDisableKeysError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_update_transition_disable_keys_error_InvalidIdentityUpdateTransitionDisableKeysError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_identity_credit_withdrawal_transition_output_script_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionOutputScriptError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_output_script_error :: InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_ctor < > (output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError { output_script }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_get_output_script < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError_set_output_script < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_output_script_error_InvalidIdentityCreditWithdrawalTransitionOutputScriptError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } } pub mod invalid_identity_key_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityKeySignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError > for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_key_signature_error :: InvalidIdentityKeySignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_ctor < > (public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError { public_key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_get_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError_set_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_key_signature_error_InvalidIdentityKeySignatureError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } } pub mod invalid_identity_public_key_security_level_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeySecurityLevelError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { pub public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub allowed_security_levels : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . public_key_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . allowed_security_levels) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError > for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_public_key_security_level_error :: InvalidIdentityPublicKeySecurityLevelError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . public_key_id) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , allowed_security_levels : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . allowed_security_levels) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_id) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_string (ffi_ref . allowed_security_levels) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_ctor < > (public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , allowed_security_levels : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError { public_key_id , purpose , security_level , allowed_security_levels }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_purpose < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_security_level < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_get_allowed_security_levels < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . allowed_security_levels } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_public_key_id < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_purpose < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_security_level < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError_set_allowed_security_levels < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_public_key_security_level_error_InvalidIdentityPublicKeySecurityLevelError) -> * mut std :: os :: raw :: c_char { (* obj) . allowed_security_levels } } pub mod invalid_asset_lock_proof_transaction_height_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockProofTransactionHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { pub proof_core_chain_locked_height : u32 , pub transaction_height : * mut u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , transaction_height : ferment :: from_opt_primitive (ffi_ref . transaction_height) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_transaction_height_error :: InvalidAssetLockProofTransactionHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , transaction_height : ferment :: to_opt_primitive (obj . transaction_height) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: destroy_opt_primitive (ffi_ref . transaction_height) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_ctor < > (proof_core_chain_locked_height : u32 , transaction_height : * mut u32) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError { proof_core_chain_locked_height , transaction_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_get_proof_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_get_transaction_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> * mut u32 { (* obj) . transaction_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_set_proof_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError_set_transaction_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_transaction_height_error_InvalidAssetLockProofTransactionHeightError) -> * mut u32 { (* obj) . transaction_height } } pub mod disabling_key_id_also_being_added_in_same_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DisablingKeyIdAlsoBeingAddedInSameTransitionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { pub key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError > for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: disabling_key_id_also_being_added_in_same_transition_error :: DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { ferment :: boxed (dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_ctor < > (key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { ferment :: boxed (dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError { key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_get_key_id < > (obj : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError_set_key_id < > (obj : * const dpp_errors_consensus_basic_identity_disabling_key_id_also_being_added_in_same_transition_error_DisablingKeyIdAlsoBeingAddedInSameTransitionError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . key_id } } pub mod identity_asset_lock_transaction_out_point_not_enough_balance_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutPointNotEnoughBalanceError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize , pub initial_asset_lock_credits : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_left : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , pub credits_required : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . credits_required) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_out_point_not_enough_balance_error :: IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index , initial_asset_lock_credits : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . initial_asset_lock_credits) , credits_left : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_left) , credits_required : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . credits_required) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . initial_asset_lock_credits) ; ferment :: unbox_any (ffi_ref . credits_left) ; ferment :: unbox_any (ffi_ref . credits_required) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_ctor < > (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize , initial_asset_lock_credits : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , credits_left : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits , credits_required : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError { transaction_id , output_index , initial_asset_lock_credits , credits_left , credits_required }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_initial_asset_lock_credits < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . initial_asset_lock_credits } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_credits_left < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_left } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_get_credits_required < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_required } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_initial_asset_lock_credits < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . initial_asset_lock_credits } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_credits_left < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_left } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError_set_credits_required < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_out_point_not_enough_balance_error_IdentityAssetLockTransactionOutPointNotEnoughBalanceError) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . credits_required } } pub mod duplicated_identity_public_key_id_basic_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DuplicatedIdentityPublicKeyIdBasicError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { pub duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . duplicated_ids) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError > for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: duplicated_identity_public_key_id_basic_error :: DuplicatedIdentityPublicKeyIdBasicError) -> * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . duplicated_ids) }) } } impl Drop for dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . duplicated_ids) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_ctor < > (duplicated_ids : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { ferment :: boxed (dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError { duplicated_ids }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_get_duplicated_ids < > (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError_set_duplicated_ids < > (obj : * const dpp_errors_consensus_basic_identity_duplicated_identity_public_key_id_basic_error_DuplicatedIdentityPublicKeyIdBasicError) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . duplicated_ids } } pub mod invalid_identity_credit_withdrawal_transition_core_fee_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionCoreFeeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { pub core_fee_per_byte : u32 , pub min_core_fee_per_byte : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : ffi_ref . core_fee_per_byte , min_core_fee_per_byte : ffi_ref . min_core_fee_per_byte } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_core_fee_error :: InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte : obj . core_fee_per_byte , min_core_fee_per_byte : obj . min_core_fee_per_byte }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_ctor < > (core_fee_per_byte : u32 , min_core_fee_per_byte : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError { core_fee_per_byte , min_core_fee_per_byte }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_get_core_fee_per_byte < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_get_min_core_fee_per_byte < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . min_core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_set_core_fee_per_byte < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError_set_min_core_fee_per_byte < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_core_fee_error_InvalidIdentityCreditWithdrawalTransitionCoreFeeError) -> u32 { (* obj) . min_core_fee_per_byte } } pub mod invalid_instant_asset_lock_proof_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_error :: InvalidInstantAssetLockProofError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_get_message < > (obj : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError_set_message < > (obj : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_error_InvalidInstantAssetLockProofError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod withdrawal_output_script_not_allowed_when_signing_with_owner_key { use crate as example_nested ; # [doc = "FFI-representation of the [`WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . key_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError > for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: withdrawal_output_script_not_allowed_when_signing_with_owner_key :: WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . key_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . key_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_ctor < > (output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError { output_script , key_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_get_output_script < > (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_get_key_id < > (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . key_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_set_output_script < > (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError_set_key_id < > (obj : * const dpp_errors_consensus_basic_identity_withdrawal_output_script_not_allowed_when_signing_with_owner_key_WithdrawalOutputScriptNotAllowedWhenSigningWithOwnerKeyError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . key_id } } pub mod data_contract_bounds_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractBoundsNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError > for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: data_contract_bounds_not_present_error :: DataContractBoundsNotPresentError) -> * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { ferment :: boxed (dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_get_data_contract_id < > (obj : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError_set_data_contract_id < > (obj : * const dpp_errors_consensus_basic_identity_data_contract_bounds_not_present_error_DataContractBoundsNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod identity_asset_lock_transaction_output_not_found_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockTransactionOutputNotFoundError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { pub output_index : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError { output_index : ffi_ref . output_index } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError > for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_transaction_output_not_found_error :: IdentityAssetLockTransactionOutputNotFoundError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { output_index : obj . output_index }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_ctor < > (output_index : usize) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError { output_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_transaction_output_not_found_error_IdentityAssetLockTransactionOutputNotFoundError) -> usize { (* obj) . output_index } } pub mod invalid_identity_credit_transfer_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditTransferAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { pub amount : u64 , pub min_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_transfer_amount_error :: InvalidIdentityCreditTransferAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { amount : obj . amount , min_amount : obj . min_amount }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_ctor < > (amount : u64 , min_amount : u64) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError { amount , min_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_get_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_get_min_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . min_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_set_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError_set_min_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_transfer_amount_error_InvalidIdentityCreditTransferAmountError) -> u64 { (* obj) . min_amount } } pub mod invalid_identity_credit_withdrawal_transition_amount_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityCreditWithdrawalTransitionAmountError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { pub amount : u64 , pub min_amount : u64 , pub max_amount : u64 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError { amount : ffi_ref . amount , min_amount : ffi_ref . min_amount , max_amount : ffi_ref . max_amount } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError > for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_identity_credit_withdrawal_transition_amount_error :: InvalidIdentityCreditWithdrawalTransitionAmountError) -> * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { amount : obj . amount , min_amount : obj . min_amount , max_amount : obj . max_amount }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_ctor < > (amount : u64 , min_amount : u64 , max_amount : u64) -> * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError { amount , min_amount , max_amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_min_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . min_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_get_max_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . max_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_min_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . min_amount } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError_set_max_amount < > (obj : * const dpp_errors_consensus_basic_identity_invalid_identity_credit_withdrawal_transition_amount_error_InvalidIdentityCreditWithdrawalTransitionAmountError) -> u64 { (* obj) . max_amount } } pub mod identity_asset_lock_proof_locked_transaction_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockProofLockedTransactionMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { pub instant_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub asset_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . instant_lock_transaction_id) , asset_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . asset_lock_transaction_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError > for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_proof_locked_transaction_mismatch_error :: IdentityAssetLockProofLockedTransactionMismatchError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . instant_lock_transaction_id) , asset_lock_transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . asset_lock_transaction_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . instant_lock_transaction_id) ; ferment :: unbox_any (ffi_ref . asset_lock_transaction_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_ctor < > (instant_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , asset_lock_transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError { instant_lock_transaction_id , asset_lock_transaction_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_get_instant_lock_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . instant_lock_transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_get_asset_lock_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . asset_lock_transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_set_instant_lock_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . instant_lock_transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError_set_asset_lock_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_proof_locked_transaction_mismatch_error_IdentityAssetLockProofLockedTransactionMismatchError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . asset_lock_transaction_id } } pub mod invalid_asset_lock_proof_core_chain_height_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidAssetLockProofCoreChainHeightError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { pub proof_core_chain_locked_height : u32 , pub current_core_chain_locked_height : u32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : ffi_ref . proof_core_chain_locked_height , current_core_chain_locked_height : ffi_ref . current_core_chain_locked_height } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError > for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_asset_lock_proof_core_chain_height_error :: InvalidAssetLockProofCoreChainHeightError) -> * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height : obj . proof_core_chain_locked_height , current_core_chain_locked_height : obj . current_core_chain_locked_height }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_ctor < > (proof_core_chain_locked_height : u32 , current_core_chain_locked_height : u32) -> * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError { proof_core_chain_locked_height , current_core_chain_locked_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_get_proof_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_get_current_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . current_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_set_proof_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . proof_core_chain_locked_height } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError_set_current_core_chain_locked_height < > (obj : * const dpp_errors_consensus_basic_identity_invalid_asset_lock_proof_core_chain_height_error_InvalidAssetLockProofCoreChainHeightError) -> u32 { (* obj) . current_core_chain_locked_height } } pub mod missing_master_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`MissingMasterPublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) -> dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError > for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: missing_master_public_key_error :: MissingMasterPublicKeyError) -> * const dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { }) } } impl Drop for dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { ferment :: boxed (dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_missing_master_public_key_error_MissingMasterPublicKeyError) { ferment :: unbox_any (ffi) ; } } pub mod identity_credit_transfer_to_self_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditTransferToSelfError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) -> dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError > for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_credit_transfer_to_self_error :: IdentityCreditTransferToSelfError) -> * const dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_credit_transfer_to_self_error_IdentityCreditTransferToSelfError) { ferment :: unbox_any (ffi) ; } } pub mod not_implemented_identity_credit_withdrawal_transition_pooling_error { use crate as example_nested ; # [doc = "FFI-representation of the [`NotImplementedIdentityCreditWithdrawalTransitionPoolingError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pub pooling : u8 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : ffi_ref . pooling } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError > for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: not_implemented_identity_credit_withdrawal_transition_pooling_error :: NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { ferment :: boxed (dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling : obj . pooling }) } } impl Drop for dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_ctor < > (pooling : u8) -> * mut dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { ferment :: boxed (dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError { pooling }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_get_pooling < > (obj : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> u8 { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError_set_pooling < > (obj : * const dpp_errors_consensus_basic_identity_not_implemented_identity_credit_withdrawal_transition_pooling_error_NotImplementedIdentityCreditWithdrawalTransitionPoolingError) -> u8 { (* obj) . pooling } } pub mod invalid_instant_asset_lock_proof_signature_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidInstantAssetLockProofSignatureError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) -> dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError { } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError > for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: invalid_instant_asset_lock_proof_signature_error :: InvalidInstantAssetLockProofSignatureError) -> * const dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { }) } } impl Drop for dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError_ctor < > () -> * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { ferment :: boxed (dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_invalid_instant_asset_lock_proof_signature_error_InvalidInstantAssetLockProofSignatureError) { ferment :: unbox_any (ffi) ; } } pub mod identity_asset_lock_state_transition_replay_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityAssetLockStateTransitionReplayError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { pub transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub output_index : usize , pub state_transition_id : * mut crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . transaction_id) , output_index : ffi_ref . output_index , state_transition_id : < crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 as ferment :: FFIConversionFrom < platform_value :: types :: bytes_32 :: Bytes32 >> :: ffi_from (ffi_ref . state_transition_id) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError > for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: identity :: identity_asset_lock_state_transition_replay_error :: IdentityAssetLockStateTransitionReplayError) -> * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { transaction_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . transaction_id) , output_index : obj . output_index , state_transition_id : < crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 as ferment :: FFIConversionTo < platform_value :: types :: bytes_32 :: Bytes32 >> :: ffi_to (obj . state_transition_id) }) } } impl Drop for dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transaction_id) ; ; ferment :: unbox_any (ffi_ref . state_transition_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_ctor < > (transaction_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , output_index : usize , state_transition_id : * mut crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32) -> * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { ferment :: boxed (dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError { transaction_id , output_index , state_transition_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_destroy < > (ffi : * mut dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_get_state_transition_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 { (* obj) . state_transition_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_transaction_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . transaction_id } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_output_index < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> usize { (* obj) . output_index } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError_set_state_transition_id < > (obj : * const dpp_errors_consensus_basic_identity_identity_asset_lock_state_transition_replay_error_IdentityAssetLockStateTransitionReplayError) -> * mut crate :: fermented :: types :: platform_value :: types :: bytes_32 :: platform_value_types_bytes_32_Bytes32 { (* obj) . state_transition_id } } } pub mod overflow_error { use crate as example_nested ; # [doc = "FFI-representation of the [`OverflowError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_overflow_error_OverflowError { pub message : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . message) } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError > for dpp_errors_consensus_basic_overflow_error_OverflowError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: overflow_error :: OverflowError) -> * const dpp_errors_consensus_basic_overflow_error_OverflowError { ferment :: boxed (dpp_errors_consensus_basic_overflow_error_OverflowError { message : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . message) }) } } impl Drop for dpp_errors_consensus_basic_overflow_error_OverflowError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . message) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_ctor < > (message : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_consensus_basic_overflow_error_OverflowError { ferment :: boxed (dpp_errors_consensus_basic_overflow_error_OverflowError { message }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_destroy < > (ffi : * mut dpp_errors_consensus_basic_overflow_error_OverflowError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_get_message < > (obj : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> * mut std :: os :: raw :: c_char { (* obj) . message } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_overflow_error_OverflowError_set_message < > (obj : * const dpp_errors_consensus_basic_overflow_error_OverflowError) -> * mut std :: os :: raw :: c_char { (* obj) . message } } pub mod unsupported_version_error { use crate as example_nested ; # [doc = "FFI-representation of the [`UnsupportedVersionError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { pub received_version : u16 , pub min_version : u16 , pub max_version : u16 } impl ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_from_const (ffi : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { let ffi_ref = & * ffi ; dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError { received_version : ffi_ref . received_version , min_version : ffi_ref . min_version , max_version : ffi_ref . max_version } } } impl ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError > for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { unsafe fn ffi_to_const (obj : dpp :: errors :: consensus :: basic :: unsupported_version_error :: UnsupportedVersionError) -> * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { received_version : obj . received_version , min_version : obj . min_version , max_version : obj . max_version }) } } impl Drop for dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_ctor < > (received_version : u16 , min_version : u16 , max_version : u16) -> * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { ferment :: boxed (dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError { received_version , min_version , max_version }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_destroy < > (ffi : * mut dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_received_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . received_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_min_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . min_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_get_max_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . max_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_received_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . received_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_min_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . min_version } # [no_mangle] pub unsafe extern "C" fn dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError_set_max_version < > (obj : * const dpp_errors_consensus_basic_unsupported_version_error_UnsupportedVersionError) -> u16 { (* obj) . max_version } } } } pub mod dpp_init_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DashPlatformProtocolInitError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_errors_dpp_init_error_DashPlatformProtocolInitError { SchemaDeserializationError (* mut example_nested :: serde_json_Error) , InvalidSchemaError (* mut std :: os :: raw :: c_char) , UnknownVersionMismatch { method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion } } impl ferment :: FFIConversionFrom < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_from_const (ffi : * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError) -> dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError { let ffi_ref = & * ffi ; match ffi_ref { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (< example_nested :: serde_json_Error as ferment :: FFIConversionFrom < serde_json :: Error >> :: ffi_from (* o_0)) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (* o_0)))) , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_from (* known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (* received) } } } } impl ferment :: FFIConversionTo < dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError > for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { unsafe fn ffi_to_const (obj : dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError) -> * const dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (match obj { dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (< example_nested :: serde_json_Error as ferment :: FFIConversionTo < serde_json :: Error >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (o_0)) , dpp :: errors :: dpp_init_error :: DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (method) , known_versions : < crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < Vec < versioned_feature_core :: FeatureVersion > >> :: ffi_to (known_versions) , received : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (received) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_errors_dpp_init_error_DashPlatformProtocolInitError { fn drop (& mut self) { unsafe { match self { dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received } => { ferment :: unbox_string (* method) ; ; ferment :: unbox_any (* known_versions) ; ; ferment :: unbox_any (* received) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_SchemaDeserializationError_ctor (o_o_0 : * mut example_nested :: serde_json_Error) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: SchemaDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_InvalidSchemaError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: InvalidSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_UnknownVersionMismatch_ctor (method : * mut std :: os :: raw :: c_char , known_versions : * mut crate :: fermented :: generics :: Vec_versioned_feature_core_FeatureVersion , received : * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError { ferment :: boxed (dpp_errors_dpp_init_error_DashPlatformProtocolInitError :: UnknownVersionMismatch { method , known_versions , received }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_dpp_init_error_DashPlatformProtocolInitError_destroy < > (ffi : * mut dpp_errors_dpp_init_error_DashPlatformProtocolInitError) { ferment :: unbox_any (ffi) ; } } pub mod invalid_vector_size_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidVectorSizeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { pub expected_size : usize , pub actual_size : usize } impl ferment :: FFIConversionFrom < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_from_const (ffi : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { let ffi_ref = & * ffi ; dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError { expected_size : ffi_ref . expected_size , actual_size : ffi_ref . actual_size } } } impl ferment :: FFIConversionTo < dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError > for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { unsafe fn ffi_to_const (obj : dpp :: errors :: invalid_vector_size_error :: InvalidVectorSizeError) -> * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { ferment :: boxed (dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { expected_size : obj . expected_size , actual_size : obj . actual_size }) } } impl Drop for dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_ctor < > (expected_size : usize , actual_size : usize) -> * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { ferment :: boxed (dpp_errors_invalid_vector_size_error_InvalidVectorSizeError { expected_size , actual_size }) } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_destroy < > (ffi : * mut dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_get_expected_size < > (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . expected_size } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_get_actual_size < > (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . actual_size } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_set_expected_size < > (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . expected_size } # [no_mangle] pub unsafe extern "C" fn dpp_errors_invalid_vector_size_error_InvalidVectorSizeError_set_actual_size < > (obj : * const dpp_errors_invalid_vector_size_error_InvalidVectorSizeError) -> usize { (* obj) . actual_size } } } pub mod bls { use crate as example_nested ; } pub mod voting { use crate as example_nested ; pub mod vote_choices { use crate as example_nested ; pub mod resource_vote_choice { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVoteChoice`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { TowardsIdentity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Abstain , Lock } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) -> dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice > for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice) -> * const dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (match obj { dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: TowardsIdentity (o_0) => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Abstain => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain , dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice :: Lock => dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain => { } , dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_TowardsIdentity_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: TowardsIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_Abstain_ctor () -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Abstain { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_Lock_ctor () -> * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { ferment :: boxed (dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice :: Lock { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice_destroy < > (ffi : * mut dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) { ferment :: unbox_any (ffi) ; } } } pub mod vote_info_storage { use crate as example_nested ; pub mod contested_document_vote_poll_winner_info { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollWinnerInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { NoWinner , WonByIdentity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Locked } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: NoWinner => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_NoWinner_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: NoWinner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_WonByIdentity_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: WonByIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_Locked_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo :: Locked { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo_destroy < > (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) { ferment :: unbox_any (ffi) ; } } pub mod contested_document_vote_poll_stored_info { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { NotStarted , Awarded (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , Locked , Started (* mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: NotStarted => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Awarded (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Locked => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked , dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus :: Started (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (< crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked => { } , dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_NotStarted_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: NotStarted { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Awarded_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Awarded (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Locked_ctor () -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Locked { }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_Started_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus :: Started (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus_destroy < > (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoVoteEventV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub resource_vote_choices : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , pub start_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub finalization_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , pub winner : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_from (ffi_ref . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo >> :: ffi_from (ffi_ref . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_from (ffi_ref . winner) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices : < crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo as ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > >> :: ffi_to (obj . resource_vote_choices) , start_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . start_block) , finalization_block : < crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo as ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo >> :: ffi_to (obj . finalization_block) , winner : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: ContestedDocumentVotePollWinnerInfo >> :: ffi_to (obj . winner) }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choices) ; ferment :: unbox_any (ffi_ref . start_block) ; ferment :: unbox_any (ffi_ref . finalization_block) ; ferment :: unbox_any (ffi_ref . winner) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_ctor < > (resource_vote_choices : * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo , start_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , finalization_block : * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo , winner : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { resource_vote_choices , start_block , finalization_block , winner }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_destroy < > (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_resource_vote_choices < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { (* obj) . resource_vote_choices } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_start_block < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . start_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_finalization_block < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . finalization_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_get_winner < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { (* obj) . winner } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_resource_vote_choices < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { (* obj) . resource_vote_choices } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_start_block < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . start_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_finalization_block < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: block :: block_info :: dpp_block_block_info_BlockInfo { (* obj) . finalization_block } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_set_winner < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_winner_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_winner_info_ContestedDocumentVotePollWinnerInfo { (* obj) . winner } # [doc = "FFI-representation of the [`ContestedDocumentVotePollStoredInfoV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { pub finalized_events : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , pub vote_poll_status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus , pub locked_count : u16 } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { let ffi_ref = & * ffi ; dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_from (ffi_ref . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_from (ffi_ref . vote_poll_status) , locked_count : ffi_ref . locked_count } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { finalized_events : < crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 as ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > >> :: ffi_to (obj . finalized_events) , vote_poll_status : < crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStatus >> :: ffi_to (obj . vote_poll_status) , locked_count : obj . locked_count }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . finalized_events) ; ferment :: unbox_any (ffi_ref . vote_poll_status) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_ctor < > (finalized_events : * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 , vote_poll_status : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus , locked_count : u16) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 { finalized_events , vote_poll_status , locked_count }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_destroy < > (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_finalized_events < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { (* obj) . finalized_events } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_vote_poll_status < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . vote_poll_status } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_get_locked_count < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> u16 { (* obj) . locked_count } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_finalized_events < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: generics :: Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { (* obj) . finalized_events } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_vote_poll_status < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStatus { (* obj) . vote_poll_status } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0_set_locked_count < > (obj : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> u16 { (* obj) . locked_count } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedDocumentVotePollStoredInfo`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { V0 (* mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) -> dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionFrom < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo > for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo) -> * const dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { ferment :: boxed (match obj { dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: ContestedDocumentVotePollStoredInfo :: V0 (o_0) => dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (< crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0 as ferment :: FFIConversionTo < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoV0) -> * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo { ferment :: boxed (dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo_destroy < > (ffi : * mut dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_ContestedDocumentVotePollStoredInfo) { ferment :: unbox_any (ffi) ; } } } pub mod contender_structs { use crate as example_nested ; pub mod contender { use crate as example_nested ; } # [doc = "FFI-representation of the [`FinalizedResourceVoteChoicesWithVoterInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice , pub voters : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { let ffi_ref = & * ffi ; dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionFrom < Vec < (platform_value :: types :: identifier :: Identifier , u8) > >> :: ffi_from (ffi_ref . voters) } } } impl ferment :: FFIConversionTo < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo) -> * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) , voters : < crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 as ferment :: FFIConversionTo < Vec < (platform_value :: types :: identifier :: Identifier , u8) > >> :: ffi_to (obj . voters) }) } } impl Drop for dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; ferment :: unbox_any (ffi_ref . voters) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_ctor < > (resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice , voters : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8) -> * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { resource_vote_choice , voters }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_destroy < > (ffi : * mut dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_get_resource_vote_choice < > (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_get_voters < > (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 { (* obj) . voters } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_set_resource_vote_choice < > (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } # [no_mangle] pub unsafe extern "C" fn dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_set_voters < > (obj : * const dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_types_identifier_Identifier_u8 { (* obj) . voters } } pub mod votes { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Vote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_Vote { ResourceVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_Vote) -> dpp :: voting :: votes :: Vote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_Vote :: ResourceVote (o_0) => dpp :: voting :: votes :: Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote > for dpp_voting_votes_Vote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: Vote) -> * const dpp_voting_votes_Vote { ferment :: boxed (match obj { dpp :: voting :: votes :: Vote :: ResourceVote (o_0) => dpp_voting_votes_Vote :: ResourceVote (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_Vote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_Vote :: ResourceVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_Vote_ResourceVote_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: dpp_voting_votes_resource_vote_ResourceVote) -> * mut dpp_voting_votes_Vote { ferment :: boxed (dpp_voting_votes_Vote :: ResourceVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_Vote_destroy < > (ffi : * mut dpp_voting_votes_Vote) { ferment :: unbox_any (ffi) ; } pub mod resource_vote { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ResourceVote`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_votes_resource_vote_ResourceVote { V0 (* mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0) } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_ResourceVote) -> dpp :: voting :: votes :: resource_vote :: ResourceVote { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: ResourceVote > for dpp_voting_votes_resource_vote_ResourceVote { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: ResourceVote) -> * const dpp_voting_votes_resource_vote_ResourceVote { ferment :: boxed (match obj { dpp :: voting :: votes :: resource_vote :: ResourceVote :: V0 (o_0) => dpp_voting_votes_resource_vote_ResourceVote :: V0 (< crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0 as ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_votes_resource_vote_ResourceVote { fn drop (& mut self) { unsafe { match self { dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_ResourceVote_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: resource_vote :: v0 :: dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut dpp_voting_votes_resource_vote_ResourceVote { ferment :: boxed (dpp_voting_votes_resource_vote_ResourceVote :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_ResourceVote_destroy < > (ffi : * mut dpp_voting_votes_resource_vote_ResourceVote) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ResourceVoteV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { pub vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , pub resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice } impl ferment :: FFIConversionFrom < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_from_const (ffi : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { let ffi_ref = & * ffi ; dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_from (ffi_ref . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionFrom < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_from (ffi_ref . resource_vote_choice) } } } impl ferment :: FFIConversionTo < dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0 > for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { unsafe fn ffi_to_const (obj : dpp :: voting :: votes :: resource_vote :: v0 :: ResourceVoteV0) -> * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { ferment :: boxed (dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { vote_poll : < crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll >> :: ffi_to (obj . vote_poll) , resource_vote_choice : < crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice as ferment :: FFIConversionTo < dpp :: voting :: vote_choices :: resource_vote_choice :: ResourceVoteChoice >> :: ffi_to (obj . resource_vote_choice) }) } } impl Drop for dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vote_poll) ; ferment :: unbox_any (ffi_ref . resource_vote_choice) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_ctor < > (vote_poll : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll , resource_vote_choice : * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice) -> * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { ferment :: boxed (dpp_voting_votes_resource_vote_v0_ResourceVoteV0 { vote_poll , resource_vote_choice }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_destroy < > (ffi : * mut dpp_voting_votes_resource_vote_v0_ResourceVoteV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_get_vote_poll < > (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_get_resource_vote_choice < > (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_set_vote_poll < > (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: dpp_voting_vote_polls_VotePoll { (* obj) . vote_poll } # [no_mangle] pub unsafe extern "C" fn dpp_voting_votes_resource_vote_v0_ResourceVoteV0_set_resource_vote_choice < > (obj : * const dpp_voting_votes_resource_vote_v0_ResourceVoteV0) -> * mut crate :: fermented :: types :: dpp :: voting :: vote_choices :: resource_vote_choice :: dpp_voting_vote_choices_resource_vote_choice_ResourceVoteChoice { (* obj) . resource_vote_choice } } pub mod accessors { use crate as example_nested ; } } } pub mod vote_polls { use crate as example_nested ; pub mod contested_document_resource_vote_poll { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedDocumentResourceVotePoll`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { pub contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_type_name : * mut std :: os :: raw :: c_char , pub index_name : * mut std :: os :: raw :: c_char , pub index_values : * mut crate :: fermented :: generics :: Vec_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { let ffi_ref = & * ffi ; dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (ffi_ref . index_values) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll > for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll) -> * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { ferment :: boxed (dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . contract_id) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , index_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . index_name) , index_values : < crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (obj . index_values) }) } } impl Drop for dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . contract_id) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_string (ffi_ref . index_name) ; ferment :: unbox_any (ffi_ref . index_values) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_ctor < > (contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_type_name : * mut std :: os :: raw :: c_char , index_name : * mut std :: os :: raw :: c_char , index_values : * mut crate :: fermented :: generics :: Vec_platform_value_Value) -> * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { ferment :: boxed (dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll { contract_id , document_type_name , index_name , index_values }) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_destroy < > (ffi : * mut dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_contract_id < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_document_type_name < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_index_name < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_get_index_values < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut crate :: fermented :: generics :: Vec_platform_value_Value { (* obj) . index_values } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_contract_id < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_document_type_name < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_index_name < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut std :: os :: raw :: c_char { (* obj) . index_name } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll_set_index_values < > (obj : * const dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut crate :: fermented :: generics :: Vec_platform_value_Value { (* obj) . index_values } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VotePoll`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_voting_vote_polls_VotePoll { ContestedDocumentResourceVotePoll (* mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) } impl ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_from_const (ffi : * const dpp_voting_vote_polls_VotePoll) -> dpp :: voting :: vote_polls :: VotePoll { let ffi_ref = & * ffi ; match ffi_ref { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionFrom < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: VotePoll > for dpp_voting_vote_polls_VotePoll { unsafe fn ffi_to_const (obj : dpp :: voting :: vote_polls :: VotePoll) -> * const dpp_voting_vote_polls_VotePoll { ferment :: boxed (match obj { dpp :: voting :: vote_polls :: VotePoll :: ContestedDocumentResourceVotePoll (o_0) => dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (< crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll as ferment :: FFIConversionTo < dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: ContestedDocumentResourceVotePoll >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_voting_vote_polls_VotePoll { fn drop (& mut self) { unsafe { match self { dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_VotePoll_ContestedDocumentResourceVotePoll_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: vote_polls :: contested_document_resource_vote_poll :: dpp_voting_vote_polls_contested_document_resource_vote_poll_ContestedDocumentResourceVotePoll) -> * mut dpp_voting_vote_polls_VotePoll { ferment :: boxed (dpp_voting_vote_polls_VotePoll :: ContestedDocumentResourceVotePoll (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_voting_vote_polls_VotePoll_destroy < > (ffi : * mut dpp_voting_vote_polls_VotePoll) { ferment :: unbox_any (ffi) ; } } } pub mod data_contract { use crate as example_nested ; # [cfg (feature = "factories")] pub mod factory { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContract`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_DataContract { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DataContract) -> dpp :: data_contract :: DataContract { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_DataContract :: V0 (o_0) => dpp :: data_contract :: DataContract :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_from (* o_0)) , dpp_data_contract_DataContract :: V1 (o_0) => dpp :: data_contract :: DataContract :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DataContract > for dpp_data_contract_DataContract { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DataContract) -> * const dpp_data_contract_DataContract { ferment :: boxed (match obj { dpp :: data_contract :: DataContract :: V0 (o_0) => dpp_data_contract_DataContract :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionTo < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: DataContract :: V1 (o_0) => dpp_data_contract_DataContract :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionTo < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_DataContract { fn drop (& mut self) { unsafe { match self { dpp_data_contract_DataContract :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_DataContract :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: v0 :: data_contract :: dpp_data_contract_v0_data_contract_DataContractV0) -> * mut dpp_data_contract_DataContract { ferment :: boxed (dpp_data_contract_DataContract :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: v1 :: data_contract :: dpp_data_contract_v1_data_contract_DataContractV1) -> * mut dpp_data_contract_DataContract { ferment :: boxed (dpp_data_contract_DataContract :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DataContract_destroy < > (ffi : * mut dpp_data_contract_DataContract) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`DocumentName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DocumentName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DocumentName) -> dpp :: data_contract :: DocumentName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DocumentName > for dpp_data_contract_DocumentName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DocumentName) -> * const dpp_data_contract_DocumentName { ferment :: boxed (dpp_data_contract_DocumentName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DocumentName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_ctor < > (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_DocumentName { ferment :: boxed (dpp_data_contract_DocumentName (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_destroy < > (ffi : * mut dpp_data_contract_DocumentName) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_get_0 < > (obj : * const dpp_data_contract_DocumentName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DocumentName_set_0 < > (obj : * const dpp_data_contract_DocumentName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; # [cfg (feature = "validation")] pub mod validate_document { use crate as example_nested ; } pub mod schema { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validate_update { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } # [cfg (feature = "validation")] pub mod validate_groups { use crate as example_nested ; } pub mod equal_ignoring_time_based_fields { use crate as example_nested ; } } # [cfg (any (feature = "state-transitions" , feature = "factories"))] pub mod created_data_contract { use crate as example_nested ; pub mod fields { use crate as example_nested ; } } pub mod group { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_v0_GroupV0 { pub members : * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , pub required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_v0_GroupV0) -> dpp :: data_contract :: group :: v0 :: GroupV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: group :: v0 :: GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_from (ffi_ref . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_from (ffi_ref . required_power) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 > for dpp_data_contract_group_v0_GroupV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: v0 :: GroupV0) -> * const dpp_data_contract_group_v0_GroupV0 { ferment :: boxed (dpp_data_contract_group_v0_GroupV0 { members : < crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > >> :: ffi_to (obj . members) , required_power : < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower as ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower >> :: ffi_to (obj . required_power) }) } } impl Drop for dpp_data_contract_group_v0_GroupV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . members) ; ferment :: unbox_any (ffi_ref . required_power) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_ctor < > (members : * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower , required_power : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower) -> * mut dpp_data_contract_group_v0_GroupV0 { ferment :: boxed (dpp_data_contract_group_v0_GroupV0 { members , required_power }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_destroy < > (ffi : * mut dpp_data_contract_group_v0_GroupV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_get_members < > (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { (* obj) . members } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_get_required_power < > (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower { (* obj) . required_power } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_set_members < > (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { (* obj) . members } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_v0_GroupV0_set_required_power < > (obj : * const dpp_data_contract_group_v0_GroupV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupRequiredPower { (* obj) . required_power } } pub mod methods { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Group`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_group_Group { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_Group) -> dpp :: data_contract :: group :: Group { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_group_Group :: V0 (o_0) => dpp :: data_contract :: group :: Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: Group > for dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: Group) -> * const dpp_data_contract_group_Group { ferment :: boxed (match obj { dpp :: data_contract :: group :: Group :: V0 (o_0) => dpp_data_contract_group_Group :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0 as ferment :: FFIConversionTo < dpp :: data_contract :: group :: v0 :: GroupV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { match self { dpp_data_contract_group_Group :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_Group_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: group :: v0 :: dpp_data_contract_group_v0_GroupV0) -> * mut dpp_data_contract_group_Group { ferment :: boxed (dpp_data_contract_group_Group :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_Group_destroy < > (ffi : * mut dpp_data_contract_group_Group) { ferment :: unbox_any (ffi) ; } pub mod accessors { use crate as example_nested ; } # [doc = "FFI-representation of the [`GroupRequiredPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupRequiredPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupRequiredPower) -> dpp :: data_contract :: group :: GroupRequiredPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupRequiredPower > for dpp_data_contract_group_GroupRequiredPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupRequiredPower) -> * const dpp_data_contract_group_GroupRequiredPower { ferment :: boxed (dpp_data_contract_group_GroupRequiredPower (obj)) } } impl Drop for dpp_data_contract_group_GroupRequiredPower { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_ctor < > (o_0 : u32) -> * mut dpp_data_contract_group_GroupRequiredPower { ferment :: boxed (dpp_data_contract_group_GroupRequiredPower (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_destroy < > (ffi : * mut dpp_data_contract_group_GroupRequiredPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_get_0 < > (obj : * const dpp_data_contract_group_GroupRequiredPower) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupRequiredPower_set_0 < > (obj : * const dpp_data_contract_group_GroupRequiredPower) -> u32 { (* obj) . 0 } # [doc = "FFI-representation of the [`GroupMemberPower`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_group_GroupMemberPower (u32) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_group_GroupMemberPower) -> dpp :: data_contract :: group :: GroupMemberPower { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: group :: GroupMemberPower > for dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : dpp :: data_contract :: group :: GroupMemberPower) -> * const dpp_data_contract_group_GroupMemberPower { ferment :: boxed (dpp_data_contract_group_GroupMemberPower (obj)) } } impl Drop for dpp_data_contract_group_GroupMemberPower { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_ctor < > (o_0 : u32) -> * mut dpp_data_contract_group_GroupMemberPower { ferment :: boxed (dpp_data_contract_group_GroupMemberPower (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_destroy < > (ffi : * mut dpp_data_contract_group_GroupMemberPower) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_get_0 < > (obj : * const dpp_data_contract_group_GroupMemberPower) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_group_GroupMemberPower_set_0 < > (obj : * const dpp_data_contract_group_GroupMemberPower) -> u32 { (* obj) . 0 } } pub mod errors { use crate as example_nested ; pub mod invalid_document_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidDocumentTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { pub doc_type : * mut std :: os :: raw :: c_char , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (ffi_ref . data_contract) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError > for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: invalid_document_type_error :: InvalidDocumentTypeError) -> * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { doc_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . doc_type) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (obj . data_contract) }) } } impl Drop for dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . doc_type) ; ferment :: unbox_any (ffi_ref . data_contract) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_ctor < > (doc_type : * mut std :: os :: raw :: c_char , data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { ferment :: boxed (dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError { doc_type , data_contract }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_destroy < > (ffi : * mut dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_get_doc_type < > (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . doc_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_get_data_contract < > (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_set_doc_type < > (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . doc_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError_set_data_contract < > (obj : * const dpp_data_contract_errors_invalid_document_type_error_InvalidDocumentTypeError) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract { (* obj) . data_contract } } pub mod contract { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_contract_DataContractError { DecodingContractError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) , DecodingDocumentError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) , InvalidDocumentTypeError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) , DocumentTypesAreMissingError (* mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) , MissingRequiredKey (* mut std :: os :: raw :: c_char) , FieldRequirementUnmet (* mut std :: os :: raw :: c_char) , RegexError (* mut std :: os :: raw :: c_char) , KeyWrongType (* mut std :: os :: raw :: c_char) , ValueWrongType (* mut std :: os :: raw :: c_char) , InvalidURI (* mut std :: os :: raw :: c_char) , KeyWrongBounds (* mut std :: os :: raw :: c_char) , KeyValueMustExist (* mut std :: os :: raw :: c_char) , ValueDecodingError (* mut std :: os :: raw :: c_char) , EncodingDataStructureNotSupported (* mut std :: os :: raw :: c_char) , InvalidContractStructure (* mut std :: os :: raw :: c_char) , DocumentTypeNotFound (* mut std :: os :: raw :: c_char) , DocumentTypeFieldNotFound (* mut std :: os :: raw :: c_char) , ReferenceDefinitionNotFound (* mut std :: os :: raw :: c_char) , DocumentOwnerIdMissing (* mut std :: os :: raw :: c_char) , DocumentIdMissing (* mut std :: os :: raw :: c_char) , Unsupported (* mut std :: os :: raw :: c_char) , CorruptedSerialization (* mut std :: os :: raw :: c_char) , JsonSchema (* mut crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_contract_DataContractError) -> dpp :: data_contract :: errors :: contract :: DataContractError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError as ferment :: FFIConversionFrom < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: contract :: DataContractError > for dpp_data_contract_errors_contract_DataContractError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: contract :: DataContractError) -> * const dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingContractError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DecodingDocumentError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: decode :: decoding_error :: DecodingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidDocumentTypeError (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: InvalidDocumentTypeError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypesAreMissingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (< crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: DocumentTypesAreMissingError >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: MissingRequiredKey (o_0) => dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: FieldRequirementUnmet (o_0) => dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: RegexError (o_0) => dpp_data_contract_errors_contract_DataContractError :: RegexError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueWrongType (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidURI (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidURI (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyWrongBounds (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: KeyValueMustExist (o_0) => dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ValueDecodingError (o_0) => dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: EncodingDataStructureNotSupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: InvalidContractStructure (o_0) => dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentTypeFieldNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: ReferenceDefinitionNotFound (o_0) => dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentOwnerIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: DocumentIdMissing (o_0) => dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: Unsupported (o_0) => dpp_data_contract_errors_contract_DataContractError :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: CorruptedSerialization (o_0) => dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: contract :: DataContractError :: JsonSchema (o_0) => dpp_data_contract_errors_contract_DataContractError :: JsonSchema (< crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError as ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_contract_DataContractError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: RegexError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DecodingContractError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DecodingContractError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DecodingDocumentError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: decode :: decoding_error :: dpp_errors_consensus_basic_decode_decoding_error_DecodingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DecodingDocumentError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidDocumentTypeError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: document :: invalid_document_type_error :: dpp_errors_consensus_basic_document_invalid_document_type_error_InvalidDocumentTypeError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidDocumentTypeError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypesAreMissingError_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: data_contract :: document_types_are_missing_error :: dpp_errors_consensus_basic_data_contract_document_types_are_missing_error_DocumentTypesAreMissingError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypesAreMissingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_MissingRequiredKey_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: MissingRequiredKey (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_FieldRequirementUnmet_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: FieldRequirementUnmet (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_RegexError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: RegexError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyWrongType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyWrongType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ValueWrongType_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ValueWrongType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidURI_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidURI (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyWrongBounds_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyWrongBounds (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_KeyValueMustExist_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: KeyValueMustExist (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ValueDecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ValueDecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_EncodingDataStructureNotSupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: EncodingDataStructureNotSupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_InvalidContractStructure_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: InvalidContractStructure (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypeNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypeNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentTypeFieldNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentTypeFieldNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_ReferenceDefinitionNotFound_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: ReferenceDefinitionNotFound (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentOwnerIdMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentOwnerIdMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_DocumentIdMissing_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: DocumentIdMissing (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_Unsupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: Unsupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_CorruptedSerialization_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: CorruptedSerialization (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_JsonSchema_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: errors :: json_schema_error :: dpp_data_contract_errors_json_schema_error_JsonSchemaError) -> * mut dpp_data_contract_errors_contract_DataContractError { ferment :: boxed (dpp_data_contract_errors_contract_DataContractError :: JsonSchema (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_contract_DataContractError_destroy < > (ffi : * mut dpp_data_contract_errors_contract_DataContractError) { ferment :: unbox_any (ffi) ; } } pub mod data_contract_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError > for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: data_contract_not_present_error :: DataContractNotPresentError) -> * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_ctor < > (data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { ferment :: boxed (dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError { data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_destroy < > (ffi : * mut dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_get_data_contract_id < > (obj : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError_set_data_contract_id < > (obj : * const dpp_data_contract_errors_data_contract_not_present_error_DataContractNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod json_schema_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`JsonSchemaError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_errors_json_schema_error_JsonSchemaError { CreateSchemaError (* mut std :: os :: raw :: c_char) , SchemaCompatibilityValidationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_json_schema_error_JsonSchemaError) -> dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError > for dpp_data_contract_errors_json_schema_error_JsonSchemaError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError) -> * const dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (match obj { dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: CreateSchemaError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dpp :: data_contract :: errors :: json_schema_error :: JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_errors_json_schema_error_JsonSchemaError { fn drop (& mut self) { unsafe { match self { dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_0) => { ferment :: unbox_string (* o_0) ; } , dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_CreateSchemaError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_data_contract_errors_json_schema_error_JsonSchemaError :: CreateSchemaError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_SchemaCompatibilityValidationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError { ferment :: boxed (dpp_data_contract_errors_json_schema_error_JsonSchemaError :: SchemaCompatibilityValidationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_json_schema_error_JsonSchemaError_destroy < > (ffi : * mut dpp_data_contract_errors_json_schema_error_JsonSchemaError) { ferment :: unbox_any (ffi) ; } } pub mod identity_not_present_error { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityNotPresentError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { let ffi_ref = & * ffi ; dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError > for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { unsafe fn ffi_to_const (obj : dpp :: data_contract :: errors :: identity_not_present_error :: IdentityNotPresentError) -> * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { ferment :: boxed (dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) }) } } impl Drop for dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { ferment :: boxed (dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError { id }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_destroy < > (ffi : * mut dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_get_id < > (obj : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError_set_id < > (obj : * const dpp_data_contract_errors_identity_not_present_error_IdentityNotPresentError) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } } } pub mod config { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractConfig`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_config_DataContractConfig { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_DataContractConfig) -> dpp :: data_contract :: config :: DataContractConfig { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_from (* o_0)) , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => dpp :: data_contract :: config :: DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig > for dpp_data_contract_config_DataContractConfig { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: DataContractConfig) -> * const dpp_data_contract_config_DataContractConfig { ferment :: boxed (match obj { dpp :: data_contract :: config :: DataContractConfig :: V0 (o_0) => dpp_data_contract_config_DataContractConfig :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: config :: DataContractConfig :: V1 (o_0) => dpp_data_contract_config_DataContractConfig :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1 as ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_config_DataContractConfig { fn drop (& mut self) { unsafe { match self { dpp_data_contract_config_DataContractConfig :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_config_DataContractConfig :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: v0 :: dpp_data_contract_config_v0_DataContractConfigV0) -> * mut dpp_data_contract_config_DataContractConfig { ferment :: boxed (dpp_data_contract_config_DataContractConfig :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: v1 :: dpp_data_contract_config_v1_DataContractConfigV1) -> * mut dpp_data_contract_config_DataContractConfig { ferment :: boxed (dpp_data_contract_config_DataContractConfig :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_DataContractConfig_destroy < > (ffi : * mut dpp_data_contract_config_DataContractConfig) { ferment :: unbox_any (ffi) ; } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v1_DataContractConfigV1 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub sized_integer_types : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v1_DataContractConfigV1) -> dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v1 :: DataContractConfigV1 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , sized_integer_types : ffi_ref . sized_integer_types } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v1 :: DataContractConfigV1 > for dpp_data_contract_config_v1_DataContractConfigV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v1 :: DataContractConfigV1) -> * const dpp_data_contract_config_v1_DataContractConfigV1 { ferment :: boxed (dpp_data_contract_config_v1_DataContractConfigV1 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , sized_integer_types : obj . sized_integer_types }) } } impl Drop for dpp_data_contract_config_v1_DataContractConfigV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_ctor < > (can_be_deleted : bool , readonly : bool , keeps_history : bool , documents_keep_history_contract_default : bool , documents_mutable_contract_default : bool , documents_can_be_deleted_contract_default : bool , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , sized_integer_types : bool) -> * mut dpp_data_contract_config_v1_DataContractConfigV1 { ferment :: boxed (dpp_data_contract_config_v1_DataContractConfigV1 { can_be_deleted , readonly , keeps_history , documents_keep_history_contract_default , documents_mutable_contract_default , documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key , sized_integer_types }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_destroy < > (ffi : * mut dpp_data_contract_config_v1_DataContractConfigV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_can_be_deleted < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_readonly < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_keeps_history < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_keep_history_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_mutable_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_documents_can_be_deleted_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_get_sized_integer_types < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . sized_integer_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_can_be_deleted < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_readonly < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_keeps_history < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_keep_history_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_mutable_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_documents_can_be_deleted_contract_default < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v1_DataContractConfigV1_set_sized_integer_types < > (obj : * const dpp_data_contract_config_v1_DataContractConfigV1) -> bool { (* obj) . sized_integer_types } } pub mod methods { use crate as example_nested ; pub mod validate_update { use crate as example_nested ; } } pub mod fields { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractConfigV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_config_v0_DataContractConfigV0 { pub can_be_deleted : bool , pub readonly : bool , pub keeps_history : bool , pub documents_keep_history_contract_default : bool , pub documents_mutable_contract_default : bool , pub documents_can_be_deleted_contract_default : bool , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements } impl ferment :: FFIConversionFrom < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_config_v0_DataContractConfigV0) -> dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: config :: v0 :: DataContractConfigV0 { can_be_deleted : ffi_ref . can_be_deleted , readonly : ffi_ref . readonly , keeps_history : ffi_ref . keeps_history , documents_keep_history_contract_default : ffi_ref . documents_keep_history_contract_default , documents_mutable_contract_default : ffi_ref . documents_mutable_contract_default , documents_can_be_deleted_contract_default : ffi_ref . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: config :: v0 :: DataContractConfigV0 > for dpp_data_contract_config_v0_DataContractConfigV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: config :: v0 :: DataContractConfigV0) -> * const dpp_data_contract_config_v0_DataContractConfigV0 { ferment :: boxed (dpp_data_contract_config_v0_DataContractConfigV0 { can_be_deleted : obj . can_be_deleted , readonly : obj . readonly , keeps_history : obj . keeps_history , documents_keep_history_contract_default : obj . documents_keep_history_contract_default , documents_mutable_contract_default : obj . documents_mutable_contract_default , documents_can_be_deleted_contract_default : obj . documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) }) } } impl Drop for dpp_data_contract_config_v0_DataContractConfigV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_ctor < > (can_be_deleted : bool , readonly : bool , keeps_history : bool , documents_keep_history_contract_default : bool , documents_mutable_contract_default : bool , documents_can_be_deleted_contract_default : bool , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) -> * mut dpp_data_contract_config_v0_DataContractConfigV0 { ferment :: boxed (dpp_data_contract_config_v0_DataContractConfigV0 { can_be_deleted , readonly , keeps_history , documents_keep_history_contract_default , documents_mutable_contract_default , documents_can_be_deleted_contract_default , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_destroy < > (ffi : * mut dpp_data_contract_config_v0_DataContractConfigV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_can_be_deleted < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_readonly < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_keeps_history < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_keep_history_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_mutable_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_documents_can_be_deleted_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_get_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_can_be_deleted < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_readonly < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . readonly } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_keeps_history < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . keeps_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_keep_history_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_keep_history_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_mutable_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_mutable_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_documents_can_be_deleted_contract_default < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> bool { (* obj) . documents_can_be_deleted_contract_default } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_config_v0_DataContractConfigV0_set_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_config_v0_DataContractConfigV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } } } # [doc = "FFI-representation of the [`DefinitionName`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_DefinitionName (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_DefinitionName) -> dpp :: data_contract :: DefinitionName { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: DefinitionName > for dpp_data_contract_DefinitionName { unsafe fn ffi_to_const (obj : dpp :: data_contract :: DefinitionName) -> * const dpp_data_contract_DefinitionName { ferment :: boxed (dpp_data_contract_DefinitionName (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_DefinitionName { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_ctor < > (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_DefinitionName { ferment :: boxed (dpp_data_contract_DefinitionName (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_destroy < > (ffi : * mut dpp_data_contract_DefinitionName) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_get_0 < > (obj : * const dpp_data_contract_DefinitionName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_DefinitionName_set_0 < > (obj : * const dpp_data_contract_DefinitionName) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [doc = "FFI-representation of the [`GroupContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_GroupContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_GroupContractPosition) -> dpp :: data_contract :: GroupContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition > for dpp_data_contract_GroupContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: GroupContractPosition) -> * const dpp_data_contract_GroupContractPosition { ferment :: boxed (dpp_data_contract_GroupContractPosition (obj)) } } impl Drop for dpp_data_contract_GroupContractPosition { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_ctor < > (o_0 : u16) -> * mut dpp_data_contract_GroupContractPosition { ferment :: boxed (dpp_data_contract_GroupContractPosition (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_destroy < > (ffi : * mut dpp_data_contract_GroupContractPosition) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_get_0 < > (obj : * const dpp_data_contract_GroupContractPosition) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_GroupContractPosition_set_0 < > (obj : * const dpp_data_contract_GroupContractPosition) -> u16 { (* obj) . 0 } pub mod v1 { use crate as example_nested ; pub mod serialization { use crate as example_nested ; } pub mod methods { use crate as example_nested ; pub mod schema { use crate as example_nested ; } } pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v1_data_contract_DataContractV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v1_data_contract_DataContractV1) -> dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: v1 :: data_contract :: DataContractV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_from (ffi_ref . tokens) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v1 :: data_contract :: DataContractV1 > for dpp_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v1 :: data_contract :: DataContractV1) -> * const dpp_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (dpp_data_contract_v1_data_contract_DataContractV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_to (obj . tokens) }) } } impl Drop for dpp_data_contract_v1_data_contract_DataContractV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , version : u32 , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration) -> * mut dpp_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (dpp_data_contract_v1_data_contract_DataContractV1 { id , version , owner_id , document_types , config , schema_defs , created_at , updated_at , created_at_block_height , updated_at_block_height , created_at_epoch , updated_at_epoch , groups , tokens }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_destroy < > (ffi : * mut dpp_data_contract_v1_data_contract_DataContractV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_id < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_version < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_owner_id < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_document_types < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_config < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_schema_defs < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at_block_height < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at_block_height < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_created_at_epoch < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_updated_at_epoch < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_groups < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_get_tokens < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { (* obj) . tokens } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_id < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_version < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_owner_id < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_document_types < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_config < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_schema_defs < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at_block_height < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at_block_height < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_created_at_epoch < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_updated_at_epoch < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_groups < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v1_data_contract_DataContractV1_set_tokens < > (obj : * const dpp_data_contract_v1_data_contract_DataContractV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { (* obj) . tokens } } pub mod conversion { use crate as example_nested ; } } # [doc = "FFI-representation of the [`JsonSchema`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_JsonSchema (* mut example_nested :: serde_json_Value) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_JsonSchema) -> dpp :: data_contract :: JsonSchema { let ffi_ref = & * ffi ; < example_nested :: serde_json_Value as ferment :: FFIConversionFrom < serde_json :: Value >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: JsonSchema > for dpp_data_contract_JsonSchema { unsafe fn ffi_to_const (obj : dpp :: data_contract :: JsonSchema) -> * const dpp_data_contract_JsonSchema { ferment :: boxed (dpp_data_contract_JsonSchema (< example_nested :: serde_json_Value as ferment :: FFIConversionTo < serde_json :: Value >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_JsonSchema { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_ctor < > (o_0 : * mut example_nested :: serde_json_Value) -> * mut dpp_data_contract_JsonSchema { ferment :: boxed (dpp_data_contract_JsonSchema (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_destroy < > (ffi : * mut dpp_data_contract_JsonSchema) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_get_0 < > (obj : * const dpp_data_contract_JsonSchema) -> * mut example_nested :: serde_json_Value { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_JsonSchema_set_0 < > (obj : * const dpp_data_contract_JsonSchema) -> * mut example_nested :: serde_json_Value { (* obj) . 0 } pub mod extra { use crate as example_nested ; # [cfg (test)] pub mod drive_api_tests { use crate as example_nested ; } } pub mod storage_requirements { use crate as example_nested ; pub mod keys_for_document_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StorageKeyRequirements`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { Unique = 0 , Multiple = 1 , MultipleReferenceToLatest = 2 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) -> dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements > for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { unsafe fn ffi_to_const (obj : dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements) -> * const dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (match obj { dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Unique => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: Multiple => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple , dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements :: MultipleReferenceToLatest => dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { fn drop (& mut self) { unsafe { match self { dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple => { } , dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_Unique_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Unique { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_Multiple_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: Multiple { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_MultipleReferenceToLatest_ctor () -> * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { ferment :: boxed (dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements :: MultipleReferenceToLatest { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements_destroy < > (ffi : * mut dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements) { ferment :: unbox_any (ffi) ; } } } # [cfg (any (feature = "data-contract-value-conversion" , feature = "data-contract-cbor-conversion" , feature = "data-contract-json-conversion"))] pub mod conversion { use crate as example_nested ; # [cfg (feature = "data-contract-value-conversion")] pub mod value { use crate as example_nested ; } # [cfg (feature = "data-contract-json-conversion")] pub mod json { use crate as example_nested ; } # [cfg (feature = "data-contract-cbor-conversion")] pub mod cbor { use crate as example_nested ; } } pub mod document_type { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (feature = "validation")] pub mod validator { use crate as example_nested ; # [doc = "FFI-representation of the [`StatelessJsonSchemaLazyValidator`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator (* mut dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: validator :: StatelessJsonSchemaLazyValidator > for dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator) -> dpp :: data_contract :: document_type :: v0 :: validator :: StatelessJsonSchemaLazyValidator { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v0 :: validator :: StatelessJsonSchemaLazyValidator (< dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator as ferment :: FFIConversionFrom < dpp :: validation :: json_schema_validator :: JsonSchemaValidator >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: validator :: StatelessJsonSchemaLazyValidator > for dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v0 :: validator :: StatelessJsonSchemaLazyValidator) -> * const dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator { ferment :: boxed (dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator (< dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator as ferment :: FFIConversionTo < dpp :: validation :: json_schema_validator :: JsonSchemaValidator >> :: ffi_to (obj . 0))) } } impl Drop for dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator_ctor < > (o_0 : * mut dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator) -> * mut dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator { ferment :: boxed (dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator_destroy < > (ffi : * mut dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator_get_0 < > (obj : * const dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator) -> * mut dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator_set_0 < > (obj : * const dpp_data_contract_document_type_v0_validator_StatelessJsonSchemaLazyValidator) -> * mut dpp :: validation :: json_schema_validator :: dpp_validation_JsonSchemaValidator { (* obj) . 0 } } # [doc = "FFI-representation of the [`DocumentTypeV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_v0_DocumentTypeV0 { pub name : * mut std :: os :: raw :: c_char , pub schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , pub index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , pub flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , pub identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub documents_keep_history : bool , pub documents_mutable : bool , pub documents_can_be_deleted : bool , pub documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , pub trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , pub creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , pub security_level_requirement : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (ffi_ref . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_from (ffi_ref . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (ffi_ref . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (ffi_ref . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . transient_fields) , documents_keep_history : ffi_ref . documents_keep_history , documents_mutable : ffi_ref . documents_mutable , documents_can_be_deleted : ffi_ref . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable >> :: ffi_from (ffi_ref . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionFrom < dpp :: nft :: TradeMode >> :: ffi_from (ffi_ref . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_from (ffi_ref . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionFrom < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_from_opt (ffi_ref . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level_requirement) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for dpp_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0) -> * const dpp_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (dpp_data_contract_document_type_v0_DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , schema : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (obj . schema) , indices : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > >> :: ffi_to (obj . indices) , index_structure : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_to (obj . index_structure) , flattened_properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . flattened_properties) , properties : < crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (obj . properties) , identifier_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . identifier_paths) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) , required_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . required_fields) , transient_fields : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . transient_fields) , documents_keep_history : obj . documents_keep_history , documents_mutable : obj . documents_mutable , documents_can_be_deleted : obj . documents_can_be_deleted , documents_transferable : < crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable as ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable >> :: ffi_to (obj . documents_transferable) , trade_mode : < crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode as ferment :: FFIConversionTo < dpp :: nft :: TradeMode >> :: ffi_to (obj . trade_mode) , creation_restriction_mode : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode >> :: ffi_to (obj . creation_restriction_mode) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , requires_identity_encryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_encryption_bounded_key) , requires_identity_decryption_bounded_key : < crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements as ferment :: FFIConversionTo < dpp :: data_contract :: storage_requirements :: keys_for_document_type :: StorageKeyRequirements >> :: ffi_to_opt (obj . requires_identity_decryption_bounded_key) , security_level_requirement : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level_requirement) }) } } impl Drop for dpp_data_contract_document_type_v0_DocumentTypeV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . schema) ; ferment :: unbox_any (ffi_ref . indices) ; ferment :: unbox_any (ffi_ref . index_structure) ; ferment :: unbox_any (ffi_ref . flattened_properties) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any (ffi_ref . identifier_paths) ; ferment :: unbox_any (ffi_ref . binary_paths) ; ferment :: unbox_any (ffi_ref . required_fields) ; ferment :: unbox_any (ffi_ref . transient_fields) ; ; ; ; ferment :: unbox_any (ffi_ref . documents_transferable) ; ferment :: unbox_any (ffi_ref . trade_mode) ; ferment :: unbox_any (ffi_ref . creation_restriction_mode) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_encryption_bounded_key) ; ferment :: unbox_any_opt (ffi_ref . requires_identity_decryption_bounded_key) ; ferment :: unbox_any (ffi_ref . security_level_requirement) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_ctor < > (name : * mut std :: os :: raw :: c_char , schema : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , indices : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index , index_structure : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel , flattened_properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , properties : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty , identifier_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , required_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , transient_fields : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , documents_keep_history : bool , documents_mutable : bool , documents_can_be_deleted : bool , documents_transferable : * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable , trade_mode : * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode , creation_restriction_mode : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , requires_identity_encryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , requires_identity_decryption_bounded_key : * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements , security_level_requirement : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel) -> * mut dpp_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (dpp_data_contract_document_type_v0_DocumentTypeV0 { name , schema , indices , index_structure , flattened_properties , properties , identifier_paths , binary_paths , required_fields , transient_fields , documents_keep_history , documents_mutable , documents_can_be_deleted , documents_transferable , trade_mode , creation_restriction_mode , data_contract_id , requires_identity_encryption_bounded_key , requires_identity_decryption_bounded_key , security_level_requirement }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_destroy < > (ffi : * mut dpp_data_contract_document_type_v0_DocumentTypeV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_name < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_schema < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . schema } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_indices < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { (* obj) . indices } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_index_structure < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . index_structure } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_flattened_properties < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . flattened_properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_properties < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_identifier_paths < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . identifier_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_binary_paths < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_required_fields < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . required_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_transient_fields < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . transient_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_keep_history < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_keep_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_mutable < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_mutable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_can_be_deleted < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_documents_transferable < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable { (* obj) . documents_transferable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_trade_mode < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode { (* obj) . trade_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_creation_restriction_mode < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_data_contract_id < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_get_security_level_requirement < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level_requirement } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_name < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_schema < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: platform_value :: platform_value_Value { (* obj) . schema } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_indices < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { (* obj) . indices } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_index_structure < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . index_structure } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_flattened_properties < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . flattened_properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_properties < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_identifier_paths < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . identifier_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_binary_paths < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_required_fields < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . required_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_transient_fields < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . transient_fields } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_keep_history < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_keep_history } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_mutable < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_mutable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_can_be_deleted < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> bool { (* obj) . documents_can_be_deleted } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_documents_transferable < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: document :: transfer :: dpp_document_transfer_Transferable { (* obj) . documents_transferable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_trade_mode < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: nft :: dpp_nft_TradeMode { (* obj) . trade_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_creation_restriction_mode < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: restricted_creation :: dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { (* obj) . creation_restriction_mode } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_data_contract_id < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_requires_identity_encryption_bounded_key < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_encryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_requires_identity_decryption_bounded_key < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: storage_requirements :: keys_for_document_type :: dpp_data_contract_storage_requirements_keys_for_document_type_StorageKeyRequirements { (* obj) . requires_identity_decryption_bounded_key } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_v0_DocumentTypeV0_set_security_level_requirement < > (obj : * const dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level_requirement } } pub mod class_methods { use crate as example_nested ; pub mod try_from_schema { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } pub mod create_document_types_from_document_schemas { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } } pub mod schema { use crate as example_nested ; # [cfg (feature = "validation")] pub mod validate_max_depth { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [cfg (feature = "validation")] pub mod validate_schema_compatibility { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod recursive_schema_validator { use crate as example_nested ; pub mod traversal_validator { use crate as example_nested ; } } pub mod enrich_with_base_schema { use crate as example_nested ; } pub mod find_identifier_and_binary_paths { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTypeRef`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentTypeRef { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) } impl < 'a , > ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentTypeRef) -> dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (Box :: leak (Box :: new (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)))) } } } impl < 'a , > ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentTypeRef < 'a > > for dpp_data_contract_document_type_DocumentTypeRef { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentTypeRef < 'a >) -> * const dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentTypeRef :: V0 (o_0) => dpp_data_contract_document_type_DocumentTypeRef :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0 . clone ())) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentTypeRef { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentTypeRef_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp_data_contract_document_type_DocumentTypeRef { ferment :: boxed (dpp_data_contract_document_type_DocumentTypeRef :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentTypeRef_destroy < 'a > (ffi : * mut dpp_data_contract_document_type_DocumentTypeRef) { ferment :: unbox_any (ffi) ; } pub mod index { use crate as example_nested ; # [doc = "FFI-representation of the [`ContestedIndexInformation`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_ContestedIndexInformation { pub field_matches : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , pub resolution : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_from (ffi_ref . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_from (ffi_ref . resolution) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation > for dpp_data_contract_document_type_index_ContestedIndexInformation { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexInformation) -> * const dpp_data_contract_document_type_index_ContestedIndexInformation { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexInformation { field_matches : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > >> :: ffi_to (obj . field_matches) , resolution : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution >> :: ffi_to (obj . resolution) }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexInformation { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . field_matches) ; ferment :: unbox_any (ffi_ref . resolution) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_ctor < > (field_matches : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch , resolution : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution) -> * mut dpp_data_contract_document_type_index_ContestedIndexInformation { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexInformation { field_matches , resolution }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_destroy < > (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexInformation) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_get_field_matches < > (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { (* obj) . field_matches } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_get_resolution < > (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution { (* obj) . resolution } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_set_field_matches < > (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { (* obj) . field_matches } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexInformation_set_resolution < > (obj : * const dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexResolution { (* obj) . resolution } # [doc = "FFI-representation of the [`Index`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_Index { pub name : * mut std :: os :: raw :: c_char , pub properties : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty , pub unique : bool , pub null_searchable : bool , pub contested_index : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_Index) -> dpp :: data_contract :: document_type :: index :: Index { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_from (ffi_ref . properties) , unique : ffi_ref . unique , null_searchable : ffi_ref . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_from_opt (ffi_ref . contested_index) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: Index > for dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: Index) -> * const dpp_data_contract_document_type_index_Index { ferment :: boxed (dpp_data_contract_document_type_index_Index { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , properties : < crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > >> :: ffi_to (obj . properties) , unique : obj . unique , null_searchable : obj . null_searchable , contested_index : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexInformation >> :: ffi_to_opt (obj . contested_index) }) } } impl Drop for dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . properties) ; ; ; ferment :: unbox_any_opt (ffi_ref . contested_index) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_ctor < > (name : * mut std :: os :: raw :: c_char , properties : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty , unique : bool , null_searchable : bool , contested_index : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation) -> * mut dpp_data_contract_document_type_index_Index { ferment :: boxed (dpp_data_contract_document_type_index_Index { name , properties , unique , null_searchable , contested_index }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_destroy < > (ffi : * mut dpp_data_contract_document_type_index_Index) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_name < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_properties < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_unique < > (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . unique } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_null_searchable < > (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . null_searchable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_get_contested_index < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation { (* obj) . contested_index } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_name < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_properties < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_index_IndexProperty { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_unique < > (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . unique } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_null_searchable < > (obj : * const dpp_data_contract_document_type_index_Index) -> bool { (* obj) . null_searchable } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_Index_set_contested_index < > (obj : * const dpp_data_contract_document_type_index_Index) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexInformation { (* obj) . contested_index } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`OrderBy`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_OrderBy { Asc , Desc } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_OrderBy) -> dpp :: data_contract :: document_type :: index :: OrderBy { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_OrderBy :: Asc => dpp :: data_contract :: document_type :: index :: OrderBy :: Asc , dpp_data_contract_document_type_index_OrderBy :: Desc => dpp :: data_contract :: document_type :: index :: OrderBy :: Desc } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: OrderBy > for dpp_data_contract_document_type_index_OrderBy { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: OrderBy) -> * const dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: OrderBy :: Asc => dpp_data_contract_document_type_index_OrderBy :: Asc , dpp :: data_contract :: document_type :: index :: OrderBy :: Desc => dpp_data_contract_document_type_index_OrderBy :: Desc , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_OrderBy { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_OrderBy :: Asc => { } , dpp_data_contract_document_type_index_OrderBy :: Desc => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_Asc_ctor () -> * mut dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (dpp_data_contract_document_type_index_OrderBy :: Asc { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_Desc_ctor () -> * mut dpp_data_contract_document_type_index_OrderBy { ferment :: boxed (dpp_data_contract_document_type_index_OrderBy :: Desc { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_OrderBy_destroy < > (ffi : * mut dpp_data_contract_document_type_index_OrderBy) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`IndexProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_IndexProperty { pub name : * mut std :: os :: raw :: c_char , pub ascending : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_IndexProperty) -> dpp :: data_contract :: document_type :: index :: IndexProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index :: IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , ascending : ffi_ref . ascending } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: IndexProperty > for dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: IndexProperty) -> * const dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (dpp_data_contract_document_type_index_IndexProperty { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , ascending : obj . ascending }) } } impl Drop for dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_ctor < > (name : * mut std :: os :: raw :: c_char , ascending : bool) -> * mut dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (dpp_data_contract_document_type_index_IndexProperty { name , ascending }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_destroy < > (ffi : * mut dpp_data_contract_document_type_index_IndexProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_get_name < > (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_get_ascending < > (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> bool { (* obj) . ascending } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_set_name < > (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_IndexProperty_set_ascending < > (obj : * const dpp_data_contract_document_type_index_IndexProperty) -> bool { (* obj) . ascending } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexResolution`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexResolution { MasternodeVote = 0 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexResolution) -> dpp :: data_contract :: document_type :: index :: ContestedIndexResolution { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexResolution > for dpp_data_contract_document_type_index_ContestedIndexResolution { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexResolution) -> * const dpp_data_contract_document_type_index_ContestedIndexResolution { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexResolution :: MasternodeVote => dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexResolution { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexResolution_MasternodeVote_ctor () -> * mut dpp_data_contract_document_type_index_ContestedIndexResolution { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexResolution :: MasternodeVote { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexResolution_destroy < > (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexResolution) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContestedIndexFieldMatch`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_ContestedIndexFieldMatch { Regex (* mut dpp :: data_contract :: document_type :: index :: LazyRegex) , PositiveIntegerMatch (* mut [u8 ; 16]) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex ((& * * o_0) . clone ()) , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch) -> * const dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: Regex (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (ferment :: boxed (o_0)) , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_Regex_ctor (o_o_0 : * mut dpp :: data_contract :: document_type :: index :: LazyRegex) -> * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: Regex (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_PositiveIntegerMatch_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (dpp_data_contract_document_type_index_ContestedIndexFieldMatch :: PositiveIntegerMatch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_ContestedIndexFieldMatch_destroy < > (ffi : * mut dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { ferment :: unbox_any (ffi) ; } } pub mod accessors { use crate as example_nested ; } pub mod index_level { use crate as example_nested ; # [doc = "FFI-representation of the [`IndexLevel`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevel { pub sub_index_levels : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , pub has_index_with_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , pub level_identifier : u64 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevel) -> dpp :: data_contract :: document_type :: index_level :: IndexLevel { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_from (ffi_ref . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_from_opt (ffi_ref . has_index_with_type) , level_identifier : ffi_ref . level_identifier } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevel > for dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevel) -> * const dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevel { sub_index_levels : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > >> :: ffi_to (obj . sub_index_levels) , has_index_with_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo >> :: ffi_to_opt (obj . has_index_with_type) , level_identifier : obj . level_identifier }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . sub_index_levels) ; ferment :: unbox_any_opt (ffi_ref . has_index_with_type) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_ctor < > (sub_index_levels : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel , has_index_with_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo , level_identifier : u64) -> * mut dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevel { sub_index_levels , has_index_with_type , level_identifier }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_destroy < > (ffi : * mut dpp_data_contract_document_type_index_level_IndexLevel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_sub_index_levels < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . sub_index_levels } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_has_index_with_type < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { (* obj) . has_index_with_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_get_level_identifier < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> u64 { (* obj) . level_identifier } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_sub_index_levels < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { (* obj) . sub_index_levels } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_has_index_with_type < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { (* obj) . has_index_with_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevel_set_level_identifier < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevel) -> u64 { (* obj) . level_identifier } # [doc = "FFI-representation of the [`IndexLevelTypeInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { pub should_insert_with_all_null : bool , pub index_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo { should_insert_with_all_null : ffi_ref . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_from (ffi_ref . index_type) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo > for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexLevelTypeInfo) -> * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { should_insert_with_all_null : obj . should_insert_with_all_null , index_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType >> :: ffi_to (obj . index_type) }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . index_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_ctor < > (should_insert_with_all_null : bool , index_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType) -> * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexLevelTypeInfo { should_insert_with_all_null , index_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_destroy < > (ffi : * mut dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_get_should_insert_with_all_null < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> bool { (* obj) . should_insert_with_all_null } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_get_index_type < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType { (* obj) . index_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_set_should_insert_with_all_null < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> bool { (* obj) . should_insert_with_all_null } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexLevelTypeInfo_set_index_type < > (obj : * const dpp_data_contract_document_type_index_level_IndexLevelTypeInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexType { (* obj) . index_type } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IndexType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_index_level_IndexType { NonUniqueIndex , UniqueIndex , ContestedResourceIndex } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_index_level_IndexType) -> dpp :: data_contract :: document_type :: index_level :: IndexType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: index_level :: IndexType > for dpp_data_contract_document_type_index_level_IndexType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: index_level :: IndexType) -> * const dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: index_level :: IndexType :: NonUniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: UniqueIndex => dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex , dpp :: data_contract :: document_type :: index_level :: IndexType :: ContestedResourceIndex => dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_index_level_IndexType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex => { } , dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_NonUniqueIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: NonUniqueIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_UniqueIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: UniqueIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_ContestedResourceIndex_ctor () -> * mut dpp_data_contract_document_type_index_level_IndexType { ferment :: boxed (dpp_data_contract_document_type_index_level_IndexType :: ContestedResourceIndex { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_index_level_IndexType_destroy < > (ffi : * mut dpp_data_contract_document_type_index_level_IndexType) { ferment :: unbox_any (ffi) ; } } pub mod property { use crate as example_nested ; # [doc = "FFI-representation of the [`ByteArrayPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_ByteArrayPropertySizes { pub min_size : * mut u16 , pub max_size : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes { min_size : ferment :: from_opt_primitive (ffi_ref . min_size) , max_size : ferment :: from_opt_primitive (ffi_ref . max_size) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes > for dpp_data_contract_document_type_property_ByteArrayPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes) -> * const dpp_data_contract_document_type_property_ByteArrayPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_ByteArrayPropertySizes { min_size : ferment :: to_opt_primitive (obj . min_size) , max_size : ferment :: to_opt_primitive (obj . max_size) }) } } impl Drop for dpp_data_contract_document_type_property_ByteArrayPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: destroy_opt_primitive (ffi_ref . min_size) ; ferment :: destroy_opt_primitive (ffi_ref . max_size) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_ctor < > (min_size : * mut u16 , max_size : * mut u16) -> * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_ByteArrayPropertySizes { min_size , max_size }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_destroy < > (ffi : * mut dpp_data_contract_document_type_property_ByteArrayPropertySizes) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_get_min_size < > (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . min_size } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_get_max_size < > (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . max_size } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_set_min_size < > (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . min_size } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_ByteArrayPropertySizes_set_max_size < > (obj : * const dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut u16 { (* obj) . max_size } pub mod array { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ArrayItemType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_array_ArrayItemType { Integer , Number , String (* mut usize , * mut usize) , ByteArray (* mut usize , * mut usize) , Identifier , Boolean , Date } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_array_ArrayItemType) -> dpp :: data_contract :: document_type :: property :: array :: ArrayItemType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (ferment :: from_opt_primitive (* o_0) , ferment :: from_opt_primitive (* o_1)) , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > for dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: array :: ArrayItemType) -> * const dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Integer => dpp_data_contract_document_type_property_array_ArrayItemType :: Integer , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Number => dpp_data_contract_document_type_property_array_ArrayItemType :: Number , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: String (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: String (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: ByteArray (o_0 , o_1) => dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (ferment :: to_opt_primitive (o_0) , ferment :: to_opt_primitive (o_1)) , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Identifier => dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Boolean => dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean , dpp :: data_contract :: document_type :: property :: array :: ArrayItemType :: Date => dpp_data_contract_document_type_property_array_ArrayItemType :: Date , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_array_ArrayItemType :: Integer => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Number => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_0 , o_1) => { ferment :: destroy_opt_primitive (* o_0) ; ; ferment :: destroy_opt_primitive (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_0 , o_1) => { ferment :: destroy_opt_primitive (* o_0) ; ; ferment :: destroy_opt_primitive (* o_1) ; } , dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean => { } , dpp_data_contract_document_type_property_array_ArrayItemType :: Date => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Integer_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Integer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Number_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Number { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_String_ctor (o_o_0 : * mut usize , o_o_1 : * mut usize) -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: String (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_ByteArray_ctor (o_o_0 : * mut usize , o_o_1 : * mut usize) -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: ByteArray (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Identifier_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Identifier { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Boolean_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Boolean { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_Date_ctor () -> * mut dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (dpp_data_contract_document_type_property_array_ArrayItemType :: Date { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_array_ArrayItemType_destroy < > (ffi : * mut dpp_data_contract_document_type_property_array_ArrayItemType) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPropertyType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_property_DocumentPropertyType { U128 , I128 , U64 , I64 , U32 , I32 , U16 , I16 , U8 , I8 , F64 , String (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes) , ByteArray (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes) , Identifier , Boolean , Date , Object (* mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) , Array (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) , VariableTypeArray (* mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentPropertyType) -> dpp :: data_contract :: document_type :: property :: DocumentPropertyType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_from (* o_0)) , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType > for dpp_data_contract_document_type_property_DocumentPropertyType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentPropertyType) -> * const dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U128 => dpp_data_contract_document_type_property_DocumentPropertyType :: U128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I128 => dpp_data_contract_document_type_property_DocumentPropertyType :: I128 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U64 => dpp_data_contract_document_type_property_DocumentPropertyType :: U64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I64 => dpp_data_contract_document_type_property_DocumentPropertyType :: I64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U32 => dpp_data_contract_document_type_property_DocumentPropertyType :: U32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I32 => dpp_data_contract_document_type_property_DocumentPropertyType :: I32 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U16 => dpp_data_contract_document_type_property_DocumentPropertyType :: U16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I16 => dpp_data_contract_document_type_property_DocumentPropertyType :: I16 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: U8 => dpp_data_contract_document_type_property_DocumentPropertyType :: U8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: I8 => dpp_data_contract_document_type_property_DocumentPropertyType :: I8 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: F64 => dpp_data_contract_document_type_property_DocumentPropertyType :: F64 , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: String (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: String (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: ByteArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: ByteArrayPropertySizes >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Identifier => dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Boolean => dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Date => dpp_data_contract_document_type_property_DocumentPropertyType :: Date , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Object (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Object (< crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: Array (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: Array (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >> :: ffi_to (o_0)) , dpp :: data_contract :: document_type :: property :: DocumentPropertyType :: VariableTypeArray (o_0) => dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (< crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType as ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_property_DocumentPropertyType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_property_DocumentPropertyType :: U128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I128 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I32 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I16 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: U8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: I8 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: F64 => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Date => { } , dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U128_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U128 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I128_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I128 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U32_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U32 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I32_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I32 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U16_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U16 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I16_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I16 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_U8_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: U8 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_I8_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: I8 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_F64_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: F64 { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_String_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_StringPropertySizes) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: String (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_ByteArray_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_ByteArrayPropertySizes) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: ByteArray (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Identifier_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Identifier { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Boolean_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Boolean { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Date_ctor () -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Date { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Object_ctor (o_o_0 : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Object (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_Array_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: Array (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_VariableTypeArray_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut dpp_data_contract_document_type_property_DocumentPropertyType { ferment :: boxed (dpp_data_contract_document_type_property_DocumentPropertyType :: VariableTypeArray (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentPropertyType_destroy < > (ffi : * mut dpp_data_contract_document_type_property_DocumentPropertyType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`StringPropertySizes`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_StringPropertySizes { pub min_length : * mut u16 , pub max_length : * mut u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_StringPropertySizes) -> dpp :: data_contract :: document_type :: property :: StringPropertySizes { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: StringPropertySizes { min_length : ferment :: from_opt_primitive (ffi_ref . min_length) , max_length : ferment :: from_opt_primitive (ffi_ref . max_length) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: StringPropertySizes > for dpp_data_contract_document_type_property_StringPropertySizes { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: StringPropertySizes) -> * const dpp_data_contract_document_type_property_StringPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_StringPropertySizes { min_length : ferment :: to_opt_primitive (obj . min_length) , max_length : ferment :: to_opt_primitive (obj . max_length) }) } } impl Drop for dpp_data_contract_document_type_property_StringPropertySizes { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: destroy_opt_primitive (ffi_ref . min_length) ; ferment :: destroy_opt_primitive (ffi_ref . max_length) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_ctor < > (min_length : * mut u16 , max_length : * mut u16) -> * mut dpp_data_contract_document_type_property_StringPropertySizes { ferment :: boxed (dpp_data_contract_document_type_property_StringPropertySizes { min_length , max_length }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_destroy < > (ffi : * mut dpp_data_contract_document_type_property_StringPropertySizes) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_get_min_length < > (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . min_length } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_get_max_length < > (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . max_length } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_set_min_length < > (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . min_length } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_StringPropertySizes_set_max_length < > (obj : * const dpp_data_contract_document_type_property_StringPropertySizes) -> * mut u16 { (* obj) . max_length } # [doc = "FFI-representation of the [`DocumentProperty`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_document_type_property_DocumentProperty { pub property_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType , pub required : bool , pub transient : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_property_DocumentProperty) -> dpp :: data_contract :: document_type :: property :: DocumentProperty { let ffi_ref = & * ffi ; dpp :: data_contract :: document_type :: property :: DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_from (ffi_ref . property_type) , required : ffi_ref . required , transient : ffi_ref . transient } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentProperty > for dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: property :: DocumentProperty) -> * const dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (dpp_data_contract_document_type_property_DocumentProperty { property_type : < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: property :: DocumentPropertyType >> :: ffi_to (obj . property_type) , required : obj . required , transient : obj . transient }) } } impl Drop for dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . property_type) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_ctor < > (property_type : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType , required : bool , transient : bool) -> * mut dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (dpp_data_contract_document_type_property_DocumentProperty { property_type , required , transient }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_destroy < > (ffi : * mut dpp_data_contract_document_type_property_DocumentProperty) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_property_type < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType { (* obj) . property_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_required < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . required } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_get_transient < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . transient } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_property_type < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentPropertyType { (* obj) . property_type } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_required < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . required } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_property_DocumentProperty_set_transient < > (obj : * const dpp_data_contract_document_type_property_DocumentProperty) -> bool { (* obj) . transient } } pub mod methods { use crate as example_nested ; pub mod deserialize_value_for_key { use crate as example_nested ; } pub mod estimated_size { use crate as example_nested ; } pub mod serialize_value_for_key { use crate as example_nested ; } pub mod create_document_from_data { use crate as example_nested ; } pub mod contested_vote_poll_for_document { use crate as example_nested ; } pub mod index_for_types { use crate as example_nested ; } pub mod create_document_with_prevalidated_properties { use crate as example_nested ; } pub mod prefunded_voting_balances_for_document { use crate as example_nested ; } pub mod max_size { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validate_update { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } } pub mod restricted_creation { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`CreationRestrictionMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { NoRestrictions , OwnerOnly , NoCreationAllowed } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) -> dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode > for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode) -> * const dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoRestrictions => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: OwnerOnly => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly , dpp :: data_contract :: document_type :: restricted_creation :: CreationRestrictionMode :: NoCreationAllowed => dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly => { } , dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_NoRestrictions_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoRestrictions { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_OwnerOnly_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: OwnerOnly { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_NoCreationAllowed_ctor () -> * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode { ferment :: boxed (dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode :: NoCreationAllowed { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode_destroy < > (ffi : * mut dpp_data_contract_document_type_restricted_creation_CreationRestrictionMode) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_document_type_DocumentType { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_document_type_DocumentType) -> dpp :: data_contract :: document_type :: DocumentType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => dpp :: data_contract :: document_type :: DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: DocumentType > for dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: document_type :: DocumentType) -> * const dpp_data_contract_document_type_DocumentType { ferment :: boxed (match obj { dpp :: data_contract :: document_type :: DocumentType :: V0 (o_0) => dpp_data_contract_document_type_DocumentType :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < dpp :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_document_type_DocumentType :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentType_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: v0 :: dpp_data_contract_document_type_v0_DocumentTypeV0) -> * mut dpp_data_contract_document_type_DocumentType { ferment :: boxed (dpp_data_contract_document_type_DocumentType :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_document_type_DocumentType_destroy < > (ffi : * mut dpp_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } } pub mod serialized_version { use crate as example_nested ; pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , pub tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from_opt (ffi_ref . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_from (ffi_ref . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_from (ffi_ref . tokens) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 > for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1) -> * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { ferment :: boxed (dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , created_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . created_at_epoch) , updated_at_epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to_opt (obj . updated_at_epoch) , groups : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > >> :: ffi_to (obj . groups) , tokens : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > >> :: ffi_to (obj . tokens) }) } } impl Drop for dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_epoch) ; ferment :: unbox_any_opt (ffi_ref . updated_at_epoch) ; ferment :: unbox_any (ffi_ref . groups) ; ferment :: unbox_any (ffi_ref . tokens) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , version : u32 , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value , created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , updated_at_epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , groups : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group , tokens : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration) -> * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { ferment :: boxed (dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 { id , config , version , owner_id , schema_defs , document_schemas , created_at , updated_at , created_at_block_height , updated_at_block_height , created_at_epoch , updated_at_epoch , groups , tokens }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_destroy < > (ffi : * mut dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_id < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_config < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_version < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_owner_id < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_schema_defs < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_document_schemas < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at_block_height < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at_block_height < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_created_at_epoch < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_updated_at_epoch < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_groups < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_get_tokens < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { (* obj) . tokens } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_id < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_config < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_version < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_owner_id < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_schema_defs < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_document_schemas < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at_block_height < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at_block_height < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_created_at_epoch < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . created_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_updated_at_epoch < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . updated_at_epoch } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_groups < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { (* obj) . groups } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1_set_tokens < > (obj : * const dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { (* obj) . tokens } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractInSerializationFormat`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_serialized_version_DataContractInSerializationFormat { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) , V1 (* mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_DataContractInSerializationFormat) -> dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_from (* o_0)) , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat > for dpp_data_contract_serialized_version_DataContractInSerializationFormat { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat) -> * const dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (match obj { dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V0 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 >> :: ffi_to (o_0)) , dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat :: V1 (o_0) => dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (< crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1 as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v1 :: DataContractInSerializationFormatV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_serialized_version_DataContractInSerializationFormat { fn drop (& mut self) { unsafe { match self { dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v0 :: dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: v1 :: dpp_data_contract_serialized_version_v1_DataContractInSerializationFormatV1) -> * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat { ferment :: boxed (dpp_data_contract_serialized_version_DataContractInSerializationFormat :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_DataContractInSerializationFormat_destroy < > (ffi : * mut dpp_data_contract_serialized_version_DataContractInSerializationFormat) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractInSerializationFormatV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , pub document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_from (ffi_ref . document_schemas) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0 > for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: serialized_version :: v0 :: DataContractInSerializationFormatV0) -> * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { ferment :: boxed (dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) , document_schemas : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > >> :: ffi_to (obj . document_schemas) }) } } impl Drop for dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . config) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; ferment :: unbox_any (ffi_ref . document_schemas) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , version : u32 , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value , document_schemas : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) -> * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { ferment :: boxed (dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0 { id , config , version , owner_id , schema_defs , document_schemas }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_destroy < > (ffi : * mut dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_id < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_config < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_version < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_owner_id < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_schema_defs < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_get_document_schemas < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_id < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_config < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_version < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_owner_id < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_schema_defs < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0_set_document_schemas < > (obj : * const dpp_data_contract_serialized_version_v0_DataContractInSerializationFormatV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { (* obj) . document_schemas } } } # [doc = "FFI-representation of the [`PropertyPath`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_PropertyPath (* mut std :: os :: raw :: c_char) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_PropertyPath) -> dpp :: data_contract :: PropertyPath { let ffi_ref = & * ffi ; < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < dpp :: data_contract :: PropertyPath > for dpp_data_contract_PropertyPath { unsafe fn ffi_to_const (obj : dpp :: data_contract :: PropertyPath) -> * const dpp_data_contract_PropertyPath { ferment :: boxed (dpp_data_contract_PropertyPath (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj))) } } impl Drop for dpp_data_contract_PropertyPath { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_ctor < > (o_0 : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_PropertyPath { ferment :: boxed (dpp_data_contract_PropertyPath (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_destroy < > (ffi : * mut dpp_data_contract_PropertyPath) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_get_0 < > (obj : * const dpp_data_contract_PropertyPath) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_PropertyPath_set_0 < > (obj : * const dpp_data_contract_PropertyPath) -> * mut std :: os :: raw :: c_char { (* obj) . 0 } pub mod associated_token { use crate as example_nested ; pub mod token_pre_programmed_distribution { use crate as example_nested ; pub mod methods { use crate as example_nested ; } } pub mod token_configuration_localization { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigurationLocalizationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { pub should_capitalize : bool , pub singular_form : * mut std :: os :: raw :: c_char , pub plural_form : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 { should_capitalize : ffi_ref . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . plural_form) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 > for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0) -> * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { should_capitalize : obj . should_capitalize , singular_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . singular_form) , plural_form : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . plural_form) }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_string (ffi_ref . singular_form) ; ferment :: unbox_string (ffi_ref . plural_form) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_ctor < > (should_capitalize : bool , singular_form : * mut std :: os :: raw :: c_char , plural_form : * mut std :: os :: raw :: c_char) -> * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 { should_capitalize , singular_form , plural_form }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_should_capitalize < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> bool { (* obj) . should_capitalize } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_singular_form < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . singular_form } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_get_plural_form < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . plural_form } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_should_capitalize < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> bool { (* obj) . should_capitalize } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_singular_form < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . singular_form } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0_set_plural_form < > (obj : * const dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut std :: os :: raw :: c_char { (* obj) . plural_form } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationLocalization`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization) -> * const dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: TokenConfigurationLocalizationV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: v0 :: dpp_data_contract_associated_token_token_configuration_localization_v0_TokenConfigurationLocalizationV0) -> * mut dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { ferment :: unbox_any (ffi) ; } pub mod accessors { use crate as example_nested ; } } pub mod token_configuration_convention { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigurationConvention`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention > for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention) -> * const dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_configuration_convention :: TokenConfigurationConvention :: V0 (o_0) => dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> * mut dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_configuration_convention_TokenConfigurationConvention) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; pub mod validate_localizations { use crate as example_nested ; } } pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigurationConventionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { pub localizations : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , pub decimals : u16 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_from (ffi_ref . localizations) , decimals : ffi_ref . decimals } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0 > for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_configuration_convention :: v0 :: TokenConfigurationConventionV0) -> * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { localizations : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > >> :: ffi_to (obj . localizations) , decimals : obj . decimals }) } } impl Drop for dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . localizations) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_ctor < > (localizations : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization , decimals : u16) -> * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { ferment :: boxed (dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0 { localizations , decimals }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_get_localizations < > (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { (* obj) . localizations } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_get_decimals < > (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> u16 { (* obj) . decimals } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_set_localizations < > (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { (* obj) . localizations } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0_set_decimals < > (obj : * const dpp_data_contract_associated_token_token_configuration_convention_v0_TokenConfigurationConventionV0) -> u16 { (* obj) . decimals } } } pub mod token_distribution_rules { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod token_keeps_history_rules { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } pub mod token_configuration { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } pub mod methods { use crate as example_nested ; pub mod validate_token_configuration_update { use crate as example_nested ; } pub mod validate_token_configuration_groups_exist { use crate as example_nested ; } pub mod authorized_action_takers_for_configuration_item { use crate as example_nested ; } pub mod can_apply_token_configuration_item { use crate as example_nested ; } pub mod apply_token_configuration_item { use crate as example_nested ; } } pub mod accessors { use crate as example_nested ; } } pub mod token_distribution_key { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDistributionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { PreProgrammed = 0 , Perpetual = 1 } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) -> dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType > for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType) -> * const dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: PreProgrammed => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed , dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType :: Perpetual => dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed => { } , dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_PreProgrammed_ctor () -> * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: PreProgrammed { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_Perpetual_ctor () -> * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { ferment :: boxed (dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType :: Perpetual { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType) { ferment :: unbox_any (ffi) ; } } pub mod token_perpetual_distribution { use crate as example_nested ; pub mod reward_distribution_moment { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`RewardDistributionMoment`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { BlockBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) , TimeBasedMoment (* mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) , EpochBasedMoment (* mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment > for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: BlockBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: TimeBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (< crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: reward_distribution_moment :: RewardDistributionMoment :: EpochBasedMoment (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (< crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_BlockBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: BlockBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_TimeBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: TimeBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_EpochBasedMoment_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment :: EpochBasedMoment (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_perpetual_distribution_reward_distribution_moment_RewardDistributionMoment) { ferment :: unbox_any (ffi) ; } } pub mod methods { use crate as example_nested ; } pub mod distribution_function { use crate as example_nested ; pub mod validation { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DistributionFunction`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { FixedAmount { amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , Random { min : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } , StepDecreasingAmount { step_count : u32 , decrease_per_interval_numerator : u16 , decrease_per_interval_denominator : u16 , s : * mut u64 , n : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 } , Stepwise (* mut crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) , Linear { a : i64 , d : u64 , start_step : * mut u64 , starting_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Polynomial { a : i64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Exponential { a : u64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , c : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , Logarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } , InvertedLogarithmic { a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64 } } impl ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) -> dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* amount) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* max) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , s , n , min_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count : * step_count , decrease_per_interval_numerator : * decrease_per_interval_numerator , decrease_per_interval_denominator : * decrease_per_interval_denominator , s : ferment :: from_opt_primitive (* s) , n : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* n) , min_value : ferment :: from_opt_primitive (* min_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a : * a , d : * d , start_step : ferment :: from_opt_primitive (* start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* starting_amount) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , c , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , c : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* c) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a : * a , d : * d , m : * m , n : * n , o : * o , start_moment : ferment :: from_opt_primitive (* start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* b) , min_value : ferment :: from_opt_primitive (* min_value) , max_value : ferment :: from_opt_primitive (* max_value) } } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction > for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { unsafe fn ffi_to_const (obj : dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction) -> * const dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (match obj { dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: FixedAmount { amount } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (amount) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Random { min , max } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (min) , max : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (max) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , s , n , min_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count : step_count , decrease_per_interval_numerator : decrease_per_interval_numerator , decrease_per_interval_denominator : decrease_per_interval_denominator , s : ferment :: to_opt_primitive (s) , n : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (n) , min_value : ferment :: to_opt_primitive (min_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Stepwise (o_0) => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (< crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a : a , d : d , start_step : ferment :: to_opt_primitive (start_step) , starting_amount : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (starting_amount) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Exponential { a , d , m , n , o , start_moment , c , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , c : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (c) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , dpp :: data_contract :: associated_token :: token_perpetual_distribution :: distribution_function :: DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a : a , d : d , m : m , n : n , o : o , start_moment : ferment :: to_opt_primitive (start_moment) , b : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (b) , min_value : ferment :: to_opt_primitive (min_value) , max_value : ferment :: to_opt_primitive (max_value) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { fn drop (& mut self) { unsafe { match self { dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount } => { ferment :: unbox_any (* amount) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max } => { ferment :: unbox_any (* min) ; ; ferment :: unbox_any (* max) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , s , n , min_value } => { ; ; ; ; ; ; ferment :: destroy_opt_primitive (* s) ; ; ferment :: unbox_any (* n) ; ; ferment :: destroy_opt_primitive (* min_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value } => { ; ; ; ; ferment :: destroy_opt_primitive (* start_step) ; ; ferment :: unbox_any (* starting_amount) ; ; ferment :: destroy_opt_primitive (* min_value) ; ; ferment :: destroy_opt_primitive (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: destroy_opt_primitive (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: destroy_opt_primitive (* min_value) ; ; ferment :: destroy_opt_primitive (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , c , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: destroy_opt_primitive (* start_moment) ; ; ferment :: unbox_any (* c) ; ; ferment :: destroy_opt_primitive (* min_value) ; ; ferment :: destroy_opt_primitive (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: destroy_opt_primitive (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: destroy_opt_primitive (* min_value) ; ; ferment :: destroy_opt_primitive (* max_value) ; } , dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value } => { ; ; ; ; ; ; ; ; ; ; ferment :: destroy_opt_primitive (* start_moment) ; ; ferment :: unbox_any (* b) ; ; ferment :: destroy_opt_primitive (* min_value) ; ; ferment :: destroy_opt_primitive (* max_value) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_FixedAmount_ctor (amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: FixedAmount { amount }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Random_ctor (min : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , max : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Random { min , max }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_StepDecreasingAmount_ctor (step_count : u32 , decrease_per_interval_numerator : u16 , decrease_per_interval_denominator : u16 , s : * mut u64 , n : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: StepDecreasingAmount { step_count , decrease_per_interval_numerator , decrease_per_interval_denominator , s , n , min_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Stepwise_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Stepwise (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Linear_ctor (a : i64 , d : u64 , start_step : * mut u64 , starting_amount : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Linear { a , d , start_step , starting_amount , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Polynomial_ctor (a : i64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Polynomial { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Exponential_ctor (a : u64 , d : u64 , m : i64 , n : u64 , o : i64 , start_moment : * mut u64 , c : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Exponential { a , d , m , n , o , start_moment , c , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_Logarithmic_ctor (a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: Logarithmic { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_InvertedLogarithmic_ctor (a : i64 , d : u64 , m : u64 , n : u64 , o : i64 , start_moment : * mut u64 , b : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount , min_value : * mut u64 , max_value : * mut u64) -> * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction { ferment :: boxed (dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction :: InvertedLogarithmic { a , d , m , n , o , start_moment , b , min_value , max_value }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction_destroy < > (ffi : * mut dpp_data_contract_associated_token_token_perpetual_distribution_distribution_function_DistributionFunction) { ferment :: unbox_any (ffi) ; } pub mod evaluate { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } pub mod reward_distribution_type { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; } } } # [doc = "FFI-representation of the [`TokenContractPosition`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_TokenContractPosition (u16) ; impl ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_TokenContractPosition) -> dpp :: data_contract :: TokenContractPosition { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: data_contract :: TokenContractPosition > for dpp_data_contract_TokenContractPosition { unsafe fn ffi_to_const (obj : dpp :: data_contract :: TokenContractPosition) -> * const dpp_data_contract_TokenContractPosition { ferment :: boxed (dpp_data_contract_TokenContractPosition (obj)) } } impl Drop for dpp_data_contract_TokenContractPosition { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_ctor < > (o_0 : u16) -> * mut dpp_data_contract_TokenContractPosition { ferment :: boxed (dpp_data_contract_TokenContractPosition (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_destroy < > (ffi : * mut dpp_data_contract_TokenContractPosition) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_get_0 < > (obj : * const dpp_data_contract_TokenContractPosition) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_TokenContractPosition_set_0 < > (obj : * const dpp_data_contract_TokenContractPosition) -> u16 { (* obj) . 0 } pub mod v0 { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod schema { use crate as example_nested ; } } pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_v0_data_contract_DataContractV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub version : u32 , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , pub metadata : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata , pub config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , pub schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_v0_data_contract_DataContractV0) -> dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: v0 :: data_contract :: DataContractV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , version : ffi_ref . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_from (ffi_ref . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionFrom < dpp :: metadata :: Metadata >> :: ffi_from_opt (ffi_ref . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionFrom < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_from (ffi_ref . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_from_opt (ffi_ref . schema_defs) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: v0 :: data_contract :: DataContractV0 > for dpp_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: v0 :: data_contract :: DataContractV0) -> * const dpp_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (dpp_data_contract_v0_data_contract_DataContractV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , version : obj . version , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , document_types : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > >> :: ffi_to (obj . document_types) , metadata : < crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata as ferment :: FFIConversionTo < dpp :: metadata :: Metadata >> :: ffi_to_opt (obj . metadata) , config : < crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig as ferment :: FFIConversionTo < dpp :: data_contract :: config :: DataContractConfig >> :: ffi_to (obj . config) , schema_defs : < crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > >> :: ffi_to_opt (obj . schema_defs) }) } } impl Drop for dpp_data_contract_v0_data_contract_DataContractV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . document_types) ; ferment :: unbox_any_opt (ffi_ref . metadata) ; ferment :: unbox_any (ffi_ref . config) ; ferment :: unbox_any_opt (ffi_ref . schema_defs) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , version : u32 , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , document_types : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType , metadata : * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata , config : * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig , schema_defs : * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) -> * mut dpp_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (dpp_data_contract_v0_data_contract_DataContractV0 { id , version , owner_id , document_types , metadata , config , schema_defs }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_destroy < > (ffi : * mut dpp_data_contract_v0_data_contract_DataContractV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_id < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_version < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_owner_id < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_document_types < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_metadata < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata { (* obj) . metadata } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_config < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_get_schema_defs < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_id < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_version < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> u32 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_owner_id < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_document_types < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { (* obj) . document_types } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_metadata < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: metadata :: dpp_metadata_Metadata { (* obj) . metadata } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_config < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: config :: dpp_data_contract_config_DataContractConfig { (* obj) . config } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_v0_data_contract_DataContractV0_set_schema_defs < > (obj : * const dpp_data_contract_v0_data_contract_DataContractV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { (* obj) . schema_defs } } pub mod serialization { use crate as example_nested ; } pub mod conversion { use crate as example_nested ; } } pub mod change_control_rules { use crate as example_nested ; pub mod authorized_action_takers { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`AuthorizedActionTakers`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { NoOne , ContractOwner , Identity (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , MainGroup , Group (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) -> dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers > for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers) -> * const dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: NoOne => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: ContractOwner => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Identity (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: MainGroup => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup , dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers :: Group (o_0) => dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup => { } , dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_NoOne_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: NoOne { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_ContractOwner_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: ContractOwner { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_Identity_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Identity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_MainGroup_ctor () -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: MainGroup { }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_Group_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition) -> * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { ferment :: boxed (dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers :: Group (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers_destroy < > (ffi : * mut dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers) { ferment :: unbox_any (ffi) ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`ChangeControlRulesV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { pub authorized_to_make_change : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub admin_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , pub changing_authorized_action_takers_to_no_one_allowed : bool , pub changing_admin_action_takers_to_no_one_allowed : bool , pub self_changing_admin_action_takers_allowed : bool } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { let ffi_ref = & * ffi ; dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_from (ffi_ref . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : ffi_ref . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : ffi_ref . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : ffi_ref . self_changing_admin_action_takers_allowed } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 > for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0) -> * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { ferment :: boxed (dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { authorized_to_make_change : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . authorized_to_make_change) , admin_action_takers : < crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: authorized_action_takers :: AuthorizedActionTakers >> :: ffi_to (obj . admin_action_takers) , changing_authorized_action_takers_to_no_one_allowed : obj . changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed : obj . changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed : obj . self_changing_admin_action_takers_allowed }) } } impl Drop for dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . authorized_to_make_change) ; ferment :: unbox_any (ffi_ref . admin_action_takers) ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_ctor < > (authorized_to_make_change : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , admin_action_takers : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers , changing_authorized_action_takers_to_no_one_allowed : bool , changing_admin_action_takers_to_no_one_allowed : bool , self_changing_admin_action_takers_allowed : bool) -> * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { ferment :: boxed (dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 { authorized_to_make_change , admin_action_takers , changing_authorized_action_takers_to_no_one_allowed , changing_admin_action_takers_to_no_one_allowed , self_changing_admin_action_takers_allowed }) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_destroy < > (ffi : * mut dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_authorized_to_make_change < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_to_make_change } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_admin_action_takers < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . admin_action_takers } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_changing_authorized_action_takers_to_no_one_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_authorized_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_changing_admin_action_takers_to_no_one_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_admin_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_get_self_changing_admin_action_takers_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . self_changing_admin_action_takers_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_authorized_to_make_change < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . authorized_to_make_change } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_admin_action_takers < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: authorized_action_takers :: dpp_data_contract_change_control_rules_authorized_action_takers_AuthorizedActionTakers { (* obj) . admin_action_takers } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_changing_authorized_action_takers_to_no_one_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_authorized_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_changing_admin_action_takers_to_no_one_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . changing_admin_action_takers_to_no_one_allowed } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0_set_self_changing_admin_action_takers_allowed < > (obj : * const dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> bool { (* obj) . self_changing_admin_action_takers_allowed } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ChangeControlRules`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_data_contract_change_control_rules_ChangeControlRules { V0 (* mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) } impl ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_from_const (ffi : * const dpp_data_contract_change_control_rules_ChangeControlRules) -> dpp :: data_contract :: change_control_rules :: ChangeControlRules { let ffi_ref = & * ffi ; match ffi_ref { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionFrom < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: ChangeControlRules > for dpp_data_contract_change_control_rules_ChangeControlRules { unsafe fn ffi_to_const (obj : dpp :: data_contract :: change_control_rules :: ChangeControlRules) -> * const dpp_data_contract_change_control_rules_ChangeControlRules { ferment :: boxed (match obj { dpp :: data_contract :: change_control_rules :: ChangeControlRules :: V0 (o_0) => dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (< crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0 as ferment :: FFIConversionTo < dpp :: data_contract :: change_control_rules :: v0 :: ChangeControlRulesV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_data_contract_change_control_rules_ChangeControlRules { fn drop (& mut self) { unsafe { match self { dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_ChangeControlRules_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: change_control_rules :: v0 :: dpp_data_contract_change_control_rules_v0_ChangeControlRulesV0) -> * mut dpp_data_contract_change_control_rules_ChangeControlRules { ferment :: boxed (dpp_data_contract_change_control_rules_ChangeControlRules :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_data_contract_change_control_rules_ChangeControlRules_destroy < > (ffi : * mut dpp_data_contract_change_control_rules_ChangeControlRules) { ferment :: unbox_any (ffi) ; } } } pub mod asset_lock { use crate as example_nested ; pub mod reduced_asset_lock_value { use crate as example_nested ; } } pub mod validation { use crate as example_nested ; # [cfg (feature = "validation")] pub mod json_schema_validator { use crate as example_nested ; pub mod methods { use crate as example_nested ; pub mod compile { use crate as example_nested ; } pub mod new { use crate as example_nested ; } pub mod validate { use crate as example_nested ; } } } # [cfg (feature = "validation")] pub mod byte_array_keyword { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } } # [cfg (feature = "state-transitions")] pub mod state_transition { use crate as example_nested ; pub mod proof_result { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionProofResult`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_proof_result_StateTransitionProofResult { VerifiedDataContract (* mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) , VerifiedIdentity (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity) , VerifiedTokenBalanceAbsence (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) , VerifiedTokenBalance (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) , VerifiedTokenIdentityInfo (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) , VerifiedTokenStatus (* mut crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus) , VerifiedTokenIdentitiesBalances (* mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) , VerifiedPartialIdentity (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) , VerifiedBalanceTransfer (* mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity , * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) , VerifiedDocuments (* mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) , VerifiedTokenActionWithDocument (* mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) , VerifiedMasternodeVote (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) , VerifiedNextDistribution (* mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_proof_result_StateTransitionProofResult) -> dpp :: state_transition :: proof_result :: StateTransitionProofResult { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionFrom < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionFrom < dpp :: tokens :: status :: TokenStatus >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: PartialIdentity >> :: ffi_from (* o_1)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: proof_result :: StateTransitionProofResult > for dpp_state_transition_proof_result_StateTransitionProofResult { unsafe fn ffi_to_const (obj : dpp :: state_transition :: proof_result :: StateTransitionProofResult) -> * const dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (match obj { dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDataContract (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (< crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionTo < dpp :: data_contract :: DataContract >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionTo < dpp :: identity :: identity :: Identity >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < dpp :: balances :: credits :: TokenAmount >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo as ferment :: FFIConversionTo < dpp :: tokens :: info :: IdentityTokenInfo >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenStatus (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (< crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus as ferment :: FFIConversionTo < dpp :: tokens :: status :: TokenStatus >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_0) , < crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity as ferment :: FFIConversionTo < dpp :: identity :: identity :: PartialIdentity >> :: ffi_to (o_1)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedDocuments (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (< crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document as ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , dpp :: state_transition :: proof_result :: StateTransitionProofResult :: VerifiedNextDistribution (o_0) => dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (< crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_proof_result_StateTransitionProofResult { fn drop (& mut self) { unsafe { match self { dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedDataContract_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDataContract (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedIdentity_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenBalanceAbsence_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalanceAbsence (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenBalance_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , o_o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenBalance (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenIdentityInfo_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , o_o_1 : * mut crate :: fermented :: types :: dpp :: tokens :: info :: dpp_tokens_info_IdentityTokenInfo) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentityInfo (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenStatus_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: tokens :: status :: dpp_tokens_status_TokenStatus) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenStatus (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenIdentitiesBalances_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenIdentitiesBalances (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedPartialIdentity_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedPartialIdentity (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedBalanceTransfer_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity , o_o_1 : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_PartialIdentity) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedBalanceTransfer (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedDocuments_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedDocuments (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedTokenActionWithDocument_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedTokenActionWithDocument (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedMasternodeVote_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedMasternodeVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_VerifiedNextDistribution_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote) -> * mut dpp_state_transition_proof_result_StateTransitionProofResult { ferment :: boxed (dpp_state_transition_proof_result_StateTransitionProofResult :: VerifiedNextDistribution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_proof_result_StateTransitionProofResult_destroy < > (ffi : * mut dpp_state_transition_proof_result_StateTransitionProofResult) { ferment :: unbox_any (ffi) ; } } pub mod errors { use crate as example_nested ; # [cfg (feature = "state-transition-validation")] pub mod public_key_mismatch_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeyMismatchError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { pub public_key : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError { public_key : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_from (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError > for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_mismatch_error :: PublicKeyMismatchError) -> * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { ferment :: boxed (dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { public_key : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_to (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_ctor < > (public_key : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey) -> * mut dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { ferment :: boxed (dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError { public_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_destroy < > (ffi : * mut dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_get_public_key < > (obj : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . public_key } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError_set_public_key < > (obj : * const dpp_state_transition_errors_public_key_mismatch_error_PublicKeyMismatchError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey { (* obj) . public_key } } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . public_key_type) }) } } impl Drop for dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor < > (public_key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType) -> * mut dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy < > (ffi : * mut dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type < > (obj : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type < > (obj : * const dpp_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . public_key_type } } # [cfg (feature = "state-transition-validation")] pub mod state_transition_is_not_signed_error { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionIsNotSignedError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { pub state_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition >> :: ffi_from (ffi_ref . state_transition) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError > for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_is_not_signed_error :: StateTransitionIsNotSignedError) -> * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { ferment :: boxed (dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { state_transition : < crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition >> :: ffi_to (obj . state_transition) }) } } impl Drop for dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . state_transition) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_ctor < > (state_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition) -> * mut dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { ferment :: boxed (dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError { state_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_destroy < > (ffi : * mut dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_get_state_transition < > (obj : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition { (* obj) . state_transition } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError_set_state_transition < > (obj : * const dpp_state_transition_errors_state_transition_is_not_signed_error_StateTransitionIsNotSignedError) -> * mut crate :: fermented :: types :: dpp :: state_transition :: dpp_state_transition_StateTransition { (* obj) . state_transition } } # [cfg (any (all (feature = "state-transitions" , feature = "validation") , feature = "state-transition-validation"))] pub mod state_transition_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_errors_state_transition_error_StateTransitionError { InvalidStateTransitionError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_state_transition : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_state_transition_error_StateTransitionError) -> dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_state_transition) } } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError > for dpp_state_transition_errors_state_transition_error_StateTransitionError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError) -> * const dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (match obj { dpp :: state_transition :: errors :: state_transition_error :: StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_state_transition : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_state_transition) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_errors_state_transition_error_StateTransitionError { fn drop (& mut self) { unsafe { match self { dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_state_transition) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_error_StateTransitionError_InvalidStateTransitionError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_state_transition : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_state_transition_errors_state_transition_error_StateTransitionError { ferment :: boxed (dpp_state_transition_errors_state_transition_error_StateTransitionError :: InvalidStateTransitionError { errors , raw_state_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_state_transition_error_StateTransitionError_destroy < > (ffi : * mut dpp_state_transition_errors_state_transition_error_StateTransitionError) { ferment :: unbox_any (ffi) ; } } # [cfg (any (feature = "state-transition-validation" , feature = "state-transition-signing"))] pub mod invalid_signature_public_key_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidSignaturePublicKeyError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { pub public_key : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . public_key) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError > for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: invalid_signature_public_key_error :: InvalidSignaturePublicKeyError) -> * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { ferment :: boxed (dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { public_key : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . public_key) }) } } impl Drop for dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_ctor < > (public_key : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { ferment :: boxed (dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError { public_key }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_destroy < > (ffi : * mut dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_get_public_key < > (obj : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . public_key } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError_set_public_key < > (obj : * const dpp_state_transition_errors_invalid_signature_public_key_error_InvalidSignaturePublicKeyError) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . public_key } } # [cfg (feature = "state-transition-validation")] pub mod public_key_security_level_not_met_error { use crate as example_nested ; # [doc = "FFI-representation of the [`PublicKeySecurityLevelNotMetError`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { pub public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { let ffi_ref = & * ffi ; dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . required_security_level) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError > for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { unsafe fn ffi_to_const (obj : dpp :: state_transition :: errors :: public_key_security_level_not_met_error :: PublicKeySecurityLevelNotMetError) -> * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . public_key_security_level) , required_security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . required_security_level) }) } } impl Drop for dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_key_security_level) ; ferment :: unbox_any (ffi_ref . required_security_level) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_ctor < > (public_key_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , required_security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel) -> * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { ferment :: boxed (dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError { public_key_security_level , required_security_level }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_destroy < > (ffi : * mut dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_public_key_security_level < > (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_get_required_security_level < > (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . required_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_public_key_security_level < > (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . public_key_security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError_set_required_security_level < > (obj : * const dpp_state_transition_errors_public_key_security_level_not_met_error_PublicKeySecurityLevelNotMetError) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . required_security_level } } } pub mod abstract_state_transition { use crate as example_nested ; } pub mod state_transitions { use crate as example_nested ; pub mod contract { use crate as example_nested ; pub mod data_contract_update_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: v0 :: DataContractUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_ctor < > (identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0 { identity_contract_nonce , data_contract , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_data_contract < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_data_contract < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_update_transition_v0_DataContractUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod accessors { use crate as example_nested ; } } pub mod common_fields { use crate as example_nested ; } pub mod data_contract_create_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { pub data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , pub identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionFrom < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_from (ffi_ref . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0) -> * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { data_contract : < crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat as ferment :: FFIConversionTo < dpp :: data_contract :: serialized_version :: DataContractInSerializationFormat >> :: ffi_to (obj . data_contract) , identity_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . identity_nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_ctor < > (data_contract : * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat , identity_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { data_contract , identity_nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_data_contract < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_identity_nonce < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_data_contract < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: serialized_version :: dpp_data_contract_serialized_version_DataContractInSerializationFormat { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_identity_nonce < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } # [cfg (feature = "state-transition-json-conversion")] pub mod json_conversion { use crate as example_nested ; } pub mod accessors { use crate as example_nested ; } } } pub mod common_fields { use crate as example_nested ; } pub mod document { use crate as example_nested ; pub mod batch_transition { use crate as example_nested ; pub mod resolvers { use crate as example_nested ; } # [cfg (feature = "validation")] pub mod validation { use crate as example_nested ; pub mod find_duplicates_by_id { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod validate_basic_structure { use crate as example_nested ; } } pub mod methods { use crate as example_nested ; } pub mod batched_transition { use crate as example_nested ; pub mod token_transfer_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub amount : u64 , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char , pub shared_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote , pub private_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , amount : ffi_ref . amount , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: SharedEncryptedNote >> :: ffi_from_opt (ffi_ref . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionFrom < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_from_opt (ffi_ref . private_encrypted_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , amount : obj . amount , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) , shared_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: SharedEncryptedNote >> :: ffi_to_opt (obj . shared_encrypted_note) , private_encrypted_note : < crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote as ferment :: FFIConversionTo < dpp :: tokens :: PrivateEncryptedNote >> :: ffi_to_opt (obj . private_encrypted_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any (ffi_ref . recipient_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; ferment :: unbox_any_opt (ffi_ref . shared_encrypted_note) ; ferment :: unbox_any_opt (ffi_ref . private_encrypted_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , amount : u64 , recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_note : * mut std :: os :: raw :: c_char , shared_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote , private_encrypted_note : * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 { base , amount , recipient_id , public_note , shared_encrypted_note , private_encrypted_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_recipient_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_shared_encrypted_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote { (* obj) . shared_encrypted_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_get_private_encrypted_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote { (* obj) . private_encrypted_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_recipient_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_shared_encrypted_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_SharedEncryptedNote { (* obj) . shared_encrypted_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0_set_private_encrypted_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: dpp_tokens_PrivateEncryptedNote { (* obj) . private_encrypted_note } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: TokenTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_v0_TokenTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_freeze_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenFreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenFreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub identity_to_freeze_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: v0 :: TokenFreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , identity_to_freeze_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_to_freeze_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . identity_to_freeze_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , identity_to_freeze_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0 { base , identity_to_freeze_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_identity_to_freeze_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_to_freeze_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_identity_to_freeze_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_to_freeze_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_v0_TokenFreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } pub mod validate_structure { use crate as example_nested ; } } pub mod document_update_price_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentUpdatePriceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentUpdatePriceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: v0 :: DocumentUpdatePriceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0 { base , revision , price }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_get_price < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0_set_price < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_v0_DocumentUpdatePriceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } } } pub mod document_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { Create (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) , Replace (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) , Delete (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) , Transfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) , UpdatePrice (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) , Purchase (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Create (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Replace (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Delete (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: UpdatePrice (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: DocumentUpdatePriceTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition :: Purchase (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Create_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Create (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Replace_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Replace (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Delete_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Delete (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Transfer_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Transfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_UpdatePrice_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_update_price_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_update_price_transition_DocumentUpdatePriceTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: UpdatePrice (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_Purchase_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition :: Purchase (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_claim_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenClaimTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub distribution_type : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_from (ffi_ref . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , distribution_type : < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_distribution_key :: TokenDistributionType >> :: ffi_to (obj . distribution_type) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . distribution_type) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , distribution_type : * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 { base , distribution_type , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_distribution_type < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { (* obj) . distribution_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_distribution_type < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_distribution_key :: dpp_data_contract_associated_token_token_distribution_key_TokenDistributionType { (* obj) . distribution_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenClaimTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: TokenClaimTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_v0_TokenClaimTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchedTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { Document (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) , Token (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Document (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition :: Token (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_Document_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Document (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_Token_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition :: Token (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) { ferment :: unbox_any (ffi) ; } pub mod token_config_update_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenConfigUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenConfigUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub update_token_configuration_item : * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , update_token_configuration_item : < example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_item :: TokenConfigurationChangeItem >> :: ffi_from (ffi_ref . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: v0 :: TokenConfigUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , update_token_configuration_item : < example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI as ferment :: FFIConversionTo < dpp :: data_contract :: associated_token :: token_configuration_item :: TokenConfigurationChangeItem >> :: ffi_to (obj . update_token_configuration_item) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . update_token_configuration_item) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , update_token_configuration_item : * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0 { base , update_token_configuration_item , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_update_token_configuration_item < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI { (* obj) . update_token_configuration_item } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_update_token_configuration_item < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut example_nested :: custom :: dpp :: TokenConfigurationChangeItemFFI { (* obj) . update_token_configuration_item } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_v0_TokenConfigUpdateTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } pub mod validate_structure { use crate as example_nested ; } } pub mod document_base_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub document_type_name : * mut std :: os :: raw :: c_char , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: v0 :: DocumentBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , document_type_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . document_type_name) , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ferment :: unbox_string (ffi_ref . document_type_name) ; ferment :: unbox_any (ffi_ref . data_contract_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , document_type_name : * mut std :: os :: raw :: c_char , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0 { id , identity_contract_nonce , document_type_name , data_contract_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_document_type_name < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_get_data_contract_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_document_type_name < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . document_type_name } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0_set_data_contract_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_v0_DocumentBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } } pub mod fields { use crate as example_nested ; } } pub mod document_transfer_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub recipient_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , recipient_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_owner_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , recipient_owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_owner_id) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . recipient_owner_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , recipient_owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 { base , revision , recipient_owner_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_get_recipient_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0_set_recipient_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_owner_id } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: DocumentTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: DocumentTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transfer_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_v0_DocumentTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transfer_transition_DocumentTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_replace_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentReplaceTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . data) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 { base , revision , data }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_get_data < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0_set_data < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentReplaceTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: DocumentReplaceTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: DocumentReplaceTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_replace_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_v0_DocumentReplaceTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_replace_transition_DocumentReplaceTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_purchase_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentPurchaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: DocumentPurchaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_DocumentPurchaseTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentPurchaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionFrom < dpp :: balances :: credits :: Credits >> :: ffi_from (ffi_ref . price) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_purchase_transition :: v0 :: DocumentPurchaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , price : < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits as ferment :: FFIConversionTo < dpp :: balances :: credits :: Credits >> :: ffi_to (obj . price) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . price) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , price : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0 { base , revision , price }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_get_price < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_revision < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0_set_price < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_purchase_transition_v0_DocumentPurchaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits { (* obj) . price } } } pub mod document_create_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , pub entropy : * mut crate :: fermented :: generics :: Arr_u8_32 , pub data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub prefunded_voting_balance : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) >> :: ffi_from_opt (ffi_ref . prefunded_voting_balance) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) , entropy : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . entropy) , data : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . data) , prefunded_voting_balance : < crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits as ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) >> :: ffi_to_opt (obj . prefunded_voting_balance) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . entropy) ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any_opt (ffi_ref . prefunded_voting_balance) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition , entropy : * mut crate :: fermented :: generics :: Arr_u8_32 , data : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , prefunded_voting_balance : * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 { base , entropy , data , prefunded_voting_balance }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_entropy < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . entropy } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_data < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_get_prefunded_voting_balance < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits { (* obj) . prefunded_voting_balance } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_entropy < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . entropy } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_data < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0_set_prefunded_voting_balance < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut crate :: fermented :: generics :: Tuple_String_dpp_balances_credits_Credits { (* obj) . prefunded_voting_balance } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: DocumentCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: DocumentCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_create_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_v0_DocumentCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_create_transition_DocumentCreateTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_mint_transition { use crate as example_nested ; pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenMintTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenMintTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub issued_to_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , issued_to_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from_opt (ffi_ref . issued_to_identity_id) , amount : ffi_ref . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: v0 :: TokenMintTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , issued_to_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to_opt (obj . issued_to_identity_id) , amount : obj . amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any_opt (ffi_ref . issued_to_identity_id) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , issued_to_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0 { base , issued_to_identity_id , amount , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_issued_to_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . issued_to_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_issued_to_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . issued_to_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_v0_TokenMintTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } } pub mod document_transition_action_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentTransitionActionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { Create , Replace , Delete , Transfer , Purchase , UpdatePrice , IgnoreWhileBumpingRevision } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Create => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Replace => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Delete => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Transfer => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: Purchase => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: UpdatePrice => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition_action_type :: DocumentTransitionActionType :: IgnoreWhileBumpingRevision => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice => { } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Create_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Create { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Replace_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Replace { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Delete_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Delete { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Transfer_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Transfer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_Purchase_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: Purchase { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_UpdatePrice_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: UpdatePrice { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_IgnoreWhileBumpingRevision_ctor () -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType :: IgnoreWhileBumpingRevision { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_action_type_DocumentTransitionActionType) { ferment :: unbox_any (ffi) ; } } pub mod token_destroy_frozen_funds_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenDestroyFrozenFundsTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) { ferment :: unbox_any (ffi) ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenDestroyFrozenFundsTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: v0 :: TokenDestroyFrozenFundsTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0 { base , frozen_identity_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_frozen_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_frozen_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_v0_TokenDestroyFrozenFundsTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } pub mod validate_structure { use crate as example_nested ; } } pub mod token_burn_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenBurnTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub burn_amount : u64 , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , burn_amount : ffi_ref . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , burn_amount : obj . burn_amount , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , burn_amount : u64 , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 { base , burn_amount , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_burn_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> u64 { (* obj) . burn_amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_burn_amount < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> u64 { (* obj) . burn_amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } pub mod validate_structure { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBurnTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: TokenBurnTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_v0_TokenBurnTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) { ferment :: unbox_any (ffi) ; } } pub mod document_delete_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentDeleteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_from (ffi_ref . base) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: DocumentBaseTransition >> :: ffi_to (obj . base) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 { base }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_base_transition_DocumentBaseTransition { (* obj) . base } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentDeleteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: DocumentDeleteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: DocumentDeleteTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_delete_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_v0_DocumentDeleteTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_delete_transition_DocumentDeleteTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_base_transition { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenBaseTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { pub identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub token_contract_position : u16 , pub data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub using_group_info : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . identity_contract_nonce) , token_contract_position : ffi_ref . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo >> :: ffi_from_opt (ffi_ref . using_group_info) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { identity_contract_nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . identity_contract_nonce) , token_contract_position : obj . token_contract_position , data_contract_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . data_contract_id) , token_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . token_id) , using_group_info : < crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo as ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo >> :: ffi_to_opt (obj . using_group_info) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_contract_nonce) ; ; ferment :: unbox_any (ffi_ref . data_contract_id) ; ferment :: unbox_any (ffi_ref . token_id) ; ferment :: unbox_any_opt (ffi_ref . using_group_info) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_ctor < > (identity_contract_nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , token_contract_position : u16 , data_contract_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , token_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , using_group_info : * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 { identity_contract_nonce , token_contract_position , data_contract_id , token_id , using_group_info }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_token_contract_position < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> u16 { (* obj) . token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_data_contract_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_token_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_get_using_group_info < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo { (* obj) . using_group_info } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_identity_contract_nonce < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . identity_contract_nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_token_contract_position < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> u16 { (* obj) . token_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_data_contract_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . data_contract_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_token_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . token_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0_set_using_group_info < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut crate :: fermented :: types :: dpp :: group :: dpp_group_GroupStateTransitionInfo { (* obj) . using_group_info } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenBaseTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: TokenBaseTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_v0_TokenBaseTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { Burn (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) , Mint (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) , Transfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) , Freeze (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) , Unfreeze (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) , DestroyFrozenFunds (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) , Claim (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) , EmergencyAction (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) , ConfigUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Burn (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: TokenBurnTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Mint (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: TokenMintTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Transfer (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: TokenTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Freeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: TokenFreezeTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Unfreeze (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: DestroyFrozenFunds (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: TokenDestroyFrozenFundsTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: Claim (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: TokenClaimTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: EmergencyAction (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transition :: TokenTransition :: ConfigUpdate (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: TokenConfigUpdateTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Burn_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_burn_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_burn_transition_TokenBurnTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Burn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Mint_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_mint_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_mint_transition_TokenMintTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Mint (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Transfer_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_transfer_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transfer_transition_TokenTransferTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Transfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Freeze_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_freeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_freeze_transition_TokenFreezeTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Freeze (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Unfreeze_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Unfreeze (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_DestroyFrozenFunds_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_destroy_frozen_funds_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_destroy_frozen_funds_transition_TokenDestroyFrozenFundsTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: DestroyFrozenFunds (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_Claim_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_claim_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_claim_transition_TokenClaimTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: Claim (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_EmergencyAction_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: EmergencyAction (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_ConfigUpdate_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_config_update_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_config_update_transition_TokenConfigUpdateTransition) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition :: ConfigUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_transition_TokenTransition) { ferment :: unbox_any (ffi) ; } } pub mod token_emergency_action_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenEmergencyActionTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: TokenEmergencyActionTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_TokenEmergencyActionTransition) { ferment :: unbox_any (ffi) ; } pub mod validate_structure { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenEmergencyActionTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub emergency_action : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionFrom < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_from (ffi_ref . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_emergency_action_transition :: v0 :: TokenEmergencyActionTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , emergency_action : < crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction as ferment :: FFIConversionTo < dpp :: tokens :: emergency_action :: TokenEmergencyAction >> :: ffi_to (obj . emergency_action) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . emergency_action) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , emergency_action : * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0 { base , emergency_action , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_emergency_action < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction { (* obj) . emergency_action } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_emergency_action < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut crate :: fermented :: types :: dpp :: tokens :: emergency_action :: dpp_tokens_emergency_action_TokenEmergencyAction { (* obj) . emergency_action } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_emergency_action_transition_v0_TokenEmergencyActionTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } } pub mod token_unfreeze_transition { use crate as example_nested ; pub mod validate_structure { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`TokenUnfreezeTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { pub base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , pub frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub public_note : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_from (ffi_ref . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . public_note) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { base : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: TokenBaseTransition >> :: ffi_to (obj . base) , frozen_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . frozen_identity_id) , public_note : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . public_note) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . frozen_identity_id) ; ferment :: unbox_any_opt (ffi_ref . public_note) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_ctor < > (base : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition , frozen_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , public_note : * mut std :: os :: raw :: c_char) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 { base , frozen_identity_id , public_note }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_frozen_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_get_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_base < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_base_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_base_transition_TokenBaseTransition { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_frozen_identity_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . frozen_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0_set_public_note < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut std :: os :: raw :: c_char { (* obj) . public_note } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TokenUnfreezeTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition > for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: TokenUnfreezeTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: TokenUnfreezeTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: token_unfreeze_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_v0_TokenUnfreezeTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_batched_transition_token_unfreeze_transition_TokenUnfreezeTransition) { ferment :: unbox_any (ffi) ; } } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`BatchTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 > for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0) -> * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_ctor < > (owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 { owner_id , transitions , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_transitions < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_transitions < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`BatchTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) , V1 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition > for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition) -> * const dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V0 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: BatchTransitionV0 >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition :: V1 (o_0) => dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v0 :: dpp_state_transition_state_transitions_document_batch_transition_v0_BatchTransitionV0) -> * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_BatchTransition :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_BatchTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) { ferment :: unbox_any (ffi) ; } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`BatchTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_from (ffi_ref . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1 > for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: document :: batch_transition :: v1 :: BatchTransitionV1) -> * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , transitions : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > >> :: ffi_to (obj . transitions) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . transitions) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_ctor < > (owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , transitions : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1 { owner_id , transitions , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_destroy < > (ffi : * mut dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_transitions < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_get_signature < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_owner_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_transitions < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { (* obj) . transitions } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1_set_signature < > (obj : * const dpp_state_transition_state_transitions_document_batch_transition_v1_BatchTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } } } pub mod identity { use crate as example_nested ; pub mod public_key_in_creation { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityPublicKeyInCreationV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { pub id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , pub purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , pub security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , pub contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , pub read_only : bool , pub data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . id) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_from (ffi_ref . key_type) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_from (ffi_ref . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_from (ffi_ref . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_from_opt (ffi_ref . contract_bounds) , read_only : ffi_ref . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . data) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 > for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . id) , key_type : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: key_type :: KeyType >> :: ffi_to (obj . key_type) , purpose : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: purpose :: Purpose >> :: ffi_to (obj . purpose) , security_level : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >> :: ffi_to (obj . security_level) , contract_bounds : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: contract_bounds :: ContractBounds >> :: ffi_to_opt (obj . contract_bounds) , read_only : obj . read_only , data : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . data) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . key_type) ; ferment :: unbox_any (ffi_ref . purpose) ; ferment :: unbox_any (ffi_ref . security_level) ; ferment :: unbox_any_opt (ffi_ref . contract_bounds) ; ; ferment :: unbox_any (ffi_ref . data) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_ctor < > (id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , key_type : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType , purpose : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose , security_level : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel , contract_bounds : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds , read_only : bool , data : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 { id , key_type , purpose , security_level , contract_bounds , read_only , data , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_id < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_key_type < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_purpose < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_security_level < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_contract_bounds < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_read_only < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_data < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_id < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_key_type < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: key_type :: dpp_identity_identity_public_key_key_type_KeyType { (* obj) . key_type } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_purpose < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose { (* obj) . purpose } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_security_level < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel { (* obj) . security_level } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_contract_bounds < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: contract_bounds :: dpp_identity_identity_public_key_contract_bounds_ContractBounds { (* obj) . contract_bounds } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_read_only < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> bool { (* obj) . read_only } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_data < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityPublicKeyInCreation`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation) -> * const dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation :: V0 (o_0) => dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: IdentityPublicKeyInCreationV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: v0 :: dpp_state_transition_state_transitions_identity_public_key_in_creation_v0_IdentityPublicKeyInCreationV0) -> * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; pub mod validate_identity_public_keys_structure { use crate as example_nested ; } pub mod duplicated_keys_witness { use crate as example_nested ; } pub mod duplicated_key_ids_witness { use crate as example_nested ; } pub mod hash { use crate as example_nested ; } # [cfg (feature = "state-transition-signing")] pub mod from_public_key_signed_with_private_key { use crate as example_nested ; } # [cfg (feature = "state-transition-signing")] pub mod from_public_key_signed_external { use crate as example_nested ; } } } pub mod identity_create_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { pub public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . public_keys) , asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . public_keys) ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . identity_id) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_ctor < > (public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier) -> * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 { public_keys , asset_lock_proof , user_fee_increase , signature , identity_id }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_asset_lock_proof < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_asset_lock_proof < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition > for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: IdentityCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_create_transition_v0_IdentityCreateTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) { ferment :: unbox_any (ffi) ; } pub mod accessors { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } } pub mod masternode_vote_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeVoteTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pub pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub vote : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionFrom < dpp :: voting :: votes :: Vote >> :: ffi_from (ffi_ref . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pro_tx_hash : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . pro_tx_hash) , voter_identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . voter_identity_id) , vote : < crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote as ferment :: FFIConversionTo < dpp :: voting :: votes :: Vote >> :: ffi_to (obj . vote) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any (ffi_ref . voter_identity_id) ; ferment :: unbox_any (ffi_ref . vote) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_ctor < > (pro_tx_hash : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , voter_identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , vote : * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 { pro_tx_hash , voter_identity_id , vote , nonce , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_pro_tx_hash < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_voter_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_vote < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote { (* obj) . vote } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_pro_tx_hash < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_voter_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . voter_identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_vote < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: voting :: votes :: dpp_voting_votes_Vote { (* obj) . vote } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MasternodeVoteTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) -> dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition > for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition) -> * const dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: MasternodeVoteTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: v0 :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_v0_MasternodeVoteTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; } } pub mod identity_credit_withdrawal_transition { use crate as example_nested ; pub mod accessors { use crate as example_nested ; } pub mod v1 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV1`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from_opt (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to_opt (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any_opt (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , core_fee_per_byte : u32 , pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 { identity_id , amount , core_fee_per_byte , pooling , output_script , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_core_fee_per_byte < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_pooling < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_output_script < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_core_fee_per_byte < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_pooling < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_output_script < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditWithdrawalTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub core_fee_per_byte : u32 , pub pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , pub output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , amount : ffi_ref . amount , core_fee_per_byte : ffi_ref . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionFrom < dpp :: withdrawal :: Pooling >> :: ffi_from (ffi_ref . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionFrom < dpp :: identity :: core_script :: CoreScript >> :: ffi_from (ffi_ref . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , amount : obj . amount , core_fee_per_byte : obj . core_fee_per_byte , pooling : < crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling as ferment :: FFIConversionTo < dpp :: withdrawal :: Pooling >> :: ffi_to (obj . pooling) , output_script : < crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript as ferment :: FFIConversionTo < dpp :: identity :: core_script :: CoreScript >> :: ffi_to (obj . output_script) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ; ; ferment :: unbox_any (ffi_ref . pooling) ; ferment :: unbox_any (ffi_ref . output_script) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , core_fee_per_byte : u32 , pooling : * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling , output_script : * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 { identity_id , amount , core_fee_per_byte , pooling , output_script , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_core_fee_per_byte < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_pooling < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_output_script < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_core_fee_per_byte < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> u32 { (* obj) . core_fee_per_byte } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_pooling < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: withdrawal :: dpp_withdrawal_Pooling { (* obj) . pooling } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_output_script < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: core_script :: dpp_identity_core_script_CoreScript { (* obj) . output_script } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditWithdrawalTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) , V1 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 >> :: ffi_from (* o_0)) , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition > for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: IdentityCreditWithdrawalTransitionV0 >> :: ffi_to (o_0)) , dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition :: V1 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: IdentityCreditWithdrawalTransitionV1 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v0_IdentityCreditWithdrawalTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: v1 :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_v1_IdentityCreditWithdrawalTransitionV1) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition :: V1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; } } pub mod identity_credit_transfer_transition { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod methods { use crate as example_nested ; } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityCreditTransferTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub amount : u64 , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . recipient_id) , amount : ffi_ref . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , recipient_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . recipient_id) , amount : obj . amount , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . recipient_id) ; ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , recipient_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , amount : u64 , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 { identity_id , recipient_id , amount , nonce , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_recipient_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_recipient_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . recipient_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_amount < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> u64 { (* obj) . amount } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod accessors { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityCreditTransferTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition > for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition) -> * const dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: IdentityCreditTransferTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_v0_IdentityCreditTransferTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) { ferment :: unbox_any (ffi) ; } } pub mod identity_topup_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentityTopUpTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { pub asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionFrom < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_from (ffi_ref . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { asset_lock_proof : < crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof as ferment :: FFIConversionTo < dpp :: identity :: state_transition :: asset_lock_proof :: AssetLockProof >> :: ffi_to (obj . asset_lock_proof) , identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . asset_lock_proof) ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_ctor < > (asset_lock_proof : * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof , identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 { asset_lock_proof , identity_id , user_fee_increase , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_asset_lock_proof < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_asset_lock_proof < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: state_transition :: asset_lock_proof :: dpp_identity_state_transition_asset_lock_proof_AssetLockProof { (* obj) . asset_lock_proof } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } pub mod methods { use crate as example_nested ; } pub mod accessors { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityTopUpTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition > for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition) -> * const dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: IdentityTopUpTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_topup_transition_v0_IdentityTopUpTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) { ferment :: unbox_any (ffi) ; } } pub mod common_fields { use crate as example_nested ; } pub mod identity_update_transition { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [cfg (feature = "state-transition-json-conversion")] pub mod json_conversion { use crate as example_nested ; } # [doc = "FFI-representation of the [`IdentityUpdateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { pub identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , pub add_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , pub disable_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID , pub user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , pub signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { let ffi_ref = & * ffi ; dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from (ffi_ref . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce >> :: ffi_from (ffi_ref . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_from (ffi_ref . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_from (ffi_ref . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease >> :: ffi_from (ffi_ref . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (ffi_ref . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 > for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { identity_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . identity_id) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to (obj . revision) , nonce : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce as ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce >> :: ffi_to (obj . nonce) , add_public_keys : < crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation as ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > >> :: ffi_to (obj . add_public_keys) , disable_public_keys : < crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > >> :: ffi_to (obj . disable_public_keys) , user_fee_increase : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease as ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease >> :: ffi_to (obj . user_fee_increase) , signature_public_key_id : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_to (obj . signature_public_key_id) , signature : < crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData as ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData >> :: ffi_to (obj . signature) }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . identity_id) ; ferment :: unbox_any (ffi_ref . revision) ; ferment :: unbox_any (ffi_ref . nonce) ; ferment :: unbox_any (ffi_ref . add_public_keys) ; ferment :: unbox_any (ffi_ref . disable_public_keys) ; ferment :: unbox_any (ffi_ref . user_fee_increase) ; ferment :: unbox_any (ffi_ref . signature_public_key_id) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_ctor < > (identity_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , nonce : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce , add_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation , disable_public_keys : * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID , user_fee_increase : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease , signature_public_key_id : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , signature : * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData) -> * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 { identity_id , revision , nonce , add_public_keys , disable_public_keys , user_fee_increase , signature_public_key_id , signature }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_revision < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_add_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . add_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_disable_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . disable_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_get_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_identity_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . identity_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_revision < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_nonce < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_IdentityNonce { (* obj) . nonce } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_add_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { (* obj) . add_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_disable_public_keys < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: generics :: Vec_dpp_identity_identity_public_key_KeyID { (* obj) . disable_public_keys } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_user_fee_increase < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_UserFeeIncrease { (* obj) . user_fee_increase } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_signature_public_key_id < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID { (* obj) . signature_public_key_id } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0_set_signature < > (obj : * const dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut crate :: fermented :: types :: platform_value :: types :: binary_data :: platform_value_types_binary_data_BinaryData { (* obj) . signature } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`IdentityUpdateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { V0 (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) -> dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition > for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition) -> * const dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { ferment :: boxed (match obj { dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition :: V0 (o_0) => dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0 as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: IdentityUpdateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: v0 :: dpp_state_transition_state_transitions_identity_identity_update_transition_v0_IdentityUpdateTransitionV0) -> * mut dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition { ferment :: boxed (dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition_destroy < > (ffi : * mut dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) { ferment :: unbox_any (ffi) ; } pub mod methods { use crate as example_nested ; } pub mod accessors { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } } } } pub mod serialization { use crate as example_nested ; } pub mod state_transition_types { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransitionType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_state_transition_types_StateTransitionType { DataContractCreate = 0 , Batch = 1 , IdentityCreate = 2 , IdentityTopUp = 3 , DataContractUpdate = 4 , IdentityUpdate = 5 , IdentityCreditWithdrawal = 6 , IdentityCreditTransfer = 7 , MasternodeVote = 8 } impl ferment :: FFIConversionFrom < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_state_transition_types_StateTransitionType) -> dpp :: state_transition :: state_transition_types :: StateTransitionType { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: state_transition_types :: StateTransitionType > for dpp_state_transition_state_transition_types_StateTransitionType { unsafe fn ffi_to_const (obj : dpp :: state_transition :: state_transition_types :: StateTransitionType) -> * const dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (match obj { dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractCreate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: Batch => dpp_state_transition_state_transition_types_StateTransitionType :: Batch , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityTopUp => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp , dpp :: state_transition :: state_transition_types :: StateTransitionType :: DataContractUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityUpdate => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditWithdrawal => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal , dpp :: state_transition :: state_transition_types :: StateTransitionType :: IdentityCreditTransfer => dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer , dpp :: state_transition :: state_transition_types :: StateTransitionType :: MasternodeVote => dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_state_transition_types_StateTransitionType { fn drop (& mut self) { unsafe { match self { dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: Batch => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp => { } , dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal => { } , dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer => { } , dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_DataContractCreate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: DataContractCreate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_Batch_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: Batch { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityTopUp_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityTopUp { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_DataContractUpdate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: DataContractUpdate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityUpdate_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityUpdate { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreditWithdrawal_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditWithdrawal { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_IdentityCreditTransfer_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: IdentityCreditTransfer { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_MasternodeVote_ctor () -> * mut dpp_state_transition_state_transition_types_StateTransitionType { ferment :: boxed (dpp_state_transition_state_transition_types_StateTransitionType :: MasternodeVote { }) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_state_transition_types_StateTransitionType_destroy < > (ffi : * mut dpp_state_transition_state_transition_types_StateTransitionType) { ferment :: unbox_any (ffi) ; } } pub mod traits { use crate as example_nested ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`StateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_state_transition_StateTransition { DataContractCreate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) , DataContractUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) , Batch (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) , IdentityCreate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) , IdentityTopUp (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) , IdentityCreditWithdrawal (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) , IdentityUpdate (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) , IdentityCreditTransfer (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) , MasternodeVote (* mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) } impl ferment :: FFIConversionFrom < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_from_const (ffi : * const dpp_state_transition_StateTransition) -> dpp :: state_transition :: StateTransition { let ffi_ref = & * ffi ; match ffi_ref { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => dpp :: state_transition :: StateTransition :: DataContractCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => dpp :: state_transition :: StateTransition :: DataContractUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: Batch (o_0) => dpp :: state_transition :: StateTransition :: Batch (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => dpp :: state_transition :: StateTransition :: IdentityTopUp (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => dpp :: state_transition :: StateTransition :: IdentityUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition >> :: ffi_from (* o_0)) , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => dpp :: state_transition :: StateTransition :: MasternodeVote (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: state_transition :: StateTransition > for dpp_state_transition_StateTransition { unsafe fn ffi_to_const (obj : dpp :: state_transition :: StateTransition) -> * const dpp_state_transition_StateTransition { ferment :: boxed (match obj { dpp :: state_transition :: StateTransition :: DataContractCreate (o_0) => dpp_state_transition_StateTransition :: DataContractCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: DataContractUpdate (o_0) => dpp_state_transition_StateTransition :: DataContractUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: Batch (o_0) => dpp_state_transition_StateTransition :: Batch (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: BatchTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreate (o_0) => dpp_state_transition_StateTransition :: IdentityCreate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: IdentityCreateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityTopUp (o_0) => dpp_state_transition_StateTransition :: IdentityTopUp (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: IdentityTopUpTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditWithdrawal (o_0) => dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: IdentityCreditWithdrawalTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityUpdate (o_0) => dpp_state_transition_StateTransition :: IdentityUpdate (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: IdentityUpdateTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: IdentityCreditTransfer (o_0) => dpp_state_transition_StateTransition :: IdentityCreditTransfer (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: IdentityCreditTransferTransition >> :: ffi_to (o_0)) , dpp :: state_transition :: StateTransition :: MasternodeVote (o_0) => dpp_state_transition_StateTransition :: MasternodeVote (< crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: MasternodeVoteTransition >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_state_transition_StateTransition { fn drop (& mut self) { unsafe { match self { dpp_state_transition_StateTransition :: DataContractCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: DataContractUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: Batch (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityTopUp (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityUpdate (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_0) => { ferment :: unbox_any (* o_0) ; } , dpp_state_transition_StateTransition :: MasternodeVote (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_DataContractCreate_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: dpp_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: DataContractCreate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_DataContractUpdate_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: DataContractUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_Batch_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: dpp_state_transition_state_transitions_document_batch_transition_BatchTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: Batch (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreate_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_create_transition :: dpp_state_transition_state_transitions_identity_identity_create_transition_IdentityCreateTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityTopUp_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_topup_transition :: dpp_state_transition_state_transitions_identity_identity_topup_transition_IdentityTopUpTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityTopUp (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreditWithdrawal_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_withdrawal_transition :: dpp_state_transition_state_transitions_identity_identity_credit_withdrawal_transition_IdentityCreditWithdrawalTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreditWithdrawal (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityUpdate_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_update_transition :: dpp_state_transition_state_transitions_identity_identity_update_transition_IdentityUpdateTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityUpdate (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_IdentityCreditTransfer_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: identity_credit_transfer_transition :: dpp_state_transition_state_transitions_identity_identity_credit_transfer_transition_IdentityCreditTransferTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: IdentityCreditTransfer (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_MasternodeVote_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: masternode_vote_transition :: dpp_state_transition_state_transitions_identity_masternode_vote_transition_MasternodeVoteTransition) -> * mut dpp_state_transition_StateTransition { ferment :: boxed (dpp_state_transition_StateTransition :: MasternodeVote (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_state_transition_StateTransition_destroy < > (ffi : * mut dpp_state_transition_StateTransition) { ferment :: unbox_any (ffi) ; } } pub mod block { use crate as example_nested ; pub mod extended_block_info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod extended_epoch_info { use crate as example_nested ; } pub mod finalized_epoch_info { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } pub mod block_info { use crate as example_nested ; # [doc = "FFI-representation of the [`BlockInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_block_info_BlockInfo { pub time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , pub height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub core_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch } impl ferment :: FFIConversionFrom < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_from_const (ffi : * const dpp_block_block_info_BlockInfo) -> dpp :: block :: block_info :: BlockInfo { let ffi_ref = & * ffi ; dpp :: block :: block_info :: BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis >> :: ffi_from (ffi_ref . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from (ffi_ref . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from (ffi_ref . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch >> :: ffi_from (ffi_ref . epoch) } } } impl ferment :: FFIConversionTo < dpp :: block :: block_info :: BlockInfo > for dpp_block_block_info_BlockInfo { unsafe fn ffi_to_const (obj : dpp :: block :: block_info :: BlockInfo) -> * const dpp_block_block_info_BlockInfo { ferment :: boxed (dpp_block_block_info_BlockInfo { time_ms : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis as ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis >> :: ffi_to (obj . time_ms) , height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to (obj . height) , core_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to (obj . core_height) , epoch : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch as ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch >> :: ffi_to (obj . epoch) }) } } impl Drop for dpp_block_block_info_BlockInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time_ms) ; ferment :: unbox_any (ffi_ref . height) ; ferment :: unbox_any (ffi_ref . core_height) ; ferment :: unbox_any (ffi_ref . epoch) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_ctor < > (time_ms : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis , height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , core_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , epoch : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch) -> * mut dpp_block_block_info_BlockInfo { ferment :: boxed (dpp_block_block_info_BlockInfo { time_ms , height , core_height , epoch }) } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_destroy < > (ffi : * mut dpp_block_block_info_BlockInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_time_ms < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_height < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_core_height < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . core_height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_get_epoch < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch { (* obj) . epoch } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_time_ms < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_TimestampMillis { (* obj) . time_ms } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_height < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_core_height < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . core_height } # [no_mangle] pub unsafe extern "C" fn dpp_block_block_info_BlockInfo_set_epoch < > (obj : * const dpp_block_block_info_BlockInfo) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_Epoch { (* obj) . epoch } } pub mod epoch { use crate as example_nested ; # [doc = "FFI-representation of the [`EpochIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_EpochIndex (u16) ; impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_EpochIndex) -> dpp :: block :: epoch :: EpochIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex > for dpp_block_epoch_EpochIndex { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: EpochIndex) -> * const dpp_block_epoch_EpochIndex { ferment :: boxed (dpp_block_epoch_EpochIndex (obj)) } } impl Drop for dpp_block_epoch_EpochIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_ctor < > (o_0 : u16) -> * mut dpp_block_epoch_EpochIndex { ferment :: boxed (dpp_block_epoch_EpochIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_destroy < > (ffi : * mut dpp_block_epoch_EpochIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_get_0 < > (obj : * const dpp_block_epoch_EpochIndex) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_EpochIndex_set_0 < > (obj : * const dpp_block_epoch_EpochIndex) -> u16 { (* obj) . 0 } # [doc = "FFI-representation of the [`Epoch`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_block_epoch_Epoch { pub index : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , pub key : * mut crate :: fermented :: generics :: Arr_u8_2 } impl ferment :: FFIConversionFrom < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_from_const (ffi : * const dpp_block_epoch_Epoch) -> dpp :: block :: epoch :: Epoch { let ffi_ref = & * ffi ; dpp :: block :: epoch :: Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionFrom < dpp :: block :: epoch :: EpochIndex >> :: ffi_from (ffi_ref . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionFrom < [u8 ; 2] >> :: ffi_from (ffi_ref . key) } } } impl ferment :: FFIConversionTo < dpp :: block :: epoch :: Epoch > for dpp_block_epoch_Epoch { unsafe fn ffi_to_const (obj : dpp :: block :: epoch :: Epoch) -> * const dpp_block_epoch_Epoch { ferment :: boxed (dpp_block_epoch_Epoch { index : < crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex as ferment :: FFIConversionTo < dpp :: block :: epoch :: EpochIndex >> :: ffi_to (obj . index) , key : < crate :: fermented :: generics :: Arr_u8_2 as ferment :: FFIConversionTo < [u8 ; 2] >> :: ffi_to (obj . key) }) } } impl Drop for dpp_block_epoch_Epoch { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . index) ; ferment :: unbox_any (ffi_ref . key) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_ctor < > (index : * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex , key : * mut crate :: fermented :: generics :: Arr_u8_2) -> * mut dpp_block_epoch_Epoch { ferment :: boxed (dpp_block_epoch_Epoch { index , key }) } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_destroy < > (ffi : * mut dpp_block_epoch_Epoch) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_get_index < > (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_get_key < > (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: generics :: Arr_u8_2 { (* obj) . key } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_set_index < > (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: types :: dpp :: block :: epoch :: dpp_block_epoch_EpochIndex { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dpp_block_epoch_Epoch_set_key < > (obj : * const dpp_block_epoch_Epoch) -> * mut crate :: fermented :: generics :: Arr_u8_2 { (* obj) . key } } } pub mod prelude { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeMultiplier`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_FeeMultiplier (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_from_const (ffi : * const dpp_prelude_FeeMultiplier) -> dpp :: prelude :: FeeMultiplier { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: FeeMultiplier > for dpp_prelude_FeeMultiplier { unsafe fn ffi_to_const (obj : dpp :: prelude :: FeeMultiplier) -> * const dpp_prelude_FeeMultiplier { ferment :: boxed (dpp_prelude_FeeMultiplier (obj)) } } impl Drop for dpp_prelude_FeeMultiplier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_ctor < > (o_0 : u64) -> * mut dpp_prelude_FeeMultiplier { ferment :: boxed (dpp_prelude_FeeMultiplier (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_destroy < > (ffi : * mut dpp_prelude_FeeMultiplier) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_get_0 < > (obj : * const dpp_prelude_FeeMultiplier) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_FeeMultiplier_set_0 < > (obj : * const dpp_prelude_FeeMultiplier) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`BlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_BlockHeight (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_BlockHeight) -> dpp :: prelude :: BlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight > for dpp_prelude_BlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: BlockHeight) -> * const dpp_prelude_BlockHeight { ferment :: boxed (dpp_prelude_BlockHeight (obj)) } } impl Drop for dpp_prelude_BlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_ctor < > (o_0 : u64) -> * mut dpp_prelude_BlockHeight { ferment :: boxed (dpp_prelude_BlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_destroy < > (ffi : * mut dpp_prelude_BlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_get_0 < > (obj : * const dpp_prelude_BlockHeight) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_BlockHeight_set_0 < > (obj : * const dpp_prelude_BlockHeight) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`IdentityNonce`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_IdentityNonce (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_from_const (ffi : * const dpp_prelude_IdentityNonce) -> dpp :: prelude :: IdentityNonce { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: IdentityNonce > for dpp_prelude_IdentityNonce { unsafe fn ffi_to_const (obj : dpp :: prelude :: IdentityNonce) -> * const dpp_prelude_IdentityNonce { ferment :: boxed (dpp_prelude_IdentityNonce (obj)) } } impl Drop for dpp_prelude_IdentityNonce { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_ctor < > (o_0 : u64) -> * mut dpp_prelude_IdentityNonce { ferment :: boxed (dpp_prelude_IdentityNonce (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_destroy < > (ffi : * mut dpp_prelude_IdentityNonce) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_get_0 < > (obj : * const dpp_prelude_IdentityNonce) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_IdentityNonce_set_0 < > (obj : * const dpp_prelude_IdentityNonce) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`TimestampMillisInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillisInterval (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillisInterval) -> dpp :: prelude :: TimestampMillisInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillisInterval > for dpp_prelude_TimestampMillisInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillisInterval) -> * const dpp_prelude_TimestampMillisInterval { ferment :: boxed (dpp_prelude_TimestampMillisInterval (obj)) } } impl Drop for dpp_prelude_TimestampMillisInterval { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_ctor < > (o_0 : u64) -> * mut dpp_prelude_TimestampMillisInterval { ferment :: boxed (dpp_prelude_TimestampMillisInterval (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_destroy < > (ffi : * mut dpp_prelude_TimestampMillisInterval) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_get_0 < > (obj : * const dpp_prelude_TimestampMillisInterval) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillisInterval_set_0 < > (obj : * const dpp_prelude_TimestampMillisInterval) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`EpochInterval`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_EpochInterval (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_from_const (ffi : * const dpp_prelude_EpochInterval) -> dpp :: prelude :: EpochInterval { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: EpochInterval > for dpp_prelude_EpochInterval { unsafe fn ffi_to_const (obj : dpp :: prelude :: EpochInterval) -> * const dpp_prelude_EpochInterval { ferment :: boxed (dpp_prelude_EpochInterval (obj)) } } impl Drop for dpp_prelude_EpochInterval { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_ctor < > (o_0 : u16) -> * mut dpp_prelude_EpochInterval { ferment :: boxed (dpp_prelude_EpochInterval (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_destroy < > (ffi : * mut dpp_prelude_EpochInterval) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_get_0 < > (obj : * const dpp_prelude_EpochInterval) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_EpochInterval_set_0 < > (obj : * const dpp_prelude_EpochInterval) -> u16 { (* obj) . 0 } # [doc = "FFI-representation of the [`Revision`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_Revision (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_from_const (ffi : * const dpp_prelude_Revision) -> dpp :: prelude :: Revision { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: Revision > for dpp_prelude_Revision { unsafe fn ffi_to_const (obj : dpp :: prelude :: Revision) -> * const dpp_prelude_Revision { ferment :: boxed (dpp_prelude_Revision (obj)) } } impl Drop for dpp_prelude_Revision { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_ctor < > (o_0 : u64) -> * mut dpp_prelude_Revision { ferment :: boxed (dpp_prelude_Revision (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_destroy < > (ffi : * mut dpp_prelude_Revision) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_get_0 < > (obj : * const dpp_prelude_Revision) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_Revision_set_0 < > (obj : * const dpp_prelude_Revision) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`RootEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RootEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RootEncryptionKeyIndex) -> dpp :: prelude :: RootEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RootEncryptionKeyIndex > for dpp_prelude_RootEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RootEncryptionKeyIndex) -> * const dpp_prelude_RootEncryptionKeyIndex { ferment :: boxed (dpp_prelude_RootEncryptionKeyIndex (obj)) } } impl Drop for dpp_prelude_RootEncryptionKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_ctor < > (o_0 : u32) -> * mut dpp_prelude_RootEncryptionKeyIndex { ferment :: boxed (dpp_prelude_RootEncryptionKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_destroy < > (ffi : * mut dpp_prelude_RootEncryptionKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_get_0 < > (obj : * const dpp_prelude_RootEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RootEncryptionKeyIndex_set_0 < > (obj : * const dpp_prelude_RootEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [doc = "FFI-representation of the [`DerivationEncryptionKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_DerivationEncryptionKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_DerivationEncryptionKeyIndex) -> dpp :: prelude :: DerivationEncryptionKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: DerivationEncryptionKeyIndex > for dpp_prelude_DerivationEncryptionKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: DerivationEncryptionKeyIndex) -> * const dpp_prelude_DerivationEncryptionKeyIndex { ferment :: boxed (dpp_prelude_DerivationEncryptionKeyIndex (obj)) } } impl Drop for dpp_prelude_DerivationEncryptionKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_ctor < > (o_0 : u32) -> * mut dpp_prelude_DerivationEncryptionKeyIndex { ferment :: boxed (dpp_prelude_DerivationEncryptionKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_destroy < > (ffi : * mut dpp_prelude_DerivationEncryptionKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_get_0 < > (obj : * const dpp_prelude_DerivationEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_DerivationEncryptionKeyIndex_set_0 < > (obj : * const dpp_prelude_DerivationEncryptionKeyIndex) -> u32 { (* obj) . 0 } # [doc = "FFI-representation of the [`StartAtIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_StartAtIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_StartAtIncluded) -> dpp :: prelude :: StartAtIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: StartAtIncluded > for dpp_prelude_StartAtIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: StartAtIncluded) -> * const dpp_prelude_StartAtIncluded { ferment :: boxed (dpp_prelude_StartAtIncluded (obj)) } } impl Drop for dpp_prelude_StartAtIncluded { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_ctor < > (o_0 : bool) -> * mut dpp_prelude_StartAtIncluded { ferment :: boxed (dpp_prelude_StartAtIncluded (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_destroy < > (ffi : * mut dpp_prelude_StartAtIncluded) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_get_0 < > (obj : * const dpp_prelude_StartAtIncluded) -> bool { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_StartAtIncluded_set_0 < > (obj : * const dpp_prelude_StartAtIncluded) -> bool { (* obj) . 0 } # [doc = "FFI-representation of the [`TimestampIncluded`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampIncluded (bool) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampIncluded) -> dpp :: prelude :: TimestampIncluded { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampIncluded > for dpp_prelude_TimestampIncluded { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampIncluded) -> * const dpp_prelude_TimestampIncluded { ferment :: boxed (dpp_prelude_TimestampIncluded (obj)) } } impl Drop for dpp_prelude_TimestampIncluded { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_ctor < > (o_0 : bool) -> * mut dpp_prelude_TimestampIncluded { ferment :: boxed (dpp_prelude_TimestampIncluded (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_destroy < > (ffi : * mut dpp_prelude_TimestampIncluded) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_get_0 < > (obj : * const dpp_prelude_TimestampIncluded) -> bool { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampIncluded_set_0 < > (obj : * const dpp_prelude_TimestampIncluded) -> bool { (* obj) . 0 } # [doc = "FFI-representation of the [`UserFeeIncrease`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_UserFeeIncrease (u16) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_from_const (ffi : * const dpp_prelude_UserFeeIncrease) -> dpp :: prelude :: UserFeeIncrease { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: UserFeeIncrease > for dpp_prelude_UserFeeIncrease { unsafe fn ffi_to_const (obj : dpp :: prelude :: UserFeeIncrease) -> * const dpp_prelude_UserFeeIncrease { ferment :: boxed (dpp_prelude_UserFeeIncrease (obj)) } } impl Drop for dpp_prelude_UserFeeIncrease { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_ctor < > (o_0 : u16) -> * mut dpp_prelude_UserFeeIncrease { ferment :: boxed (dpp_prelude_UserFeeIncrease (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_destroy < > (ffi : * mut dpp_prelude_UserFeeIncrease) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_get_0 < > (obj : * const dpp_prelude_UserFeeIncrease) -> u16 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_UserFeeIncrease_set_0 < > (obj : * const dpp_prelude_UserFeeIncrease) -> u16 { (* obj) . 0 } # [doc = "FFI-representation of the [`RecipientKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_RecipientKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_RecipientKeyIndex) -> dpp :: prelude :: RecipientKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: RecipientKeyIndex > for dpp_prelude_RecipientKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: RecipientKeyIndex) -> * const dpp_prelude_RecipientKeyIndex { ferment :: boxed (dpp_prelude_RecipientKeyIndex (obj)) } } impl Drop for dpp_prelude_RecipientKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_ctor < > (o_0 : u32) -> * mut dpp_prelude_RecipientKeyIndex { ferment :: boxed (dpp_prelude_RecipientKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_destroy < > (ffi : * mut dpp_prelude_RecipientKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_get_0 < > (obj : * const dpp_prelude_RecipientKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_RecipientKeyIndex_set_0 < > (obj : * const dpp_prelude_RecipientKeyIndex) -> u32 { (* obj) . 0 } # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dpp_prelude_CoreBlockHeight) -> dpp :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight > for dpp_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dpp :: prelude :: CoreBlockHeight) -> * const dpp_prelude_CoreBlockHeight { ferment :: boxed (dpp_prelude_CoreBlockHeight (obj)) } } impl Drop for dpp_prelude_CoreBlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_ctor < > (o_0 : u32) -> * mut dpp_prelude_CoreBlockHeight { ferment :: boxed (dpp_prelude_CoreBlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_destroy < > (ffi : * mut dpp_prelude_CoreBlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_get_0 < > (obj : * const dpp_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_CoreBlockHeight_set_0 < > (obj : * const dpp_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } # [doc = "FFI-representation of the [`TimestampMillis`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_TimestampMillis (u64) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_from_const (ffi : * const dpp_prelude_TimestampMillis) -> dpp :: prelude :: TimestampMillis { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: TimestampMillis > for dpp_prelude_TimestampMillis { unsafe fn ffi_to_const (obj : dpp :: prelude :: TimestampMillis) -> * const dpp_prelude_TimestampMillis { ferment :: boxed (dpp_prelude_TimestampMillis (obj)) } } impl Drop for dpp_prelude_TimestampMillis { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_ctor < > (o_0 : u64) -> * mut dpp_prelude_TimestampMillis { ferment :: boxed (dpp_prelude_TimestampMillis (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_destroy < > (ffi : * mut dpp_prelude_TimestampMillis) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_get_0 < > (obj : * const dpp_prelude_TimestampMillis) -> u64 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_TimestampMillis_set_0 < > (obj : * const dpp_prelude_TimestampMillis) -> u64 { (* obj) . 0 } # [doc = "FFI-representation of the [`SenderKeyIndex`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_prelude_SenderKeyIndex (u32) ; impl ferment :: FFIConversionFrom < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_from_const (ffi : * const dpp_prelude_SenderKeyIndex) -> dpp :: prelude :: SenderKeyIndex { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dpp :: prelude :: SenderKeyIndex > for dpp_prelude_SenderKeyIndex { unsafe fn ffi_to_const (obj : dpp :: prelude :: SenderKeyIndex) -> * const dpp_prelude_SenderKeyIndex { ferment :: boxed (dpp_prelude_SenderKeyIndex (obj)) } } impl Drop for dpp_prelude_SenderKeyIndex { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_ctor < > (o_0 : u32) -> * mut dpp_prelude_SenderKeyIndex { ferment :: boxed (dpp_prelude_SenderKeyIndex (o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_destroy < > (ffi : * mut dpp_prelude_SenderKeyIndex) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_get_0 < > (obj : * const dpp_prelude_SenderKeyIndex) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dpp_prelude_SenderKeyIndex_set_0 < > (obj : * const dpp_prelude_SenderKeyIndex) -> u32 { (* obj) . 0 } } pub mod document { use crate as example_nested ; pub mod fields { use crate as example_nested ; } pub mod serialization_traits { use crate as example_nested ; # [cfg (feature = "document-value-conversion")] pub mod platform_value_conversion { use crate as example_nested ; } # [cfg (feature = "document-cbor-conversion")] pub mod cbor_conversion { use crate as example_nested ; } pub mod platform_serialization_conversion { use crate as example_nested ; pub mod deserialize { use crate as example_nested ; } pub mod serialize { use crate as example_nested ; } } # [cfg (feature = "document-json-conversion")] pub mod json_conversion { use crate as example_nested ; } } # [cfg (feature = "factories")] pub mod specialized_document_factory { use crate as example_nested ; } pub mod document_methods { use crate as example_nested ; pub mod get_raw_for_document_type { use crate as example_nested ; } pub mod get_raw_for_contract { use crate as example_nested ; } pub mod is_equal_ignoring_timestamps { use crate as example_nested ; } pub mod hash { use crate as example_nested ; } } # [cfg (feature = "factories")] pub mod document_factory { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Document`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_Document { V0 (* mut crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0) } impl ferment :: FFIConversionFrom < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_from_const (ffi : * const dpp_document_Document) -> dpp :: document :: Document { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_Document :: V0 (o_0) => dpp :: document :: Document :: V0 (< crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0 as ferment :: FFIConversionFrom < dpp :: document :: v0 :: DocumentV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dpp :: document :: Document > for dpp_document_Document { unsafe fn ffi_to_const (obj : dpp :: document :: Document) -> * const dpp_document_Document { ferment :: boxed (match obj { dpp :: document :: Document :: V0 (o_0) => dpp_document_Document :: V0 (< crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0 as ferment :: FFIConversionTo < dpp :: document :: v0 :: DocumentV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_Document { fn drop (& mut self) { unsafe { match self { dpp_document_Document :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_Document_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: dpp :: document :: v0 :: dpp_document_v0_DocumentV0) -> * mut dpp_document_Document { ferment :: boxed (dpp_document_Document :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_document_Document_destroy < > (ffi : * mut dpp_document_Document) { ferment :: unbox_any (ffi) ; } pub mod accessors { use crate as example_nested ; } # [cfg (feature = "extended-document")] pub mod extended_document { use crate as example_nested ; pub mod v0 { use crate as example_nested ; } pub mod fields { use crate as example_nested ; } } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentV0`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_document_v0_DocumentV0 { pub id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub properties : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , pub revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , pub created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub transferred_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , pub created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub transferred_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , pub created_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub updated_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , pub transferred_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight } impl ferment :: FFIConversionFrom < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_from_const (ffi : * const dpp_document_v0_DocumentV0) -> dpp :: document :: v0 :: DocumentV0 { let ffi_ref = & * ffi ; dpp :: document :: v0 :: DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_from (ffi_ref . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionFrom < dpp :: prelude :: Revision >> :: ffi_from_opt (ffi_ref . revision) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . updated_at) , transferred_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_from_opt (ffi_ref . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: BlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dpp :: prelude :: CoreBlockHeight >> :: ffi_from_opt (ffi_ref . transferred_at_core_block_height) } } } impl ferment :: FFIConversionTo < dpp :: document :: v0 :: DocumentV0 > for dpp_document_v0_DocumentV0 { unsafe fn ffi_to_const (obj : dpp :: document :: v0 :: DocumentV0) -> * const dpp_document_v0_DocumentV0 { ferment :: boxed (dpp_document_v0_DocumentV0 { id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . id) , owner_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . owner_id) , properties : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > >> :: ffi_to (obj . properties) , revision : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision as ferment :: FFIConversionTo < dpp :: prelude :: Revision >> :: ffi_to_opt (obj . revision) , created_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . created_at) , updated_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . updated_at) , transferred_at : < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: TimestampMillis >> :: ffi_to_opt (obj . transferred_at) , created_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . created_at_block_height) , updated_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . updated_at_block_height) , transferred_at_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: BlockHeight >> :: ffi_to_opt (obj . transferred_at_block_height) , created_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . created_at_core_block_height) , updated_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . updated_at_core_block_height) , transferred_at_core_block_height : < crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dpp :: prelude :: CoreBlockHeight >> :: ffi_to_opt (obj . transferred_at_core_block_height) }) } } impl Drop for dpp_document_v0_DocumentV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . id) ; ferment :: unbox_any (ffi_ref . owner_id) ; ferment :: unbox_any (ffi_ref . properties) ; ferment :: unbox_any_opt (ffi_ref . revision) ; ferment :: unbox_any_opt (ffi_ref . created_at) ; ferment :: unbox_any_opt (ffi_ref . updated_at) ; ferment :: unbox_any_opt (ffi_ref . transferred_at) ; ferment :: unbox_any_opt (ffi_ref . created_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_block_height) ; ferment :: unbox_any_opt (ffi_ref . created_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . updated_at_core_block_height) ; ferment :: unbox_any_opt (ffi_ref . transferred_at_core_block_height) ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_ctor < > (id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , owner_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , properties : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value , revision : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision , created_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , updated_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , transferred_at : * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis , created_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , updated_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , transferred_at_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight , created_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , updated_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight , transferred_at_core_block_height : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight) -> * mut dpp_document_v0_DocumentV0 { ferment :: boxed (dpp_document_v0_DocumentV0 { id , owner_id , properties , revision , created_at , updated_at , transferred_at , created_at_block_height , updated_at_block_height , transferred_at_block_height , created_at_core_block_height , updated_at_core_block_height , transferred_at_core_block_height }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_destroy < > (ffi : * mut dpp_document_v0_DocumentV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_id < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_owner_id < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_properties < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_revision < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . transferred_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . transferred_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_created_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . created_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_updated_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . updated_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_get_transferred_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . transferred_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_id < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_owner_id < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . owner_id } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_properties < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_platform_value_Value { (* obj) . properties } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_revision < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_Revision { (* obj) . revision } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . created_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . updated_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_TimestampMillis { (* obj) . transferred_at } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . created_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . updated_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_BlockHeight { (* obj) . transferred_at_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_created_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . created_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_updated_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . updated_at_core_block_height } # [no_mangle] pub unsafe extern "C" fn dpp_document_v0_DocumentV0_set_transferred_at_core_block_height < > (obj : * const dpp_document_v0_DocumentV0) -> * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_CoreBlockHeight { (* obj) . transferred_at_core_block_height } } pub mod transfer { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Transferable`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_transfer_Transferable { Never = 0 , Always = 1 } impl ferment :: FFIConversionFrom < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_from_const (ffi : * const dpp_document_transfer_Transferable) -> dpp :: document :: transfer :: Transferable { let ffi_ref = & * ffi ; match ffi_ref { dpp_document_transfer_Transferable :: Never => dpp :: document :: transfer :: Transferable :: Never , dpp_document_transfer_Transferable :: Always => dpp :: document :: transfer :: Transferable :: Always } } } impl ferment :: FFIConversionTo < dpp :: document :: transfer :: Transferable > for dpp_document_transfer_Transferable { unsafe fn ffi_to_const (obj : dpp :: document :: transfer :: Transferable) -> * const dpp_document_transfer_Transferable { ferment :: boxed (match obj { dpp :: document :: transfer :: Transferable :: Never => dpp_document_transfer_Transferable :: Never , dpp :: document :: transfer :: Transferable :: Always => dpp_document_transfer_Transferable :: Always , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_transfer_Transferable { fn drop (& mut self) { unsafe { match self { dpp_document_transfer_Transferable :: Never => { } , dpp_document_transfer_Transferable :: Always => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_Never_ctor () -> * mut dpp_document_transfer_Transferable { ferment :: boxed (dpp_document_transfer_Transferable :: Never { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_Always_ctor () -> * mut dpp_document_transfer_Transferable { ferment :: boxed (dpp_document_transfer_Transferable :: Always { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_transfer_Transferable_destroy < > (ffi : * mut dpp_document_transfer_Transferable) { ferment :: unbox_any (ffi) ; } } pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dpp_document_errors_DocumentError { # [cfg (feature = "state-transitions")] DocumentAlreadyExistsError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , # [cfg (feature = "state-transitions")] DocumentNotProvidedError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidActionError (u8) , InvalidActionNameError { actions : * mut crate :: fermented :: generics :: Vec_String } , # [cfg (feature = "state-transitions")] InvalidDocumentActionError { document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } , InvalidDocumentError { errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_document : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } , InvalidInitialRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , RevisionAbsentError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToReplaceImmutableDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , TryingToDeleteIndelibleDocument { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , MismatchOwnerIdsError { documents : * mut crate :: fermented :: generics :: Vec_dpp_document_Document } , DocumentNoRevisionError { document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } , NoDocumentsSuppliedError } impl ferment :: FFIConversionFrom < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_from_const (ffi : * const dpp_document_errors_DocumentError) -> dpp :: document :: errors :: DocumentError { let ffi_ref = & * ffi ; match ffi_ref { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => dpp :: document :: errors :: DocumentError :: InvalidActionError (* o_0) , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* actions) } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_from (* document_transition) } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_from (* errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (* raw_document) } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > >> :: ffi_from (* documents) } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document : Box :: new (< crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from (* document)) } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError } } } impl ferment :: FFIConversionTo < dpp :: document :: errors :: DocumentError > for dpp_document_errors_DocumentError { unsafe fn ffi_to_const (obj : dpp :: document :: errors :: DocumentError) -> * const dpp_document_errors_DocumentError { ferment :: boxed (match obj { # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentAlreadyExistsError { document_transition } => dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: DocumentNotProvidedError { document_transition } => dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidActionError (o_0) => dpp_document_errors_DocumentError :: InvalidActionError (o_0) , dpp :: document :: errors :: DocumentError :: InvalidActionNameError { actions } => dpp_document_errors_DocumentError :: InvalidActionNameError { actions : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (actions) } , # [cfg (feature = "state-transitions")] dpp :: document :: errors :: DocumentError :: InvalidDocumentActionError { document_transition } => dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition : < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition as ferment :: FFIConversionTo < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >> :: ffi_to (document_transition) } , dpp :: document :: errors :: DocumentError :: InvalidDocumentError { errors , raw_document } => dpp_document_errors_DocumentError :: InvalidDocumentError { errors : < crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError as ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > >> :: ffi_to (errors) , raw_document : < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionTo < platform_value :: Value >> :: ffi_to (raw_document) } , dpp :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document } => dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: RevisionAbsentError { document } => dpp_document_errors_DocumentError :: RevisionAbsentError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToReplaceImmutableDocument { document } => dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: TryingToDeleteIndelibleDocument { document } => dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: MismatchOwnerIdsError { documents } => dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents : < crate :: fermented :: generics :: Vec_dpp_document_Document as ferment :: FFIConversionTo < Vec < dpp :: document :: Document > >> :: ffi_to (documents) } , dpp :: document :: errors :: DocumentError :: DocumentNoRevisionError { document } => dpp_document_errors_DocumentError :: DocumentNoRevisionError { document : < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionTo < dpp :: document :: Document >> :: ffi_to (* document) } , dpp :: document :: errors :: DocumentError :: NoDocumentsSuppliedError => dpp_document_errors_DocumentError :: NoDocumentsSuppliedError , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dpp_document_errors_DocumentError { fn drop (& mut self) { unsafe { match self { # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidActionError (o_0) => { ; } , dpp_document_errors_DocumentError :: InvalidActionNameError { actions } => { ferment :: unbox_any (* actions) ; } , # [cfg (feature = "state-transitions")] dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition } => { ferment :: unbox_any (* document_transition) ; } , dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document } => { ferment :: unbox_any (* errors) ; ; ferment :: unbox_any (* raw_document) ; } , dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: RevisionAbsentError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents } => { ferment :: unbox_any (* documents) ; } , dpp_document_errors_DocumentError :: DocumentNoRevisionError { document } => { ferment :: unbox_any (* document) ; } , dpp_document_errors_DocumentError :: NoDocumentsSuppliedError => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentAlreadyExistsError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentAlreadyExistsError { document_transition }) } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentNotProvidedError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentNotProvidedError { document_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidActionError_ctor (o_o_0 : u8) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidActionNameError_ctor (actions : * mut crate :: fermented :: generics :: Vec_String) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidActionNameError { actions }) } # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidDocumentActionError_ctor (document_transition : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidDocumentActionError { document_transition }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidDocumentError_ctor (errors : * mut crate :: fermented :: generics :: Vec_dpp_errors_consensus_consensus_error_ConsensusError , raw_document : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidDocumentError { errors , raw_document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_InvalidInitialRevisionError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: InvalidInitialRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_RevisionAbsentError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: RevisionAbsentError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_TryingToReplaceImmutableDocument_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: TryingToReplaceImmutableDocument { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_TryingToDeleteIndelibleDocument_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: TryingToDeleteIndelibleDocument { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_MismatchOwnerIdsError_ctor (documents : * mut crate :: fermented :: generics :: Vec_dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: MismatchOwnerIdsError { documents }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_DocumentNoRevisionError_ctor (document : * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: DocumentNoRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_NoDocumentsSuppliedError_ctor () -> * mut dpp_document_errors_DocumentError { ferment :: boxed (dpp_document_errors_DocumentError :: NoDocumentsSuppliedError { }) } # [no_mangle] pub unsafe extern "C" fn dpp_document_errors_DocumentError_destroy < > (ffi : * mut dpp_document_errors_DocumentError) { ferment :: unbox_any (ffi) ; } } } pub mod group { use crate as example_nested ; # [doc = "FFI-representation of the [`GroupStateTransitionInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dpp_group_GroupStateTransitionInfo { pub group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub action_is_proposer : bool } impl ferment :: FFIConversionFrom < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_from_const (ffi : * const dpp_group_GroupStateTransitionInfo) -> dpp :: group :: GroupStateTransitionInfo { let ffi_ref = & * ffi ; dpp :: group :: GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (ffi_ref . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (ffi_ref . action_id) , action_is_proposer : ffi_ref . action_is_proposer } } } impl ferment :: FFIConversionTo < dpp :: group :: GroupStateTransitionInfo > for dpp_group_GroupStateTransitionInfo { unsafe fn ffi_to_const (obj : dpp :: group :: GroupStateTransitionInfo) -> * const dpp_group_GroupStateTransitionInfo { ferment :: boxed (dpp_group_GroupStateTransitionInfo { group_contract_position : < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionTo < dpp :: data_contract :: GroupContractPosition >> :: ffi_to (obj . group_contract_position) , action_id : < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier >> :: ffi_to (obj . action_id) , action_is_proposer : obj . action_is_proposer }) } } impl Drop for dpp_group_GroupStateTransitionInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . group_contract_position) ; ferment :: unbox_any (ffi_ref . action_id) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_ctor < > (group_contract_position : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , action_id : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , action_is_proposer : bool) -> * mut dpp_group_GroupStateTransitionInfo { ferment :: boxed (dpp_group_GroupStateTransitionInfo { group_contract_position , action_id , action_is_proposer }) } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_destroy < > (ffi : * mut dpp_group_GroupStateTransitionInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_group_contract_position < > (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_action_id < > (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_get_action_is_proposer < > (obj : * const dpp_group_GroupStateTransitionInfo) -> bool { (* obj) . action_is_proposer } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_group_contract_position < > (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition { (* obj) . group_contract_position } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_action_id < > (obj : * const dpp_group_GroupStateTransitionInfo) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier { (* obj) . action_id } # [no_mangle] pub unsafe extern "C" fn dpp_group_GroupStateTransitionInfo_set_action_is_proposer < > (obj : * const dpp_group_GroupStateTransitionInfo) -> bool { (* obj) . action_is_proposer } pub mod group_action { use crate as example_nested ; } } } pub mod platform_value { use crate as example_nested ; pub mod btreemap_extensions { use crate as example_nested ; } pub mod index { use crate as example_nested ; } pub mod types { use crate as example_nested ; pub mod binary_data { use crate as example_nested ; # [doc = "FFI-representation of the [`BinaryData`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_binary_data_BinaryData (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_from_const (ffi : * const platform_value_types_binary_data_BinaryData) -> platform_value :: types :: binary_data :: BinaryData { let ffi_ref = & * ffi ; platform_value :: types :: binary_data :: BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: binary_data :: BinaryData > for platform_value_types_binary_data_BinaryData { unsafe fn ffi_to_const (obj : platform_value :: types :: binary_data :: BinaryData) -> * const platform_value_types_binary_data_BinaryData { ferment :: boxed (platform_value_types_binary_data_BinaryData (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_binary_data_BinaryData { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_ctor < > (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_types_binary_data_BinaryData { ferment :: boxed (platform_value_types_binary_data_BinaryData (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_destroy < > (ffi : * mut platform_value_types_binary_data_BinaryData) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_get_0 < > (obj : * const platform_value_types_binary_data_BinaryData) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_binary_data_BinaryData_set_0 < > (obj : * const platform_value_types_binary_data_BinaryData) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } } pub mod bytes_32 { use crate as example_nested ; # [doc = "FFI-representation of the [`Bytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_32_Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_32_Bytes32) -> platform_value :: types :: bytes_32 :: Bytes32 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_32 :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_32 :: Bytes32 > for platform_value_types_bytes_32_Bytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_32 :: Bytes32) -> * const platform_value_types_bytes_32_Bytes32 { ferment :: boxed (platform_value_types_bytes_32_Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_32_Bytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_types_bytes_32_Bytes32 { ferment :: boxed (platform_value_types_bytes_32_Bytes32 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_destroy < > (ffi : * mut platform_value_types_bytes_32_Bytes32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_get_0 < > (obj : * const platform_value_types_bytes_32_Bytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_32_Bytes32_set_0 < > (obj : * const platform_value_types_bytes_32_Bytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } } pub mod identifier { use crate as example_nested ; # [doc = "FFI-representation of the [`IdentifierBytes32`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_IdentifierBytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_IdentifierBytes32) -> platform_value :: types :: identifier :: IdentifierBytes32 { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 > for platform_value_types_identifier_IdentifierBytes32 { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: IdentifierBytes32) -> * const platform_value_types_identifier_IdentifierBytes32 { ferment :: boxed (platform_value_types_identifier_IdentifierBytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_IdentifierBytes32 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_types_identifier_IdentifierBytes32 { ferment :: boxed (platform_value_types_identifier_IdentifierBytes32 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_destroy < > (ffi : * mut platform_value_types_identifier_IdentifierBytes32) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_get_0 < > (obj : * const platform_value_types_identifier_IdentifierBytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_IdentifierBytes32_set_0 < > (obj : * const platform_value_types_identifier_IdentifierBytes32) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [doc = "FFI-representation of the [`Identifier`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_identifier_Identifier (* mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) ; impl ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_from_const (ffi : * const platform_value_types_identifier_Identifier) -> platform_value :: types :: identifier :: Identifier { let ffi_ref = & * ffi ; platform_value :: types :: identifier :: Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: identifier :: Identifier > for platform_value_types_identifier_Identifier { unsafe fn ffi_to_const (obj : platform_value :: types :: identifier :: Identifier) -> * const platform_value_types_identifier_Identifier { ferment :: boxed (platform_value_types_identifier_Identifier (< crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 as ferment :: FFIConversionTo < platform_value :: types :: identifier :: IdentifierBytes32 >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_identifier_Identifier { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_ctor < > (o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32) -> * mut platform_value_types_identifier_Identifier { ferment :: boxed (platform_value_types_identifier_Identifier (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_destroy < > (ffi : * mut platform_value_types_identifier_Identifier) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_get_0 < > (obj : * const platform_value_types_identifier_Identifier) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_identifier_Identifier_set_0 < > (obj : * const platform_value_types_identifier_Identifier) -> * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_IdentifierBytes32 { (* obj) . 0 } } pub mod bytes_20 { use crate as example_nested ; # [doc = "FFI-representation of the [`Bytes20`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_types_bytes_20_Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) ; impl ferment :: FFIConversionFrom < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_from_const (ffi : * const platform_value_types_bytes_20_Bytes20) -> platform_value :: types :: bytes_20 :: Bytes20 { let ffi_ref = & * ffi ; platform_value :: types :: bytes_20 :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < platform_value :: types :: bytes_20 :: Bytes20 > for platform_value_types_bytes_20_Bytes20 { unsafe fn ffi_to_const (obj : platform_value :: types :: bytes_20 :: Bytes20) -> * const platform_value_types_bytes_20_Bytes20 { ferment :: boxed (platform_value_types_bytes_20_Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (obj . 0))) } } impl Drop for platform_value_types_bytes_20_Bytes20 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_20) -> * mut platform_value_types_bytes_20_Bytes20 { ferment :: boxed (platform_value_types_bytes_20_Bytes20 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_destroy < > (ffi : * mut platform_value_types_bytes_20_Bytes20) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_get_0 < > (obj : * const platform_value_types_bytes_20_Bytes20) -> * mut crate :: fermented :: generics :: Arr_u8_20 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_types_bytes_20_Bytes20_set_0 < > (obj : * const platform_value_types_bytes_20_Bytes20) -> * mut crate :: fermented :: generics :: Arr_u8_20 { (* obj) . 0 } } } pub mod macros { use crate as example_nested ; } pub mod converter { use crate as example_nested ; # [cfg (feature = "json")] pub mod serde_json { use crate as example_nested ; } } # [doc = "FFI-representation of the [`Hash256`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_Hash256 (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_from_const (ffi : * const platform_value_Hash256) -> platform_value :: Hash256 { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: Hash256 > for platform_value_Hash256 { unsafe fn ffi_to_const (obj : platform_value :: Hash256) -> * const platform_value_Hash256 { ferment :: boxed (platform_value_Hash256 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj))) } } impl Drop for platform_value_Hash256 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_Hash256 { ferment :: boxed (platform_value_Hash256 (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_destroy < > (ffi : * mut platform_value_Hash256) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_get_0 < > (obj : * const platform_value_Hash256) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_Hash256_set_0 < > (obj : * const platform_value_Hash256) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } pub mod inner_value_at_path { use crate as example_nested ; # [cfg (test)] pub mod tests { use crate as example_nested ; } } pub mod patch { use crate as example_nested ; pub mod diff { use crate as example_nested ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Value`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_Value { U128 (* mut [u8 ; 16]) , I128 (* mut [u8 ; 16]) , U64 (u64) , I64 (i64) , U32 (u32) , I32 (i32) , U16 (u16) , I16 (i16) , U8 (u8) , I8 (i8) , Bytes (* mut crate :: fermented :: generics :: Vec_u8) , Bytes20 (* mut crate :: fermented :: generics :: Arr_u8_20) , Bytes32 (* mut crate :: fermented :: generics :: Arr_u8_32) , Bytes36 (* mut crate :: fermented :: generics :: Arr_u8_36) , EnumU8 (* mut crate :: fermented :: generics :: Vec_u8) , EnumString (* mut crate :: fermented :: generics :: Vec_String) , Identifier (* mut crate :: fermented :: types :: platform_value :: platform_value_Hash256) , Float (f64) , Text (* mut std :: os :: raw :: c_char) , Bool (bool) , Null , Array (* mut crate :: fermented :: generics :: Vec_platform_value_Value) , Map (* mut crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap) } impl ferment :: FFIConversionFrom < platform_value :: Value > for platform_value_Value { unsafe fn ffi_from_const (ffi : * const platform_value_Value) -> platform_value :: Value { let ffi_ref = & * ffi ; match ffi_ref { platform_value_Value :: U128 (o_0) => platform_value :: Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (* o_0)) , platform_value_Value :: I128 (o_0) => platform_value :: Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (* o_0)) , platform_value_Value :: U64 (o_0) => platform_value :: Value :: U64 (* o_0) , platform_value_Value :: I64 (o_0) => platform_value :: Value :: I64 (* o_0) , platform_value_Value :: U32 (o_0) => platform_value :: Value :: U32 (* o_0) , platform_value_Value :: I32 (o_0) => platform_value :: Value :: I32 (* o_0) , platform_value_Value :: U16 (o_0) => platform_value :: Value :: U16 (* o_0) , platform_value_Value :: I16 (o_0) => platform_value :: Value :: I16 (* o_0) , platform_value_Value :: U8 (o_0) => platform_value :: Value :: U8 (* o_0) , platform_value_Value :: I8 (o_0) => platform_value :: Value :: I8 (* o_0) , platform_value_Value :: Bytes (o_0) => platform_value :: Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes20 (o_0) => platform_value :: Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionFrom < [u8 ; 20] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes32 (o_0) => platform_value :: Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o_0)) , platform_value_Value :: Bytes36 (o_0) => platform_value :: Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionFrom < [u8 ; 36] >> :: ffi_from (* o_0)) , platform_value_Value :: EnumU8 (o_0) => platform_value :: Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (* o_0)) , platform_value_Value :: EnumString (o_0) => platform_value :: Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (* o_0)) , platform_value_Value :: Identifier (o_0) => platform_value :: Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionFrom < platform_value :: Hash256 >> :: ffi_from (* o_0)) , platform_value_Value :: Float (o_0) => platform_value :: Value :: Float (* o_0) , platform_value_Value :: Text (o_0) => platform_value :: Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_Value :: Bool (o_0) => platform_value :: Value :: Bool (* o_0) , platform_value_Value :: Null => platform_value :: Value :: Null , platform_value_Value :: Array (o_0) => platform_value :: Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionFrom < Vec < platform_value :: Value > >> :: ffi_from (* o_0)) , platform_value_Value :: Map (o_0) => platform_value :: Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: Value > for platform_value_Value { unsafe fn ffi_to_const (obj : platform_value :: Value) -> * const platform_value_Value { ferment :: boxed (match obj { platform_value :: Value :: U128 (o_0) => platform_value_Value :: U128 (< [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (o_0)) , platform_value :: Value :: I128 (o_0) => platform_value_Value :: I128 (< [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (o_0)) , platform_value :: Value :: U64 (o_0) => platform_value_Value :: U64 (o_0) , platform_value :: Value :: I64 (o_0) => platform_value_Value :: I64 (o_0) , platform_value :: Value :: U32 (o_0) => platform_value_Value :: U32 (o_0) , platform_value :: Value :: I32 (o_0) => platform_value_Value :: I32 (o_0) , platform_value :: Value :: U16 (o_0) => platform_value_Value :: U16 (o_0) , platform_value :: Value :: I16 (o_0) => platform_value_Value :: I16 (o_0) , platform_value :: Value :: U8 (o_0) => platform_value_Value :: U8 (o_0) , platform_value :: Value :: I8 (o_0) => platform_value_Value :: I8 (o_0) , platform_value :: Value :: Bytes (o_0) => platform_value_Value :: Bytes (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes20 (o_0) => platform_value_Value :: Bytes20 (< crate :: fermented :: generics :: Arr_u8_20 as ferment :: FFIConversionTo < [u8 ; 20] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes32 (o_0) => platform_value_Value :: Bytes32 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) , platform_value :: Value :: Bytes36 (o_0) => platform_value_Value :: Bytes36 (< crate :: fermented :: generics :: Arr_u8_36 as ferment :: FFIConversionTo < [u8 ; 36] >> :: ffi_to (o_0)) , platform_value :: Value :: EnumU8 (o_0) => platform_value_Value :: EnumU8 (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (o_0)) , platform_value :: Value :: EnumString (o_0) => platform_value_Value :: EnumString (< crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (o_0)) , platform_value :: Value :: Identifier (o_0) => platform_value_Value :: Identifier (< crate :: fermented :: types :: platform_value :: platform_value_Hash256 as ferment :: FFIConversionTo < platform_value :: Hash256 >> :: ffi_to (o_0)) , platform_value :: Value :: Float (o_0) => platform_value_Value :: Float (o_0) , platform_value :: Value :: Text (o_0) => platform_value_Value :: Text (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: Value :: Bool (o_0) => platform_value_Value :: Bool (o_0) , platform_value :: Value :: Null => platform_value_Value :: Null , platform_value :: Value :: Array (o_0) => platform_value_Value :: Array (< crate :: fermented :: generics :: Vec_platform_value_Value as ferment :: FFIConversionTo < Vec < platform_value :: Value > >> :: ffi_to (o_0)) , platform_value :: Value :: Map (o_0) => platform_value_Value :: Map (< crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap as ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_Value { fn drop (& mut self) { unsafe { match self { platform_value_Value :: U128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: I128 (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , platform_value_Value :: U64 (o_0) => { ; } , platform_value_Value :: I64 (o_0) => { ; } , platform_value_Value :: U32 (o_0) => { ; } , platform_value_Value :: I32 (o_0) => { ; } , platform_value_Value :: U16 (o_0) => { ; } , platform_value_Value :: I16 (o_0) => { ; } , platform_value_Value :: U8 (o_0) => { ; } , platform_value_Value :: I8 (o_0) => { ; } , platform_value_Value :: Bytes (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes20 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes32 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Bytes36 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumU8 (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: EnumString (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Identifier (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Float (o_0) => { ; } , platform_value_Value :: Text (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_Value :: Bool (o_0) => { ; } , platform_value_Value :: Null => { } , platform_value_Value :: Array (o_0) => { ferment :: unbox_any (* o_0) ; } , platform_value_Value :: Map (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U128_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U128 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I128_ctor (o_o_0 : * mut [u8 ; 16]) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I128 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U64_ctor (o_o_0 : u64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I64_ctor (o_o_0 : i64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I64 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U32_ctor (o_o_0 : u32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I32_ctor (o_o_0 : i32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U16_ctor (o_o_0 : u16) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U16 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I16_ctor (o_o_0 : i16) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I16 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_U8_ctor (o_o_0 : u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: U8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_I8_ctor (o_o_0 : i8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: I8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes20_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_20) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes20 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes32_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes32 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bytes36_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_36) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bytes36 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_EnumU8_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: EnumU8 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_EnumString_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_String) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: EnumString (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Identifier_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Hash256) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Identifier (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Float_ctor (o_o_0 : f64) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Float (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Text_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Text (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Bool_ctor (o_o_0 : bool) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Bool (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Null_ctor () -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Null { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Array_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_platform_value_Value) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Array (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_Map_ctor (o_o_0 : * mut crate :: fermented :: types :: platform_value :: value_map :: platform_value_value_map_ValueMap) -> * mut platform_value_Value { ferment :: boxed (platform_value_Value :: Map (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_Value_destroy < > (ffi : * mut platform_value_Value) { ferment :: unbox_any (ffi) ; } pub mod value_map { use crate as example_nested ; # [doc = "FFI-representation of the [`ValueMap`]"] # [repr (C)] # [derive (Clone)] pub struct platform_value_value_map_ValueMap (* mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) ; impl ferment :: FFIConversionFrom < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_from_const (ffi : * const platform_value_value_map_ValueMap) -> platform_value :: value_map :: ValueMap { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < platform_value :: value_map :: ValueMap > for platform_value_value_map_ValueMap { unsafe fn ffi_to_const (obj : platform_value :: value_map :: ValueMap) -> * const platform_value_value_map_ValueMap { ferment :: boxed (platform_value_value_map_ValueMap (< crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value as ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > >> :: ffi_to (obj))) } } impl Drop for platform_value_value_map_ValueMap { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_ctor < > (o_0 : * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value) -> * mut platform_value_value_map_ValueMap { ferment :: boxed (platform_value_value_map_ValueMap (o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_destroy < > (ffi : * mut platform_value_value_map_ValueMap) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_get_0 < > (obj : * const platform_value_value_map_ValueMap) -> * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn platform_value_value_map_ValueMap_set_0 < > (obj : * const platform_value_value_map_ValueMap) -> * mut crate :: fermented :: generics :: Vec_Tuple_platform_value_Value_platform_value_Value { (* obj) . 0 } } pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Error`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_value_error_Error { Unsupported (* mut std :: os :: raw :: c_char) , StructureError (* mut std :: os :: raw :: c_char) , PathError (* mut std :: os :: raw :: c_char) , IntegerSizeError , IntegerParsingError , StringDecodingError (* mut std :: os :: raw :: c_char) , KeyMustBeAString , ByteLengthNot20BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot32BytesError (* mut std :: os :: raw :: c_char) , ByteLengthNot36BytesError (* mut std :: os :: raw :: c_char) , SerdeSerializationError (* mut std :: os :: raw :: c_char) , SerdeDeserializationError (* mut std :: os :: raw :: c_char) , CborSerializationError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_from_const (ffi : * const platform_value_error_Error) -> platform_value :: error :: Error { let ffi_ref = & * ffi ; match ffi_ref { platform_value_error_Error :: Unsupported (o_0) => platform_value :: error :: Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: StructureError (o_0) => platform_value :: error :: Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: PathError (o_0) => platform_value :: error :: Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: IntegerSizeError => platform_value :: error :: Error :: IntegerSizeError , platform_value_error_Error :: IntegerParsingError => platform_value :: error :: Error :: IntegerParsingError , platform_value_error_Error :: StringDecodingError (o_0) => platform_value :: error :: Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: KeyMustBeAString => platform_value :: error :: Error :: KeyMustBeAString , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => platform_value :: error :: Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeSerializationError (o_0) => platform_value :: error :: Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: SerdeDeserializationError (o_0) => platform_value :: error :: Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , platform_value_error_Error :: CborSerializationError (o_0) => platform_value :: error :: Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_value :: error :: Error > for platform_value_error_Error { unsafe fn ffi_to_const (obj : platform_value :: error :: Error) -> * const platform_value_error_Error { ferment :: boxed (match obj { platform_value :: error :: Error :: Unsupported (o_0) => platform_value_error_Error :: Unsupported (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: StructureError (o_0) => platform_value_error_Error :: StructureError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: PathError (o_0) => platform_value_error_Error :: PathError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: IntegerSizeError => platform_value_error_Error :: IntegerSizeError , platform_value :: error :: Error :: IntegerParsingError => platform_value_error_Error :: IntegerParsingError , platform_value :: error :: Error :: StringDecodingError (o_0) => platform_value_error_Error :: StringDecodingError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: KeyMustBeAString => platform_value_error_Error :: KeyMustBeAString , platform_value :: error :: Error :: ByteLengthNot20BytesError (o_0) => platform_value_error_Error :: ByteLengthNot20BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot32BytesError (o_0) => platform_value_error_Error :: ByteLengthNot32BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: ByteLengthNot36BytesError (o_0) => platform_value_error_Error :: ByteLengthNot36BytesError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeSerializationError (o_0) => platform_value_error_Error :: SerdeSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: SerdeDeserializationError (o_0) => platform_value_error_Error :: SerdeDeserializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , platform_value :: error :: Error :: CborSerializationError (o_0) => platform_value_error_Error :: CborSerializationError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_value_error_Error { fn drop (& mut self) { unsafe { match self { platform_value_error_Error :: Unsupported (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: StructureError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: PathError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: IntegerSizeError => { } , platform_value_error_Error :: IntegerParsingError => { } , platform_value_error_Error :: StringDecodingError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: KeyMustBeAString => { } , platform_value_error_Error :: ByteLengthNot20BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot32BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: ByteLengthNot36BytesError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: SerdeDeserializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , platform_value_error_Error :: CborSerializationError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_Unsupported_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: Unsupported (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_StructureError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: StructureError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_PathError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: PathError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_IntegerSizeError_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: IntegerSizeError { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_IntegerParsingError_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: IntegerParsingError { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_StringDecodingError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: StringDecodingError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_KeyMustBeAString_ctor () -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: KeyMustBeAString { }) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot20BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot20BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot32BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot32BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_ByteLengthNot36BytesError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: ByteLengthNot36BytesError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_SerdeSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: SerdeSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_SerdeDeserializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: SerdeDeserializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_CborSerializationError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_value_error_Error { ferment :: boxed (platform_value_error_Error :: CborSerializationError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_value_error_Error_destroy < > (ffi : * mut platform_value_error_Error) { ferment :: unbox_any (ffi) ; } } pub mod value_serialization { use crate as example_nested ; } } pub mod platform_version { use crate as example_nested ; pub mod version { use crate as example_nested ; pub mod dpp_versions { use crate as example_nested ; pub mod dpp_token_versions { use crate as example_nested ; } pub mod dpp_costs_versions { use crate as example_nested ; } pub mod dpp_method_versions { use crate as example_nested ; } pub mod dpp_identity_versions { use crate as example_nested ; } pub mod dpp_voting_versions { use crate as example_nested ; } pub mod dpp_state_transition_versions { use crate as example_nested ; } pub mod dpp_contract_versions { use crate as example_nested ; } pub mod dpp_asset_lock_versions { use crate as example_nested ; } pub mod dpp_state_transition_conversion_versions { use crate as example_nested ; } pub mod dpp_validation_versions { use crate as example_nested ; } pub mod dpp_state_transition_method_versions { use crate as example_nested ; } pub mod dpp_state_transition_serialization_versions { use crate as example_nested ; } pub mod dpp_document_versions { use crate as example_nested ; } pub mod dpp_factory_versions { use crate as example_nested ; } } pub mod system_limits { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemLimits`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_limits_SystemLimits { pub estimated_contract_max_serialized_size : u16 , pub max_field_value_size : u32 , pub max_state_transition_size : u64 , pub max_transitions_in_documents_batch : u16 , pub withdrawal_transactions_per_block_limit : u16 , pub retry_signing_expired_withdrawal_documents_per_block_limit : u16 , pub max_withdrawal_amount : u64 , pub max_contract_group_size : u32 , pub max_token_redemption_cycles : u32 } impl ferment :: FFIConversionFrom < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_limits_SystemLimits) -> platform_version :: version :: system_limits :: SystemLimits { let ffi_ref = & * ffi ; platform_version :: version :: system_limits :: SystemLimits { estimated_contract_max_serialized_size : ffi_ref . estimated_contract_max_serialized_size , max_field_value_size : ffi_ref . max_field_value_size , max_state_transition_size : ffi_ref . max_state_transition_size , max_transitions_in_documents_batch : ffi_ref . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : ffi_ref . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : ffi_ref . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : ffi_ref . max_withdrawal_amount , max_contract_group_size : ffi_ref . max_contract_group_size , max_token_redemption_cycles : ffi_ref . max_token_redemption_cycles } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_limits :: SystemLimits > for platform_version_version_system_limits_SystemLimits { unsafe fn ffi_to_const (obj : platform_version :: version :: system_limits :: SystemLimits) -> * const platform_version_version_system_limits_SystemLimits { ferment :: boxed (platform_version_version_system_limits_SystemLimits { estimated_contract_max_serialized_size : obj . estimated_contract_max_serialized_size , max_field_value_size : obj . max_field_value_size , max_state_transition_size : obj . max_state_transition_size , max_transitions_in_documents_batch : obj . max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit : obj . withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit : obj . retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount : obj . max_withdrawal_amount , max_contract_group_size : obj . max_contract_group_size , max_token_redemption_cycles : obj . max_token_redemption_cycles }) } } impl Drop for platform_version_version_system_limits_SystemLimits { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_ctor < > (estimated_contract_max_serialized_size : u16 , max_field_value_size : u32 , max_state_transition_size : u64 , max_transitions_in_documents_batch : u16 , withdrawal_transactions_per_block_limit : u16 , retry_signing_expired_withdrawal_documents_per_block_limit : u16 , max_withdrawal_amount : u64 , max_contract_group_size : u32 , max_token_redemption_cycles : u32) -> * mut platform_version_version_system_limits_SystemLimits { ferment :: boxed (platform_version_version_system_limits_SystemLimits { estimated_contract_max_serialized_size , max_field_value_size , max_state_transition_size , max_transitions_in_documents_batch , withdrawal_transactions_per_block_limit , retry_signing_expired_withdrawal_documents_per_block_limit , max_withdrawal_amount , max_contract_group_size , max_token_redemption_cycles }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_destroy < > (ffi : * mut platform_version_version_system_limits_SystemLimits) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_estimated_contract_max_serialized_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . estimated_contract_max_serialized_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_field_value_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_field_value_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_state_transition_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_state_transition_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_transitions_in_documents_batch < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . max_transitions_in_documents_batch } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_withdrawal_transactions_per_block_limit < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . withdrawal_transactions_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_retry_signing_expired_withdrawal_documents_per_block_limit < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . retry_signing_expired_withdrawal_documents_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_withdrawal_amount < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_withdrawal_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_contract_group_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_contract_group_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_get_max_token_redemption_cycles < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_token_redemption_cycles } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_estimated_contract_max_serialized_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . estimated_contract_max_serialized_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_field_value_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_field_value_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_state_transition_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_state_transition_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_transitions_in_documents_batch < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . max_transitions_in_documents_batch } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_withdrawal_transactions_per_block_limit < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . withdrawal_transactions_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_retry_signing_expired_withdrawal_documents_per_block_limit < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u16 { (* obj) . retry_signing_expired_withdrawal_documents_per_block_limit } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_withdrawal_amount < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u64 { (* obj) . max_withdrawal_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_contract_group_size < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_contract_group_size } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_limits_SystemLimits_set_max_token_redemption_cycles < > (obj : * const platform_version_version_system_limits_SystemLimits) -> u32 { (* obj) . max_token_redemption_cycles } } pub mod fee { use crate as example_nested ; pub mod storage { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeStorageVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_storage_FeeStorageVersion { pub storage_disk_usage_credit_per_byte : u64 , pub storage_processing_credit_per_byte : u64 , pub storage_load_credit_per_byte : u64 , pub non_storage_load_credit_per_byte : u64 , pub storage_seek_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_storage_FeeStorageVersion) -> platform_version :: version :: fee :: storage :: FeeStorageVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: storage :: FeeStorageVersion { storage_disk_usage_credit_per_byte : ffi_ref . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : ffi_ref . storage_processing_credit_per_byte , storage_load_credit_per_byte : ffi_ref . storage_load_credit_per_byte , non_storage_load_credit_per_byte : ffi_ref . non_storage_load_credit_per_byte , storage_seek_cost : ffi_ref . storage_seek_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion > for platform_version_version_fee_storage_FeeStorageVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: storage :: FeeStorageVersion) -> * const platform_version_version_fee_storage_FeeStorageVersion { ferment :: boxed (platform_version_version_fee_storage_FeeStorageVersion { storage_disk_usage_credit_per_byte : obj . storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte : obj . storage_processing_credit_per_byte , storage_load_credit_per_byte : obj . storage_load_credit_per_byte , non_storage_load_credit_per_byte : obj . non_storage_load_credit_per_byte , storage_seek_cost : obj . storage_seek_cost }) } } impl Drop for platform_version_version_fee_storage_FeeStorageVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_ctor < > (storage_disk_usage_credit_per_byte : u64 , storage_processing_credit_per_byte : u64 , storage_load_credit_per_byte : u64 , non_storage_load_credit_per_byte : u64 , storage_seek_cost : u64) -> * mut platform_version_version_fee_storage_FeeStorageVersion { ferment :: boxed (platform_version_version_fee_storage_FeeStorageVersion { storage_disk_usage_credit_per_byte , storage_processing_credit_per_byte , storage_load_credit_per_byte , non_storage_load_credit_per_byte , storage_seek_cost }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_destroy < > (ffi : * mut platform_version_version_fee_storage_FeeStorageVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_disk_usage_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_disk_usage_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_processing_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_processing_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_load_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_non_storage_load_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . non_storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_get_storage_seek_cost < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_seek_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_disk_usage_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_disk_usage_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_processing_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_processing_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_load_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_non_storage_load_credit_per_byte < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . non_storage_load_credit_per_byte } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_storage_FeeStorageVersion_set_storage_seek_cost < > (obj : * const platform_version_version_fee_storage_FeeStorageVersion) -> u64 { (* obj) . storage_seek_cost } } # [doc = "FFI-representation of the [`FeeVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_FeeVersion { pub fee_version_number : * mut platform_version :: version :: fee :: FeeVersionNumber , pub uses_version_fee_multiplier_permille : * mut u64 , pub storage : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion , pub signature : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion , pub hashing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion , pub processing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion , pub data_contract : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion , pub state_transition_min_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , pub vote_resolution_fund_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_FeeVersion) -> platform_version :: version :: fee :: FeeVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: FeeVersion { fee_version_number : (& * ffi_ref . fee_version_number) . clone () , uses_version_fee_multiplier_permille : ferment :: from_opt_primitive (ffi_ref . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_from (ffi_ref . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_from (ffi_ref . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_from (ffi_ref . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_from (ffi_ref . processing) , data_contract : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion as ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion >> :: ffi_from (ffi_ref . data_contract) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_from (ffi_ref . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_from (ffi_ref . vote_resolution_fund_fees) } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: FeeVersion > for platform_version_version_fee_FeeVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: FeeVersion) -> * const platform_version_version_fee_FeeVersion { ferment :: boxed (platform_version_version_fee_FeeVersion { fee_version_number : ferment :: boxed (obj . fee_version_number) , uses_version_fee_multiplier_permille : ferment :: to_opt_primitive (obj . uses_version_fee_multiplier_permille) , storage : < crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: storage :: FeeStorageVersion >> :: ffi_to (obj . storage) , signature : < crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion >> :: ffi_to (obj . signature) , hashing : < crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion >> :: ffi_to (obj . hashing) , processing : < crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion >> :: ffi_to (obj . processing) , data_contract : < crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion as ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion >> :: ffi_to (obj . data_contract) , state_transition_min_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees >> :: ffi_to (obj . state_transition_min_fees) , vote_resolution_fund_fees : < crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees as ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees >> :: ffi_to (obj . vote_resolution_fund_fees) }) } } impl Drop for platform_version_version_fee_FeeVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . fee_version_number) ; ferment :: destroy_opt_primitive (ffi_ref . uses_version_fee_multiplier_permille) ; ferment :: unbox_any (ffi_ref . storage) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any (ffi_ref . hashing) ; ferment :: unbox_any (ffi_ref . processing) ; ferment :: unbox_any (ffi_ref . data_contract) ; ferment :: unbox_any (ffi_ref . state_transition_min_fees) ; ferment :: unbox_any (ffi_ref . vote_resolution_fund_fees) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_ctor < > (fee_version_number : * mut platform_version :: version :: fee :: FeeVersionNumber , uses_version_fee_multiplier_permille : * mut u64 , storage : * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion , signature : * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion , hashing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion , processing : * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion , data_contract : * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion , state_transition_min_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees , vote_resolution_fund_fees : * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> * mut platform_version_version_fee_FeeVersion { ferment :: boxed (platform_version_version_fee_FeeVersion { fee_version_number , uses_version_fee_multiplier_permille , storage , signature , hashing , processing , data_contract , state_transition_min_fees , vote_resolution_fund_fees }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_destroy < > (ffi : * mut platform_version_version_fee_FeeVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_fee_version_number < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut platform_version :: version :: fee :: FeeVersionNumber { (* obj) . fee_version_number } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_uses_version_fee_multiplier_permille < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut u64 { (* obj) . uses_version_fee_multiplier_permille } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_storage < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion { (* obj) . storage } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_signature < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_hashing < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion { (* obj) . hashing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_processing < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion { (* obj) . processing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_data_contract < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_state_transition_min_fees < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { (* obj) . state_transition_min_fees } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_get_vote_resolution_fund_fees < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { (* obj) . vote_resolution_fund_fees } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_fee_version_number < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut platform_version :: version :: fee :: FeeVersionNumber { (* obj) . fee_version_number } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_uses_version_fee_multiplier_permille < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut u64 { (* obj) . uses_version_fee_multiplier_permille } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_storage < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: storage :: platform_version_version_fee_storage_FeeStorageVersion { (* obj) . storage } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_signature < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: signature :: platform_version_version_fee_signature_FeeSignatureVersion { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_hashing < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: hashing :: platform_version_version_fee_hashing_FeeHashingVersion { (* obj) . hashing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_processing < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: processing :: platform_version_version_fee_processing_FeeProcessingVersion { (* obj) . processing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_data_contract < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: data_contract :: platform_version_version_fee_data_contract_FeeDataContractValidationVersion { (* obj) . data_contract } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_state_transition_min_fees < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: state_transition_min_fees :: platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { (* obj) . state_transition_min_fees } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_FeeVersion_set_vote_resolution_fund_fees < > (obj : * const platform_version_version_fee_FeeVersion) -> * mut crate :: fermented :: types :: platform_version :: version :: fee :: vote_resolution_fund_fees :: platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { (* obj) . vote_resolution_fund_fees } pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeDataContractValidationVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_data_contract_FeeDataContractValidationVersion { pub document_type_base_fee : u64 , pub document_type_size_fee : u64 , pub document_type_per_property_fee : u64 , pub document_type_base_non_unique_index_fee : u64 , pub document_type_non_unique_index_per_property_fee : u64 , pub document_type_base_unique_index_fee : u64 , pub document_type_unique_index_per_property_fee : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_FeeDataContractValidationVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion { document_type_base_fee : ffi_ref . document_type_base_fee , document_type_size_fee : ffi_ref . document_type_size_fee , document_type_per_property_fee : ffi_ref . document_type_per_property_fee , document_type_base_non_unique_index_fee : ffi_ref . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : ffi_ref . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : ffi_ref . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : ffi_ref . document_type_unique_index_per_property_fee } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion > for platform_version_version_fee_data_contract_FeeDataContractValidationVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: data_contract :: FeeDataContractValidationVersion) -> * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion { ferment :: boxed (platform_version_version_fee_data_contract_FeeDataContractValidationVersion { document_type_base_fee : obj . document_type_base_fee , document_type_size_fee : obj . document_type_size_fee , document_type_per_property_fee : obj . document_type_per_property_fee , document_type_base_non_unique_index_fee : obj . document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee : obj . document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee : obj . document_type_base_unique_index_fee , document_type_unique_index_per_property_fee : obj . document_type_unique_index_per_property_fee }) } } impl Drop for platform_version_version_fee_data_contract_FeeDataContractValidationVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_ctor < > (document_type_base_fee : u64 , document_type_size_fee : u64 , document_type_per_property_fee : u64 , document_type_base_non_unique_index_fee : u64 , document_type_non_unique_index_per_property_fee : u64 , document_type_base_unique_index_fee : u64 , document_type_unique_index_per_property_fee : u64) -> * mut platform_version_version_fee_data_contract_FeeDataContractValidationVersion { ferment :: boxed (platform_version_version_fee_data_contract_FeeDataContractValidationVersion { document_type_base_fee , document_type_size_fee , document_type_per_property_fee , document_type_base_non_unique_index_fee , document_type_non_unique_index_per_property_fee , document_type_base_unique_index_fee , document_type_unique_index_per_property_fee }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_destroy < > (ffi : * mut platform_version_version_fee_data_contract_FeeDataContractValidationVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_base_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_size_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_size_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_base_non_unique_index_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_non_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_non_unique_index_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_non_unique_index_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_base_unique_index_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_get_document_type_unique_index_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_unique_index_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_base_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_size_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_size_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_base_non_unique_index_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_non_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_non_unique_index_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_non_unique_index_per_property_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_base_unique_index_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_base_unique_index_fee } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_data_contract_FeeDataContractValidationVersion_set_document_type_unique_index_per_property_fee < > (obj : * const platform_version_version_fee_data_contract_FeeDataContractValidationVersion) -> u64 { (* obj) . document_type_unique_index_per_property_fee } } pub mod state_transition_min_fees { use crate as example_nested ; # [doc = "FFI-representation of the [`StateTransitionMinFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { pub credit_transfer : u64 , pub credit_withdrawal : u64 , pub identity_update : u64 , pub document_batch_sub_transition : u64 , pub contract_create : u64 , pub contract_update : u64 , pub masternode_vote : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees { credit_transfer : ffi_ref . credit_transfer , credit_withdrawal : ffi_ref . credit_withdrawal , identity_update : ffi_ref . identity_update , document_batch_sub_transition : ffi_ref . document_batch_sub_transition , contract_create : ffi_ref . contract_create , contract_update : ffi_ref . contract_update , masternode_vote : ffi_ref . masternode_vote } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees > for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: state_transition_min_fees :: StateTransitionMinFees) -> * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { ferment :: boxed (platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { credit_transfer : obj . credit_transfer , credit_withdrawal : obj . credit_withdrawal , identity_update : obj . identity_update , document_batch_sub_transition : obj . document_batch_sub_transition , contract_create : obj . contract_create , contract_update : obj . contract_update , masternode_vote : obj . masternode_vote }) } } impl Drop for platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_ctor < > (credit_transfer : u64 , credit_withdrawal : u64 , identity_update : u64 , document_batch_sub_transition : u64 , contract_create : u64 , contract_update : u64 , masternode_vote : u64) -> * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { ferment :: boxed (platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees { credit_transfer , credit_withdrawal , identity_update , document_batch_sub_transition , contract_create , contract_update , masternode_vote }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_destroy < > (ffi : * mut platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_credit_transfer < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_transfer } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_credit_withdrawal < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_withdrawal } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_identity_update < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . identity_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_document_batch_sub_transition < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . document_batch_sub_transition } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_contract_create < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_create } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_contract_update < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_get_masternode_vote < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . masternode_vote } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_credit_transfer < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_transfer } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_credit_withdrawal < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . credit_withdrawal } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_identity_update < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . identity_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_document_batch_sub_transition < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . document_batch_sub_transition } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_contract_create < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_create } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_contract_update < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . contract_update } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees_set_masternode_vote < > (obj : * const platform_version_version_fee_state_transition_min_fees_StateTransitionMinFees) -> u64 { (* obj) . masternode_vote } } pub mod signature { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeSignatureVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_signature_FeeSignatureVersion { pub verify_signature_ecdsa_secp256k1 : u64 , pub verify_signature_bls12_381 : u64 , pub verify_signature_ecdsa_hash160 : u64 , pub verify_signature_bip13_script_hash : u64 , pub verify_signature_eddsa25519_hash160 : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_signature_FeeSignatureVersion) -> platform_version :: version :: fee :: signature :: FeeSignatureVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: signature :: FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : ffi_ref . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : ffi_ref . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : ffi_ref . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : ffi_ref . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : ffi_ref . verify_signature_eddsa25519_hash160 } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: signature :: FeeSignatureVersion > for platform_version_version_fee_signature_FeeSignatureVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: signature :: FeeSignatureVersion) -> * const platform_version_version_fee_signature_FeeSignatureVersion { ferment :: boxed (platform_version_version_fee_signature_FeeSignatureVersion { verify_signature_ecdsa_secp256k1 : obj . verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 : obj . verify_signature_bls12_381 , verify_signature_ecdsa_hash160 : obj . verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash : obj . verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 : obj . verify_signature_eddsa25519_hash160 }) } } impl Drop for platform_version_version_fee_signature_FeeSignatureVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_ctor < > (verify_signature_ecdsa_secp256k1 : u64 , verify_signature_bls12_381 : u64 , verify_signature_ecdsa_hash160 : u64 , verify_signature_bip13_script_hash : u64 , verify_signature_eddsa25519_hash160 : u64) -> * mut platform_version_version_fee_signature_FeeSignatureVersion { ferment :: boxed (platform_version_version_fee_signature_FeeSignatureVersion { verify_signature_ecdsa_secp256k1 , verify_signature_bls12_381 , verify_signature_ecdsa_hash160 , verify_signature_bip13_script_hash , verify_signature_eddsa25519_hash160 }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_destroy < > (ffi : * mut platform_version_version_fee_signature_FeeSignatureVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_ecdsa_secp256k1 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_secp256k1 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_bls12_381 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bls12_381 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_ecdsa_hash160 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_hash160 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_bip13_script_hash < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bip13_script_hash } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_get_verify_signature_eddsa25519_hash160 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_eddsa25519_hash160 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_ecdsa_secp256k1 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_secp256k1 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_bls12_381 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bls12_381 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_ecdsa_hash160 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_ecdsa_hash160 } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_bip13_script_hash < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_bip13_script_hash } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_signature_FeeSignatureVersion_set_verify_signature_eddsa25519_hash160 < > (obj : * const platform_version_version_fee_signature_FeeSignatureVersion) -> u64 { (* obj) . verify_signature_eddsa25519_hash160 } } pub mod vote_resolution_fund_fees { use crate as example_nested ; # [doc = "FFI-representation of the [`VoteResolutionFundFees`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { pub contested_document_vote_resolution_fund_required_amount : u64 , pub contested_document_vote_resolution_unlock_fund_required_amount : u64 , pub contested_document_single_vote_cost : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { let ffi_ref = & * ffi ; platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : ffi_ref . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : ffi_ref . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : ffi_ref . contested_document_single_vote_cost } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees > for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: vote_resolution_fund_fees :: VoteResolutionFundFees) -> * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { ferment :: boxed (platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount : obj . contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount : obj . contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost : obj . contested_document_single_vote_cost }) } } impl Drop for platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_ctor < > (contested_document_vote_resolution_fund_required_amount : u64 , contested_document_vote_resolution_unlock_fund_required_amount : u64 , contested_document_single_vote_cost : u64) -> * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { ferment :: boxed (platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees { contested_document_vote_resolution_fund_required_amount , contested_document_vote_resolution_unlock_fund_required_amount , contested_document_single_vote_cost }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_destroy < > (ffi : * mut platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_vote_resolution_fund_required_amount < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_vote_resolution_unlock_fund_required_amount < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_unlock_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_get_contested_document_single_vote_cost < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_single_vote_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_vote_resolution_fund_required_amount < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_vote_resolution_unlock_fund_required_amount < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_vote_resolution_unlock_fund_required_amount } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees_set_contested_document_single_vote_cost < > (obj : * const platform_version_version_fee_vote_resolution_fund_fees_VoteResolutionFundFees) -> u64 { (* obj) . contested_document_single_vote_cost } } pub mod hashing { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeHashingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_hashing_FeeHashingVersion { pub blake3_base : u64 , pub blake3_per_block : u64 , pub sha256_per_block : u64 , pub sha256_ripe_md160_base : u64 , pub single_sha256_base : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_hashing_FeeHashingVersion) -> platform_version :: version :: fee :: hashing :: FeeHashingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: hashing :: FeeHashingVersion { blake3_base : ffi_ref . blake3_base , blake3_per_block : ffi_ref . blake3_per_block , sha256_per_block : ffi_ref . sha256_per_block , sha256_ripe_md160_base : ffi_ref . sha256_ripe_md160_base , single_sha256_base : ffi_ref . single_sha256_base } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: hashing :: FeeHashingVersion > for platform_version_version_fee_hashing_FeeHashingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: hashing :: FeeHashingVersion) -> * const platform_version_version_fee_hashing_FeeHashingVersion { ferment :: boxed (platform_version_version_fee_hashing_FeeHashingVersion { blake3_base : obj . blake3_base , blake3_per_block : obj . blake3_per_block , sha256_per_block : obj . sha256_per_block , sha256_ripe_md160_base : obj . sha256_ripe_md160_base , single_sha256_base : obj . single_sha256_base }) } } impl Drop for platform_version_version_fee_hashing_FeeHashingVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_ctor < > (blake3_base : u64 , blake3_per_block : u64 , sha256_per_block : u64 , sha256_ripe_md160_base : u64 , single_sha256_base : u64) -> * mut platform_version_version_fee_hashing_FeeHashingVersion { ferment :: boxed (platform_version_version_fee_hashing_FeeHashingVersion { blake3_base , blake3_per_block , sha256_per_block , sha256_ripe_md160_base , single_sha256_base }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_destroy < > (ffi : * mut platform_version_version_fee_hashing_FeeHashingVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_blake3_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_blake3_per_block < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_sha256_per_block < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_sha256_ripe_md160_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_ripe_md160_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_get_single_sha256_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . single_sha256_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_blake3_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_blake3_per_block < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . blake3_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_sha256_per_block < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_per_block } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_sha256_ripe_md160_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . sha256_ripe_md160_base } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_hashing_FeeHashingVersion_set_single_sha256_base < > (obj : * const platform_version_version_fee_hashing_FeeHashingVersion) -> u64 { (* obj) . single_sha256_base } } pub mod processing { use crate as example_nested ; # [doc = "FFI-representation of the [`FeeProcessingVersion`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_fee_processing_FeeProcessingVersion { pub fetch_identity_balance_processing_cost : u64 , pub fetch_identity_revision_processing_cost : u64 , pub fetch_identity_balance_and_revision_processing_cost : u64 , pub fetch_identity_cost_per_look_up_key_by_id : u64 , pub fetch_identity_token_balance_processing_cost : u64 , pub fetch_prefunded_specialized_balance_processing_cost : u64 , pub fetch_single_identity_key_processing_cost : u64 , pub validate_key_structure : u64 , pub perform_network_threshold_signing : u64 } impl ferment :: FFIConversionFrom < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_from_const (ffi : * const platform_version_version_fee_processing_FeeProcessingVersion) -> platform_version :: version :: fee :: processing :: FeeProcessingVersion { let ffi_ref = & * ffi ; platform_version :: version :: fee :: processing :: FeeProcessingVersion { fetch_identity_balance_processing_cost : ffi_ref . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : ffi_ref . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : ffi_ref . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : ffi_ref . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : ffi_ref . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : ffi_ref . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : ffi_ref . fetch_single_identity_key_processing_cost , validate_key_structure : ffi_ref . validate_key_structure , perform_network_threshold_signing : ffi_ref . perform_network_threshold_signing } } } impl ferment :: FFIConversionTo < platform_version :: version :: fee :: processing :: FeeProcessingVersion > for platform_version_version_fee_processing_FeeProcessingVersion { unsafe fn ffi_to_const (obj : platform_version :: version :: fee :: processing :: FeeProcessingVersion) -> * const platform_version_version_fee_processing_FeeProcessingVersion { ferment :: boxed (platform_version_version_fee_processing_FeeProcessingVersion { fetch_identity_balance_processing_cost : obj . fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost : obj . fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost : obj . fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id : obj . fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost : obj . fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost : obj . fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost : obj . fetch_single_identity_key_processing_cost , validate_key_structure : obj . validate_key_structure , perform_network_threshold_signing : obj . perform_network_threshold_signing }) } } impl Drop for platform_version_version_fee_processing_FeeProcessingVersion { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; ; ; ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_ctor < > (fetch_identity_balance_processing_cost : u64 , fetch_identity_revision_processing_cost : u64 , fetch_identity_balance_and_revision_processing_cost : u64 , fetch_identity_cost_per_look_up_key_by_id : u64 , fetch_identity_token_balance_processing_cost : u64 , fetch_prefunded_specialized_balance_processing_cost : u64 , fetch_single_identity_key_processing_cost : u64 , validate_key_structure : u64 , perform_network_threshold_signing : u64) -> * mut platform_version_version_fee_processing_FeeProcessingVersion { ferment :: boxed (platform_version_version_fee_processing_FeeProcessingVersion { fetch_identity_balance_processing_cost , fetch_identity_revision_processing_cost , fetch_identity_balance_and_revision_processing_cost , fetch_identity_cost_per_look_up_key_by_id , fetch_identity_token_balance_processing_cost , fetch_prefunded_specialized_balance_processing_cost , fetch_single_identity_key_processing_cost , validate_key_structure , perform_network_threshold_signing }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_destroy < > (ffi : * mut platform_version_version_fee_processing_FeeProcessingVersion) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_revision_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_balance_and_revision_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_and_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_cost_per_look_up_key_by_id < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_cost_per_look_up_key_by_id } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_identity_token_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_token_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_prefunded_specialized_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_prefunded_specialized_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_fetch_single_identity_key_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_single_identity_key_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_validate_key_structure < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . validate_key_structure } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_get_perform_network_threshold_signing < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . perform_network_threshold_signing } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_revision_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_balance_and_revision_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_balance_and_revision_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_cost_per_look_up_key_by_id < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_cost_per_look_up_key_by_id } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_identity_token_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_identity_token_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_prefunded_specialized_balance_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_prefunded_specialized_balance_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_fetch_single_identity_key_processing_cost < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . fetch_single_identity_key_processing_cost } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_validate_key_structure < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . validate_key_structure } # [no_mangle] pub unsafe extern "C" fn platform_version_version_fee_processing_FeeProcessingVersion_set_perform_network_threshold_signing < > (obj : * const platform_version_version_fee_processing_FeeProcessingVersion) -> u64 { (* obj) . perform_network_threshold_signing } } } pub mod system_data_contract_versions { use crate as example_nested ; # [doc = "FFI-representation of the [`SystemDataContractVersions`]"] # [repr (C)] # [derive (Clone)] pub struct platform_version_version_system_data_contract_versions_SystemDataContractVersions { pub withdrawals : * mut example_nested :: versioned_feature_core_FeatureVersion , pub dpns : * mut example_nested :: versioned_feature_core_FeatureVersion , pub dashpay : * mut example_nested :: versioned_feature_core_FeatureVersion , pub masternode_reward_shares : * mut example_nested :: versioned_feature_core_FeatureVersion , pub feature_flags : * mut example_nested :: versioned_feature_core_FeatureVersion , pub wallet : * mut example_nested :: versioned_feature_core_FeatureVersion } impl ferment :: FFIConversionFrom < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_from_const (ffi : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { let ffi_ref = & * ffi ; platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions { withdrawals : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . withdrawals) , dpns : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . dpns) , dashpay : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . dashpay) , masternode_reward_shares : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . masternode_reward_shares) , feature_flags : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . feature_flags) , wallet : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionFrom < versioned_feature_core :: FeatureVersion >> :: ffi_from (ffi_ref . wallet) } } } impl ferment :: FFIConversionTo < platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions > for platform_version_version_system_data_contract_versions_SystemDataContractVersions { unsafe fn ffi_to_const (obj : platform_version :: version :: system_data_contract_versions :: SystemDataContractVersions) -> * const platform_version_version_system_data_contract_versions_SystemDataContractVersions { ferment :: boxed (platform_version_version_system_data_contract_versions_SystemDataContractVersions { withdrawals : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . withdrawals) , dpns : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . dpns) , dashpay : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . dashpay) , masternode_reward_shares : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . masternode_reward_shares) , feature_flags : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . feature_flags) , wallet : < example_nested :: versioned_feature_core_FeatureVersion as ferment :: FFIConversionTo < versioned_feature_core :: FeatureVersion >> :: ffi_to (obj . wallet) }) } } impl Drop for platform_version_version_system_data_contract_versions_SystemDataContractVersions { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . withdrawals) ; ferment :: unbox_any (ffi_ref . dpns) ; ferment :: unbox_any (ffi_ref . dashpay) ; ferment :: unbox_any (ffi_ref . masternode_reward_shares) ; ferment :: unbox_any (ffi_ref . feature_flags) ; ferment :: unbox_any (ffi_ref . wallet) ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_ctor < > (withdrawals : * mut example_nested :: versioned_feature_core_FeatureVersion , dpns : * mut example_nested :: versioned_feature_core_FeatureVersion , dashpay : * mut example_nested :: versioned_feature_core_FeatureVersion , masternode_reward_shares : * mut example_nested :: versioned_feature_core_FeatureVersion , feature_flags : * mut example_nested :: versioned_feature_core_FeatureVersion , wallet : * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions { ferment :: boxed (platform_version_version_system_data_contract_versions_SystemDataContractVersions { withdrawals , dpns , dashpay , masternode_reward_shares , feature_flags , wallet }) } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_destroy < > (ffi : * mut platform_version_version_system_data_contract_versions_SystemDataContractVersions) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_withdrawals < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . withdrawals } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_dpns < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . dpns } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_dashpay < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . dashpay } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_masternode_reward_shares < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . masternode_reward_shares } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_feature_flags < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . feature_flags } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_get_wallet < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . wallet } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_withdrawals < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . withdrawals } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_dpns < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . dpns } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_dashpay < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . dashpay } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_masternode_reward_shares < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . masternode_reward_shares } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_feature_flags < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . feature_flags } # [no_mangle] pub unsafe extern "C" fn platform_version_version_system_data_contract_versions_SystemDataContractVersions_set_wallet < > (obj : * const platform_version_version_system_data_contract_versions_SystemDataContractVersions) -> * mut example_nested :: versioned_feature_core_FeatureVersion { (* obj) . wallet } } pub mod drive_abci_versions { use crate as example_nested ; pub mod drive_abci_withdrawal_constants { use crate as example_nested ; } pub mod drive_abci_method_versions { use crate as example_nested ; } pub mod drive_abci_structure_versions { use crate as example_nested ; } pub mod drive_abci_query_versions { use crate as example_nested ; } pub mod drive_abci_validation_versions { use crate as example_nested ; } } pub mod drive_versions { use crate as example_nested ; pub mod drive_credit_pool_method_versions { use crate as example_nested ; } pub mod drive_contract_method_versions { use crate as example_nested ; } pub mod drive_token_method_versions { use crate as example_nested ; } pub mod drive_document_method_versions { use crate as example_nested ; } pub mod drive_vote_method_versions { use crate as example_nested ; } pub mod drive_verify_method_versions { use crate as example_nested ; } pub mod drive_group_method_versions { use crate as example_nested ; } pub mod drive_state_transition_method_versions { use crate as example_nested ; } pub mod drive_structure_version { use crate as example_nested ; } pub mod drive_grove_method_versions { use crate as example_nested ; } pub mod drive_identity_method_versions { use crate as example_nested ; } } # [cfg (feature = "mock-versions")] pub mod mocks { use crate as example_nested ; } } pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`PlatformVersionError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum platform_version_error_PlatformVersionError { UnknownVersionError (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_from_const (ffi : * const platform_version_error_PlatformVersionError) -> platform_version :: error :: PlatformVersionError { let ffi_ref = & * ffi ; match ffi_ref { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => platform_version :: error :: PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < platform_version :: error :: PlatformVersionError > for platform_version_error_PlatformVersionError { unsafe fn ffi_to_const (obj : platform_version :: error :: PlatformVersionError) -> * const platform_version_error_PlatformVersionError { ferment :: boxed (match obj { platform_version :: error :: PlatformVersionError :: UnknownVersionError (o_0) => platform_version_error_PlatformVersionError :: UnknownVersionError (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for platform_version_error_PlatformVersionError { fn drop (& mut self) { unsafe { match self { platform_version_error_PlatformVersionError :: UnknownVersionError (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn platform_version_error_PlatformVersionError_UnknownVersionError_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut platform_version_error_PlatformVersionError { ferment :: boxed (platform_version_error_PlatformVersionError :: UnknownVersionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn platform_version_error_PlatformVersionError_destroy < > (ffi : * mut platform_version_error_PlatformVersionError) { ferment :: unbox_any (ffi) ; } } } pub mod example_simple { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; pub mod document_type { use crate as example_nested ; pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DocumentTypeV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_document_type_v0_DocumentTypeV0 { pub name : * mut std :: os :: raw :: c_char , pub binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for example_simple_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 { let ffi_ref = & * ffi ; example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . binary_paths) } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 > for example_simple_data_contract_document_type_v0_DocumentTypeV0 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0) -> * const example_simple_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (example_simple_data_contract_document_type_v0_DocumentTypeV0 { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , binary_paths : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . binary_paths) }) } } impl Drop for example_simple_data_contract_document_type_v0_DocumentTypeV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . binary_paths) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_ctor < > (name : * mut std :: os :: raw :: c_char , binary_paths : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String) -> * mut example_simple_data_contract_document_type_v0_DocumentTypeV0 { ferment :: boxed (example_simple_data_contract_document_type_v0_DocumentTypeV0 { name , binary_paths }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_destroy < > (ffi : * mut example_simple_data_contract_document_type_v0_DocumentTypeV0) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_get_name < > (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_get_binary_paths < > (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_set_name < > (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_v0_DocumentTypeV0_set_binary_paths < > (obj : * const example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . binary_paths } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_data_contract_document_type_DocumentType { V0 (* mut crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0) } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: DocumentType > for example_simple_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_document_type_DocumentType) -> example_simple :: data_contract :: document_type :: DocumentType { let ffi_ref = & * ffi ; match ffi_ref { example_simple_data_contract_document_type_DocumentType :: V0 (o_0) => example_simple :: data_contract :: document_type :: DocumentType :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionFrom < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: DocumentType > for example_simple_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: document_type :: DocumentType) -> * const example_simple_data_contract_document_type_DocumentType { ferment :: boxed (match obj { example_simple :: data_contract :: document_type :: DocumentType :: V0 (o_0) => example_simple_data_contract_document_type_DocumentType :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0 as ferment :: FFIConversionTo < example_simple :: data_contract :: document_type :: v0 :: DocumentTypeV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { match self { example_simple_data_contract_document_type_DocumentType :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_DocumentType_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: data_contract :: document_type :: v0 :: example_simple_data_contract_document_type_v0_DocumentTypeV0) -> * mut example_simple_data_contract_document_type_DocumentType { ferment :: boxed (example_simple_data_contract_document_type_DocumentType :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_document_type_DocumentType_destroy < > (ffi : * mut example_simple_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } } pub mod v1 { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV1`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_v1_data_contract_DataContractV1 { } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 > for example_simple_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_v1_data_contract_DataContractV1) -> example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 { let ffi_ref = & * ffi ; example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 { } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 > for example_simple_data_contract_v1_data_contract_DataContractV1 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: v1 :: data_contract :: DataContractV1) -> * const example_simple_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (example_simple_data_contract_v1_data_contract_DataContractV1 { }) } } impl Drop for example_simple_data_contract_v1_data_contract_DataContractV1 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v1_data_contract_DataContractV1_ctor < > () -> * mut example_simple_data_contract_v1_data_contract_DataContractV1 { ferment :: boxed (example_simple_data_contract_v1_data_contract_DataContractV1 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v1_data_contract_DataContractV1_destroy < > (ffi : * mut example_simple_data_contract_v1_data_contract_DataContractV1) { ferment :: unbox_any (ffi) ; } } } pub mod v0 { use crate as example_nested ; pub mod data_contract { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_data_contract_v0_data_contract_DataContractV0 { } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 > for example_simple_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_v0_data_contract_DataContractV0) -> example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 { let ffi_ref = & * ffi ; example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 { } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 > for example_simple_data_contract_v0_data_contract_DataContractV0 { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: v0 :: data_contract :: DataContractV0) -> * const example_simple_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (example_simple_data_contract_v0_data_contract_DataContractV0 { }) } } impl Drop for example_simple_data_contract_v0_data_contract_DataContractV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v0_data_contract_DataContractV0_ctor < > () -> * mut example_simple_data_contract_v0_data_contract_DataContractV0 { ferment :: boxed (example_simple_data_contract_v0_data_contract_DataContractV0 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_v0_data_contract_DataContractV0_destroy < > (ffi : * mut example_simple_data_contract_v0_data_contract_DataContractV0) { ferment :: unbox_any (ffi) ; } } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContract`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_data_contract_DataContract { V0 (* mut crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0) , V1 (* mut crate :: fermented :: types :: example_simple :: data_contract :: v1 :: data_contract :: example_simple_data_contract_v1_data_contract_DataContractV1) , # [cfg (test)] Test } impl ferment :: FFIConversionFrom < example_simple :: data_contract :: DataContract > for example_simple_data_contract_DataContract { unsafe fn ffi_from_const (ffi : * const example_simple_data_contract_DataContract) -> example_simple :: data_contract :: DataContract { let ffi_ref = & * ffi ; match ffi_ref { example_simple_data_contract_DataContract :: V0 (o_0) => example_simple :: data_contract :: DataContract :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionFrom < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_from (* o_0)) , example_simple_data_contract_DataContract :: V1 (o_0) => example_simple :: data_contract :: DataContract :: V1 (< crate :: fermented :: types :: example_simple :: data_contract :: v1 :: data_contract :: example_simple_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionFrom < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_from (* o_0)) , # [cfg (test)] example_simple_data_contract_DataContract :: Test => example_simple :: data_contract :: DataContract :: Test } } } impl ferment :: FFIConversionTo < example_simple :: data_contract :: DataContract > for example_simple_data_contract_DataContract { unsafe fn ffi_to_const (obj : example_simple :: data_contract :: DataContract) -> * const example_simple_data_contract_DataContract { ferment :: boxed (match obj { example_simple :: data_contract :: DataContract :: V0 (o_0) => example_simple_data_contract_DataContract :: V0 (< crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0 as ferment :: FFIConversionTo < example_simple :: data_contract :: v0 :: data_contract :: DataContractV0 >> :: ffi_to (o_0)) , example_simple :: data_contract :: DataContract :: V1 (o_0) => example_simple_data_contract_DataContract :: V1 (< crate :: fermented :: types :: example_simple :: data_contract :: v1 :: data_contract :: example_simple_data_contract_v1_data_contract_DataContractV1 as ferment :: FFIConversionTo < example_simple :: data_contract :: v1 :: data_contract :: DataContractV1 >> :: ffi_to (o_0)) , # [cfg (test)] example_simple :: data_contract :: DataContract :: Test => example_simple_data_contract_DataContract :: Test , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_data_contract_DataContract { fn drop (& mut self) { unsafe { match self { example_simple_data_contract_DataContract :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , example_simple_data_contract_DataContract :: V1 (o_0) => { ferment :: unbox_any (* o_0) ; } , # [cfg (test)] example_simple_data_contract_DataContract :: Test => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: data_contract :: v0 :: data_contract :: example_simple_data_contract_v0_data_contract_DataContractV0) -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_V1_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: data_contract :: v1 :: data_contract :: example_simple_data_contract_v1_data_contract_DataContractV1) -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: V1 (o_o_0)) } # [cfg (test)] # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_Test_ctor () -> * mut example_simple_data_contract_DataContract { ferment :: boxed (example_simple_data_contract_DataContract :: Test { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_data_contract_DataContract_destroy < > (ffi : * mut example_simple_data_contract_DataContract) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`RootStruct`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_RootStruct { pub name : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_simple :: RootStruct > for example_simple_RootStruct { unsafe fn ffi_from_const (ffi : * const example_simple_RootStruct) -> example_simple :: RootStruct { let ffi_ref = & * ffi ; example_simple :: RootStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) } } } impl ferment :: FFIConversionTo < example_simple :: RootStruct > for example_simple_RootStruct { unsafe fn ffi_to_const (obj : example_simple :: RootStruct) -> * const example_simple_RootStruct { ferment :: boxed (example_simple_RootStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) }) } } impl Drop for example_simple_RootStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_ctor < > (name : * mut std :: os :: raw :: c_char) -> * mut example_simple_RootStruct { ferment :: boxed (example_simple_RootStruct { name }) } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_destroy < > (ffi : * mut example_simple_RootStruct) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_get_name < > (obj : * const example_simple_RootStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_simple_RootStruct_set_name < > (obj : * const example_simple_RootStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } pub mod document { use crate as example_nested ; pub mod errors { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DocumentError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_document_errors_DocumentError { InvalidActionError (u8) , InvalidInitialRevisionError { document : * mut crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document } } impl ferment :: FFIConversionFrom < example_simple :: document :: errors :: DocumentError > for example_simple_document_errors_DocumentError { unsafe fn ffi_from_const (ffi : * const example_simple_document_errors_DocumentError) -> example_simple :: document :: errors :: DocumentError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_document_errors_DocumentError :: InvalidActionError (o_0) => example_simple :: document :: errors :: DocumentError :: InvalidActionError (* o_0) , example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document } => example_simple :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document : Box :: new (< crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document as ferment :: FFIConversionFrom < example_simple :: document :: Document >> :: ffi_from (* document)) } } } } impl ferment :: FFIConversionTo < example_simple :: document :: errors :: DocumentError > for example_simple_document_errors_DocumentError { unsafe fn ffi_to_const (obj : example_simple :: document :: errors :: DocumentError) -> * const example_simple_document_errors_DocumentError { ferment :: boxed (match obj { example_simple :: document :: errors :: DocumentError :: InvalidActionError (o_0) => example_simple_document_errors_DocumentError :: InvalidActionError (o_0) , example_simple :: document :: errors :: DocumentError :: InvalidInitialRevisionError { document } => example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document : < crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document as ferment :: FFIConversionTo < example_simple :: document :: Document >> :: ffi_to (* document) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_document_errors_DocumentError { fn drop (& mut self) { unsafe { match self { example_simple_document_errors_DocumentError :: InvalidActionError (o_0) => { ; } , example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document } => { ferment :: unbox_any (* document) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_InvalidActionError_ctor (o_o_0 : u8) -> * mut example_simple_document_errors_DocumentError { ferment :: boxed (example_simple_document_errors_DocumentError :: InvalidActionError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_InvalidInitialRevisionError_ctor (document : * mut crate :: fermented :: types :: example_simple :: document :: example_simple_document_Document) -> * mut example_simple_document_errors_DocumentError { ferment :: boxed (example_simple_document_errors_DocumentError :: InvalidInitialRevisionError { document }) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_errors_DocumentError_destroy < > (ffi : * mut example_simple_document_errors_DocumentError) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`Document`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_document_Document { V0 } impl ferment :: FFIConversionFrom < example_simple :: document :: Document > for example_simple_document_Document { unsafe fn ffi_from_const (ffi : * const example_simple_document_Document) -> example_simple :: document :: Document { let ffi_ref = & * ffi ; match ffi_ref { example_simple_document_Document :: V0 => example_simple :: document :: Document :: V0 } } } impl ferment :: FFIConversionTo < example_simple :: document :: Document > for example_simple_document_Document { unsafe fn ffi_to_const (obj : example_simple :: document :: Document) -> * const example_simple_document_Document { ferment :: boxed (match obj { example_simple :: document :: Document :: V0 => example_simple_document_Document :: V0 , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_document_Document { fn drop (& mut self) { unsafe { match self { example_simple_document_Document :: V0 => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_document_Document_V0_ctor () -> * mut example_simple_document_Document { ferment :: boxed (example_simple_document_Document :: V0 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_document_Document_destroy < > (ffi : * mut example_simple_document_Document) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`Unstable`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_Unstable { pub secs : * mut [u8 ; 16] , pub nanos : * mut [u8 ; 16] } impl ferment :: FFIConversionFrom < example_simple :: Unstable > for example_simple_Unstable { unsafe fn ffi_from_const (ffi : * const example_simple_Unstable) -> example_simple :: Unstable { let ffi_ref = & * ffi ; example_simple :: Unstable { secs : < [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (ffi_ref . secs) , nanos : < [u8 ; 16] as ferment :: FFIConversionFrom < i128 >> :: ffi_from (ffi_ref . nanos) } } } impl ferment :: FFIConversionTo < example_simple :: Unstable > for example_simple_Unstable { unsafe fn ffi_to_const (obj : example_simple :: Unstable) -> * const example_simple_Unstable { ferment :: boxed (example_simple_Unstable { secs : < [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (obj . secs) , nanos : < [u8 ; 16] as ferment :: FFIConversionTo < i128 >> :: ffi_to (obj . nanos) }) } } impl Drop for example_simple_Unstable { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . secs) ; ferment :: unbox_any_opt (ffi_ref . nanos) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_ctor < > (secs : * mut [u8 ; 16] , nanos : * mut [u8 ; 16]) -> * mut example_simple_Unstable { ferment :: boxed (example_simple_Unstable { secs , nanos }) } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_destroy < > (ffi : * mut example_simple_Unstable) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_get_secs < > (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . secs } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_get_nanos < > (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . nanos } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_set_secs < > (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . secs } # [no_mangle] pub unsafe extern "C" fn example_simple_Unstable_set_nanos < > (obj : * const example_simple_Unstable) -> * mut [u8 ; 16] { (* obj) . nanos } pub mod state_transition { use crate as example_nested ; pub mod errors { use crate as example_nested ; pub mod invalid_identity_public_key_type_error { use crate as example_nested ; # [doc = "FFI-representation of the [`InvalidIdentityPublicKeyTypeError`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { pub public_key_type : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_from_const (ffi : * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { let ffi_ref = & * ffi ; example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError { public_key_type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . public_key_type) } } } impl ferment :: FFIConversionTo < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError > for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { unsafe fn ffi_to_const (obj : example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError) -> * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . public_key_type) }) } } impl Drop for example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . public_key_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_ctor < > (public_key_type : * mut std :: os :: raw :: c_char) -> * mut example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { ferment :: boxed (example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError { public_key_type }) } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_destroy < > (ffi : * mut example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_get_public_key_type < > (obj : * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . public_key_type } # [no_mangle] pub unsafe extern "C" fn example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError_set_public_key_type < > (obj : * const example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut std :: os :: raw :: c_char { (* obj) . public_key_type } } } } # [doc = "FFI-representation of the [`example_simple::get_root_struct`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_get_root_struct () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: get_root_struct () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } pub mod example { use crate as example_nested ; pub mod address { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::example::address::address_simple_result`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_example_address_address_simple_result (script : * mut crate :: fermented :: generics :: Vec_u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_simple :: example :: address :: address_simple_result (< crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from (script)) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_simple::example::address::address_with_script_pubkey`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_example_address_address_with_script_pubkey (script : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std :: os :: raw :: c_char { let obj = example_simple :: example :: address :: address_with_script_pubkey (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (script)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj) } } pub mod custom_conversion { use crate as example_nested ; # [doc = "FFI-representation of the [`StructUsesDurationTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_example_custom_conversion_StructUsesDurationTuple { pub time : * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration } impl ferment :: FFIConversionFrom < example_simple :: example :: custom_conversion :: StructUsesDurationTuple > for example_simple_example_custom_conversion_StructUsesDurationTuple { unsafe fn ffi_from_const (ffi : * const example_simple_example_custom_conversion_StructUsesDurationTuple) -> example_simple :: example :: custom_conversion :: StructUsesDurationTuple { let ffi_ref = & * ffi ; example_simple :: example :: custom_conversion :: StructUsesDurationTuple { time : < crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration as ferment :: FFIConversionFrom < (std :: time :: Duration , std :: time :: Duration) >> :: ffi_from (ffi_ref . time) } } } impl ferment :: FFIConversionTo < example_simple :: example :: custom_conversion :: StructUsesDurationTuple > for example_simple_example_custom_conversion_StructUsesDurationTuple { unsafe fn ffi_to_const (obj : example_simple :: example :: custom_conversion :: StructUsesDurationTuple) -> * const example_simple_example_custom_conversion_StructUsesDurationTuple { ferment :: boxed (example_simple_example_custom_conversion_StructUsesDurationTuple { time : < crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration as ferment :: FFIConversionTo < (std :: time :: Duration , std :: time :: Duration) >> :: ffi_to (obj . time) }) } } impl Drop for example_simple_example_custom_conversion_StructUsesDurationTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_ctor < > (time : * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration) -> * mut example_simple_example_custom_conversion_StructUsesDurationTuple { ferment :: boxed (example_simple_example_custom_conversion_StructUsesDurationTuple { time }) } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_destroy < > (ffi : * mut example_simple_example_custom_conversion_StructUsesDurationTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_get_time < > (obj : * const example_simple_example_custom_conversion_StructUsesDurationTuple) -> * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration { (* obj) . time } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesDurationTuple_set_time < > (obj : * const example_simple_example_custom_conversion_StructUsesDurationTuple) -> * mut crate :: fermented :: generics :: Tuple_std_time_Duration_std_time_Duration { (* obj) . time } # [doc = "FFI-representation of the [`StructUsesGenericWithCustom`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_example_custom_conversion_StructUsesGenericWithCustom { pub time : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration } impl ferment :: FFIConversionFrom < example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom > for example_simple_example_custom_conversion_StructUsesGenericWithCustom { unsafe fn ffi_from_const (ffi : * const example_simple_example_custom_conversion_StructUsesGenericWithCustom) -> example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom { let ffi_ref = & * ffi ; example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom { time : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , std :: time :: Duration > >> :: ffi_from (ffi_ref . time) } } } impl ferment :: FFIConversionTo < example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom > for example_simple_example_custom_conversion_StructUsesGenericWithCustom { unsafe fn ffi_to_const (obj : example_simple :: example :: custom_conversion :: StructUsesGenericWithCustom) -> * const example_simple_example_custom_conversion_StructUsesGenericWithCustom { ferment :: boxed (example_simple_example_custom_conversion_StructUsesGenericWithCustom { time : < crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , std :: time :: Duration > >> :: ffi_to (obj . time) }) } } impl Drop for example_simple_example_custom_conversion_StructUsesGenericWithCustom { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . time) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_ctor < > (time : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration) -> * mut example_simple_example_custom_conversion_StructUsesGenericWithCustom { ferment :: boxed (example_simple_example_custom_conversion_StructUsesGenericWithCustom { time }) } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_destroy < > (ffi : * mut example_simple_example_custom_conversion_StructUsesGenericWithCustom) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_get_time < > (obj : * const example_simple_example_custom_conversion_StructUsesGenericWithCustom) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration { (* obj) . time } # [no_mangle] pub unsafe extern "C" fn example_simple_example_custom_conversion_StructUsesGenericWithCustom_set_time < > (obj : * const example_simple_example_custom_conversion_StructUsesGenericWithCustom) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_std_time_Duration { (* obj) . time } } } pub mod nested { use crate as example_nested ; # [doc = "FFI-representation of the [`RootUser`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_nested_RootUser { pub root : * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct } impl ferment :: FFIConversionFrom < example_simple :: nested :: RootUser > for example_simple_nested_RootUser { unsafe fn ffi_from_const (ffi : * const example_simple_nested_RootUser) -> example_simple :: nested :: RootUser { let ffi_ref = & * ffi ; example_simple :: nested :: RootUser { root : < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionFrom < example_simple :: RootStruct >> :: ffi_from (ffi_ref . root) } } } impl ferment :: FFIConversionTo < example_simple :: nested :: RootUser > for example_simple_nested_RootUser { unsafe fn ffi_to_const (obj : example_simple :: nested :: RootUser) -> * const example_simple_nested_RootUser { ferment :: boxed (example_simple_nested_RootUser { root : < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj . root) }) } } impl Drop for example_simple_nested_RootUser { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . root) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_ctor < > (root : * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct) -> * mut example_simple_nested_RootUser { ferment :: boxed (example_simple_nested_RootUser { root }) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_destroy < > (ffi : * mut example_simple_nested_RootUser) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_get_root < > (obj : * const example_simple_nested_RootUser) -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { (* obj) . root } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_RootUser_set_root < > (obj : * const example_simple_nested_RootUser) -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { (* obj) . root } # [doc = "FFI-representation of the [`example_simple::nested::get_root_struct_2`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_nested_get_root_struct_2 () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: nested :: get_root_struct_2 () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`HashID`]"] # [repr (C)] # [derive (Clone)] pub struct example_simple_nested_HashID (* mut crate :: fermented :: generics :: Arr_u8_32) ; impl ferment :: FFIConversionFrom < example_simple :: nested :: HashID > for example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const example_simple_nested_HashID) -> example_simple :: nested :: HashID { let ffi_ref = & * ffi ; < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . 0) } } impl ferment :: FFIConversionTo < example_simple :: nested :: HashID > for example_simple_nested_HashID { unsafe fn ffi_to_const (obj : example_simple :: nested :: HashID) -> * const example_simple_nested_HashID { ferment :: boxed (example_simple_nested_HashID (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj))) } } impl Drop for example_simple_nested_HashID { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut example_simple_nested_HashID { ferment :: boxed (example_simple_nested_HashID (o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_destroy < > (ffi : * mut example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_get_0 < > (obj : * const example_simple_nested_HashID) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_HashID_set_0 < > (obj : * const example_simple_nested_HashID) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . 0 } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestEnum`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_nested_TestEnum { Variant1 (* mut std :: os :: raw :: c_char) , Variant2 , Variant3 (* mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , u32) , Variant4 (* mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , u32 , * mut std :: os :: raw :: c_char) , Variant5 (* mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID , u32 , * mut std :: os :: raw :: c_char) , Variant6 (* mut crate :: fermented :: generics :: Arr_u8_32) } impl ferment :: FFIConversionFrom < example_simple :: nested :: TestEnum > for example_simple_nested_TestEnum { unsafe fn ffi_from_const (ffi : * const example_simple_nested_TestEnum) -> example_simple :: nested :: TestEnum { let ffi_ref = & * ffi ; match ffi_ref { example_simple_nested_TestEnum :: Variant1 (o_0) => example_simple :: nested :: TestEnum :: Variant1 (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_nested_TestEnum :: Variant2 => example_simple :: nested :: TestEnum :: Variant2 , example_simple_nested_TestEnum :: Variant3 (o_0 , o_1) => example_simple :: nested :: TestEnum :: Variant3 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (* o_0) , * o_1) , example_simple_nested_TestEnum :: Variant4 (o_0 , o_1 , o_2) => example_simple :: nested :: TestEnum :: Variant4 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (* o_0) , * o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_2)) , example_simple_nested_TestEnum :: Variant5 (o_0 , o_1 , o_2) => example_simple :: nested :: TestEnum :: Variant5 (< crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > >> :: ffi_from (* o_0) , * o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_2)) , example_simple_nested_TestEnum :: Variant6 (o_0) => example_simple :: nested :: TestEnum :: Variant6 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: nested :: TestEnum > for example_simple_nested_TestEnum { unsafe fn ffi_to_const (obj : example_simple :: nested :: TestEnum) -> * const example_simple_nested_TestEnum { ferment :: boxed (match obj { example_simple :: nested :: TestEnum :: Variant1 (o_0) => example_simple_nested_TestEnum :: Variant1 (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: nested :: TestEnum :: Variant2 => example_simple_nested_TestEnum :: Variant2 , example_simple :: nested :: TestEnum :: Variant3 (o_0 , o_1) => example_simple_nested_TestEnum :: Variant3 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o_0) , o_1) , example_simple :: nested :: TestEnum :: Variant4 (o_0 , o_1 , o_2) => example_simple_nested_TestEnum :: Variant4 (< crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (o_0) , o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_2)) , example_simple :: nested :: TestEnum :: Variant5 (o_0 , o_1 , o_2) => example_simple_nested_TestEnum :: Variant5 (< crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID as ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > >> :: ffi_to (o_0) , o_1 , < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_2)) , example_simple :: nested :: TestEnum :: Variant6 (o_0) => example_simple_nested_TestEnum :: Variant6 (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_nested_TestEnum { fn drop (& mut self) { unsafe { match self { example_simple_nested_TestEnum :: Variant1 (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_nested_TestEnum :: Variant2 => { } , example_simple_nested_TestEnum :: Variant3 (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ; } , example_simple_nested_TestEnum :: Variant4 (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ; ; ferment :: unbox_string (* o_2) ; } , example_simple_nested_TestEnum :: Variant5 (o_0 , o_1 , o_2) => { ferment :: unbox_any (* o_0) ; ; ; ; ferment :: unbox_string (* o_2) ; } , example_simple_nested_TestEnum :: Variant6 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant1_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant1 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant2_ctor () -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant2 { }) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant3_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_o_1 : u32) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant3 (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant4_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_o_1 : u32 , o_o_2 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant4 (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant5_ctor (o_o_0 : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_simple_nested_HashID , o_o_1 : u32 , o_o_2 : * mut std :: os :: raw :: c_char) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant5 (o_o_0 , o_o_1 , o_o_2)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_Variant6_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut example_simple_nested_TestEnum { ferment :: boxed (example_simple_nested_TestEnum :: Variant6 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_nested_TestEnum_destroy < > (ffi : * mut example_simple_nested_TestEnum) { ferment :: unbox_any (ffi) ; } pub mod double_nested { use crate as example_nested ; # [doc = "FFI-representation of the [`example_simple::nested::double_nested::get_root_struct_3`]"] # [no_mangle] pub unsafe extern "C" fn example_simple_nested_double_nested_get_root_struct_3 () -> * mut crate :: fermented :: types :: example_simple :: example_simple_RootStruct { let obj = example_simple :: nested :: double_nested :: get_root_struct_3 () ; < crate :: fermented :: types :: example_simple :: example_simple_RootStruct as ferment :: FFIConversionTo < example_simple :: RootStruct >> :: ffi_to (obj) } } } pub mod errors { use crate as example_nested ; pub mod context { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ContextProviderError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_errors_context_ContextProviderError { Generic (* mut std :: os :: raw :: c_char) , Config (* mut std :: os :: raw :: c_char) , InvalidDataContract (* mut std :: os :: raw :: c_char) , InvalidQuorum (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < example_simple :: errors :: context :: ContextProviderError > for example_simple_errors_context_ContextProviderError { unsafe fn ffi_from_const (ffi : * const example_simple_errors_context_ContextProviderError) -> example_simple :: errors :: context :: ContextProviderError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_errors_context_ContextProviderError :: Generic (o_0) => example_simple :: errors :: context :: ContextProviderError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: Config (o_0) => example_simple :: errors :: context :: ContextProviderError :: Config (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_0) => example_simple :: errors :: context :: ContextProviderError :: InvalidDataContract (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_0) => example_simple :: errors :: context :: ContextProviderError :: InvalidQuorum (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: errors :: context :: ContextProviderError > for example_simple_errors_context_ContextProviderError { unsafe fn ffi_to_const (obj : example_simple :: errors :: context :: ContextProviderError) -> * const example_simple_errors_context_ContextProviderError { ferment :: boxed (match obj { example_simple :: errors :: context :: ContextProviderError :: Generic (o_0) => example_simple_errors_context_ContextProviderError :: Generic (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: Config (o_0) => example_simple_errors_context_ContextProviderError :: Config (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: InvalidDataContract (o_0) => example_simple_errors_context_ContextProviderError :: InvalidDataContract (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_simple :: errors :: context :: ContextProviderError :: InvalidQuorum (o_0) => example_simple_errors_context_ContextProviderError :: InvalidQuorum (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_errors_context_ContextProviderError { fn drop (& mut self) { unsafe { match self { example_simple_errors_context_ContextProviderError :: Generic (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: Config (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_0) => { ferment :: unbox_string (* o_0) ; } , example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_Generic_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: Generic (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_Config_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: Config (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_InvalidDataContract_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: InvalidDataContract (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_InvalidQuorum_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_simple_errors_context_ContextProviderError { ferment :: boxed (example_simple_errors_context_ContextProviderError :: InvalidQuorum (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_context_ContextProviderError_destroy < > (ffi : * mut example_simple_errors_context_ContextProviderError) { ferment :: unbox_any (ffi) ; } } pub mod protocol_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ProtocolError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_simple_errors_protocol_error_ProtocolError { InvalidPKT (* mut crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) } impl ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError > for example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const example_simple_errors_protocol_error_ProtocolError) -> example_simple :: errors :: protocol_error :: ProtocolError { let ffi_ref = & * ffi ; match ffi_ref { example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_0) => example_simple :: errors :: protocol_error :: ProtocolError :: InvalidPKT (< crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionFrom < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_simple :: errors :: protocol_error :: ProtocolError > for example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : example_simple :: errors :: protocol_error :: ProtocolError) -> * const example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (match obj { example_simple :: errors :: protocol_error :: ProtocolError :: InvalidPKT (o_0) => example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (< crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError as ferment :: FFIConversionTo < example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: InvalidIdentityPublicKeyTypeError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { match self { example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_protocol_error_ProtocolError_InvalidPKT_ctor (o_o_0 : * mut crate :: fermented :: types :: example_simple :: state_transition :: errors :: invalid_identity_public_key_type_error :: example_simple_state_transition_errors_invalid_identity_public_key_type_error_InvalidIdentityPublicKeyTypeError) -> * mut example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (example_simple_errors_protocol_error_ProtocolError :: InvalidPKT (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_simple_errors_protocol_error_ProtocolError_destroy < > (ffi : * mut example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } } } } pub mod dashcore { use crate as example_nested ; # [cfg (feature = "serde")] pub mod serde_utils { use crate as example_nested ; } pub mod taproot { use crate as example_nested ; } pub mod network { use crate as example_nested ; # [cfg (feature = "std")] pub mod message_qrinfo { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`MNSkipListMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_network_message_qrinfo_MNSkipListMode { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_MNSkipListMode) -> dashcore :: network :: message_qrinfo :: MNSkipListMode { let ffi_ref = & * ffi ; match ffi_ref { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode > for dashcore_network_message_qrinfo_MNSkipListMode { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: MNSkipListMode) -> * const dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (match obj { dashcore :: network :: message_qrinfo :: MNSkipListMode :: NoSkipping => dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipFirst => dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipExcept => dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept , dashcore :: network :: message_qrinfo :: MNSkipListMode :: SkipAll => dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_network_message_qrinfo_MNSkipListMode { fn drop (& mut self) { unsafe { match self { dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept => { } , dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_NoSkipping_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: NoSkipping { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipFirst_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipFirst { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipExcept_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipExcept { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_SkipAll_ctor () -> * mut dashcore_network_message_qrinfo_MNSkipListMode { ferment :: boxed (dashcore_network_message_qrinfo_MNSkipListMode :: SkipAll { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_MNSkipListMode_destroy < > (ffi : * mut dashcore_network_message_qrinfo_MNSkipListMode) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`QuorumSnapshot`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_network_message_qrinfo_QuorumSnapshot { pub skip_list_mode : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode , pub active_quorum_members : * mut crate :: fermented :: generics :: Vec_bool , pub skip_list : * mut crate :: fermented :: generics :: Vec_u32 } impl ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_from_const (ffi : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> dashcore :: network :: message_qrinfo :: QuorumSnapshot { let ffi_ref = & * ffi ; dashcore :: network :: message_qrinfo :: QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionFrom < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_from (ffi_ref . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from (ffi_ref . skip_list) } } } impl ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: QuorumSnapshot > for dashcore_network_message_qrinfo_QuorumSnapshot { unsafe fn ffi_to_const (obj : dashcore :: network :: message_qrinfo :: QuorumSnapshot) -> * const dashcore_network_message_qrinfo_QuorumSnapshot { ferment :: boxed (dashcore_network_message_qrinfo_QuorumSnapshot { skip_list_mode : < crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode as ferment :: FFIConversionTo < dashcore :: network :: message_qrinfo :: MNSkipListMode >> :: ffi_to (obj . skip_list_mode) , active_quorum_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . active_quorum_members) , skip_list : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionTo < Vec < u32 > >> :: ffi_to (obj . skip_list) }) } } impl Drop for dashcore_network_message_qrinfo_QuorumSnapshot { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . skip_list_mode) ; ferment :: unbox_any (ffi_ref . active_quorum_members) ; ferment :: unbox_any (ffi_ref . skip_list) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_ctor < > (skip_list_mode : * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode , active_quorum_members : * mut crate :: fermented :: generics :: Vec_bool , skip_list : * mut crate :: fermented :: generics :: Vec_u32) -> * mut dashcore_network_message_qrinfo_QuorumSnapshot { ferment :: boxed (dashcore_network_message_qrinfo_QuorumSnapshot { skip_list_mode , active_quorum_members , skip_list }) } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_destroy < > (ffi : * mut dashcore_network_message_qrinfo_QuorumSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_skip_list_mode < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_active_quorum_members < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . active_quorum_members } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_get_skip_list < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_u32 { (* obj) . skip_list } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_skip_list_mode < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: types :: dashcore :: network :: message_qrinfo :: dashcore_network_message_qrinfo_MNSkipListMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_active_quorum_members < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . active_quorum_members } # [no_mangle] pub unsafe extern "C" fn dashcore_network_message_qrinfo_QuorumSnapshot_set_skip_list < > (obj : * const dashcore_network_message_qrinfo_QuorumSnapshot) -> * mut crate :: fermented :: generics :: Vec_u32 { (* obj) . skip_list } } # [cfg (feature = "std")] pub mod address { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_sml { use crate as example_nested ; } pub mod constants { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_blockdata { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message { use crate as example_nested ; } # [cfg (feature = "std")] pub mod message_network { use crate as example_nested ; } } pub mod ephemerealdata { use crate as example_nested ; pub mod chain_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`ChainLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_chain_lock_ChainLock { pub block_height : u32 , pub block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> dashcore :: ephemerealdata :: chain_lock :: ChainLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: chain_lock :: ChainLock { block_height : ffi_ref . block_height , block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (ffi_ref . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: chain_lock :: ChainLock > for dashcore_ephemerealdata_chain_lock_ChainLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: chain_lock :: ChainLock) -> * const dashcore_ephemerealdata_chain_lock_ChainLock { ferment :: boxed (dashcore_ephemerealdata_chain_lock_ChainLock { block_height : obj . block_height , block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (obj . block_hash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_chain_lock_ChainLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . block_hash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_ctor < > (block_height : u32 , block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_ephemerealdata_chain_lock_ChainLock { ferment :: boxed (dashcore_ephemerealdata_chain_lock_ChainLock { block_height , block_hash , signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_destroy < > (ffi : * mut dashcore_ephemerealdata_chain_lock_ChainLock) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_block_height < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> u32 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_block_hash < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_get_signature < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_block_height < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> u32 { (* obj) . block_height } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_block_hash < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_chain_lock_ChainLock_set_signature < > (obj : * const dashcore_ephemerealdata_chain_lock_ChainLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } } pub mod instant_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`InstantLock`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_ephemerealdata_instant_lock_InstantLock { pub version : u8 , pub inputs : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint , pub txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub cyclehash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash , pub signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_from_const (ffi : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> dashcore :: ephemerealdata :: instant_lock :: InstantLock { let ffi_ref = & * ffi ; dashcore :: ephemerealdata :: instant_lock :: InstantLock { version : ffi_ref . version , inputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > >> :: ffi_from (ffi_ref . inputs) , txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . txid) , cyclehash : < example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: CycleHash >> :: ffi_from (ffi_ref . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . signature) } } } impl ferment :: FFIConversionTo < dashcore :: ephemerealdata :: instant_lock :: InstantLock > for dashcore_ephemerealdata_instant_lock_InstantLock { unsafe fn ffi_to_const (obj : dashcore :: ephemerealdata :: instant_lock :: InstantLock) -> * const dashcore_ephemerealdata_instant_lock_InstantLock { ferment :: boxed (dashcore_ephemerealdata_instant_lock_InstantLock { version : obj . version , inputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > >> :: ffi_to (obj . inputs) , txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . txid) , cyclehash : < example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash as ferment :: FFIConversionTo < dashcore :: hash_types :: CycleHash >> :: ffi_to (obj . cyclehash) , signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . signature) }) } } impl Drop for dashcore_ephemerealdata_instant_lock_InstantLock { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . inputs) ; ferment :: unbox_any (ffi_ref . txid) ; ferment :: unbox_any (ffi_ref . cyclehash) ; ferment :: unbox_any (ffi_ref . signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_ctor < > (version : u8 , inputs : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint , txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , cyclehash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash , signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_ephemerealdata_instant_lock_InstantLock { ferment :: boxed (dashcore_ephemerealdata_instant_lock_InstantLock { version , inputs , txid , cyclehash , signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_destroy < > (ffi : * mut dashcore_ephemerealdata_instant_lock_InstantLock) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_version < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_inputs < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . inputs } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_txid < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_cyclehash < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash { (* obj) . cyclehash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_get_signature < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_version < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_inputs < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . inputs } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_txid < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_cyclehash < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_CycleHash { (* obj) . cyclehash } # [no_mangle] pub unsafe extern "C" fn dashcore_ephemerealdata_instant_lock_InstantLock_set_signature < > (obj : * const dashcore_ephemerealdata_instant_lock_InstantLock) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . signature } } } pub mod bls_sig_utils { use crate as example_nested ; # [doc = "FFI-representation of the [`BLSPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSPublicKey (* mut crate :: fermented :: generics :: Arr_u8_48) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSPublicKey) -> dashcore :: bls_sig_utils :: BLSPublicKey { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionFrom < [u8 ; 48] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey > for dashcore_bls_sig_utils_BLSPublicKey { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSPublicKey) -> * const dashcore_bls_sig_utils_BLSPublicKey { ferment :: boxed (dashcore_bls_sig_utils_BLSPublicKey (< crate :: fermented :: generics :: Arr_u8_48 as ferment :: FFIConversionTo < [u8 ; 48] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_48) -> * mut dashcore_bls_sig_utils_BLSPublicKey { ferment :: boxed (dashcore_bls_sig_utils_BLSPublicKey (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_destroy < > (ffi : * mut dashcore_bls_sig_utils_BLSPublicKey) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_get_0 < > (obj : * const dashcore_bls_sig_utils_BLSPublicKey) -> * mut crate :: fermented :: generics :: Arr_u8_48 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSPublicKey_set_0 < > (obj : * const dashcore_bls_sig_utils_BLSPublicKey) -> * mut crate :: fermented :: generics :: Arr_u8_48 { (* obj) . 0 } # [doc = "FFI-representation of the [`BLSSignature`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_bls_sig_utils_BLSSignature (* mut crate :: fermented :: generics :: Arr_u8_96) ; impl ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_from_const (ffi : * const dashcore_bls_sig_utils_BLSSignature) -> dashcore :: bls_sig_utils :: BLSSignature { let ffi_ref = & * ffi ; dashcore :: bls_sig_utils :: BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionFrom < [u8 ; 96] >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature > for dashcore_bls_sig_utils_BLSSignature { unsafe fn ffi_to_const (obj : dashcore :: bls_sig_utils :: BLSSignature) -> * const dashcore_bls_sig_utils_BLSSignature { ferment :: boxed (dashcore_bls_sig_utils_BLSSignature (< crate :: fermented :: generics :: Arr_u8_96 as ferment :: FFIConversionTo < [u8 ; 96] >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_bls_sig_utils_BLSSignature { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_ctor < > (o_0 : * mut crate :: fermented :: generics :: Arr_u8_96) -> * mut dashcore_bls_sig_utils_BLSSignature { ferment :: boxed (dashcore_bls_sig_utils_BLSSignature (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_destroy < > (ffi : * mut dashcore_bls_sig_utils_BLSSignature) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_get_0 < > (obj : * const dashcore_bls_sig_utils_BLSSignature) -> * mut crate :: fermented :: generics :: Arr_u8_96 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_bls_sig_utils_BLSSignature_set_0 < > (obj : * const dashcore_bls_sig_utils_BLSSignature) -> * mut crate :: fermented :: generics :: Arr_u8_96 { (* obj) . 0 } } pub mod internal_macros { use crate as example_nested ; } pub mod sign_message { use crate as example_nested ; } pub mod blockdata { use crate as example_nested ; pub mod opcodes { use crate as example_nested ; } pub mod script { use crate as example_nested ; pub mod push_bytes { use crate as example_nested ; } pub mod owned { use crate as example_nested ; # [doc = "FFI-representation of the [`ScriptBuf`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_script_owned_ScriptBuf (* mut crate :: fermented :: generics :: Vec_u8) ; impl ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_script_owned_ScriptBuf) -> dashcore :: blockdata :: script :: owned :: ScriptBuf { let ffi_ref = & * ffi ; dashcore :: blockdata :: script :: owned :: ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . 0)) } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf > for dashcore_blockdata_script_owned_ScriptBuf { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: script :: owned :: ScriptBuf) -> * const dashcore_blockdata_script_owned_ScriptBuf { ferment :: boxed (dashcore_blockdata_script_owned_ScriptBuf (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . 0))) } } impl Drop for dashcore_blockdata_script_owned_ScriptBuf { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . 0) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_ctor < > (o_0 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dashcore_blockdata_script_owned_ScriptBuf { ferment :: boxed (dashcore_blockdata_script_owned_ScriptBuf (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_destroy < > (ffi : * mut dashcore_blockdata_script_owned_ScriptBuf) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_get_0 < > (obj : * const dashcore_blockdata_script_owned_ScriptBuf) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_script_owned_ScriptBuf_set_0 < > (obj : * const dashcore_blockdata_script_owned_ScriptBuf) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . 0 } } } pub mod weight { use crate as example_nested ; } pub mod locktime { use crate as example_nested ; pub mod absolute { use crate as example_nested ; } pub mod relative { use crate as example_nested ; } } pub mod constants { use crate as example_nested ; } pub mod witness { use crate as example_nested ; # [doc = "FFI-representation of the [`Witness`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_witness_Witness { pub content : * mut crate :: fermented :: generics :: Vec_u8 , pub witness_elements : usize , pub indices_start : usize } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_witness_Witness) -> dashcore :: blockdata :: witness :: Witness { let ffi_ref = & * ffi ; dashcore :: blockdata :: witness :: Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . content) , witness_elements : ffi_ref . witness_elements , indices_start : ffi_ref . indices_start } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness > for dashcore_blockdata_witness_Witness { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: witness :: Witness) -> * const dashcore_blockdata_witness_Witness { ferment :: boxed (dashcore_blockdata_witness_Witness { content : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . content) , witness_elements : obj . witness_elements , indices_start : obj . indices_start }) } } impl Drop for dashcore_blockdata_witness_Witness { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . content) ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_ctor < > (content : * mut crate :: fermented :: generics :: Vec_u8 , witness_elements : usize , indices_start : usize) -> * mut dashcore_blockdata_witness_Witness { ferment :: boxed (dashcore_blockdata_witness_Witness { content , witness_elements , indices_start }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_destroy < > (ffi : * mut dashcore_blockdata_witness_Witness) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_content < > (obj : * const dashcore_blockdata_witness_Witness) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . content } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_witness_elements < > (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . witness_elements } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_get_indices_start < > (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . indices_start } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_content < > (obj : * const dashcore_blockdata_witness_Witness) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . content } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_witness_elements < > (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . witness_elements } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_witness_Witness_set_indices_start < > (obj : * const dashcore_blockdata_witness_Witness) -> usize { (* obj) . indices_start } } pub mod transaction { use crate as example_nested ; # [doc = "FFI-representation of the [`Transaction`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_Transaction { pub version : u16 , pub lock_time : u32 , pub input : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn , pub output : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut , pub special_transaction_payload : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_Transaction) -> dashcore :: blockdata :: transaction :: Transaction { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: Transaction { version : ffi_ref . version , lock_time : ffi_ref . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_from (ffi_ref . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_from_opt (ffi_ref . special_transaction_payload) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: Transaction > for dashcore_blockdata_transaction_Transaction { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: Transaction) -> * const dashcore_blockdata_transaction_Transaction { ferment :: boxed (dashcore_blockdata_transaction_Transaction { version : obj . version , lock_time : obj . lock_time , input : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > >> :: ffi_to (obj . input) , output : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_to (obj . output) , special_transaction_payload : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload >> :: ffi_to_opt (obj . special_transaction_payload) }) } } impl Drop for dashcore_blockdata_transaction_Transaction { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . input) ; ferment :: unbox_any (ffi_ref . output) ; ferment :: unbox_any_opt (ffi_ref . special_transaction_payload) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_ctor < > (version : u16 , lock_time : u32 , input : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn , output : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut , special_transaction_payload : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> * mut dashcore_blockdata_transaction_Transaction { ferment :: boxed (dashcore_blockdata_transaction_Transaction { version , lock_time , input , output , special_transaction_payload }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_destroy < > (ffi : * mut dashcore_blockdata_transaction_Transaction) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_version < > (obj : * const dashcore_blockdata_transaction_Transaction) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_lock_time < > (obj : * const dashcore_blockdata_transaction_Transaction) -> u32 { (* obj) . lock_time } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_input < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn { (* obj) . input } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_output < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut { (* obj) . output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_get_special_transaction_payload < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload { (* obj) . special_transaction_payload } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_version < > (obj : * const dashcore_blockdata_transaction_Transaction) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_lock_time < > (obj : * const dashcore_blockdata_transaction_Transaction) -> u32 { (* obj) . lock_time } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_input < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txin_TxIn { (* obj) . input } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_output < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut { (* obj) . output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_Transaction_set_special_transaction_payload < > (obj : * const dashcore_blockdata_transaction_Transaction) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: dashcore_blockdata_transaction_special_transaction_TransactionPayload { (* obj) . special_transaction_payload } pub mod outpoint { use crate as example_nested ; # [doc = "FFI-representation of the [`OutPoint`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_outpoint_OutPoint { pub txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub vout : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> dashcore :: blockdata :: transaction :: outpoint :: OutPoint { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: outpoint :: OutPoint { txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . txid) , vout : ffi_ref . vout } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > for dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: outpoint :: OutPoint) -> * const dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (dashcore_blockdata_transaction_outpoint_OutPoint { txid : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . txid) , vout : obj . vout }) } } impl Drop for dashcore_blockdata_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . txid) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_ctor < > (txid : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , vout : u32) -> * mut dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (dashcore_blockdata_transaction_outpoint_OutPoint { txid , vout }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_destroy < > (ffi : * mut dashcore_blockdata_transaction_outpoint_OutPoint) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_get_txid < > (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_get_vout < > (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> u32 { (* obj) . vout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_set_txid < > (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . txid } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_outpoint_OutPoint_set_vout < > (obj : * const dashcore_blockdata_transaction_outpoint_OutPoint) -> u32 { (* obj) . vout } } pub mod txin { use crate as example_nested ; # [doc = "FFI-representation of the [`TxIn`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txin_TxIn { pub previous_output : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , pub script_sig : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub sequence : u32 , pub witness : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txin_TxIn) -> dashcore :: blockdata :: transaction :: txin :: TxIn { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txin :: TxIn { previous_output : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . previous_output) , script_sig : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_sig) , sequence : ffi_ref . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionFrom < dashcore :: blockdata :: witness :: Witness >> :: ffi_from (ffi_ref . witness) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txin :: TxIn > for dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txin :: TxIn) -> * const dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (dashcore_blockdata_transaction_txin_TxIn { previous_output : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . previous_output) , script_sig : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_sig) , sequence : obj . sequence , witness : < crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness as ferment :: FFIConversionTo < dashcore :: blockdata :: witness :: Witness >> :: ffi_to (obj . witness) }) } } impl Drop for dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . previous_output) ; ferment :: unbox_any (ffi_ref . script_sig) ; ; ferment :: unbox_any (ffi_ref . witness) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_ctor < > (previous_output : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , script_sig : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , sequence : u32 , witness : * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness) -> * mut dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (dashcore_blockdata_transaction_txin_TxIn { previous_output , script_sig , sequence , witness }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_destroy < > (ffi : * mut dashcore_blockdata_transaction_txin_TxIn) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_previous_output < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . previous_output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_script_sig < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_sequence < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> u32 { (* obj) . sequence } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_get_witness < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness { (* obj) . witness } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_previous_output < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . previous_output } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_script_sig < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_sequence < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> u32 { (* obj) . sequence } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txin_TxIn_set_witness < > (obj : * const dashcore_blockdata_transaction_txin_TxIn) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: witness :: dashcore_blockdata_witness_Witness { (* obj) . witness } } pub mod hash_type { use crate as example_nested ; } pub mod special_transaction { use crate as example_nested ; pub mod asset_lock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetLockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { pub version : u8 , pub credit_outputs : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload { version : ffi_ref . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_from (ffi_ref . credit_outputs) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload > for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { version : obj . version , credit_outputs : < crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut as ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > >> :: ffi_to (obj . credit_outputs) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . credit_outputs) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_ctor < > (version : u8 , credit_outputs : * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut) -> * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload { version , credit_outputs }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_get_credit_outputs < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut { (* obj) . credit_outputs } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload_set_credit_outputs < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> * mut crate :: fermented :: generics :: Vec_dashcore_blockdata_transaction_txout_TxOut { (* obj) . credit_outputs } } pub mod quorum_commitment { use crate as example_nested ; # [doc = "FFI-representation of the [`QuorumCommitmentPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { pub version : u16 , pub height : u32 , pub finalization_commitment : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload { version : ffi_ref . version , height : ffi_ref . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (ffi_ref . finalization_commitment) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { version : obj . version , height : obj . height , finalization_commitment : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_to (obj . finalization_commitment) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . finalization_commitment) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_ctor < > (version : u16 , height : u32 , finalization_commitment : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload { version , height , finalization_commitment }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_get_finalization_commitment < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { (* obj) . finalization_commitment } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload_set_finalization_commitment < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { (* obj) . finalization_commitment } # [doc = "FFI-representation of the [`QuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { pub version : u16 , pub llmq_type : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub quorum_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , pub quorum_index : * mut i16 , pub signers : * mut crate :: fermented :: generics :: Vec_bool , pub valid_members : * mut crate :: fermented :: generics :: Vec_bool , pub quorum_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub quorum_vvec_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash , pub threshold_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub all_commitment_aggregated_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry { version : ffi_ref . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (ffi_ref . llmq_type) , quorum_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (ffi_ref . quorum_hash) , quorum_index : ferment :: from_opt_primitive (ffi_ref . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionFrom < Vec < bool > >> :: ffi_from (ffi_ref . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . quorum_public_key) , quorum_vvec_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumVVecHash >> :: ffi_from (ffi_ref . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . all_commitment_aggregated_signature) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry > for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry) -> * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { version : obj . version , llmq_type : < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj . llmq_type) , quorum_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (obj . quorum_hash) , quorum_index : ferment :: to_opt_primitive (obj . quorum_index) , signers : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . signers) , valid_members : < crate :: fermented :: generics :: Vec_bool as ferment :: FFIConversionTo < Vec < bool > >> :: ffi_to (obj . valid_members) , quorum_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . quorum_public_key) , quorum_vvec_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumVVecHash >> :: ffi_to (obj . quorum_vvec_hash) , threshold_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . threshold_sig) , all_commitment_aggregated_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . all_commitment_aggregated_signature) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . llmq_type) ; ferment :: unbox_any (ffi_ref . quorum_hash) ; ferment :: destroy_opt_primitive (ffi_ref . quorum_index) ; ferment :: unbox_any (ffi_ref . signers) ; ferment :: unbox_any (ffi_ref . valid_members) ; ferment :: unbox_any (ffi_ref . quorum_public_key) ; ferment :: unbox_any (ffi_ref . quorum_vvec_hash) ; ferment :: unbox_any (ffi_ref . threshold_sig) ; ferment :: unbox_any (ffi_ref . all_commitment_aggregated_signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_ctor < > (version : u16 , llmq_type : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , quorum_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , quorum_index : * mut i16 , signers : * mut crate :: fermented :: generics :: Vec_bool , valid_members : * mut crate :: fermented :: generics :: Vec_bool , quorum_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , quorum_vvec_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash , threshold_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , all_commitment_aggregated_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { version , llmq_type , quorum_hash , quorum_index , signers , valid_members , quorum_public_key , quorum_vvec_hash , threshold_sig , all_commitment_aggregated_signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_llmq_type < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { (* obj) . llmq_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash { (* obj) . quorum_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_index < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut i16 { (* obj) . quorum_index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_signers < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . signers } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_valid_members < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . valid_members } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . quorum_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_quorum_vvec_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash { (* obj) . quorum_vvec_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_threshold_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . threshold_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_get_all_commitment_aggregated_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . all_commitment_aggregated_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_llmq_type < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { (* obj) . llmq_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash { (* obj) . quorum_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_index < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut i16 { (* obj) . quorum_index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_signers < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . signers } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_valid_members < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: generics :: Vec_bool { (* obj) . valid_members } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . quorum_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_quorum_vvec_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumVVecHash { (* obj) . quorum_vvec_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_threshold_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . threshold_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry_set_all_commitment_aggregated_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . all_commitment_aggregated_signature } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TransactionPayload`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_blockdata_transaction_special_transaction_TransactionPayload { ProviderRegistrationPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) , ProviderUpdateServicePayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) , ProviderUpdateRegistrarPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) , ProviderUpdateRevocationPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) , CoinbasePayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) , QuorumCommitmentPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) , AssetLockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) , AssetUnlockPayloadType (* mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_TransactionPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload { let ffi_ref = & * ffi ; match ffi_ref { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_from (* o_0)) , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload > for dashcore_blockdata_transaction_special_transaction_TransactionPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload) -> * const dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (match obj { dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderRegistrationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: CoinbasePayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: QuorumCommitmentPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumCommitmentPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetLockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: AssetLockPayload >> :: ffi_to (o_0)) , dashcore :: blockdata :: transaction :: special_transaction :: TransactionPayload :: AssetUnlockPayloadType (o_0) => dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (< crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_TransactionPayload { fn drop (& mut self) { unsafe { match self { dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderRegistrationPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderRegistrationPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateServicePayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateServicePayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateRegistrarPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRegistrarPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_ProviderUpdateRevocationPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: ProviderUpdateRevocationPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_CoinbasePayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: CoinbasePayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_QuorumCommitmentPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumCommitmentPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: QuorumCommitmentPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_AssetLockPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_lock :: dashcore_blockdata_transaction_special_transaction_asset_lock_AssetLockPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetLockPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_AssetUnlockPayloadType_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_TransactionPayload :: AssetUnlockPayloadType (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_TransactionPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_TransactionPayload) { ferment :: unbox_any (ffi) ; } pub mod provider_update_revocation { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateRevocationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { pub version : u16 , pub pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub reason : u16 , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload { version : ffi_ref . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . pro_tx_hash) , reason : ffi_ref . reason , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_revocation :: ProviderUpdateRevocationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { version : obj . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . pro_tx_hash) , reason : obj . reason , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_ctor < > (version : u16 , pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , reason : u16 , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload { version , pro_tx_hash , reason , inputs_hash , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_reason < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . reason } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_get_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_reason < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> u16 { (* obj) . reason } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload_set_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_revocation_ProviderUpdateRevocationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } } pub mod provider_update_service { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateServicePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { pub version : u16 , pub pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub ip_address : * mut [u8 ; 16] , pub port : u16 , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload { version : ffi_ref . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionFrom < u128 >> :: ffi_from (ffi_ref . ip_address) , port : ffi_ref . port , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload > for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_service :: ProviderUpdateServicePayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { version : obj . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . pro_tx_hash) , ip_address : < [u8 ; 16] as ferment :: FFIConversionTo < u128 >> :: ffi_to (obj . ip_address) , port : obj . port , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , payload_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ferment :: unbox_any_opt (ffi_ref . ip_address) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_ctor < > (version : u16 , pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , ip_address : * mut [u8 ; 16] , port : u16 , script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , payload_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload { version , pro_tx_hash , ip_address , port , script_payout , inputs_hash , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_ip_address < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut [u8 ; 16] { (* obj) . ip_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_get_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_ip_address < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut [u8 ; 16] { (* obj) . ip_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> u16 { (* obj) . port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload_set_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_service_ProviderUpdateServicePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . payload_sig } } pub mod asset_unlock { use crate as example_nested ; pub mod qualified_asset_unlock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { pub base : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , pub request_info : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , pub quorum_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_from (ffi_ref . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_from (ffi_ref . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (ffi_ref . quorum_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: qualified_asset_unlock :: AssetUnlockPayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { base : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload >> :: ffi_to (obj . base) , request_info : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo >> :: ffi_to (obj . request_info) , quorum_sig : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (obj . quorum_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . base) ; ferment :: unbox_any (ffi_ref . request_info) ; ferment :: unbox_any (ffi_ref . quorum_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_ctor < > (base : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload , request_info : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo , quorum_sig : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload { base , request_info , quorum_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_base < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_request_info < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { (* obj) . request_info } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_get_quorum_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . quorum_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_base < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { (* obj) . base } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_request_info < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { (* obj) . request_info } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload_set_quorum_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_qualified_asset_unlock_AssetUnlockPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . quorum_sig } } pub mod request_info { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockRequestInfo`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { pub request_height : u32 , pub quorum_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo { request_height : ffi_ref . request_height , quorum_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (ffi_ref . quorum_hash) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo > for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: request_info :: AssetUnlockRequestInfo) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { request_height : obj . request_height , quorum_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (obj . quorum_hash) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . quorum_hash) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_ctor < > (request_height : u32 , quorum_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo { request_height , quorum_hash }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_get_request_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> u32 { (* obj) . request_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_get_quorum_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash { (* obj) . quorum_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_set_request_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> u32 { (* obj) . request_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo_set_quorum_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_request_info_AssetUnlockRequestInfo) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash { (* obj) . quorum_hash } } pub mod unqualified_asset_unlock { use crate as example_nested ; # [doc = "FFI-representation of the [`AssetUnlockBasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { pub version : u8 , pub index : u64 , pub fee : u32 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload { version : ffi_ref . version , index : ffi_ref . index , fee : ffi_ref . fee } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload > for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: asset_unlock :: unqualified_asset_unlock :: AssetUnlockBasePayload) -> * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { version : obj . version , index : obj . index , fee : obj . fee }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_ctor < > (version : u8 , index : u64 , fee : u32) -> * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload { version , index , fee }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_index < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u64 { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_get_fee < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u32 { (* obj) . fee } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u8 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_index < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u64 { (* obj) . index } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload_set_fee < > (obj : * const dashcore_blockdata_transaction_special_transaction_asset_unlock_unqualified_asset_unlock_AssetUnlockBasePayload) -> u32 { (* obj) . fee } } } pub mod coinbase { use crate as example_nested ; # [doc = "FFI-representation of the [`CoinbasePayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { pub version : u16 , pub height : u32 , pub merkle_root_masternode_list : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , pub merkle_root_quorums : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , pub best_cl_height : * mut u32 , pub best_cl_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , pub asset_locked_amount : * mut u64 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload { version : ffi_ref . version , height : ffi_ref . height , merkle_root_masternode_list : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_from (ffi_ref . merkle_root_masternode_list) , merkle_root_quorums : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_from (ffi_ref . merkle_root_quorums) , best_cl_height : ferment :: from_opt_primitive (ffi_ref . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from_opt (ffi_ref . best_cl_signature) , asset_locked_amount : ferment :: from_opt_primitive (ffi_ref . asset_locked_amount) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload > for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: coinbase :: CoinbasePayload) -> * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { version : obj . version , height : obj . height , merkle_root_masternode_list : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_to (obj . merkle_root_masternode_list) , merkle_root_quorums : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_to (obj . merkle_root_quorums) , best_cl_height : ferment :: to_opt_primitive (obj . best_cl_height) , best_cl_signature : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to_opt (obj . best_cl_signature) , asset_locked_amount : ferment :: to_opt_primitive (obj . asset_locked_amount) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ; ferment :: unbox_any (ffi_ref . merkle_root_masternode_list) ; ferment :: unbox_any (ffi_ref . merkle_root_quorums) ; ferment :: destroy_opt_primitive (ffi_ref . best_cl_height) ; ferment :: unbox_any_opt (ffi_ref . best_cl_signature) ; ferment :: destroy_opt_primitive (ffi_ref . asset_locked_amount) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_ctor < > (version : u16 , height : u32 , merkle_root_masternode_list : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , merkle_root_quorums : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , best_cl_height : * mut u32 , best_cl_signature : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature , asset_locked_amount : * mut u64) -> * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload { version , height , merkle_root_masternode_list , merkle_root_quorums , best_cl_height , best_cl_signature , asset_locked_amount }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_merkle_root_masternode_list < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . merkle_root_masternode_list } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_merkle_root_quorums < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . merkle_root_quorums } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_best_cl_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u32 { (* obj) . best_cl_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_best_cl_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . best_cl_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_get_asset_locked_amount < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u64 { (* obj) . asset_locked_amount } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> u32 { (* obj) . height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_merkle_root_masternode_list < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . merkle_root_masternode_list } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_merkle_root_quorums < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . merkle_root_quorums } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_best_cl_height < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u32 { (* obj) . best_cl_height } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_best_cl_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature { (* obj) . best_cl_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload_set_asset_locked_amount < > (obj : * const dashcore_blockdata_transaction_special_transaction_coinbase_CoinbasePayload) -> * mut u64 { (* obj) . asset_locked_amount } } pub mod provider_registration { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderRegistrationPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { pub version : u16 , pub masternode_type : * mut dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType , pub masternode_mode : u16 , pub collateral_outpoint : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , pub service_address : * mut std :: net :: SocketAddr , pub owner_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , pub operator_reward : u16 , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub signature : * mut crate :: fermented :: generics :: Vec_u8 , pub platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , pub platform_p2p_port : * mut u16 , pub platform_http_port : * mut u16 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload { version : ffi_ref . version , masternode_type : (& * ffi_ref . masternode_type) . clone () , masternode_mode : ffi_ref . masternode_mode , collateral_outpoint : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_from (ffi_ref . collateral_outpoint) , service_address : (& * ffi_ref . service_address) . clone () , owner_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (ffi_ref . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (ffi_ref . voting_key_hash) , operator_reward : ffi_ref . operator_reward , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . signature) , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from_opt (ffi_ref . platform_node_id) , platform_p2p_port : ferment :: from_opt_primitive (ffi_ref . platform_p2p_port) , platform_http_port : ferment :: from_opt_primitive (ffi_ref . platform_http_port) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload > for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderRegistrationPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { version : obj . version , masternode_type : ferment :: boxed (obj . masternode_type) , masternode_mode : obj . masternode_mode , collateral_outpoint : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >> :: ffi_to (obj . collateral_outpoint) , service_address : ferment :: boxed (obj . service_address) , owner_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (obj . owner_key_hash) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (obj . voting_key_hash) , operator_reward : obj . operator_reward , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , signature : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . signature) , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to_opt (obj . platform_node_id) , platform_p2p_port : ferment :: to_opt_primitive (obj . platform_p2p_port) , platform_http_port : ferment :: to_opt_primitive (obj . platform_http_port) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . masternode_type) ; ; ferment :: unbox_any (ffi_ref . collateral_outpoint) ; ferment :: unbox_any (ffi_ref . service_address) ; ferment :: unbox_any (ffi_ref . owner_key_hash) ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . signature) ; ferment :: unbox_any_opt (ffi_ref . platform_node_id) ; ferment :: destroy_opt_primitive (ffi_ref . platform_p2p_port) ; ferment :: destroy_opt_primitive (ffi_ref . platform_http_port) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_ctor < > (version : u16 , masternode_type : * mut dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType , masternode_mode : u16 , collateral_outpoint : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint , service_address : * mut std :: net :: SocketAddr , owner_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , voting_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , operator_reward : u16 , script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , signature : * mut crate :: fermented :: generics :: Vec_u8 , platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , platform_p2p_port : * mut u16 , platform_http_port : * mut u16) -> * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload { version , masternode_type , masternode_mode , collateral_outpoint , service_address , owner_key_hash , operator_public_key , voting_key_hash , operator_reward , script_payout , inputs_hash , signature , platform_node_id , platform_p2p_port , platform_http_port }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_masternode_type < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType { (* obj) . masternode_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_masternode_mode < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . masternode_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_collateral_outpoint < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . collateral_outpoint } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_service_address < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut std :: net :: SocketAddr { (* obj) . service_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_owner_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . owner_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_operator_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_voting_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_operator_reward < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . operator_reward } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_node_id < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . platform_node_id } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_p2p_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_p2p_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_get_platform_http_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_http_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_masternode_type < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut dashcore :: blockdata :: transaction :: special_transaction :: provider_registration :: ProviderMasternodeType { (* obj) . masternode_type } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_masternode_mode < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . masternode_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_collateral_outpoint < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint { (* obj) . collateral_outpoint } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_service_address < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut std :: net :: SocketAddr { (* obj) . service_address } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_owner_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . owner_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_operator_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_voting_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_operator_reward < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> u16 { (* obj) . operator_reward } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_signature < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . signature } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_node_id < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . platform_node_id } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_p2p_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_p2p_port } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload_set_platform_http_port < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_registration_ProviderRegistrationPayload) -> * mut u16 { (* obj) . platform_http_port } } pub mod provider_update_registrar { use crate as example_nested ; # [doc = "FFI-representation of the [`ProviderUpdateRegistrarPayload`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { pub version : u16 , pub pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , pub provider_mode : u16 , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub voting_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , pub script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , pub inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , pub payload_sig : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload { version : ffi_ref . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionFrom < dashcore :: hash_types :: Txid >> :: ffi_from (ffi_ref . pro_tx_hash) , provider_mode : ffi_ref . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , voting_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (ffi_ref . voting_key_hash) , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: InputsHash >> :: ffi_from (ffi_ref . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . payload_sig) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload > for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: special_transaction :: provider_update_registrar :: ProviderUpdateRegistrarPayload) -> * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { version : obj . version , pro_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Txid as ferment :: FFIConversionTo < dashcore :: hash_types :: Txid >> :: ffi_to (obj . pro_tx_hash) , provider_mode : obj . provider_mode , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , voting_key_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (obj . voting_key_hash) , script_payout : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_payout) , inputs_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash as ferment :: FFIConversionTo < dashcore :: hash_types :: InputsHash >> :: ffi_to (obj . inputs_hash) , payload_sig : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . payload_sig) }) } } impl Drop for dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_tx_hash) ; ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . voting_key_hash) ; ferment :: unbox_any (ffi_ref . script_payout) ; ferment :: unbox_any (ffi_ref . inputs_hash) ; ferment :: unbox_any (ffi_ref . payload_sig) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_ctor < > (version : u16 , pro_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid , provider_mode : u16 , operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , voting_key_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , script_payout : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf , inputs_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash , payload_sig : * mut crate :: fermented :: generics :: Vec_u8) -> * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { ferment :: boxed (dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload { version , pro_tx_hash , provider_mode , operator_public_key , voting_key_hash , script_payout , inputs_hash , payload_sig }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_destroy < > (ffi : * mut dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_provider_mode < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . provider_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_operator_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_voting_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_get_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . payload_sig } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_version < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_pro_tx_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Txid { (* obj) . pro_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_provider_mode < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> u16 { (* obj) . provider_mode } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_operator_public_key < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_voting_key_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . voting_key_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_script_payout < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_payout } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_inputs_hash < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_InputsHash { (* obj) . inputs_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload_set_payload_sig < > (obj : * const dashcore_blockdata_transaction_special_transaction_provider_update_registrar_ProviderUpdateRegistrarPayload) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . payload_sig } } } pub mod txout { use crate as example_nested ; # [doc = "FFI-representation of the [`TxOut`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_blockdata_transaction_txout_TxOut { pub value : u64 , pub script_pubkey : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf } impl ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const dashcore_blockdata_transaction_txout_TxOut) -> dashcore :: blockdata :: transaction :: txout :: TxOut { let ffi_ref = & * ffi ; dashcore :: blockdata :: transaction :: txout :: TxOut { value : ffi_ref . value , script_pubkey : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionFrom < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_from (ffi_ref . script_pubkey) } } } impl ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: txout :: TxOut > for dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : dashcore :: blockdata :: transaction :: txout :: TxOut) -> * const dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (dashcore_blockdata_transaction_txout_TxOut { value : obj . value , script_pubkey : < crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf as ferment :: FFIConversionTo < dashcore :: blockdata :: script :: owned :: ScriptBuf >> :: ffi_to (obj . script_pubkey) }) } } impl Drop for dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . script_pubkey) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_ctor < > (value : u64 , script_pubkey : * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf) -> * mut dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (dashcore_blockdata_transaction_txout_TxOut { value , script_pubkey }) } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_destroy < > (ffi : * mut dashcore_blockdata_transaction_txout_TxOut) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_get_value < > (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> u64 { (* obj) . value } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_get_script_pubkey < > (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_pubkey } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_set_value < > (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> u64 { (* obj) . value } # [no_mangle] pub unsafe extern "C" fn dashcore_blockdata_transaction_txout_TxOut_set_script_pubkey < > (obj : * const dashcore_blockdata_transaction_txout_TxOut) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: script :: owned :: dashcore_blockdata_script_owned_ScriptBuf { (* obj) . script_pubkey } } } pub mod fee_rate { use crate as example_nested ; } pub mod block { use crate as example_nested ; } } pub mod crypto { use crate as example_nested ; pub mod sighash { use crate as example_nested ; } pub mod key { use crate as example_nested ; } } pub mod bip152 { use crate as example_nested ; } pub mod prelude { use crate as example_nested ; # [doc = "FFI-representation of the [`CoreBlockHeight`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_prelude_CoreBlockHeight (u32) ; impl ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_from_const (ffi : * const dashcore_prelude_CoreBlockHeight) -> dashcore :: prelude :: CoreBlockHeight { let ffi_ref = & * ffi ; ffi_ref . 0 } } impl ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight > for dashcore_prelude_CoreBlockHeight { unsafe fn ffi_to_const (obj : dashcore :: prelude :: CoreBlockHeight) -> * const dashcore_prelude_CoreBlockHeight { ferment :: boxed (dashcore_prelude_CoreBlockHeight (obj)) } } impl Drop for dashcore_prelude_CoreBlockHeight { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_ctor < > (o_0 : u32) -> * mut dashcore_prelude_CoreBlockHeight { ferment :: boxed (dashcore_prelude_CoreBlockHeight (o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_destroy < > (ffi : * mut dashcore_prelude_CoreBlockHeight) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_get_0 < > (obj : * const dashcore_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } # [no_mangle] pub unsafe extern "C" fn dashcore_prelude_CoreBlockHeight_set_0 < > (obj : * const dashcore_prelude_CoreBlockHeight) -> u32 { (* obj) . 0 } } pub mod util { use crate as example_nested ; } pub mod bip158 { use crate as example_nested ; } pub mod pow { use crate as example_nested ; } pub mod signer { use crate as example_nested ; } pub mod sml { use crate as example_nested ; pub mod quorum_entry { use crate as example_nested ; pub mod qualified_quorum_entry { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VerifyingChainLockSignaturesType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { Rotating (* mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) , NonRotating (* mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_from (* o_0)) , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType > for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (match obj { dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: Rotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType :: NonRotating (o_0) => dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_Rotating_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: Rotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_NonRotating_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType :: NonRotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType_destroy < > (ffi : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`QualifiedQuorumEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub quorum_entry : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , pub verified : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus , pub commitment_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash , pub entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash , pub verifying_chain_lock_signature : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { let ffi_ref = & * ffi ; dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry { quorum_entry : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionFrom < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_from (ffi_ref . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_from (ffi_ref . verified) , commitment_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumCommitmentHash >> :: ffi_from (ffi_ref . commitment_hash) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumEntryHash >> :: ffi_from (ffi_ref . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_from_opt (ffi_ref . verifying_chain_lock_signature) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry) -> * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { quorum_entry : < crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry as ferment :: FFIConversionTo < dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: QuorumEntry >> :: ffi_to (obj . quorum_entry) , verified : < crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus as ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus >> :: ffi_to (obj . verified) , commitment_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumCommitmentHash >> :: ffi_to (obj . commitment_hash) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumEntryHash >> :: ffi_to (obj . entry_hash) , verifying_chain_lock_signature : < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType as ferment :: FFIConversionTo < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: VerifyingChainLockSignaturesType >> :: ffi_to_opt (obj . verifying_chain_lock_signature) }) } } impl Drop for dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . quorum_entry) ; ferment :: unbox_any (ffi_ref . verified) ; ferment :: unbox_any (ffi_ref . commitment_hash) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . verifying_chain_lock_signature) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor < > (quorum_entry : * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry , verified : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus , commitment_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash , entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash , verifying_chain_lock_signature : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType) -> * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { quorum_entry , verified , commitment_hash , entry_hash , verifying_chain_lock_signature }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy < > (ffi : * mut dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_quorum_entry < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { (* obj) . quorum_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_verified < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { (* obj) . verified } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_commitment_hash < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash { (* obj) . commitment_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_entry_hash < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_get_verifying_chain_lock_signature < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { (* obj) . verifying_chain_lock_signature } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_quorum_entry < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: special_transaction :: quorum_commitment :: dashcore_blockdata_transaction_special_transaction_quorum_commitment_QuorumEntry { (* obj) . quorum_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_verified < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_entry_verification :: dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { (* obj) . verified } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_commitment_hash < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumCommitmentHash { (* obj) . commitment_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_entry_hash < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumEntryHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_set_verifying_chain_lock_signature < > (obj : * const dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_VerifyingChainLockSignaturesType { (* obj) . verifying_chain_lock_signature } } } pub mod quorum_validation_error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`QuorumValidationError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_QuorumValidationError { RequiredBlockNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , RequiredBlockHeightNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , VerifyingMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredMasternodeListNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) , RequiredChainLockNotPresent (* mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight , * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , RequiredRotatedChainLockSigNotPresent (u8 , * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , RequiredRotatedChainLockSigsNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , InsufficientSigners { required : u64 , found : u64 } , InsufficientValidMembers { required : u64 , found : u64 } , MismatchedBitsetLengths { signers_len : usize , valid_members_len : usize } , InvalidQuorumPublicKey , InvalidBLSPublicKey (* mut std :: os :: raw :: c_char) , InvalidBLSSignature (* mut std :: os :: raw :: c_char) , InvalidQuorumSignature , InvalidFinalSignature , AllCommitmentAggregatedSignatureNotValid (* mut std :: os :: raw :: c_char) , ThresholdSignatureNotValid (* mut std :: os :: raw :: c_char) , CommitmentHashNotPresent , RequiredSnapshotNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , SMLError (* mut crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError) , RequiredQuorumIndexNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , ExpectedOnlyRotatedQuorums (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) , ClientDataRetrievalError (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_QuorumValidationError) -> dashcore :: sml :: quorum_validation_error :: QuorumValidationError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionFrom < dashcore :: prelude :: CoreBlockHeight >> :: ffi_from (* o_0) , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (* o_0 , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required : * required , found : * found } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len : * signers_len , valid_members_len : * valid_members_len } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (* o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (* o_1)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError > for dashcore_sml_quorum_validation_error_QuorumValidationError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: QuorumValidationError) -> * const dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (< crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight as ferment :: FFIConversionTo < dashcore :: prelude :: CoreBlockHeight >> :: ffi_to (o_0) , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientSigners { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InsufficientValidMembers { required , found } => dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required : required , found : found } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len : signers_len , valid_members_len : valid_members_len } , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumPublicKey => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSPublicKey (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidBLSSignature (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidQuorumSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: InvalidFinalSignature => dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ThresholdSignatureNotValid (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CommitmentHashNotPresent => dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: SMLError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (< crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError as ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: CorruptedCodeExecution (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (< example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionTo < dashcore :: hash_types :: QuorumHash >> :: ffi_to (o_0) , < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (o_1)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: ClientDataRetrievalError (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: QuorumValidationError :: FeatureNotTurnedOn (o_0) => dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_QuorumValidationError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_0 , o_1) => { ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len } => { ; ; ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent => { } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_0 , o_1) => { ferment :: unbox_any (* o_0) ; ; ferment :: unbox_any (* o_1) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredBlockNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredBlockHeightNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredBlockHeightNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_VerifyingMasternodeListNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: VerifyingMasternodeListNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredMasternodeListNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredMasternodeListNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredChainLockNotPresent_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: prelude :: dashcore_prelude_CoreBlockHeight , o_o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredChainLockNotPresent (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredRotatedChainLockSigNotPresent_ctor (o_o_0 : u8 , o_o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigNotPresent (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredRotatedChainLockSigsNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredRotatedChainLockSigsNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InsufficientSigners_ctor (required : u64 , found : u64) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientSigners { required , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InsufficientValidMembers_ctor (required : u64 , found : u64) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InsufficientValidMembers { required , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_MismatchedBitsetLengths_ctor (signers_len : usize , valid_members_len : usize) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: MismatchedBitsetLengths { signers_len , valid_members_len }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidQuorumPublicKey_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumPublicKey { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidBLSPublicKey_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSPublicKey (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidBLSSignature_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidBLSSignature (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidQuorumSignature_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidQuorumSignature { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_InvalidFinalSignature_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: InvalidFinalSignature { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_AllCommitmentAggregatedSignatureNotValid_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: AllCommitmentAggregatedSignatureNotValid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ThresholdSignatureNotValid_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ThresholdSignatureNotValid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_CommitmentHashNotPresent_ctor () -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: CommitmentHashNotPresent { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredSnapshotNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredSnapshotNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_SMLError_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: error :: dashcore_sml_error_SmlError) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: SMLError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_RequiredQuorumIndexNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: RequiredQuorumIndexNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ExpectedOnlyRotatedQuorums_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , o_o_1 : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ExpectedOnlyRotatedQuorums (o_o_0 , o_o_1)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_ClientDataRetrievalError_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_ClientDataRetrievalError) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: ClientDataRetrievalError (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_FeatureNotTurnedOn_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_quorum_validation_error_QuorumValidationError { ferment :: boxed (dashcore_sml_quorum_validation_error_QuorumValidationError :: FeatureNotTurnedOn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_QuorumValidationError_destroy < > (ffi : * mut dashcore_sml_quorum_validation_error_QuorumValidationError) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ClientDataRetrievalError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_quorum_validation_error_ClientDataRetrievalError { RequiredBlockNotPresent (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , CoinbaseNotFoundOnBlock (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) } impl ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError) -> dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError > for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { unsafe fn ffi_to_const (obj : dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError) -> * const dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (match obj { dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: quorum_validation_error :: ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_quorum_validation_error_ClientDataRetrievalError { fn drop (& mut self) { unsafe { match self { dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_RequiredBlockNotPresent_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: RequiredBlockNotPresent (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_CoinbaseNotFoundOnBlock_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError { ferment :: boxed (dashcore_sml_quorum_validation_error_ClientDataRetrievalError :: CoinbaseNotFoundOnBlock (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_quorum_validation_error_ClientDataRetrievalError_destroy < > (ffi : * mut dashcore_sml_quorum_validation_error_ClientDataRetrievalError) { ferment :: unbox_any (ffi) ; } } pub mod address { use crate as example_nested ; } pub mod masternode_list { use crate as example_nested ; # [doc = "FFI-representation of the [`MasternodeList`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_MasternodeList { pub block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , pub known_height : u32 , pub masternode_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , pub llmq_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , pub masternodes : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , pub quorums : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_MasternodeList) -> dashcore :: sml :: masternode_list :: MasternodeList { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list :: MasternodeList { block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (ffi_ref . block_hash) , known_height : ffi_ref . known_height , masternode_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_from_opt (ffi_ref . masternode_merkle_root) , llmq_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionFrom < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_from_opt (ffi_ref . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_from (ffi_ref . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_from (ffi_ref . quorums) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list :: MasternodeList > for dashcore_sml_masternode_list_MasternodeList { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list :: MasternodeList) -> * const dashcore_sml_masternode_list_MasternodeList { ferment :: boxed (dashcore_sml_masternode_list_MasternodeList { block_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (obj . block_hash) , known_height : obj . known_height , masternode_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootMasternodeList >> :: ffi_to_opt (obj . masternode_merkle_root) , llmq_merkle_root : < example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums as ferment :: FFIConversionTo < dashcore :: hash_types :: MerkleRootQuorums >> :: ffi_to_opt (obj . llmq_merkle_root) , masternodes : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > >> :: ffi_to (obj . masternodes) , quorums : < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > >> :: ffi_to (obj . quorums) }) } } impl Drop for dashcore_sml_masternode_list_MasternodeList { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . block_hash) ; ; ferment :: unbox_any_opt (ffi_ref . masternode_merkle_root) ; ferment :: unbox_any_opt (ffi_ref . llmq_merkle_root) ; ferment :: unbox_any (ffi_ref . masternodes) ; ferment :: unbox_any (ffi_ref . quorums) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_ctor < > (block_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , known_height : u32 , masternode_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList , llmq_merkle_root : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums , masternodes : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry , quorums : * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut dashcore_sml_masternode_list_MasternodeList { ferment :: boxed (dashcore_sml_masternode_list_MasternodeList { block_hash , known_height , masternode_merkle_root , llmq_merkle_root , masternodes , quorums }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_destroy < > (ffi : * mut dashcore_sml_masternode_list_MasternodeList) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_block_hash < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_known_height < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> u32 { (* obj) . known_height } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_masternode_merkle_root < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . masternode_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_llmq_merkle_root < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . llmq_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_masternodes < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { (* obj) . masternodes } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_get_quorums < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { (* obj) . quorums } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_block_hash < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash { (* obj) . block_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_known_height < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> u32 { (* obj) . known_height } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_masternode_merkle_root < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootMasternodeList { (* obj) . masternode_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_llmq_merkle_root < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_MerkleRootQuorums { (* obj) . llmq_merkle_root } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_masternodes < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { (* obj) . masternodes } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_MasternodeList_set_quorums < > (obj : * const dashcore_sml_masternode_list_MasternodeList) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { (* obj) . quorums } } pub mod llmq_type { use crate as example_nested ; # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::index`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_index (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> u8 { let obj = dashcore :: sml :: llmq_type :: LLMQType :: index (& ferment :: FFIConversionFrom :: ffi_from (self_)) ; obj } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u16`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u16 (index : u16) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u16 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::from_u8`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_from_u8 (index : u8) -> * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType { let obj = dashcore :: sml :: llmq_type :: LLMQType :: from_u8 (index) ; < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`dashcore::sml::llmq_type::LLMQType::is_rotating_quorum_type`]"] # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_is_rotating_quorum_type (self_ : * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType) -> bool { let obj = dashcore :: sml :: llmq_type :: LLMQType :: is_rotating_quorum_type (& ferment :: FFIConversionFrom :: ffi_from (self_)) ; obj } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_type_LLMQType { LlmqtypeUnknown = 0 , Llmqtype50_60 = 1 , Llmqtype400_60 = 2 , Llmqtype400_85 = 3 , Llmqtype100_67 = 4 , Llmqtype60_75 = 5 , Llmqtype25_67 = 6 , LlmqtypeTest = 100 , LlmqtypeDevnet = 101 , LlmqtypeTestV17 = 102 , LlmqtypeTestDIP0024 = 103 , LlmqtypeTestInstantSend = 104 , LlmqtypeDevnetDIP0024 = 105 , LlmqtypeTestnetPlatform = 106 , LlmqtypeDevnetPlatform = 107 } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_type_LLMQType) -> dashcore :: sml :: llmq_type :: LLMQType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_type :: LLMQType > for dashcore_sml_llmq_type_LLMQType { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_type :: LLMQType) -> * const dashcore_sml_llmq_type_LLMQType { ferment :: boxed (match obj { dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeUnknown => dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype50_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_60 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype400_85 => dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype100_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype60_75 => dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 , dashcore :: sml :: llmq_type :: LLMQType :: Llmqtype25_67 => dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTest => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnet => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestV17 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestInstantSend => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetDIP0024 => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeTestnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform , dashcore :: sml :: llmq_type :: LLMQType :: LlmqtypeDevnetPlatform => dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_type_LLMQType { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 => { } , dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform => { } , dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeUnknown_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeUnknown { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype50_60_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype50_60 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype400_60_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype400_60 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype400_85_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype400_85 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype100_67_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype100_67 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype60_75_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype60_75 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_Llmqtype25_67_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: Llmqtype25_67 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTest_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTest { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnet_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnet { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestV17_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestV17 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestDIP0024_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestDIP0024 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestInstantSend_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestInstantSend { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnetDIP0024_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetDIP0024 { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeTestnetPlatform_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeTestnetPlatform { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_LlmqtypeDevnetPlatform_ctor () -> * mut dashcore_sml_llmq_type_LLMQType { ferment :: boxed (dashcore_sml_llmq_type_LLMQType :: LlmqtypeDevnetPlatform { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_type_LLMQType_destroy < > (ffi : * mut dashcore_sml_llmq_type_LLMQType) { ferment :: unbox_any (ffi) ; } } pub mod error { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`SmlError`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_error_SmlError { BaseBlockNotGenesis (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , BlockHashLookupFailed (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , IncompleteMnListDiff , MissingStartMasternodeList (* mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) , BaseBlockHashMismatch { expected : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , found : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash } , UnknownError , CorruptedCodeExecution (* mut std :: os :: raw :: c_char) , FeatureNotTurnedOn (* mut std :: os :: raw :: c_char) , InvalidIndexInSignatureSet (u16) , IncompleteSignatureSet } impl ferment :: FFIConversionFrom < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_from_const (ffi : * const dashcore_sml_error_SmlError) -> dashcore :: sml :: error :: SmlError { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: IncompleteMnListDiff => dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* expected) , found : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: BlockHash >> :: ffi_from (* found) } , dashcore_sml_error_SmlError :: UnknownError => dashcore :: sml :: error :: SmlError :: UnknownError , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (* o_0) , dashcore_sml_error_SmlError :: IncompleteSignatureSet => dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet } } } impl ferment :: FFIConversionTo < dashcore :: sml :: error :: SmlError > for dashcore_sml_error_SmlError { unsafe fn ffi_to_const (obj : dashcore :: sml :: error :: SmlError) -> * const dashcore_sml_error_SmlError { ferment :: boxed (match obj { dashcore :: sml :: error :: SmlError :: BaseBlockNotGenesis (o_0) => dashcore_sml_error_SmlError :: BaseBlockNotGenesis (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: BlockHashLookupFailed (o_0) => dashcore_sml_error_SmlError :: BlockHashLookupFailed (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: IncompleteMnListDiff => dashcore_sml_error_SmlError :: IncompleteMnListDiff , dashcore :: sml :: error :: SmlError :: MissingStartMasternodeList (o_0) => dashcore_sml_error_SmlError :: MissingStartMasternodeList (< example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: BaseBlockHashMismatch { expected , found } => dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (expected) , found : < example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < dashcore :: hash_types :: BlockHash >> :: ffi_to (found) } , dashcore :: sml :: error :: SmlError :: UnknownError => dashcore_sml_error_SmlError :: UnknownError , dashcore :: sml :: error :: SmlError :: CorruptedCodeExecution (o_0) => dashcore_sml_error_SmlError :: CorruptedCodeExecution (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: FeatureNotTurnedOn (o_0) => dashcore_sml_error_SmlError :: FeatureNotTurnedOn (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , dashcore :: sml :: error :: SmlError :: InvalidIndexInSignatureSet (o_0) => dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) , dashcore :: sml :: error :: SmlError :: IncompleteSignatureSet => dashcore_sml_error_SmlError :: IncompleteSignatureSet , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_error_SmlError { fn drop (& mut self) { unsafe { match self { dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: IncompleteMnListDiff => { } , dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found } => { ferment :: unbox_any (* expected) ; ; ferment :: unbox_any (* found) ; } , dashcore_sml_error_SmlError :: UnknownError => { } , dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_0) => { ferment :: unbox_string (* o_0) ; } , dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_0) => { ; } , dashcore_sml_error_SmlError :: IncompleteSignatureSet => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BaseBlockNotGenesis_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BaseBlockNotGenesis (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BlockHashLookupFailed_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BlockHashLookupFailed (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_IncompleteMnListDiff_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: IncompleteMnListDiff { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_MissingStartMasternodeList_ctor (o_o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: MissingStartMasternodeList (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_BaseBlockHashMismatch_ctor (expected : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , found : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: BaseBlockHashMismatch { expected , found }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_UnknownError_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: UnknownError { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_CorruptedCodeExecution_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: CorruptedCodeExecution (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_FeatureNotTurnedOn_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: FeatureNotTurnedOn (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_InvalidIndexInSignatureSet_ctor (o_o_0 : u16) -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: InvalidIndexInSignatureSet (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_IncompleteSignatureSet_ctor () -> * mut dashcore_sml_error_SmlError { ferment :: boxed (dashcore_sml_error_SmlError :: IncompleteSignatureSet { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_error_SmlError_destroy < > (ffi : * mut dashcore_sml_error_SmlError) { ferment :: unbox_any (ffi) ; } } pub mod masternode_list_entry { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`EntryMasternodeType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_masternode_list_entry_EntryMasternodeType { Regular , HighPerformance { platform_http_port : u16 , platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash } } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_EntryMasternodeType) -> dashcore :: sml :: masternode_list_entry :: EntryMasternodeType { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port : * platform_http_port , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (* platform_node_id) } } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType > for dashcore_sml_masternode_list_entry_EntryMasternodeType { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: EntryMasternodeType) -> * const dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (match obj { dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: Regular => dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular , dashcore :: sml :: masternode_list_entry :: EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port : platform_http_port , platform_node_id : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (platform_node_id) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_masternode_list_entry_EntryMasternodeType { fn drop (& mut self) { unsafe { match self { dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular => { } , dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id } => { ; ; ferment :: unbox_any (* platform_node_id) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_Regular_ctor () -> * mut dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (dashcore_sml_masternode_list_entry_EntryMasternodeType :: Regular { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_HighPerformance_ctor (platform_http_port : u16 , platform_node_id : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash) -> * mut dashcore_sml_masternode_list_entry_EntryMasternodeType { ferment :: boxed (dashcore_sml_masternode_list_entry_EntryMasternodeType :: HighPerformance { platform_http_port , platform_node_id }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_EntryMasternodeType_destroy < > (ffi : * mut dashcore_sml_masternode_list_entry_EntryMasternodeType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`MasternodeListEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_MasternodeListEntry { pub version : u16 , pub pro_reg_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , pub confirmed_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash , pub service_address : * mut std :: net :: SocketAddr , pub operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub key_id_voting : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , pub is_valid : bool , pub mn_type : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry > for dashcore_sml_masternode_list_entry_MasternodeListEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> dashcore :: sml :: masternode_list_entry :: MasternodeListEntry { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: MasternodeListEntry { version : ffi_ref . version , pro_reg_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: ProTxHash >> :: ffi_from (ffi_ref . pro_reg_tx_hash) , confirmed_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: ConfirmedHash >> :: ffi_from_opt (ffi_ref . confirmed_hash) , service_address : (& * ffi_ref . service_address) . clone () , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . operator_public_key) , key_id_voting : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: PubkeyHash >> :: ffi_from (ffi_ref . key_id_voting) , is_valid : ffi_ref . is_valid , mn_type : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType >> :: ffi_from (ffi_ref . mn_type) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry > for dashcore_sml_masternode_list_entry_MasternodeListEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: MasternodeListEntry) -> * const dashcore_sml_masternode_list_entry_MasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_MasternodeListEntry { version : obj . version , pro_reg_tx_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash as ferment :: FFIConversionTo < dashcore :: hash_types :: ProTxHash >> :: ffi_to (obj . pro_reg_tx_hash) , confirmed_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash as ferment :: FFIConversionTo < dashcore :: hash_types :: ConfirmedHash >> :: ffi_to_opt (obj . confirmed_hash) , service_address : ferment :: boxed (obj . service_address) , operator_public_key : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . operator_public_key) , key_id_voting : < example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash as ferment :: FFIConversionTo < dashcore :: hash_types :: PubkeyHash >> :: ffi_to (obj . key_id_voting) , is_valid : obj . is_valid , mn_type : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: EntryMasternodeType >> :: ffi_to (obj . mn_type) }) } } impl Drop for dashcore_sml_masternode_list_entry_MasternodeListEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; ferment :: unbox_any (ffi_ref . pro_reg_tx_hash) ; ferment :: unbox_any_opt (ffi_ref . confirmed_hash) ; ferment :: unbox_any (ffi_ref . service_address) ; ferment :: unbox_any (ffi_ref . operator_public_key) ; ferment :: unbox_any (ffi_ref . key_id_voting) ; ; ferment :: unbox_any (ffi_ref . mn_type) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_ctor < > (version : u16 , pro_reg_tx_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , confirmed_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash , service_address : * mut std :: net :: SocketAddr , operator_public_key : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , key_id_voting : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash , is_valid : bool , mn_type : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType) -> * mut dashcore_sml_masternode_list_entry_MasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_MasternodeListEntry { version , pro_reg_tx_hash , confirmed_hash , service_address , operator_public_key , key_id_voting , is_valid , mn_type }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_destroy < > (ffi : * mut dashcore_sml_masternode_list_entry_MasternodeListEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_version < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_pro_reg_tx_hash < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash { (* obj) . pro_reg_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_confirmed_hash < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash { (* obj) . confirmed_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_service_address < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut std :: net :: SocketAddr { (* obj) . service_address } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_operator_public_key < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_key_id_voting < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . key_id_voting } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_is_valid < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> bool { (* obj) . is_valid } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_get_mn_type < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType { (* obj) . mn_type } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_version < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_pro_reg_tx_hash < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash { (* obj) . pro_reg_tx_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_confirmed_hash < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHash { (* obj) . confirmed_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_service_address < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut std :: net :: SocketAddr { (* obj) . service_address } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_operator_public_key < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . operator_public_key } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_key_id_voting < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_PubkeyHash { (* obj) . key_id_voting } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_is_valid < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> bool { (* obj) . is_valid } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_MasternodeListEntry_set_mn_type < > (obj : * const dashcore_sml_masternode_list_entry_MasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_EntryMasternodeType { (* obj) . mn_type } # [doc = "FFI-representation of the [`OperatorPublicKey`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_OperatorPublicKey { pub data : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , pub version : u16 } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_from (ffi_ref . data) , version : ffi_ref . version } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: OperatorPublicKey > for dashcore_sml_masternode_list_entry_OperatorPublicKey { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: OperatorPublicKey) -> * const dashcore_sml_masternode_list_entry_OperatorPublicKey { ferment :: boxed (dashcore_sml_masternode_list_entry_OperatorPublicKey { data : < crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSPublicKey >> :: ffi_to (obj . data) , version : obj . version }) } } impl Drop for dashcore_sml_masternode_list_entry_OperatorPublicKey { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . data) ; ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_ctor < > (data : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey , version : u16) -> * mut dashcore_sml_masternode_list_entry_OperatorPublicKey { ferment :: boxed (dashcore_sml_masternode_list_entry_OperatorPublicKey { data , version }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_destroy < > (ffi : * mut dashcore_sml_masternode_list_entry_OperatorPublicKey) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_get_data < > (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_get_version < > (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> u16 { (* obj) . version } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_set_data < > (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSPublicKey { (* obj) . data } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_OperatorPublicKey_set_version < > (obj : * const dashcore_sml_masternode_list_entry_OperatorPublicKey) -> u16 { (* obj) . version } pub mod qualified_masternode_list_entry { use crate as example_nested ; # [doc = "FFI-representation of the [`QualifiedMasternodeListEntry`]"] # [repr (C)] # [derive (Clone)] pub struct dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub masternode_list_entry : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry , pub entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash , pub confirmed_hash_hashed_with_pro_reg_tx : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx } impl ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { let ffi_ref = & * ffi ; dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry { masternode_list_entry : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry >> :: ffi_from (ffi_ref . masternode_list_entry) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: Sha256dHash >> :: ffi_from (ffi_ref . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx as ferment :: FFIConversionFrom < dashcore :: hash_types :: ConfirmedHashHashedWithProRegTx >> :: ffi_from_opt (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry) -> * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { masternode_list_entry : < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry as ferment :: FFIConversionTo < dashcore :: sml :: masternode_list_entry :: MasternodeListEntry >> :: ffi_to (obj . masternode_list_entry) , entry_hash : < example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash as ferment :: FFIConversionTo < dashcore :: hash_types :: Sha256dHash >> :: ffi_to (obj . entry_hash) , confirmed_hash_hashed_with_pro_reg_tx : < example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx as ferment :: FFIConversionTo < dashcore :: hash_types :: ConfirmedHashHashedWithProRegTx >> :: ffi_to_opt (obj . confirmed_hash_hashed_with_pro_reg_tx) }) } } impl Drop for dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . masternode_list_entry) ; ferment :: unbox_any (ffi_ref . entry_hash) ; ferment :: unbox_any_opt (ffi_ref . confirmed_hash_hashed_with_pro_reg_tx) ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_ctor < > (masternode_list_entry : * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry , entry_hash : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash , confirmed_hash_hashed_with_pro_reg_tx : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx) -> * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { masternode_list_entry , entry_hash , confirmed_hash_hashed_with_pro_reg_tx }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_destroy < > (ffi : * mut dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_masternode_list_entry < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry { (* obj) . masternode_list_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_entry_hash < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_get_confirmed_hash_hashed_with_pro_reg_tx < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx { (* obj) . confirmed_hash_hashed_with_pro_reg_tx } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_masternode_list_entry < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: dashcore_sml_masternode_list_entry_MasternodeListEntry { (* obj) . masternode_list_entry } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_entry_hash < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_Sha256dHash { (* obj) . entry_hash } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_set_confirmed_hash_hashed_with_pro_reg_tx < > (obj : * const dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ConfirmedHashHashedWithProRegTx { (* obj) . confirmed_hash_hashed_with_pro_reg_tx } } } pub mod llmq_entry_verification { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQEntryVerificationStatus`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { Unknown , Verified , Skipped (* mut dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus) , Invalid (* mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError) } impl ferment :: FFIConversionFrom < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_from_const (ffi : * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) -> dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus { let ffi_ref = & * ffi ; match ffi_ref { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped ((& * * o_0) . clone ()) , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus > for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { unsafe fn ffi_to_const (obj : dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus) -> * const dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (match obj { dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Unknown => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Verified => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Skipped (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (ferment :: boxed (o_0)) , dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationStatus :: Invalid (o_0) => dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (< crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError as ferment :: FFIConversionTo < dashcore :: sml :: quorum_validation_error :: QuorumValidationError >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { fn drop (& mut self) { unsafe { match self { dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified => { } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_0) => { ferment :: unbox_any (* o_0) ; } , dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Unknown_ctor () -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Unknown { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Verified_ctor () -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Verified { }) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Skipped_ctor (o_o_0 : * mut dashcore :: sml :: llmq_entry_verification :: LLMQEntryVerificationSkipStatus) -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Skipped (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_Invalid_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: sml :: quorum_validation_error :: dashcore_sml_quorum_validation_error_QuorumValidationError) -> * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus { ferment :: boxed (dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus :: Invalid (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus_destroy < > (ffi : * mut dashcore_sml_llmq_entry_verification_LLMQEntryVerificationStatus) { ferment :: unbox_any (ffi) ; } } pub mod masternode_list_engine { use crate as example_nested ; # [cfg (feature = "message_verification")] pub mod message_request_verification { use crate as example_nested ; } } } pub mod psbt { use crate as example_nested ; pub mod map { use crate as example_nested ; pub mod input { use crate as example_nested ; } } # [cfg (test)] pub mod tests { use crate as example_nested ; } pub mod serialize { use crate as example_nested ; } } pub mod bip32 { use crate as example_nested ; } pub mod amount { use crate as example_nested ; # [cfg (feature = "serde")] pub mod serde { use crate as example_nested ; pub mod as_btc { use crate as example_nested ; } pub mod as_sat { use crate as example_nested ; } } } pub mod base58 { use crate as example_nested ; } pub mod hash_types { use crate as example_nested ; } pub mod merkle_tree { use crate as example_nested ; pub mod block { use crate as example_nested ; } } pub mod address { use crate as example_nested ; } pub mod consensus { use crate as example_nested ; # [cfg (feature = "serde")] pub mod serde { use crate as example_nested ; pub mod hex { use crate as example_nested ; } } pub mod encode { use crate as example_nested ; } } } pub mod example_nested { use crate as example_nested ; pub mod gen { use crate as example_nested ; pub mod dict { use crate as example_nested ; # [doc = "FFI-representation of the [`AllRefCellExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRefCellExamples { pub refcell_simple : * mut crate :: fermented :: generics :: std_cell_RefCell_u32 , pub refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot , pub refcell_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 , pub refcell_opt_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , pub opt_refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRefCellExamples > for example_nested_gen_dict_AllRefCellExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRefCellExamples) -> example_nested :: gen :: dict :: AllRefCellExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRefCellExamples { refcell_simple : < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > >> :: ffi_from (ffi_ref . refcell_simple) , refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . refcell_complex) , refcell_generic : < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_from (ffi_ref . refcell_generic) , refcell_opt_generic : < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . refcell_opt_generic) , opt_refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_refcell_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRefCellExamples > for example_nested_gen_dict_AllRefCellExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRefCellExamples) -> * const example_nested_gen_dict_AllRefCellExamples { ferment :: boxed (example_nested_gen_dict_AllRefCellExamples { refcell_simple : < crate :: fermented :: generics :: std_cell_RefCell_u32 as ferment :: FFIConversionTo < std :: cell :: RefCell < u32 > >> :: ffi_to (obj . refcell_simple) , refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . refcell_complex) , refcell_generic : < crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 as ferment :: FFIConversionTo < std :: cell :: RefCell < Vec < u8 > > >> :: ffi_to (obj . refcell_generic) , refcell_opt_generic : < crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . refcell_opt_generic) , opt_refcell_complex : < crate :: fermented :: generics :: std_cell_RefCell_Option_String as ferment :: FFIConversionTo < std :: cell :: RefCell < Option < String > > >> :: ffi_to_opt (obj . opt_refcell_complex) }) } } impl Drop for example_nested_gen_dict_AllRefCellExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . refcell_simple) ; ferment :: unbox_any (ffi_ref . refcell_complex) ; ferment :: unbox_any (ffi_ref . refcell_generic) ; ferment :: unbox_any (ffi_ref . refcell_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_refcell_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_ctor < > (refcell_simple : * mut crate :: fermented :: generics :: std_cell_RefCell_u32 , refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot , refcell_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 , refcell_opt_generic : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , opt_refcell_complex : * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String) -> * mut example_nested_gen_dict_AllRefCellExamples { ferment :: boxed (example_nested_gen_dict_AllRefCellExamples { refcell_simple , refcell_complex , refcell_generic , refcell_opt_generic , opt_refcell_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllRefCellExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_simple < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_u32 { (* obj) . refcell_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_complex < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { (* obj) . refcell_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_generic < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 { (* obj) . refcell_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_refcell_opt_generic < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . refcell_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_get_opt_refcell_complex < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String { (* obj) . opt_refcell_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_simple < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_u32 { (* obj) . refcell_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_complex < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { (* obj) . refcell_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_generic < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Vec_u8 { (* obj) . refcell_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_refcell_opt_generic < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . refcell_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRefCellExamples_set_opt_refcell_complex < > (obj : * const example_nested_gen_dict_AllRefCellExamples) -> * mut crate :: fermented :: generics :: std_cell_RefCell_Option_String { (* obj) . opt_refcell_complex } # [doc = "FFI-representation of the [`AllMapExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllMapExamples { pub k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , pub k_simple_v_opt_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 , pub k_simple_v_opt_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String , pub k_simple_v_opt_generic_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 , pub k_simple_v_opt_generic_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String , pub opt_map_k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , pub opt_map_k_simple_v_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String , pub opt_map_k_simple_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 , pub opt_map_k_generic_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 , pub map_k_opt_generic_v_opt_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMapExamples > for example_nested_gen_dict_AllMapExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllMapExamples) -> example_nested :: gen :: dict :: AllMapExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllMapExamples { k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_from (ffi_ref . k_simple_v_simple) , k_simple_v_opt_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < u32 > > >> :: ffi_from (ffi_ref . k_simple_v_opt_simple) , k_simple_v_opt_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < String > > >> :: ffi_from (ffi_ref . k_simple_v_opt_complex) , k_simple_v_opt_generic_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > >> :: ffi_from (ffi_ref . k_simple_v_opt_generic_simple) , k_simple_v_opt_generic_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > >> :: ffi_from (ffi_ref . k_simple_v_opt_generic_complex) , opt_map_k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_simple) , opt_map_k_simple_v_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , String > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_complex) , opt_map_k_simple_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Vec < u8 > > >> :: ffi_from_opt (ffi_ref . opt_map_k_simple_v_generic) , opt_map_k_generic_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > >> :: ffi_from_opt (ffi_ref . opt_map_k_generic_v_generic) , map_k_opt_generic_v_opt_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . map_k_opt_generic_v_opt_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMapExamples > for example_nested_gen_dict_AllMapExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllMapExamples) -> * const example_nested_gen_dict_AllMapExamples { ferment :: boxed (example_nested_gen_dict_AllMapExamples { k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_to (obj . k_simple_v_simple) , k_simple_v_opt_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < u32 > > >> :: ffi_to (obj . k_simple_v_opt_simple) , k_simple_v_opt_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < String > > >> :: ffi_to (obj . k_simple_v_opt_complex) , k_simple_v_opt_generic_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > >> :: ffi_to (obj . k_simple_v_opt_generic_simple) , k_simple_v_opt_generic_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > >> :: ffi_to (obj . k_simple_v_opt_generic_complex) , opt_map_k_simple_v_simple : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > >> :: ffi_to_opt (obj . opt_map_k_simple_v_simple) , opt_map_k_simple_v_complex : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , String > >> :: ffi_to_opt (obj . opt_map_k_simple_v_complex) , opt_map_k_simple_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Vec < u8 > > >> :: ffi_to_opt (obj . opt_map_k_simple_v_generic) , opt_map_k_generic_v_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > >> :: ffi_to_opt (obj . opt_map_k_generic_v_generic) , map_k_opt_generic_v_opt_generic : < crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > >> :: ffi_to (obj . map_k_opt_generic_v_opt_generic) }) } } impl Drop for example_nested_gen_dict_AllMapExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . k_simple_v_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_complex) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_generic_simple) ; ferment :: unbox_any (ffi_ref . k_simple_v_opt_generic_complex) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_simple) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_complex) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_simple_v_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_map_k_generic_v_generic) ; ferment :: unbox_any (ffi_ref . map_k_opt_generic_v_opt_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_ctor < > (k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , k_simple_v_opt_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 , k_simple_v_opt_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String , k_simple_v_opt_generic_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 , k_simple_v_opt_generic_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String , opt_map_k_simple_v_simple : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 , opt_map_k_simple_v_complex : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String , opt_map_k_simple_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 , opt_map_k_generic_v_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 , map_k_opt_generic_v_opt_generic : * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) -> * mut example_nested_gen_dict_AllMapExamples { ferment :: boxed (example_nested_gen_dict_AllMapExamples { k_simple_v_simple , k_simple_v_opt_simple , k_simple_v_opt_complex , k_simple_v_opt_generic_simple , k_simple_v_opt_generic_complex , opt_map_k_simple_v_simple , opt_map_k_simple_v_complex , opt_map_k_simple_v_generic , opt_map_k_generic_v_generic , map_k_opt_generic_v_opt_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllMapExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 { (* obj) . k_simple_v_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String { (* obj) . k_simple_v_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_generic_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 { (* obj) . k_simple_v_opt_generic_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_k_simple_v_opt_generic_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String { (* obj) . k_simple_v_opt_generic_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . opt_map_k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String { (* obj) . opt_map_k_simple_v_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_simple_v_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 { (* obj) . opt_map_k_simple_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_opt_map_k_generic_v_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 { (* obj) . opt_map_k_generic_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_get_map_k_opt_generic_v_opt_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { (* obj) . map_k_opt_generic_v_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_u32 { (* obj) . k_simple_v_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_String { (* obj) . k_simple_v_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_generic_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_u32 { (* obj) . k_simple_v_opt_generic_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_k_simple_v_opt_generic_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Option_Vec_String { (* obj) . k_simple_v_opt_generic_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_simple < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_u32 { (* obj) . opt_map_k_simple_v_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_complex < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_String { (* obj) . opt_map_k_simple_v_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_simple_v_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_Vec_u8 { (* obj) . opt_map_k_simple_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_opt_map_k_generic_v_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Vec_u8_values_Vec_u8 { (* obj) . opt_map_k_generic_v_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMapExamples_set_map_k_opt_generic_v_opt_generic < > (obj : * const example_nested_gen_dict_AllMapExamples) -> * mut crate :: fermented :: generics :: std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { (* obj) . map_k_opt_generic_v_opt_generic } # [doc = "FFI-representation of the [`AllVecExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllVecExamples { pub vec_simple : * mut crate :: fermented :: generics :: Vec_u32 , pub vec_complex : * mut crate :: fermented :: generics :: Vec_String , pub vec_generic : * mut crate :: fermented :: generics :: Vec_Vec_u8 , pub vec_opt_simple : * mut crate :: fermented :: generics :: Vec_Option_u32 , pub vec_opt_complex : * mut crate :: fermented :: generics :: Vec_Option_String , pub vec_opt_generic : * mut crate :: fermented :: generics :: Vec_Option_Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllVecExamples > for example_nested_gen_dict_AllVecExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllVecExamples) -> example_nested :: gen :: dict :: AllVecExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllVecExamples { vec_simple : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from (ffi_ref . vec_simple) , vec_complex : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from (ffi_ref . vec_complex) , vec_generic : < crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionFrom < Vec < Vec < u8 > > >> :: ffi_from (ffi_ref . vec_generic) , vec_opt_simple : < crate :: fermented :: generics :: Vec_Option_u32 as ferment :: FFIConversionFrom < Vec < Option < u32 > > >> :: ffi_from (ffi_ref . vec_opt_simple) , vec_opt_complex : < crate :: fermented :: generics :: Vec_Option_String as ferment :: FFIConversionFrom < Vec < Option < String > > >> :: ffi_from (ffi_ref . vec_opt_complex) , vec_opt_generic : < crate :: fermented :: generics :: Vec_Option_Vec_u8 as ferment :: FFIConversionFrom < Vec < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . vec_opt_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllVecExamples > for example_nested_gen_dict_AllVecExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllVecExamples) -> * const example_nested_gen_dict_AllVecExamples { ferment :: boxed (example_nested_gen_dict_AllVecExamples { vec_simple : < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionTo < Vec < u32 > >> :: ffi_to (obj . vec_simple) , vec_complex : < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionTo < Vec < String > >> :: ffi_to (obj . vec_complex) , vec_generic : < crate :: fermented :: generics :: Vec_Vec_u8 as ferment :: FFIConversionTo < Vec < Vec < u8 > > >> :: ffi_to (obj . vec_generic) , vec_opt_simple : < crate :: fermented :: generics :: Vec_Option_u32 as ferment :: FFIConversionTo < Vec < Option < u32 > > >> :: ffi_to (obj . vec_opt_simple) , vec_opt_complex : < crate :: fermented :: generics :: Vec_Option_String as ferment :: FFIConversionTo < Vec < Option < String > > >> :: ffi_to (obj . vec_opt_complex) , vec_opt_generic : < crate :: fermented :: generics :: Vec_Option_Vec_u8 as ferment :: FFIConversionTo < Vec < Option < Vec < u8 > > > >> :: ffi_to (obj . vec_opt_generic) }) } } impl Drop for example_nested_gen_dict_AllVecExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . vec_simple) ; ferment :: unbox_any (ffi_ref . vec_complex) ; ferment :: unbox_any (ffi_ref . vec_generic) ; ferment :: unbox_any (ffi_ref . vec_opt_simple) ; ferment :: unbox_any (ffi_ref . vec_opt_complex) ; ferment :: unbox_any (ffi_ref . vec_opt_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_ctor < > (vec_simple : * mut crate :: fermented :: generics :: Vec_u32 , vec_complex : * mut crate :: fermented :: generics :: Vec_String , vec_generic : * mut crate :: fermented :: generics :: Vec_Vec_u8 , vec_opt_simple : * mut crate :: fermented :: generics :: Vec_Option_u32 , vec_opt_complex : * mut crate :: fermented :: generics :: Vec_Option_String , vec_opt_generic : * mut crate :: fermented :: generics :: Vec_Option_Vec_u8) -> * mut example_nested_gen_dict_AllVecExamples { ferment :: boxed (example_nested_gen_dict_AllVecExamples { vec_simple , vec_complex , vec_generic , vec_opt_simple , vec_opt_complex , vec_opt_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllVecExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_simple < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_u32 { (* obj) . vec_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_complex < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . vec_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_generic < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Vec_u8 { (* obj) . vec_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_simple < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_u32 { (* obj) . vec_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_complex < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_String { (* obj) . vec_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_get_vec_opt_generic < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_Vec_u8 { (* obj) . vec_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_simple < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_u32 { (* obj) . vec_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_complex < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_String { (* obj) . vec_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_generic < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Vec_u8 { (* obj) . vec_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_simple < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_u32 { (* obj) . vec_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_complex < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_String { (* obj) . vec_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllVecExamples_set_vec_opt_generic < > (obj : * const example_nested_gen_dict_AllVecExamples) -> * mut crate :: fermented :: generics :: Vec_Option_Vec_u8 { (* obj) . vec_opt_generic } # [doc = "FFI-representation of the [`AllExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllExamples { pub name : * mut std :: os :: raw :: c_char , pub all_map_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples , pub all_result_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples , pub all_set_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples , pub all_arr_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples , pub all_tuple_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples , pub all_opt_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllExamples > for example_nested_gen_dict_AllExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllExamples) -> example_nested :: gen :: dict :: AllExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllExamples { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , all_map_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMapExamples >> :: ffi_from (ffi_ref . all_map_examples) , all_result_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllResultExamples >> :: ffi_from (ffi_ref . all_result_examples) , all_set_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllSetExamples >> :: ffi_from (ffi_ref . all_set_examples) , all_arr_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArrExamples >> :: ffi_from (ffi_ref . all_arr_examples) , all_tuple_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllTupleExamples >> :: ffi_from (ffi_ref . all_tuple_examples) , all_opt_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples as ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllOptExamples >> :: ffi_from (ffi_ref . all_opt_examples) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllExamples > for example_nested_gen_dict_AllExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllExamples) -> * const example_nested_gen_dict_AllExamples { ferment :: boxed (example_nested_gen_dict_AllExamples { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , all_map_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMapExamples >> :: ffi_to (obj . all_map_examples) , all_result_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllResultExamples >> :: ffi_to (obj . all_result_examples) , all_set_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllSetExamples >> :: ffi_to (obj . all_set_examples) , all_arr_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArrExamples >> :: ffi_to (obj . all_arr_examples) , all_tuple_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllTupleExamples >> :: ffi_to (obj . all_tuple_examples) , all_opt_examples : < crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples as ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllOptExamples >> :: ffi_to (obj . all_opt_examples) }) } } impl Drop for example_nested_gen_dict_AllExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_any (ffi_ref . all_map_examples) ; ferment :: unbox_any (ffi_ref . all_result_examples) ; ferment :: unbox_any (ffi_ref . all_set_examples) ; ferment :: unbox_any (ffi_ref . all_arr_examples) ; ferment :: unbox_any (ffi_ref . all_tuple_examples) ; ferment :: unbox_any (ffi_ref . all_opt_examples) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_ctor < > (name : * mut std :: os :: raw :: c_char , all_map_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples , all_result_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples , all_set_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples , all_arr_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples , all_tuple_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples , all_opt_examples : * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples) -> * mut example_nested_gen_dict_AllExamples { ferment :: boxed (example_nested_gen_dict_AllExamples { name , all_map_examples , all_result_examples , all_set_examples , all_arr_examples , all_tuple_examples , all_opt_examples }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_name < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_map_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples { (* obj) . all_map_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_result_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples { (* obj) . all_result_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_set_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples { (* obj) . all_set_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_arr_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples { (* obj) . all_arr_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_tuple_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples { (* obj) . all_tuple_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_get_all_opt_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples { (* obj) . all_opt_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_name < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_map_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllMapExamples { (* obj) . all_map_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_result_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllResultExamples { (* obj) . all_result_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_set_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllSetExamples { (* obj) . all_set_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_arr_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllArrExamples { (* obj) . all_arr_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_tuple_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllTupleExamples { (* obj) . all_tuple_examples } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllExamples_set_all_opt_examples < > (obj : * const example_nested_gen_dict_AllExamples) -> * mut crate :: fermented :: types :: example_nested :: gen :: dict :: example_nested_gen_dict_AllOptExamples { (* obj) . all_opt_examples } # [doc = "FFI-representation of the [`AllSetExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllSetExamples { pub btreeset_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 , pub btreeset_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , pub btreeset_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 , pub btreeset_opt_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 , pub btreeset_opt_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String , pub btreeset_opt_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 , pub hashset_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_u32 , pub hashset_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_String , pub hashset_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 , pub hashset_opt_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 , pub hashset_opt_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String , pub hashset_opt_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 , pub hashset_opt_complex_external : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllSetExamples > for example_nested_gen_dict_AllSetExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllSetExamples) -> example_nested :: gen :: dict :: AllSetExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllSetExamples { btreeset_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < u32 > >> :: ffi_from (ffi_ref . btreeset_simple) , btreeset_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > >> :: ffi_from (ffi_ref . btreeset_complex) , btreeset_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Vec < u8 > > >> :: ffi_from (ffi_ref . btreeset_generic) , btreeset_opt_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < u32 > > >> :: ffi_from (ffi_ref . btreeset_opt_simple) , btreeset_opt_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_String as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < String > > >> :: ffi_from (ffi_ref . btreeset_opt_complex) , btreeset_opt_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . btreeset_opt_generic) , hashset_simple : < crate :: fermented :: generics :: std_collections_HashSet_u32 as ferment :: FFIConversionFrom < std :: collections :: HashSet < u32 > >> :: ffi_from (ffi_ref . hashset_simple) , hashset_complex : < crate :: fermented :: generics :: std_collections_HashSet_String as ferment :: FFIConversionFrom < std :: collections :: HashSet < String > >> :: ffi_from (ffi_ref . hashset_complex) , hashset_generic : < crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Vec < u8 > > >> :: ffi_from (ffi_ref . hashset_generic) , hashset_opt_simple : < crate :: fermented :: generics :: std_collections_HashSet_Option_u32 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < u32 > > >> :: ffi_from (ffi_ref . hashset_opt_simple) , hashset_opt_complex : < crate :: fermented :: generics :: std_collections_HashSet_Option_String as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < String > > >> :: ffi_from (ffi_ref . hashset_opt_complex) , hashset_opt_generic : < crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . hashset_opt_generic) , hashset_opt_complex_external : < crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_from (ffi_ref . hashset_opt_complex_external) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllSetExamples > for example_nested_gen_dict_AllSetExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllSetExamples) -> * const example_nested_gen_dict_AllSetExamples { ferment :: boxed (example_nested_gen_dict_AllSetExamples { btreeset_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < u32 > >> :: ffi_to (obj . btreeset_simple) , btreeset_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > >> :: ffi_to (obj . btreeset_complex) , btreeset_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Vec < u8 > > >> :: ffi_to (obj . btreeset_generic) , btreeset_opt_simple : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < u32 > > >> :: ffi_to (obj . btreeset_opt_simple) , btreeset_opt_complex : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_String as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < String > > >> :: ffi_to (obj . btreeset_opt_complex) , btreeset_opt_generic : < crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < Vec < u8 > > > >> :: ffi_to (obj . btreeset_opt_generic) , hashset_simple : < crate :: fermented :: generics :: std_collections_HashSet_u32 as ferment :: FFIConversionTo < std :: collections :: HashSet < u32 > >> :: ffi_to (obj . hashset_simple) , hashset_complex : < crate :: fermented :: generics :: std_collections_HashSet_String as ferment :: FFIConversionTo < std :: collections :: HashSet < String > >> :: ffi_to (obj . hashset_complex) , hashset_generic : < crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: HashSet < Vec < u8 > > >> :: ffi_to (obj . hashset_generic) , hashset_opt_simple : < crate :: fermented :: generics :: std_collections_HashSet_Option_u32 as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < u32 > > >> :: ffi_to (obj . hashset_opt_simple) , hashset_opt_complex : < crate :: fermented :: generics :: std_collections_HashSet_Option_String as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < String > > >> :: ffi_to (obj . hashset_opt_complex) , hashset_opt_generic : < crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < Vec < u8 > > > >> :: ffi_to (obj . hashset_opt_generic) , hashset_opt_complex_external : < crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_to (obj . hashset_opt_complex_external) }) } } impl Drop for example_nested_gen_dict_AllSetExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . btreeset_simple) ; ferment :: unbox_any (ffi_ref . btreeset_complex) ; ferment :: unbox_any (ffi_ref . btreeset_generic) ; ferment :: unbox_any (ffi_ref . btreeset_opt_simple) ; ferment :: unbox_any (ffi_ref . btreeset_opt_complex) ; ferment :: unbox_any (ffi_ref . btreeset_opt_generic) ; ferment :: unbox_any (ffi_ref . hashset_simple) ; ferment :: unbox_any (ffi_ref . hashset_complex) ; ferment :: unbox_any (ffi_ref . hashset_generic) ; ferment :: unbox_any (ffi_ref . hashset_opt_simple) ; ferment :: unbox_any (ffi_ref . hashset_opt_complex) ; ferment :: unbox_any (ffi_ref . hashset_opt_generic) ; ferment :: unbox_any (ffi_ref . hashset_opt_complex_external) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_ctor < > (btreeset_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 , btreeset_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_String , btreeset_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 , btreeset_opt_simple : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 , btreeset_opt_complex : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String , btreeset_opt_generic : * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 , hashset_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_u32 , hashset_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_String , hashset_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 , hashset_opt_simple : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 , hashset_opt_complex : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String , hashset_opt_generic : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 , hashset_opt_complex_external : * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllSetExamples { ferment :: boxed (example_nested_gen_dict_AllSetExamples { btreeset_simple , btreeset_complex , btreeset_generic , btreeset_opt_simple , btreeset_opt_complex , btreeset_opt_generic , hashset_simple , hashset_complex , hashset_generic , hashset_opt_simple , hashset_opt_complex , hashset_opt_generic , hashset_opt_complex_external }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllSetExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 { (* obj) . btreeset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . btreeset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 { (* obj) . btreeset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 { (* obj) . btreeset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String { (* obj) . btreeset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_btreeset_opt_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 { (* obj) . btreeset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_u32 { (* obj) . hashset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_String { (* obj) . hashset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 { (* obj) . hashset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 { (* obj) . hashset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String { (* obj) . hashset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 { (* obj) . hashset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_get_hashset_opt_complex_external < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . hashset_opt_complex_external } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_u32 { (* obj) . btreeset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_String { (* obj) . btreeset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Vec_u8 { (* obj) . btreeset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_u32 { (* obj) . btreeset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_String { (* obj) . btreeset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_btreeset_opt_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_BTreeSet_Option_Vec_u8 { (* obj) . btreeset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_u32 { (* obj) . hashset_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_String { (* obj) . hashset_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Vec_u8 { (* obj) . hashset_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_simple < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_u32 { (* obj) . hashset_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_complex < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_String { (* obj) . hashset_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_generic < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_Vec_u8 { (* obj) . hashset_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllSetExamples_set_hashset_opt_complex_external < > (obj : * const example_nested_gen_dict_AllSetExamples) -> * mut crate :: fermented :: generics :: std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . hashset_opt_complex_external } # [doc = "FFI-representation of the [`AllRwLockExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRwLockExamples { pub rwlock_simple : * mut crate :: fermented :: generics :: std_sync_RwLock_u32 , pub rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot , pub rwlock_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 , pub rwlock_opt_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , pub opt_rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String , pub arc_rw_lock_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot , pub arc_rw_lock_complex_opaque : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRwLockExamples > for example_nested_gen_dict_AllRwLockExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRwLockExamples) -> example_nested :: gen :: dict :: AllRwLockExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRwLockExamples { rwlock_simple : < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > >> :: ffi_from (ffi_ref . rwlock_simple) , rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . rwlock_complex) , rwlock_generic : < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_from (ffi_ref . rwlock_generic) , rwlock_opt_generic : < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . rwlock_opt_generic) , opt_rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_rwlock_complex) , arc_rw_lock_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > >> :: ffi_from (ffi_ref . arc_rw_lock_complex) , arc_rw_lock_complex_opaque : < crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample as ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > >> :: ffi_from (ffi_ref . arc_rw_lock_complex_opaque) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRwLockExamples > for example_nested_gen_dict_AllRwLockExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRwLockExamples) -> * const example_nested_gen_dict_AllRwLockExamples { ferment :: boxed (example_nested_gen_dict_AllRwLockExamples { rwlock_simple : < crate :: fermented :: generics :: std_sync_RwLock_u32 as ferment :: FFIConversionTo < std :: sync :: RwLock < u32 > >> :: ffi_to (obj . rwlock_simple) , rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . rwlock_complex) , rwlock_generic : < crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: RwLock < Vec < u8 > > >> :: ffi_to (obj . rwlock_generic) , rwlock_opt_generic : < crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . rwlock_opt_generic) , opt_rwlock_complex : < crate :: fermented :: generics :: std_sync_RwLock_Option_String as ferment :: FFIConversionTo < std :: sync :: RwLock < Option < String > > >> :: ffi_to_opt (obj . opt_rwlock_complex) , arc_rw_lock_complex : < crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > >> :: ffi_to (obj . arc_rw_lock_complex) , arc_rw_lock_complex_opaque : < crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample as ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > >> :: ffi_to (obj . arc_rw_lock_complex_opaque) }) } } impl Drop for example_nested_gen_dict_AllRwLockExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . rwlock_simple) ; ferment :: unbox_any (ffi_ref . rwlock_complex) ; ferment :: unbox_any (ffi_ref . rwlock_generic) ; ferment :: unbox_any (ffi_ref . rwlock_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_rwlock_complex) ; ferment :: unbox_any (ffi_ref . arc_rw_lock_complex) ; ferment :: unbox_any (ffi_ref . arc_rw_lock_complex_opaque) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_ctor < > (rwlock_simple : * mut crate :: fermented :: generics :: std_sync_RwLock_u32 , rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot , rwlock_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 , rwlock_opt_generic : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , opt_rwlock_complex : * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String , arc_rw_lock_complex : * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot , arc_rw_lock_complex_opaque : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample) -> * mut example_nested_gen_dict_AllRwLockExamples { ferment :: boxed (example_nested_gen_dict_AllRwLockExamples { rwlock_simple , rwlock_complex , rwlock_generic , rwlock_opt_generic , opt_rwlock_complex , arc_rw_lock_complex , arc_rw_lock_complex_opaque }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllRwLockExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_simple < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_u32 { (* obj) . rwlock_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { (* obj) . rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_generic < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 { (* obj) . rwlock_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_rwlock_opt_generic < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . rwlock_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_opt_rwlock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String { (* obj) . opt_rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_arc_rw_lock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_rw_lock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_get_arc_rw_lock_complex_opaque < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample { (* obj) . arc_rw_lock_complex_opaque } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_simple < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_u32 { (* obj) . rwlock_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { (* obj) . rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_generic < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Vec_u8 { (* obj) . rwlock_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_rwlock_opt_generic < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . rwlock_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_opt_rwlock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_RwLock_Option_String { (* obj) . opt_rwlock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_arc_rw_lock_complex < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_rw_lock_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRwLockExamples_set_arc_rw_lock_complex_opaque < > (obj : * const example_nested_gen_dict_AllRwLockExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_gen_dict_CacheExample { (* obj) . arc_rw_lock_complex_opaque } # [doc = "FFI-representation of the [`AllOptExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllOptExamples { pub opt_complex : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllOptExamples > for example_nested_gen_dict_AllOptExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllOptExamples) -> example_nested :: gen :: dict :: AllOptExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllOptExamples { opt_complex : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_ref . opt_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllOptExamples > for example_nested_gen_dict_AllOptExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllOptExamples) -> * const example_nested_gen_dict_AllOptExamples { ferment :: boxed (example_nested_gen_dict_AllOptExamples { opt_complex : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to_opt (obj . opt_complex) }) } } impl Drop for example_nested_gen_dict_AllOptExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any_opt (ffi_ref . opt_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_ctor < > (opt_complex : * mut std :: os :: raw :: c_char) -> * mut example_nested_gen_dict_AllOptExamples { ferment :: boxed (example_nested_gen_dict_AllOptExamples { opt_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllOptExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_get_opt_complex < > (obj : * const example_nested_gen_dict_AllOptExamples) -> * mut std :: os :: raw :: c_char { (* obj) . opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllOptExamples_set_opt_complex < > (obj : * const example_nested_gen_dict_AllOptExamples) -> * mut std :: os :: raw :: c_char { (* obj) . opt_complex } # [doc = "FFI-representation of the [`AllMutexExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllMutexExamples { pub mutex_simple : * mut crate :: fermented :: generics :: std_sync_Mutex_u32 , pub mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot , pub mutex_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 , pub mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , pub opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String , pub platform_case : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllMutexExamples > for example_nested_gen_dict_AllMutexExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllMutexExamples) -> example_nested :: gen :: dict :: AllMutexExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > >> :: ffi_from (ffi_ref . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_from (ffi_ref . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . platform_case) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllMutexExamples > for example_nested_gen_dict_AllMutexExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllMutexExamples) -> * const example_nested_gen_dict_AllMutexExamples { ferment :: boxed (example_nested_gen_dict_AllMutexExamples { mutex_simple : < crate :: fermented :: generics :: std_sync_Mutex_u32 as ferment :: FFIConversionTo < std :: sync :: Mutex < u32 > >> :: ffi_to (obj . mutex_simple) , mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . mutex_complex) , mutex_generic : < crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: Mutex < Vec < u8 > > >> :: ffi_to (obj . mutex_generic) , mutex_opt_generic : < crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . mutex_opt_generic) , opt_mutex_complex : < crate :: fermented :: generics :: std_sync_Mutex_Option_String as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < String > > >> :: ffi_to_opt (obj . opt_mutex_complex) , platform_case : < crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . platform_case) }) } } impl Drop for example_nested_gen_dict_AllMutexExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . mutex_simple) ; ferment :: unbox_any (ffi_ref . mutex_complex) ; ferment :: unbox_any (ffi_ref . mutex_generic) ; ferment :: unbox_any (ffi_ref . mutex_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_mutex_complex) ; ferment :: unbox_any (ffi_ref . platform_case) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_ctor < > (mutex_simple : * mut crate :: fermented :: generics :: std_sync_Mutex_u32 , mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot , mutex_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 , mutex_opt_generic : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , opt_mutex_complex : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String , platform_case : * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot) -> * mut example_nested_gen_dict_AllMutexExamples { ferment :: boxed (example_nested_gen_dict_AllMutexExamples { mutex_simple , mutex_complex , mutex_generic , mutex_opt_generic , opt_mutex_complex , platform_case }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllMutexExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_simple < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_u32 { (* obj) . mutex_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_complex < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { (* obj) . mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_generic < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 { (* obj) . mutex_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_mutex_opt_generic < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . mutex_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_opt_mutex_complex < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String { (* obj) . opt_mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_get_platform_case < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { (* obj) . platform_case } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_simple < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_u32 { (* obj) . mutex_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_complex < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { (* obj) . mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_generic < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Vec_u8 { (* obj) . mutex_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_mutex_opt_generic < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . mutex_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_opt_mutex_complex < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_String { (* obj) . opt_mutex_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllMutexExamples_set_platform_case < > (obj : * const example_nested_gen_dict_AllMutexExamples) -> * mut crate :: fermented :: generics :: std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { (* obj) . platform_case } # [doc = "FFI-representation of the [`AllTupleExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllTupleExamples { pub tuple_string : * mut crate :: fermented :: generics :: Tuple_String_String , pub tuple_with_generic : * mut crate :: fermented :: generics :: Tuple_String_Vec_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllTupleExamples > for example_nested_gen_dict_AllTupleExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllTupleExamples) -> example_nested :: gen :: dict :: AllTupleExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllTupleExamples { tuple_string : < crate :: fermented :: generics :: Tuple_String_String as ferment :: FFIConversionFrom < (String , String) >> :: ffi_from (ffi_ref . tuple_string) , tuple_with_generic : < crate :: fermented :: generics :: Tuple_String_Vec_String as ferment :: FFIConversionFrom < (String , Vec < String >) >> :: ffi_from (ffi_ref . tuple_with_generic) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllTupleExamples > for example_nested_gen_dict_AllTupleExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllTupleExamples) -> * const example_nested_gen_dict_AllTupleExamples { ferment :: boxed (example_nested_gen_dict_AllTupleExamples { tuple_string : < crate :: fermented :: generics :: Tuple_String_String as ferment :: FFIConversionTo < (String , String) >> :: ffi_to (obj . tuple_string) , tuple_with_generic : < crate :: fermented :: generics :: Tuple_String_Vec_String as ferment :: FFIConversionTo < (String , Vec < String >) >> :: ffi_to (obj . tuple_with_generic) }) } } impl Drop for example_nested_gen_dict_AllTupleExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple_string) ; ferment :: unbox_any (ffi_ref . tuple_with_generic) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_ctor < > (tuple_string : * mut crate :: fermented :: generics :: Tuple_String_String , tuple_with_generic : * mut crate :: fermented :: generics :: Tuple_String_Vec_String) -> * mut example_nested_gen_dict_AllTupleExamples { ferment :: boxed (example_nested_gen_dict_AllTupleExamples { tuple_string , tuple_with_generic }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllTupleExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_get_tuple_string < > (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_String { (* obj) . tuple_string } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_get_tuple_with_generic < > (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_Vec_String { (* obj) . tuple_with_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_set_tuple_string < > (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_String { (* obj) . tuple_string } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllTupleExamples_set_tuple_with_generic < > (obj : * const example_nested_gen_dict_AllTupleExamples) -> * mut crate :: fermented :: generics :: Tuple_String_Vec_String { (* obj) . tuple_with_generic } # [doc = "FFI-representation of the [`AllArcExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllArcExamples { pub arc_simple : * mut crate :: fermented :: generics :: std_sync_Arc_u32 , pub arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot , pub arc_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 , pub arc_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , pub opt_arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_Option_String , pub crazy_type1 : * mut crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , pub crazy_type2 : * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArcExamples > for example_nested_gen_dict_AllArcExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllArcExamples) -> example_nested :: gen :: dict :: AllArcExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllArcExamples { arc_simple : < crate :: fermented :: generics :: std_sync_Arc_u32 as ferment :: FFIConversionFrom < std :: sync :: Arc < u32 > >> :: ffi_from (ffi_ref . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_sync_Arc_Vec_u8 as ferment :: FFIConversionFrom < std :: sync :: Arc < Vec < u8 > > >> :: ffi_from (ffi_ref . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_sync_Arc_Option_String as ferment :: FFIConversionFrom < std :: sync :: Arc < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_arc_complex) , crazy_type1 : < crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type1) , crazy_type2 : < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArcExamples > for example_nested_gen_dict_AllArcExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllArcExamples) -> * const example_nested_gen_dict_AllArcExamples { ferment :: boxed (example_nested_gen_dict_AllArcExamples { arc_simple : < crate :: fermented :: generics :: std_sync_Arc_u32 as ferment :: FFIConversionTo < std :: sync :: Arc < u32 > >> :: ffi_to (obj . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_sync_Arc_Vec_u8 as ferment :: FFIConversionTo < std :: sync :: Arc < Vec < u8 > > >> :: ffi_to (obj . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_sync_Arc_Option_String as ferment :: FFIConversionTo < std :: sync :: Arc < Option < String > > >> :: ffi_to_opt (obj . opt_arc_complex) , crazy_type1 : < crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type1) , crazy_type2 : < crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type2) }) } } impl Drop for example_nested_gen_dict_AllArcExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arc_simple) ; ferment :: unbox_any (ffi_ref . arc_complex) ; ferment :: unbox_any (ffi_ref . arc_generic) ; ferment :: unbox_any (ffi_ref . arc_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_arc_complex) ; ferment :: unbox_any (ffi_ref . crazy_type1) ; ferment :: unbox_any (ffi_ref . crazy_type2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_ctor < > (arc_simple : * mut crate :: fermented :: generics :: std_sync_Arc_u32 , arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot , arc_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 , arc_opt_generic : * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , opt_arc_complex : * mut crate :: fermented :: generics :: std_sync_Arc_Option_String , crazy_type1 : * mut crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , crazy_type2 : * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllArcExamples { ferment :: boxed (example_nested_gen_dict_AllArcExamples { arc_simple , arc_complex , arc_generic , arc_opt_generic , opt_arc_complex , crazy_type1 , crazy_type2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllArcExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_simple < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_complex < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_generic < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_arc_opt_generic < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_opt_arc_complex < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_String { (* obj) . opt_arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_crazy_type1 < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type1 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_get_crazy_type2 < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_simple < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_complex < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_generic < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_arc_opt_generic < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_opt_arc_complex < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: std_sync_Arc_Option_String { (* obj) . opt_arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_crazy_type1 < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type1 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArcExamples_set_crazy_type2 < > (obj : * const example_nested_gen_dict_AllArcExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type2 } # [doc = "FFI-representation of the [`AllResultExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllResultExamples { pub result_ok_simple_err_simple : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , pub result_ok_complex_err_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_String , pub result_ok_complex_2_err_complex : * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot , pub result_ok_complex_err_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 , pub result_ok_complex_err_opt_simple : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 , pub result_ok_complex_err_opt_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String , pub result_ok_complex_err_opt_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 , pub crazy_type : * mut crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , pub crazy_type_2 : * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllResultExamples > for example_nested_gen_dict_AllResultExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllResultExamples) -> example_nested :: gen :: dict :: AllResultExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllResultExamples { result_ok_simple_err_simple : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionFrom < Result < u32 , u32 > >> :: ffi_from (ffi_ref . result_ok_simple_err_simple) , result_ok_complex_err_complex : < crate :: fermented :: generics :: Result_ok_String_err_String as ferment :: FFIConversionFrom < Result < String , String > >> :: ffi_from (ffi_ref . result_ok_complex_err_complex) , result_ok_complex_2_err_complex : < crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . result_ok_complex_2_err_complex) , result_ok_complex_err_generic : < crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 as ferment :: FFIConversionFrom < Result < String , Vec < u8 > > >> :: ffi_from (ffi_ref . result_ok_complex_err_generic) , result_ok_complex_err_opt_simple : < crate :: fermented :: generics :: Result_ok_String_err_Option_u32 as ferment :: FFIConversionFrom < Result < String , Option < u32 > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_simple) , result_ok_complex_err_opt_complex : < crate :: fermented :: generics :: Result_ok_String_err_Option_String as ferment :: FFIConversionFrom < Result < String , Option < String > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_complex) , result_ok_complex_err_opt_generic : < crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 as ferment :: FFIConversionFrom < Result < String , Option < Vec < u8 > > > >> :: ffi_from (ffi_ref . result_ok_complex_err_opt_generic) , crazy_type : < crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_ref . crazy_type) , crazy_type_2 : < crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_from (ffi_ref . crazy_type_2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllResultExamples > for example_nested_gen_dict_AllResultExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllResultExamples) -> * const example_nested_gen_dict_AllResultExamples { ferment :: boxed (example_nested_gen_dict_AllResultExamples { result_ok_simple_err_simple : < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj . result_ok_simple_err_simple) , result_ok_complex_err_complex : < crate :: fermented :: generics :: Result_ok_String_err_String as ferment :: FFIConversionTo < Result < String , String > >> :: ffi_to (obj . result_ok_complex_err_complex) , result_ok_complex_2_err_complex : < crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . result_ok_complex_2_err_complex) , result_ok_complex_err_generic : < crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 as ferment :: FFIConversionTo < Result < String , Vec < u8 > > >> :: ffi_to (obj . result_ok_complex_err_generic) , result_ok_complex_err_opt_simple : < crate :: fermented :: generics :: Result_ok_String_err_Option_u32 as ferment :: FFIConversionTo < Result < String , Option < u32 > > >> :: ffi_to (obj . result_ok_complex_err_opt_simple) , result_ok_complex_err_opt_complex : < crate :: fermented :: generics :: Result_ok_String_err_Option_String as ferment :: FFIConversionTo < Result < String , Option < String > > >> :: ffi_to (obj . result_ok_complex_err_opt_complex) , result_ok_complex_err_opt_generic : < crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 as ferment :: FFIConversionTo < Result < String , Option < Vec < u8 > > > >> :: ffi_to (obj . result_ok_complex_err_opt_generic) , crazy_type : < crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj . crazy_type) , crazy_type_2 : < crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > >> :: ffi_to (obj . crazy_type_2) }) } } impl Drop for example_nested_gen_dict_AllResultExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . result_ok_simple_err_simple) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_2_err_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_generic) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_simple) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_complex) ; ferment :: unbox_any (ffi_ref . result_ok_complex_err_opt_generic) ; ferment :: unbox_any (ffi_ref . crazy_type) ; ferment :: unbox_any (ffi_ref . crazy_type_2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_ctor < > (result_ok_simple_err_simple : * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 , result_ok_complex_err_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_String , result_ok_complex_2_err_complex : * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot , result_ok_complex_err_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 , result_ok_complex_err_opt_simple : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 , result_ok_complex_err_opt_complex : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String , result_ok_complex_err_opt_generic : * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 , crazy_type : * mut crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError , crazy_type_2 : * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) -> * mut example_nested_gen_dict_AllResultExamples { ferment :: boxed (example_nested_gen_dict_AllResultExamples { result_ok_simple_err_simple , result_ok_complex_err_complex , result_ok_complex_2_err_complex , result_ok_complex_err_generic , result_ok_complex_err_opt_simple , result_ok_complex_err_opt_complex , result_ok_complex_err_opt_generic , crazy_type , crazy_type_2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllResultExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_simple_err_simple < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { (* obj) . result_ok_simple_err_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_String { (* obj) . result_ok_complex_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_2_err_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { (* obj) . result_ok_complex_2_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_generic < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 { (* obj) . result_ok_complex_err_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_simple < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 { (* obj) . result_ok_complex_err_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String { (* obj) . result_ok_complex_err_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_result_ok_complex_err_opt_generic < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 { (* obj) . result_ok_complex_err_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_crazy_type < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_get_crazy_type_2 < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_simple_err_simple < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { (* obj) . result_ok_simple_err_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_String { (* obj) . result_ok_complex_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_2_err_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { (* obj) . result_ok_complex_2_err_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_generic < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Vec_u8 { (* obj) . result_ok_complex_err_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_simple < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_u32 { (* obj) . result_ok_complex_err_opt_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_complex < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_String { (* obj) . result_ok_complex_err_opt_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_result_ok_complex_err_opt_generic < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_String_err_Option_Vec_u8 { (* obj) . result_ok_complex_err_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_crazy_type < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllResultExamples_set_crazy_type_2 < > (obj : * const example_nested_gen_dict_AllResultExamples) -> * mut crate :: fermented :: generics :: Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { (* obj) . crazy_type_2 } # [doc = "FFI-representation of the [`AllArrExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllArrExamples { pub arr : * mut crate :: fermented :: generics :: Arr_u8_32 , pub opt_arr : * mut crate :: fermented :: generics :: Arr_u8_32 , pub complex_arr : * mut crate :: fermented :: generics :: Arr_String_32 , pub complex_arr_2 : * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 , pub generic_arr_2 : * mut crate :: fermented :: generics :: Arr_Vec_u8_32 } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllArrExamples > for example_nested_gen_dict_AllArrExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllArrExamples) -> example_nested :: gen :: dict :: AllArrExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllArrExamples { arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . arr) , opt_arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_ref . opt_arr) , complex_arr : < crate :: fermented :: generics :: Arr_String_32 as ferment :: FFIConversionFrom < [String ; 32] >> :: ffi_from (ffi_ref . complex_arr) , complex_arr_2 : < crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 as ferment :: FFIConversionFrom < [example_nested :: model :: Quorum ; 32] >> :: ffi_from (ffi_ref . complex_arr_2) , generic_arr_2 : < crate :: fermented :: generics :: Arr_Vec_u8_32 as ferment :: FFIConversionFrom < [Vec < u8 > ; 32] >> :: ffi_from (ffi_ref . generic_arr_2) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllArrExamples > for example_nested_gen_dict_AllArrExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllArrExamples) -> * const example_nested_gen_dict_AllArrExamples { ferment :: boxed (example_nested_gen_dict_AllArrExamples { arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . arr) , opt_arr : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to_opt (obj . opt_arr) , complex_arr : < crate :: fermented :: generics :: Arr_String_32 as ferment :: FFIConversionTo < [String ; 32] >> :: ffi_to (obj . complex_arr) , complex_arr_2 : < crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 as ferment :: FFIConversionTo < [example_nested :: model :: Quorum ; 32] >> :: ffi_to (obj . complex_arr_2) , generic_arr_2 : < crate :: fermented :: generics :: Arr_Vec_u8_32 as ferment :: FFIConversionTo < [Vec < u8 > ; 32] >> :: ffi_to (obj . generic_arr_2) }) } } impl Drop for example_nested_gen_dict_AllArrExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arr) ; ferment :: unbox_any_opt (ffi_ref . opt_arr) ; ferment :: unbox_any (ffi_ref . complex_arr) ; ferment :: unbox_any (ffi_ref . complex_arr_2) ; ferment :: unbox_any (ffi_ref . generic_arr_2) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_ctor < > (arr : * mut crate :: fermented :: generics :: Arr_u8_32 , opt_arr : * mut crate :: fermented :: generics :: Arr_u8_32 , complex_arr : * mut crate :: fermented :: generics :: Arr_String_32 , complex_arr_2 : * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 , generic_arr_2 : * mut crate :: fermented :: generics :: Arr_Vec_u8_32) -> * mut example_nested_gen_dict_AllArrExamples { ferment :: boxed (example_nested_gen_dict_AllArrExamples { arr , opt_arr , complex_arr , complex_arr_2 , generic_arr_2 }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllArrExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_opt_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . opt_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_complex_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_String_32 { (* obj) . complex_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_complex_arr_2 < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 { (* obj) . complex_arr_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_get_generic_arr_2 < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_Vec_u8_32 { (* obj) . generic_arr_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_opt_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . opt_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_complex_arr < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_String_32 { (* obj) . complex_arr } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_complex_arr_2 < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_example_nested_model_Quorum_32 { (* obj) . complex_arr_2 } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllArrExamples_set_generic_arr_2 < > (obj : * const example_nested_gen_dict_AllArrExamples) -> * mut crate :: fermented :: generics :: Arr_Vec_u8_32 { (* obj) . generic_arr_2 } # [doc = "FFI-representation of the [`AllRcExamples`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_gen_dict_AllRcExamples { pub arc_simple : * mut crate :: fermented :: generics :: std_rc_Rc_u32 , pub arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot , pub arc_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 , pub arc_opt_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , pub opt_arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_Option_String } impl ferment :: FFIConversionFrom < example_nested :: gen :: dict :: AllRcExamples > for example_nested_gen_dict_AllRcExamples { unsafe fn ffi_from_const (ffi : * const example_nested_gen_dict_AllRcExamples) -> example_nested :: gen :: dict :: AllRcExamples { let ffi_ref = & * ffi ; example_nested :: gen :: dict :: AllRcExamples { arc_simple : < crate :: fermented :: generics :: std_rc_Rc_u32 as ferment :: FFIConversionFrom < std :: rc :: Rc < u32 > >> :: ffi_from (ffi_ref . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from (ffi_ref . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_rc_Rc_Vec_u8 as ferment :: FFIConversionFrom < std :: rc :: Rc < Vec < u8 > > >> :: ffi_from (ffi_ref . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_from (ffi_ref . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_rc_Rc_Option_String as ferment :: FFIConversionFrom < std :: rc :: Rc < Option < String > > >> :: ffi_from_opt (ffi_ref . opt_arc_complex) } } } impl ferment :: FFIConversionTo < example_nested :: gen :: dict :: AllRcExamples > for example_nested_gen_dict_AllRcExamples { unsafe fn ffi_to_const (obj : example_nested :: gen :: dict :: AllRcExamples) -> * const example_nested_gen_dict_AllRcExamples { ferment :: boxed (example_nested_gen_dict_AllRcExamples { arc_simple : < crate :: fermented :: generics :: std_rc_Rc_u32 as ferment :: FFIConversionTo < std :: rc :: Rc < u32 > >> :: ffi_to (obj . arc_simple) , arc_complex : < crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_to (obj . arc_complex) , arc_generic : < crate :: fermented :: generics :: std_rc_Rc_Vec_u8 as ferment :: FFIConversionTo < std :: rc :: Rc < Vec < u8 > > >> :: ffi_to (obj . arc_generic) , arc_opt_generic : < crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > >> :: ffi_to (obj . arc_opt_generic) , opt_arc_complex : < crate :: fermented :: generics :: std_rc_Rc_Option_String as ferment :: FFIConversionTo < std :: rc :: Rc < Option < String > > >> :: ffi_to_opt (obj . opt_arc_complex) }) } } impl Drop for example_nested_gen_dict_AllRcExamples { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . arc_simple) ; ferment :: unbox_any (ffi_ref . arc_complex) ; ferment :: unbox_any (ffi_ref . arc_generic) ; ferment :: unbox_any (ffi_ref . arc_opt_generic) ; ferment :: unbox_any_opt (ffi_ref . opt_arc_complex) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_ctor < > (arc_simple : * mut crate :: fermented :: generics :: std_rc_Rc_u32 , arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot , arc_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 , arc_opt_generic : * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot , opt_arc_complex : * mut crate :: fermented :: generics :: std_rc_Rc_Option_String) -> * mut example_nested_gen_dict_AllRcExamples { ferment :: boxed (example_nested_gen_dict_AllRcExamples { arc_simple , arc_complex , arc_generic , arc_opt_generic , opt_arc_complex }) } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_destroy < > (ffi : * mut example_nested_gen_dict_AllRcExamples) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_simple < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_complex < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_generic < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_arc_opt_generic < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_get_opt_arc_complex < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_String { (* obj) . opt_arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_simple < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_u32 { (* obj) . arc_simple } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_complex < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_complex } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_generic < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Vec_u8 { (* obj) . arc_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_arc_opt_generic < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { (* obj) . arc_opt_generic } # [no_mangle] pub unsafe extern "C" fn example_nested_gen_dict_AllRcExamples_set_opt_arc_complex < > (obj : * const example_nested_gen_dict_AllRcExamples) -> * mut crate :: fermented :: generics :: std_rc_Rc_Option_String { (* obj) . opt_arc_complex } } } pub mod entry { use crate as example_nested ; pub mod core { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::with_pointers`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_with_pointers (block_hash_by_height : example_nested :: entry :: BlockHashByHeight , model_by_height : example_nested :: entry :: ModelByHeight , context : * const std :: os :: raw :: c_void) -> * mut example_nested :: entry :: core :: DashSharedCore { let obj = example_nested :: entry :: core :: DashSharedCore :: with_pointers (block_hash_by_height , model_by_height , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::with_lambdas`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_with_lambdas (block_hash_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Arr_u8_32 , model_by_height : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel , context : * const std :: os :: raw :: c_void) -> * mut example_nested :: entry :: core :: DashSharedCore { let obj = example_nested :: entry :: core :: DashSharedCore :: with_lambdas (move | o_0 | unsafe { block_hash_by_height . call (o_0) } , move | o_0 | unsafe { model_by_height . call (o_0) } , context) ; ferment :: boxed (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::test_by_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_test_by_ref (self_ : * mut example_nested :: entry :: core :: DashSharedCore , data : * mut crate :: fermented :: generics :: Slice_u8) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_nested :: entry :: core :: DashSharedCore :: test_by_ref (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Slice_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (data)))) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::entry::core::DashSharedCore::test_vec_by_ref`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_core_DashSharedCore_test_vec_by_ref (self_ : * mut example_nested :: entry :: core :: DashSharedCore , data : * mut crate :: fermented :: generics :: Vec_u8) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_u32 { let obj = example_nested :: entry :: core :: DashSharedCore :: test_vec_by_ref (& * self_ , Box :: leak (Box :: new (< crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (data)))) ; < crate :: fermented :: generics :: Result_ok_u32_err_u32 as ferment :: FFIConversionTo < Result < u32 , u32 > >> :: ffi_to (obj) } } # [doc = "FFI-representation of the [`SomeModel`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_entry_SomeModel { pub hash : * mut crate :: fermented :: generics :: Arr_u8_32 , pub desc : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: entry :: SomeModel > for example_nested_entry_SomeModel { unsafe fn ffi_from_const (ffi : * const example_nested_entry_SomeModel) -> example_nested :: entry :: SomeModel { let ffi_ref = & * ffi ; example_nested :: entry :: SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_ref . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . desc) } } } impl ferment :: FFIConversionTo < example_nested :: entry :: SomeModel > for example_nested_entry_SomeModel { unsafe fn ffi_to_const (obj : example_nested :: entry :: SomeModel) -> * const example_nested_entry_SomeModel { ferment :: boxed (example_nested_entry_SomeModel { hash : < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (obj . hash) , desc : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . desc) }) } } impl Drop for example_nested_entry_SomeModel { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . hash) ; ferment :: unbox_string (ffi_ref . desc) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_ctor < > (hash : * mut crate :: fermented :: generics :: Arr_u8_32 , desc : * mut std :: os :: raw :: c_char) -> * mut example_nested_entry_SomeModel { ferment :: boxed (example_nested_entry_SomeModel { hash , desc }) } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_destroy < > (ffi : * mut example_nested_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_get_hash < > (obj : * const example_nested_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_get_desc < > (obj : * const example_nested_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_set_hash < > (obj : * const example_nested_entry_SomeModel) -> * mut crate :: fermented :: generics :: Arr_u8_32 { (* obj) . hash } # [no_mangle] pub unsafe extern "C" fn example_nested_entry_SomeModel_set_desc < > (obj : * const example_nested_entry_SomeModel) -> * mut std :: os :: raw :: c_char { (* obj) . desc } pub mod processor { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::entry::processor::Processor::register_initial_usernames`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_entry_processor_Processor_register_initial_usernames (self_ : * mut example_nested :: entry :: processor :: Processor , model : * mut example_nested :: entry :: processor :: Cache , context : * const std :: os :: raw :: c_void) { let obj = example_nested :: entry :: processor :: Processor :: register_initial_usernames (& mut * self_ , & mut * model , context) ; ; } } pub mod provider { use crate as example_nested ; } } pub mod model { use crate as example_nested ; pub mod ferment_example { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::ferment_example::get_rotated_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_ferment_example_get_rotated_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: ferment_example :: get_rotated_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::ferment_example::get_crazy_case`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_ferment_example_get_crazy_case () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: ferment_example :: get_crazy_case () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } # [doc = "FFI-representation of the [`Quorum`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_Quorum { pub llmq_type : * mut crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType } impl ferment :: FFIConversionFrom < example_nested :: model :: Quorum > for example_nested_model_Quorum { unsafe fn ffi_from_const (ffi : * const example_nested_model_Quorum) -> example_nested :: model :: Quorum { let ffi_ref = & * ffi ; example_nested :: model :: Quorum { llmq_type : < crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType as ferment :: FFIConversionFrom < example_nested :: model :: quorum :: quorum_type :: QuorumType >> :: ffi_from (ffi_ref . llmq_type) } } } impl ferment :: FFIConversionTo < example_nested :: model :: Quorum > for example_nested_model_Quorum { unsafe fn ffi_to_const (obj : example_nested :: model :: Quorum) -> * const example_nested_model_Quorum { ferment :: boxed (example_nested_model_Quorum { llmq_type : < crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType as ferment :: FFIConversionTo < example_nested :: model :: quorum :: quorum_type :: QuorumType >> :: ffi_to (obj . llmq_type) }) } } impl Drop for example_nested_model_Quorum { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . llmq_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_ctor < > (llmq_type : * mut crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType) -> * mut example_nested_model_Quorum { ferment :: boxed (example_nested_model_Quorum { llmq_type }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_destroy < > (ffi : * mut example_nested_model_Quorum) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_get_llmq_type < > (obj : * const example_nested_model_Quorum) -> * mut crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType { (* obj) . llmq_type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_Quorum_set_llmq_type < > (obj : * const example_nested_model_Quorum) -> * mut crate :: fermented :: types :: example_nested :: model :: quorum :: quorum_type :: example_nested_model_quorum_quorum_type_QuorumType { (* obj) . llmq_type } pub mod feat_dep { use crate as example_nested ; # [doc = "FFI-representation of the [`Validatorrr`]"] # [cfg (feature = "validation")] # [repr (C)] # [derive (Clone)] # [cfg (feature = "validation")] pub struct example_nested_model_feat_dep_Validatorrr { } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: Validatorrr > for example_nested_model_feat_dep_Validatorrr { unsafe fn ffi_from_const (ffi : * const example_nested_model_feat_dep_Validatorrr) -> example_nested :: model :: feat_dep :: Validatorrr { let ffi_ref = & * ffi ; example_nested :: model :: feat_dep :: Validatorrr { } } } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: Validatorrr > for example_nested_model_feat_dep_Validatorrr { unsafe fn ffi_to_const (obj : example_nested :: model :: feat_dep :: Validatorrr) -> * const example_nested_model_feat_dep_Validatorrr { ferment :: boxed (example_nested_model_feat_dep_Validatorrr { }) } } # [cfg (feature = "validation")] # [cfg (feature = "validation")] impl Drop for example_nested_model_feat_dep_Validatorrr { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_Validatorrr_ctor < > () -> * mut example_nested_model_feat_dep_Validatorrr { ferment :: boxed (example_nested_model_feat_dep_Validatorrr { }) } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_Validatorrr_destroy < > (ffi : * mut example_nested_model_feat_dep_Validatorrr) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`FeatureDependentField`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_feat_dep_FeatureDependentField { pub field_name : * mut std :: os :: raw :: c_char , # [cfg (feature = "validation")] pub field_type : * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr } impl ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: FeatureDependentField > for example_nested_model_feat_dep_FeatureDependentField { unsafe fn ffi_from_const (ffi : * const example_nested_model_feat_dep_FeatureDependentField) -> example_nested :: model :: feat_dep :: FeatureDependentField { let ffi_ref = & * ffi ; example_nested :: model :: feat_dep :: FeatureDependentField { field_name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . field_name) , # [cfg (feature = "validation")] field_type : < crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr as ferment :: FFIConversionFrom < example_nested :: model :: feat_dep :: Validatorrr >> :: ffi_from (ffi_ref . field_type) } } } impl ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: FeatureDependentField > for example_nested_model_feat_dep_FeatureDependentField { unsafe fn ffi_to_const (obj : example_nested :: model :: feat_dep :: FeatureDependentField) -> * const example_nested_model_feat_dep_FeatureDependentField { ferment :: boxed (example_nested_model_feat_dep_FeatureDependentField { field_name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . field_name) , # [cfg (feature = "validation")] field_type : < crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr as ferment :: FFIConversionTo < example_nested :: model :: feat_dep :: Validatorrr >> :: ffi_to (obj . field_type) }) } } impl Drop for example_nested_model_feat_dep_FeatureDependentField { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . field_name) ; # [cfg (feature = "validation")] ferment :: unbox_any (ffi_ref . field_type) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_ctor < > (field_name : * mut std :: os :: raw :: c_char , # [cfg (feature = "validation")] field_type : * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr) -> * mut example_nested_model_feat_dep_FeatureDependentField { ferment :: boxed (example_nested_model_feat_dep_FeatureDependentField { field_name , # [cfg (feature = "validation")] field_type }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_destroy < > (ffi : * mut example_nested_model_feat_dep_FeatureDependentField) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_get_field_name < > (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut std :: os :: raw :: c_char { (* obj) . field_name } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_get_field_type < > (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr { (* obj) . field_type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_set_field_name < > (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut std :: os :: raw :: c_char { (* obj) . field_name } # [cfg (feature = "validation")] # [no_mangle] pub unsafe extern "C" fn example_nested_model_feat_dep_FeatureDependentField_set_field_type < > (obj : * const example_nested_model_feat_dep_FeatureDependentField) -> * mut crate :: fermented :: types :: example_nested :: model :: feat_dep :: example_nested_model_feat_dep_Validatorrr { (* obj) . field_type } } pub mod indexmap { use crate as example_nested ; # [doc = "FFI-representation of the [`IndexMapExample`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_indexmap_IndexMapExample { pub set : * mut crate :: fermented :: generics :: indexmap_IndexSet_String , pub map : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String } impl ferment :: FFIConversionFrom < example_nested :: model :: indexmap :: IndexMapExample > for example_nested_model_indexmap_IndexMapExample { unsafe fn ffi_from_const (ffi : * const example_nested_model_indexmap_IndexMapExample) -> example_nested :: model :: indexmap :: IndexMapExample { let ffi_ref = & * ffi ; example_nested :: model :: indexmap :: IndexMapExample { set : < crate :: fermented :: generics :: indexmap_IndexSet_String as ferment :: FFIConversionFrom < indexmap :: IndexSet < String > >> :: ffi_from (ffi_ref . set) , map : < crate :: fermented :: generics :: indexmap_IndexMap_String_String as ferment :: FFIConversionFrom < indexmap :: IndexMap < String , String > >> :: ffi_from (ffi_ref . map) } } } impl ferment :: FFIConversionTo < example_nested :: model :: indexmap :: IndexMapExample > for example_nested_model_indexmap_IndexMapExample { unsafe fn ffi_to_const (obj : example_nested :: model :: indexmap :: IndexMapExample) -> * const example_nested_model_indexmap_IndexMapExample { ferment :: boxed (example_nested_model_indexmap_IndexMapExample { set : < crate :: fermented :: generics :: indexmap_IndexSet_String as ferment :: FFIConversionTo < indexmap :: IndexSet < String > >> :: ffi_to (obj . set) , map : < crate :: fermented :: generics :: indexmap_IndexMap_String_String as ferment :: FFIConversionTo < indexmap :: IndexMap < String , String > >> :: ffi_to (obj . map) }) } } impl Drop for example_nested_model_indexmap_IndexMapExample { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . set) ; ferment :: unbox_any (ffi_ref . map) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_ctor < > (set : * mut crate :: fermented :: generics :: indexmap_IndexSet_String , map : * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String) -> * mut example_nested_model_indexmap_IndexMapExample { ferment :: boxed (example_nested_model_indexmap_IndexMapExample { set , map }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_destroy < > (ffi : * mut example_nested_model_indexmap_IndexMapExample) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_get_set < > (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexSet_String { (* obj) . set } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_get_map < > (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String { (* obj) . map } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_set_set < > (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexSet_String { (* obj) . set } # [no_mangle] pub unsafe extern "C" fn example_nested_model_indexmap_IndexMapExample_set_map < > (obj : * const example_nested_model_indexmap_IndexMapExample) -> * mut crate :: fermented :: generics :: indexmap_IndexMap_String_String { (* obj) . map } } pub mod some_inner_2 { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::some_inner_2::get_normal_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_some_inner_2_get_normal_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: some_inner_2 :: get_normal_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelSnapshot { VO (* mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelSnapshot > for example_nested_model_TestModLevelSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelSnapshot) -> example_nested :: model :: TestModLevelSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelSnapshot > for example_nested_model_TestModLevelSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelSnapshot) -> * const example_nested_model_TestModLevelSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelSnapshot :: VO (o_0) => example_nested_model_TestModLevelSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelSnapshot :: VO (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut example_nested_model_TestModLevelSnapshot { ferment :: boxed (example_nested_model_TestModLevelSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelSnapshot_destroy < > (ffi : * mut example_nested_model_TestModLevelSnapshot) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`LLMQParams`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_LLMQParams { pub r#type : * mut std :: os :: raw :: c_char , pub known_confirmed_at_height : * mut u32 } impl ferment :: FFIConversionFrom < example_nested :: model :: LLMQParams > for example_nested_model_LLMQParams { unsafe fn ffi_from_const (ffi : * const example_nested_model_LLMQParams) -> example_nested :: model :: LLMQParams { let ffi_ref = & * ffi ; example_nested :: model :: LLMQParams { r#type : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . r#type) , known_confirmed_at_height : ferment :: from_opt_primitive (ffi_ref . known_confirmed_at_height) } } } impl ferment :: FFIConversionTo < example_nested :: model :: LLMQParams > for example_nested_model_LLMQParams { unsafe fn ffi_to_const (obj : example_nested :: model :: LLMQParams) -> * const example_nested_model_LLMQParams { ferment :: boxed (example_nested_model_LLMQParams { r#type : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . r#type) , known_confirmed_at_height : ferment :: to_opt_primitive (obj . known_confirmed_at_height) }) } } impl Drop for example_nested_model_LLMQParams { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . r#type) ; ferment :: destroy_opt_primitive (ffi_ref . known_confirmed_at_height) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_ctor < > (r#type : * mut std :: os :: raw :: c_char , known_confirmed_at_height : * mut u32) -> * mut example_nested_model_LLMQParams { ferment :: boxed (example_nested_model_LLMQParams { r#type , known_confirmed_at_height }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_destroy < > (ffi : * mut example_nested_model_LLMQParams) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_get_type < > (obj : * const example_nested_model_LLMQParams) -> * mut std :: os :: raw :: c_char { (* obj) . r#type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_get_known_confirmed_at_height < > (obj : * const example_nested_model_LLMQParams) -> * mut u32 { (* obj) . known_confirmed_at_height } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_set_type < > (obj : * const example_nested_model_LLMQParams) -> * mut std :: os :: raw :: c_char { (* obj) . r#type } # [no_mangle] pub unsafe extern "C" fn example_nested_model_LLMQParams_set_known_confirmed_at_height < > (obj : * const example_nested_model_LLMQParams) -> * mut u32 { (* obj) . known_confirmed_at_height } pub mod some_inner { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::some_inner::get_normal_quorum`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_some_inner_get_normal_quorum () -> * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum { let obj = example_nested :: model :: some_inner :: get_normal_quorum () ; < crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum as ferment :: FFIConversionTo < example_nested :: model :: Quorum >> :: ffi_to (obj) } } pub mod snapshot { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`VerifyingChainLockSignaturesType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_snapshot_VerifyingChainLockSignaturesType { Rotating (* mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) , NonRotating (* mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType > for example_nested_model_snapshot_VerifyingChainLockSignaturesType { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_VerifyingChainLockSignaturesType) -> example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_0) => example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_from (* o_0)) , example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_0) => example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionFrom < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType > for example_nested_model_snapshot_VerifyingChainLockSignaturesType { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType) -> * const example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (match obj { example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: Rotating (o_0) => example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (< crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4 as ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] >> :: ffi_to (o_0)) , example_nested :: model :: snapshot :: VerifyingChainLockSignaturesType :: NonRotating (o_0) => example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (< crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature as ferment :: FFIConversionTo < dashcore :: bls_sig_utils :: BLSSignature >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_snapshot_VerifyingChainLockSignaturesType { fn drop (& mut self) { unsafe { match self { example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_0) => { ferment :: unbox_any (* o_0) ; } , example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_Rotating_ctor (o_o_0 : * mut crate :: fermented :: generics :: Arr_dashcore_bls_sig_utils_BLSSignature_4) -> * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (example_nested_model_snapshot_VerifyingChainLockSignaturesType :: Rotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_NonRotating_ctor (o_o_0 : * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType { ferment :: boxed (example_nested_model_snapshot_VerifyingChainLockSignaturesType :: NonRotating (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_VerifyingChainLockSignaturesType_destroy < > (ffi : * mut example_nested_model_snapshot_VerifyingChainLockSignaturesType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`LLMQSnapshot`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_snapshot_LLMQSnapshot { pub member_list : * mut crate :: fermented :: generics :: Vec_u8 , pub skip_list : * mut crate :: fermented :: generics :: Vec_i32 , pub skip_list_mode : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode , pub option_vec : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot > for example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_LLMQSnapshot) -> example_nested :: model :: snapshot :: LLMQSnapshot { let ffi_ref = & * ffi ; example_nested :: model :: snapshot :: LLMQSnapshot { member_list : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (ffi_ref . member_list) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionFrom < Vec < i32 > >> :: ffi_from (ffi_ref . skip_list) , skip_list_mode : < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_from (ffi_ref . skip_list_mode) , option_vec : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (ffi_ref . option_vec) } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshot > for example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: LLMQSnapshot) -> * const example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshot { member_list : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to (obj . member_list) , skip_list : < crate :: fermented :: generics :: Vec_i32 as ferment :: FFIConversionTo < Vec < i32 > >> :: ffi_to (obj . skip_list) , skip_list_mode : < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_to (obj . skip_list_mode) , option_vec : < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionTo < Vec < u8 > >> :: ffi_to_opt (obj . option_vec) }) } } impl Drop for example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . member_list) ; ferment :: unbox_any (ffi_ref . skip_list) ; ferment :: unbox_any (ffi_ref . skip_list_mode) ; ferment :: unbox_any_opt (ffi_ref . option_vec) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_ctor < > (member_list : * mut crate :: fermented :: generics :: Vec_u8 , skip_list : * mut crate :: fermented :: generics :: Vec_i32 , skip_list_mode : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode , option_vec : * mut crate :: fermented :: generics :: Vec_u8) -> * mut example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshot { member_list , skip_list , skip_list_mode , option_vec }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_destroy < > (ffi : * mut example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_member_list < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . member_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_skip_list < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_i32 { (* obj) . skip_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_skip_list_mode < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_get_option_vec < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . option_vec } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_member_list < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . member_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_skip_list < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_i32 { (* obj) . skip_list } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_skip_list_mode < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode { (* obj) . skip_list_mode } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshot_set_option_vec < > (obj : * const example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: generics :: Vec_u8 { (* obj) . option_vec } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`LLMQSnapshotSkipMode`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_snapshot_LLMQSnapshotSkipMode { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 } impl ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > for example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_from_const (ffi : * const example_nested_model_snapshot_LLMQSnapshotSkipMode) -> example_nested :: model :: snapshot :: LLMQSnapshotSkipMode { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: NoSkipping , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipFirst , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipExcept , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll => example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipAll } } } impl ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > for example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_to_const (obj : example_nested :: model :: snapshot :: LLMQSnapshotSkipMode) -> * const example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (match obj { example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: NoSkipping => example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipFirst => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipExcept => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept , example_nested :: model :: snapshot :: LLMQSnapshotSkipMode :: SkipAll => example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_snapshot_LLMQSnapshotSkipMode { fn drop (& mut self) { unsafe { match self { example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept => { } , example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_NoSkipping_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: NoSkipping { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipFirst_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipFirst { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipExcept_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipExcept { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_SkipAll_ctor () -> * mut example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (example_nested_model_snapshot_LLMQSnapshotSkipMode :: SkipAll { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_snapshot_LLMQSnapshotSkipMode_destroy < > (ffi : * mut example_nested_model_snapshot_LLMQSnapshotSkipMode) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelOptSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelOptSnapshot { VO (* mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelOptSnapshot > for example_nested_model_TestModLevelOptSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelOptSnapshot) -> example_nested :: model :: TestModLevelOptSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelOptSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelOptSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_from_opt (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelOptSnapshot > for example_nested_model_TestModLevelOptSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelOptSnapshot) -> * const example_nested_model_TestModLevelOptSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelOptSnapshot :: VO (o_0) => example_nested_model_TestModLevelOptSnapshot :: VO (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >> :: ffi_to_opt (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelOptSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelOptSnapshot :: VO (o_0) => { ferment :: unbox_any_opt (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelOptSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut example_nested_model_TestModLevelOptSnapshot { ferment :: boxed (example_nested_model_TestModLevelOptSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelOptSnapshot_destroy < > (ffi : * mut example_nested_model_TestModLevelOptSnapshot) { ferment :: unbox_any (ffi) ; } pub mod many_scopes { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::new`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_new () -> * mut example_nested :: model :: many_scopes :: Struct111 { let obj = example_nested :: model :: many_scopes :: Struct111 :: new () ; ferment :: boxed (obj) } # [no_mangle] pub static example_nested_model_many_scopes_Struct111_example_nested_model_many_scopes_Trait111 : crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111_VTable = { # [no_mangle] unsafe extern "C" fn example_nested_model_many_scopes_Trait111_example_nested_model_many_scopes_Struct111_method1 (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * ((* self_) . object as * const example_nested :: model :: many_scopes :: Struct111)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111_VTable { method1 : example_nested_model_many_scopes_Trait111_example_nested_model_many_scopes_Struct111_method1 } } ; # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_as_crate_fermented_types_example_nested_model_many_scopes_example_nested_model_many_scopes_Trait111 (obj : * const example_nested :: model :: many_scopes :: Struct111) -> crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111 { crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111 { object : obj as * const () , vtable : & example_nested_model_many_scopes_Struct111_example_nested_model_many_scopes_Trait111 } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_as_crate_fermented_types_example_nested_model_many_scopes_example_nested_model_many_scopes_Trait111_destroy (obj : crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) { ferment :: unbox_any (obj . object as * mut example_nested :: model :: many_scopes :: Struct111) ; } # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::method1`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_Trait111_method1 (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * ((* self_) . object as * const example_nested :: model :: many_scopes :: Struct111)) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Struct111::method1`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_many_scopes_Struct111_method1 (self_ : * mut example_nested :: model :: many_scopes :: Struct111) -> * mut std :: os :: raw :: c_char { let obj = < example_nested :: model :: many_scopes :: Struct111 as example_nested :: model :: many_scopes :: Trait111 > :: method1 (& * self_) ; < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj) } # [repr (C)] # [derive (Clone)] pub struct example_nested_model_many_scopes_Trait111 { object : * const () , vtable : * const example_nested_model_many_scopes_Trait111_VTable } # [repr (C)] # [derive (Clone)] pub struct example_nested_model_many_scopes_Trait111_VTable { # [doc = "FFI-representation of the [`example_nested::model::many_scopes::Trait111::method1`]"] pub method1 : unsafe extern "C" fn (self_ : * mut crate :: fermented :: types :: example_nested :: model :: many_scopes :: example_nested_model_many_scopes_Trait111) -> * mut std :: os :: raw :: c_char } } pub mod callback { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_classic`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_classic (_callback : example_nested :: model :: callback :: ClassicCallback) { let obj = example_nested :: model :: callback :: find_current_block_classic (_callback) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::should_process_diff_in_range2`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_should_process_diff_in_range2 (_callback : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { let obj = example_nested :: model :: callback :: should_process_diff_in_range2 (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::lookup_block_hash_by_height`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_lookup_block_hash_by_height (_callback : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Option_u8_32) { let obj = example_nested :: model :: callback :: lookup_block_hash_by_height (move | o_0 | unsafe { _callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::setup_two_callbacks`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_setup_two_callbacks (_callback1 : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , _callback2 : crate :: fermented :: generics :: Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { let obj = example_nested :: model :: callback :: setup_two_callbacks (move | o_0 , o_1 | unsafe { _callback1 . call (o_0 , o_1) } , move | o_0 | unsafe { _callback2 . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_desc`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_desc (_callback : crate :: fermented :: generics :: Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String) { let obj = example_nested :: model :: callback :: find_current_block_desc (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::lookup_merkle_root_by_hash`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_lookup_merkle_root_by_hash (_callback : crate :: fermented :: generics :: Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32) { let obj = example_nested :: model :: callback :: lookup_merkle_root_by_hash (move | o_0 | unsafe { _callback . call (o_0) }) ; ; } # [doc = "FFI-representation of the [`example_nested::model::callback::find_current_block_desc_mut`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_callback_find_current_block_desc_mut (_callback : crate :: fermented :: generics :: FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String) { let obj = example_nested :: model :: callback :: find_current_block_desc_mut (move | o_0 , o_1 | unsafe { _callback . call (o_0 , o_1) }) ; ; } } pub mod tuples { use crate as example_nested ; # [doc = "FFI-representation of the [`ExampleWithOptPrimitive`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithOptPrimitive { pub v : * mut u32 } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithOptPrimitive > for example_nested_model_tuples_ExampleWithOptPrimitive { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithOptPrimitive) -> example_nested :: model :: tuples :: ExampleWithOptPrimitive { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithOptPrimitive { v : ferment :: from_opt_primitive (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithOptPrimitive > for example_nested_model_tuples_ExampleWithOptPrimitive { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithOptPrimitive) -> * const example_nested_model_tuples_ExampleWithOptPrimitive { ferment :: boxed (example_nested_model_tuples_ExampleWithOptPrimitive { v : ferment :: to_opt_primitive (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithOptPrimitive { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: destroy_opt_primitive (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_ctor < > (v : * mut u32) -> * mut example_nested_model_tuples_ExampleWithOptPrimitive { ferment :: boxed (example_nested_model_tuples_ExampleWithOptPrimitive { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_destroy < > (ffi : * mut example_nested_model_tuples_ExampleWithOptPrimitive) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_get_v < > (obj : * const example_nested_model_tuples_ExampleWithOptPrimitive) -> * mut u32 { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithOptPrimitive_set_v < > (obj : * const example_nested_model_tuples_ExampleWithOptPrimitive) -> * mut u32 { (* obj) . v } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_hash_id_form_snapshot`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_hash_id_form_snapshot (_snapshot : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID { let obj = example_nested :: model :: tuples :: get_hash_id_form_snapshot (< crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (_snapshot)) ; < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionTo < example_simple :: nested :: HashID >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`VecofArr`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_VecofArr { pub v : * mut crate :: fermented :: generics :: Vec_u8_32 } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: VecofArr > for example_nested_model_tuples_VecofArr { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_VecofArr) -> example_nested :: model :: tuples :: VecofArr { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: VecofArr { v : < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionFrom < Vec < [u8 ; 32] > >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: VecofArr > for example_nested_model_tuples_VecofArr { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: VecofArr) -> * const example_nested_model_tuples_VecofArr { ferment :: boxed (example_nested_model_tuples_VecofArr { v : < crate :: fermented :: generics :: Vec_u8_32 as ferment :: FFIConversionTo < Vec < [u8 ; 32] > >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_VecofArr { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_ctor < > (v : * mut crate :: fermented :: generics :: Vec_u8_32) -> * mut example_nested_model_tuples_VecofArr { ferment :: boxed (example_nested_model_tuples_VecofArr { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_destroy < > (ffi : * mut example_nested_model_tuples_VecofArr) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_get_v < > (obj : * const example_nested_model_tuples_VecofArr) -> * mut crate :: fermented :: generics :: Vec_u8_32 { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_VecofArr_set_v < > (obj : * const example_nested_model_tuples_VecofArr) -> * mut crate :: fermented :: generics :: Vec_u8_32 { (* obj) . v } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_simple_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_simple_complex () -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { let obj = example_nested :: model :: tuples :: get_tuple_simple_complex () ; < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_simple`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_simple () -> * mut crate :: fermented :: generics :: Tuple_u32_u32 { let obj = example_nested :: model :: tuples :: get_tuple_simple () ; < crate :: fermented :: generics :: Tuple_u32_u32 as ferment :: FFIConversionTo < (u32 , u32) >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`StructWithTupleWithOptional`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_StructWithTupleWithOptional { pub tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: StructWithTupleWithOptional > for example_nested_model_tuples_StructWithTupleWithOptional { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_StructWithTupleWithOptional) -> example_nested :: model :: tuples :: StructWithTupleWithOptional { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: StructWithTupleWithOptional { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) >> :: ffi_from (ffi_ref . tuple) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: StructWithTupleWithOptional > for example_nested_model_tuples_StructWithTupleWithOptional { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: StructWithTupleWithOptional) -> * const example_nested_model_tuples_StructWithTupleWithOptional { ferment :: boxed (example_nested_model_tuples_StructWithTupleWithOptional { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) >> :: ffi_to (obj . tuple) }) } } impl Drop for example_nested_model_tuples_StructWithTupleWithOptional { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_ctor < > (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot) -> * mut example_nested_model_tuples_StructWithTupleWithOptional { ferment :: boxed (example_nested_model_tuples_StructWithTupleWithOptional { tuple }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_destroy < > (ffi : * mut example_nested_model_tuples_StructWithTupleWithOptional) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_get_tuple < > (obj : * const example_nested_model_tuples_StructWithTupleWithOptional) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { (* obj) . tuple } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTupleWithOptional_set_tuple < > (obj : * const example_nested_model_tuples_StructWithTupleWithOptional) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { (* obj) . tuple } # [doc = "FFI-representation of the [`TransUser`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_TransUser { pub transition : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: TransUser > for example_nested_model_tuples_TransUser { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_TransUser) -> example_nested :: model :: tuples :: TransUser { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: TransUser { transition : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (ffi_ref . transition) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: TransUser > for example_nested_model_tuples_TransUser { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: TransUser) -> * const example_nested_model_tuples_TransUser { ferment :: boxed (example_nested_model_tuples_TransUser { transition : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (obj . transition) }) } } impl Drop for example_nested_model_tuples_TransUser { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . transition) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_ctor < > (transition : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_model_tuples_TransUser { ferment :: boxed (example_nested_model_tuples_TransUser { transition }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_destroy < > (ffi : * mut example_nested_model_tuples_TransUser) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_get_transition < > (obj : * const example_nested_model_tuples_TransUser) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . transition } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_TransUser_set_transition < > (obj : * const example_nested_model_tuples_TransUser) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . transition } # [doc = "FFI-representation of the [`ExampleWithGenericTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithGenericTuple { pub v : * mut crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithGenericTuple > for example_nested_model_tuples_ExampleWithGenericTuple { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithGenericTuple) -> example_nested :: model :: tuples :: ExampleWithGenericTuple { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithGenericTuple { v : < crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash) >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithGenericTuple > for example_nested_model_tuples_ExampleWithGenericTuple { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithGenericTuple) -> * const example_nested_model_tuples_ExampleWithGenericTuple { ferment :: boxed (example_nested_model_tuples_ExampleWithGenericTuple { v : < crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash) >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithGenericTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_ctor < > (v : * mut crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash) -> * mut example_nested_model_tuples_ExampleWithGenericTuple { ferment :: boxed (example_nested_model_tuples_ExampleWithGenericTuple { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_destroy < > (ffi : * mut example_nested_model_tuples_ExampleWithGenericTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_get_v < > (obj : * const example_nested_model_tuples_ExampleWithGenericTuple) -> * mut crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithGenericTuple_set_v < > (obj : * const example_nested_model_tuples_ExampleWithGenericTuple) -> * mut crate :: fermented :: generics :: Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { (* obj) . v } # [doc = "FFI-representation of the [`ExampleWithCustomGeneric`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_ExampleWithCustomGeneric { pub v : * mut crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: ExampleWithCustomGeneric > for example_nested_model_tuples_ExampleWithCustomGeneric { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_ExampleWithCustomGeneric) -> example_nested :: model :: tuples :: ExampleWithCustomGeneric { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: ExampleWithCustomGeneric { v : < crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash as ferment :: FFIConversionFrom < Vec < dashcore :: hash_types :: BlockHash > >> :: ffi_from (ffi_ref . v) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: ExampleWithCustomGeneric > for example_nested_model_tuples_ExampleWithCustomGeneric { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: ExampleWithCustomGeneric) -> * const example_nested_model_tuples_ExampleWithCustomGeneric { ferment :: boxed (example_nested_model_tuples_ExampleWithCustomGeneric { v : < crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash as ferment :: FFIConversionTo < Vec < dashcore :: hash_types :: BlockHash > >> :: ffi_to (obj . v) }) } } impl Drop for example_nested_model_tuples_ExampleWithCustomGeneric { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . v) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_ctor < > (v : * mut crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash) -> * mut example_nested_model_tuples_ExampleWithCustomGeneric { ferment :: boxed (example_nested_model_tuples_ExampleWithCustomGeneric { v }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_destroy < > (ffi : * mut example_nested_model_tuples_ExampleWithCustomGeneric) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_get_v < > (obj : * const example_nested_model_tuples_ExampleWithCustomGeneric) -> * mut crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash { (* obj) . v } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_ExampleWithCustomGeneric_set_v < > (obj : * const example_nested_model_tuples_ExampleWithCustomGeneric) -> * mut crate :: fermented :: generics :: Vec_dashcore_hash_types_BlockHash { (* obj) . v } # [doc = "FFI-representation of the [`StructWithTuple`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_model_tuples_StructWithTuple { pub tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID } impl ferment :: FFIConversionFrom < example_nested :: model :: tuples :: StructWithTuple > for example_nested_model_tuples_StructWithTuple { unsafe fn ffi_from_const (ffi : * const example_nested_model_tuples_StructWithTuple) -> example_nested :: model :: tuples :: StructWithTuple { let ffi_ref = & * ffi ; example_nested :: model :: tuples :: StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (ffi_ref . tuple) } } } impl ferment :: FFIConversionTo < example_nested :: model :: tuples :: StructWithTuple > for example_nested_model_tuples_StructWithTuple { unsafe fn ffi_to_const (obj : example_nested :: model :: tuples :: StructWithTuple) -> * const example_nested_model_tuples_StructWithTuple { ferment :: boxed (example_nested_model_tuples_StructWithTuple { tuple : < crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) >> :: ffi_to (obj . tuple) }) } } impl Drop for example_nested_model_tuples_StructWithTuple { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . tuple) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_ctor < > (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) -> * mut example_nested_model_tuples_StructWithTuple { ferment :: boxed (example_nested_model_tuples_StructWithTuple { tuple }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_destroy < > (ffi : * mut example_nested_model_tuples_StructWithTuple) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_get_tuple < > (obj : * const example_nested_model_tuples_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { (* obj) . tuple } # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_StructWithTuple_set_tuple < > (obj : * const example_nested_model_tuples_StructWithTuple) -> * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID { (* obj) . tuple } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_complex_complex_opt`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_complex_complex_opt (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot) -> u32 { let obj = example_nested :: model :: tuples :: get_tuple_complex_complex_opt (< crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) >> :: ffi_from (tuple)) ; obj } # [doc = "FFI-representation of the [`example_nested::model::tuples::get_tuple_complex_complex`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_model_tuples_get_tuple_complex_complex (tuple : * mut crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID) -> u32 { let obj = example_nested :: model :: tuples :: get_tuple_complex_complex (< crate :: fermented :: generics :: Tuple_u32_example_simple_nested_HashID as ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) >> :: ffi_from (tuple)) ; obj } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`TestModLevelVecSnapshot`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_TestModLevelVecSnapshot { VO (* mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) } impl ferment :: FFIConversionFrom < example_nested :: model :: TestModLevelVecSnapshot > for example_nested_model_TestModLevelVecSnapshot { unsafe fn ffi_from_const (ffi : * const example_nested_model_TestModLevelVecSnapshot) -> example_nested :: model :: TestModLevelVecSnapshot { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_TestModLevelVecSnapshot :: VO (o_0) => example_nested :: model :: TestModLevelVecSnapshot :: VO (< crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: model :: TestModLevelVecSnapshot > for example_nested_model_TestModLevelVecSnapshot { unsafe fn ffi_to_const (obj : example_nested :: model :: TestModLevelVecSnapshot) -> * const example_nested_model_TestModLevelVecSnapshot { ferment :: boxed (match obj { example_nested :: model :: TestModLevelVecSnapshot :: VO (o_0) => example_nested_model_TestModLevelVecSnapshot :: VO (< crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode as ferment :: FFIConversionTo < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_TestModLevelVecSnapshot { fn drop (& mut self) { unsafe { match self { example_nested_model_TestModLevelVecSnapshot :: VO (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelVecSnapshot_VO_ctor (o_o_0 : * mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut example_nested_model_TestModLevelVecSnapshot { ferment :: boxed (example_nested_model_TestModLevelVecSnapshot :: VO (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_TestModLevelVecSnapshot_destroy < > (ffi : * mut example_nested_model_TestModLevelVecSnapshot) { ferment :: unbox_any (ffi) ; } pub mod quorum { use crate as example_nested ; pub mod quorum_type { use crate as example_nested ; # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`QuorumType`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_quorum_quorum_type_QuorumType { Normal , Rotated } impl ferment :: FFIConversionFrom < example_nested :: model :: quorum :: quorum_type :: QuorumType > for example_nested_model_quorum_quorum_type_QuorumType { unsafe fn ffi_from_const (ffi : * const example_nested_model_quorum_quorum_type_QuorumType) -> example_nested :: model :: quorum :: quorum_type :: QuorumType { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_quorum_quorum_type_QuorumType :: Normal => example_nested :: model :: quorum :: quorum_type :: QuorumType :: Normal , example_nested_model_quorum_quorum_type_QuorumType :: Rotated => example_nested :: model :: quorum :: quorum_type :: QuorumType :: Rotated } } } impl ferment :: FFIConversionTo < example_nested :: model :: quorum :: quorum_type :: QuorumType > for example_nested_model_quorum_quorum_type_QuorumType { unsafe fn ffi_to_const (obj : example_nested :: model :: quorum :: quorum_type :: QuorumType) -> * const example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (match obj { example_nested :: model :: quorum :: quorum_type :: QuorumType :: Normal => example_nested_model_quorum_quorum_type_QuorumType :: Normal , example_nested :: model :: quorum :: quorum_type :: QuorumType :: Rotated => example_nested_model_quorum_quorum_type_QuorumType :: Rotated , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_quorum_quorum_type_QuorumType { fn drop (& mut self) { unsafe { match self { example_nested_model_quorum_quorum_type_QuorumType :: Normal => { } , example_nested_model_quorum_quorum_type_QuorumType :: Rotated => { } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_Normal_ctor () -> * mut example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (example_nested_model_quorum_quorum_type_QuorumType :: Normal { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_Rotated_ctor () -> * mut example_nested_model_quorum_quorum_type_QuorumType { ferment :: boxed (example_nested_model_quorum_quorum_type_QuorumType :: Rotated { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_QuorumType_destroy < > (ffi : * mut example_nested_model_quorum_quorum_type_QuorumType) { ferment :: unbox_any (ffi) ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`OBJCEnumTest`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_model_quorum_quorum_type_OBJCEnumTest { Regular , UnnamedEx (* mut std :: os :: raw :: c_char) , NamedEx { qtype : * mut std :: os :: raw :: c_char } } impl ferment :: FFIConversionFrom < example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest > for example_nested_model_quorum_quorum_type_OBJCEnumTest { unsafe fn ffi_from_const (ffi : * const example_nested_model_quorum_quorum_type_OBJCEnumTest) -> example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest { let ffi_ref = & * ffi ; match ffi_ref { example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: Regular , example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_0) => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: UnnamedEx (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* o_0)) , example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype } => example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: NamedEx { qtype : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (* qtype) } } } } impl ferment :: FFIConversionTo < example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest > for example_nested_model_quorum_quorum_type_OBJCEnumTest { unsafe fn ffi_to_const (obj : example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest) -> * const example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (match obj { example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: Regular => example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular , example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: UnnamedEx (o_0) => example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (< std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (o_0)) , example_nested :: model :: quorum :: quorum_type :: OBJCEnumTest :: NamedEx { qtype } => example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (qtype) } , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_model_quorum_quorum_type_OBJCEnumTest { fn drop (& mut self) { unsafe { match self { example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular => { } , example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_0) => { ferment :: unbox_string (* o_0) ; } , example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype } => { ferment :: unbox_string (* qtype) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_Regular_ctor () -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: Regular { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_UnnamedEx_ctor (o_o_0 : * mut std :: os :: raw :: c_char) -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: UnnamedEx (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_NamedEx_ctor (qtype : * mut std :: os :: raw :: c_char) -> * mut example_nested_model_quorum_quorum_type_OBJCEnumTest { ferment :: boxed (example_nested_model_quorum_quorum_type_OBJCEnumTest :: NamedEx { qtype }) } # [no_mangle] pub unsafe extern "C" fn example_nested_model_quorum_quorum_type_OBJCEnumTest_destroy < > (ffi : * mut example_nested_model_quorum_quorum_type_OBJCEnumTest) { ferment :: unbox_any (ffi) ; } } } } pub mod custom { use crate as example_nested ; } # [doc = "FFI-representation of the [`example_nested::test_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_test_lifetime < 'a > (_example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: test_lifetime (< crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_lifetime_support`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_lifetime_support < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_lifetime_support (& * self_ , < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_staticlifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_staticlifetime (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_staticlifetime (& * self_ , < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'static > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_generic_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_generic_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: Vec_example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_generic_lifetime (& * self_ , < crate :: fermented :: generics :: Vec_example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < Vec < example_nested :: ExampleEnumLif < 'a > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_map_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_map_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) { let obj = example_nested :: Manager :: check_map_lifetime (& * self_ , < crate :: fermented :: generics :: std_collections_Map_keys_String_values_example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`example_nested::Manager::check_map_deep_lifetime`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_Manager_check_map_deep_lifetime < 'a > (self_ : * mut example_nested :: Manager , _example : * mut crate :: fermented :: generics :: std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { let obj = example_nested :: Manager :: check_map_deep_lifetime (& * self_ , < crate :: fermented :: generics :: std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionFrom < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > >> :: ffi_from (_example)) ; ; } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`ExampleEnumLif`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_ExampleEnumLif { Varik (* mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) } impl < 'a , > ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > > for example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const example_nested_ExampleEnumLif) -> example_nested :: ExampleEnumLif < 'a > { let ffi_ref = & * ffi ; match ffi_ref { example_nested_ExampleEnumLif :: Varik (o_0) => example_nested :: ExampleEnumLif :: Varik (Box :: leak (Box :: new (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (* o_0)))) } } } impl < 'a , > ferment :: FFIConversionTo < example_nested :: ExampleEnumLif < 'a > > for example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : example_nested :: ExampleEnumLif < 'a >) -> * const example_nested_ExampleEnumLif { ferment :: boxed (match obj { example_nested :: ExampleEnumLif :: Varik (o_0) => example_nested_ExampleEnumLif :: Varik (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (o_0 . clone ())) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { match self { example_nested_ExampleEnumLif :: Varik (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_ExampleEnumLif_Varik_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_ExampleEnumLif { ferment :: boxed (example_nested_ExampleEnumLif :: Varik (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_ExampleEnumLif_destroy < 'a > (ffi : * mut example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } pub mod state_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`example_nested::state_transition::ContractsManager::contract_registration_transition`]"] # [cfg (feature = "state-transitions")] # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_ContractsManager_contract_registration_transition (self_ : * mut example_nested :: state_transition :: ContractsManager , contract : * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract) -> * mut crate :: fermented :: generics :: Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { let obj = example_nested :: state_transition :: ContractsManager :: contract_registration_transition (& * self_ , < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DataContract as ferment :: FFIConversionFrom < dpp :: data_contract :: DataContract >> :: ffi_from (contract)) ; < crate :: fermented :: generics :: Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError as ferment :: FFIConversionTo < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: protocol_error :: ProtocolError > >> :: ffi_to (obj) } # [doc = "FFI-representation of the [`example_nested::state_transition::ContractsManager::basic_errror`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_ContractsManager_basic_errror (self_ : * mut example_nested :: state_transition :: ContractsManager) -> * mut crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError { let obj = example_nested :: state_transition :: ContractsManager :: basic_errror (& * self_) ; < crate :: fermented :: types :: dpp :: errors :: consensus :: basic :: basic_error :: dpp_errors_consensus_basic_basic_error_BasicError as ferment :: FFIConversionTo < dpp :: errors :: consensus :: basic :: basic_error :: BasicError >> :: ffi_to (obj) } pub mod state_transitions { use crate as example_nested ; pub mod contract { use crate as example_nested ; pub mod data_contract_create_transition { use crate as example_nested ; # [doc = "FFI-representation of the [`ExampleStructLif`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { pub varik : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition } impl < 'a , > ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > { let ffi_ref = & * ffi ; example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif { varik : Box :: leak (Box :: new (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_from (ffi_ref . varik))) } } } impl < 'a , > ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a > > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: ExampleStructLif < 'a >) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { varik : < crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition >> :: ffi_to (obj . varik . clone ()) }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_any (ffi_ref . varik) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_ctor < 'a > (varik : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif { varik }) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_destroy < 'a > (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_get_varik < 'a > (obj : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . varik } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif_set_varik < 'a > (obj : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_ExampleStructLif) -> * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { (* obj) . varik } pub mod v0 { use crate as example_nested ; # [doc = "FFI-representation of the [`DataContractCreateTransitionV0`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { } impl ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { let ffi_ref = & * ffi ; example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 { } } } impl ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { fn drop (& mut self) { unsafe { let ffi_ref = self ; ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_ctor < > () -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 { }) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0_destroy < > (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) { ferment :: unbox_any (ffi) ; } } # [doc = "FFI-representation of the [`# doc = \"FFI-representation of the [`DataContractCreateTransition`]\"`]"] # [repr (C)] # [derive (Clone)] # [non_exhaustive] pub enum example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { V0 (* mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) } impl ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_from_const (ffi : * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) -> example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition { let ffi_ref = & * ffi ; match ffi_ref { example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionFrom < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_from (* o_0)) } } } impl ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition > for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { unsafe fn ffi_to_const (obj : example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition) -> * const example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (match obj { example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: DataContractCreateTransition :: V0 (o_0) => example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (< crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0 as ferment :: FFIConversionTo < example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: DataContractCreateTransitionV0 >> :: ffi_to (o_0)) , _ => unreachable ! ("This is unreachable") }) } } impl Drop for example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { fn drop (& mut self) { unsafe { match self { example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_0) => { ferment :: unbox_any (* o_0) ; } , _ => unreachable ! ("This is unreachable") } ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_V0_ctor (o_o_0 : * mut crate :: fermented :: types :: example_nested :: state_transition :: state_transitions :: contract :: data_contract_create_transition :: v0 :: example_nested_state_transition_state_transitions_contract_data_contract_create_transition_v0_DataContractCreateTransitionV0) -> * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition { ferment :: boxed (example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition :: V0 (o_o_0)) } # [no_mangle] pub unsafe extern "C" fn example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition_destroy < > (ffi : * mut example_nested_state_transition_state_transitions_contract_data_contract_create_transition_DataContractCreateTransition) { ferment :: unbox_any (ffi) ; } } } } } # [doc = "FFI-representation of the [`SomeStruct`]"] # [repr (C)] # [derive (Clone)] pub struct example_nested_SomeStruct { pub name : * mut std :: os :: raw :: c_char , pub names : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < example_nested :: SomeStruct > for example_nested_SomeStruct { unsafe fn ffi_from_const (ffi : * const example_nested_SomeStruct) -> example_nested :: SomeStruct { let ffi_ref = & * ffi ; example_nested :: SomeStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (ffi_ref . name) , names : Box :: leak (Box :: new (< std :: os :: raw :: c_char as ferment :: FFIConversionFrom < & str >> :: ffi_from (ffi_ref . names))) } } } impl ferment :: FFIConversionTo < example_nested :: SomeStruct > for example_nested_SomeStruct { unsafe fn ffi_to_const (obj : example_nested :: SomeStruct) -> * const example_nested_SomeStruct { ferment :: boxed (example_nested_SomeStruct { name : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < String >> :: ffi_to (obj . name) , names : < std :: os :: raw :: c_char as ferment :: FFIConversionTo < & str >> :: ffi_to (obj . names) }) } } impl Drop for example_nested_SomeStruct { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment :: unbox_string (ffi_ref . name) ; ferment :: unbox_string (ffi_ref . names) ; } } } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_ctor < > (name : * mut std :: os :: raw :: c_char , names : * mut std :: os :: raw :: c_char) -> * mut example_nested_SomeStruct { ferment :: boxed (example_nested_SomeStruct { name , names }) } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_destroy < > (ffi : * mut example_nested_SomeStruct) { ferment :: unbox_any (ffi) ; } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_get_name < > (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_get_names < > (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . names } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_set_name < > (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . name } # [no_mangle] pub unsafe extern "C" fn example_nested_SomeStruct_set_names < > (obj : * const example_nested_SomeStruct) -> * mut std :: os :: raw :: c_char { (* obj) . names } # [doc = "FFI-representation of the [`example_nested::identity_public_key_test`]"] # [no_mangle] pub unsafe extern "C" fn example_nested_identity_public_key_test (identity : * mut crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity) -> * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey { let obj = example_nested :: identity_public_key_test (< crate :: fermented :: types :: dpp :: identity :: identity :: dpp_identity_identity_Identity as ferment :: FFIConversionFrom < dpp :: identity :: identity :: Identity >> :: ffi_from (identity)) ; < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionTo < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_to (obj) } } } # [allow (clippy :: let_and_return , clippy :: suspicious_else_formatting , clippy :: redundant_field_names , dead_code , non_camel_case_types , non_snake_case , non_upper_case_globals , redundant_semicolons , unreachable_patterns , unused_braces , unused_imports , unused_parens , unused_qualifications , unused_unsafe , unused_variables)] pub mod generics { use crate as example_nested ; # [repr (C)] # [derive (Clone)] pub struct Arr_Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < [Vec < u8 > ; 32] > for Arr_Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_Vec_u8_32) -> [Vec < u8 > ; 32] { let ffi_ref = & * ffi ; let vec : Vec < Vec < u8 > > = ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [Vec < u8 > ; 32] > for Arr_Vec_u8_32 { unsafe fn ffi_to_const (obj : [Vec < u8 > ; 32]) -> * const Arr_Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Arr_Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Arr_Vec_u8_32 { ferment :: boxed (Arr_Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_Vec_u8_32_destroy (ffi : * mut Arr_Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < u32 > > > for std_collections_BTreeSet_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_u32) -> std :: collections :: BTreeSet < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_opt_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < u32 > > > for std_collections_BTreeSet_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < u32 > >) -> * const std_collections_BTreeSet_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_primitive_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut std_collections_BTreeSet_Option_u32 { ferment :: boxed (std_collections_BTreeSet_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_u32_destroy (ffi : * mut std_collections_BTreeSet_Option_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < String > > > for std_sync_RwLock_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Option_String) -> std :: sync :: RwLock < Option < String > > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Option < String > > > for std_sync_RwLock_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Option < String > >) -> * const std_sync_RwLock_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_RwLock_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_RwLock_Option_String { ferment :: boxed (std_sync_RwLock_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_String_destroy (ffi : * mut std_sync_RwLock_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < u32 > > > for std_collections_Map_keys_u32_values_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_u32) -> std :: collections :: BTreeMap < u32 , Option < u32 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | ferment :: from_opt_primitive (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < u32 > > > for std_collections_Map_keys_u32_values_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < u32 > >) -> * const std_collections_Map_keys_u32_values_Option_u32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_opt_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_ctor (count : usize , keys : * mut u32 , values : * mut * mut u32) -> * mut std_collections_Map_keys_u32_values_Option_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_Option_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_u32 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < String , Option < u32 > > > for Result_ok_String_err_Option_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_u32) -> Result < String , Option < u32 > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | ferment :: from_opt_primitive (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < u32 > > > for Result_ok_String_err_Option_u32 { unsafe fn ffi_to_const (obj : Result < String , Option < u32 > >) -> * const Result_ok_String_err_Option_u32 { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: to_opt_primitive (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_String_err_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: destroy_opt_primitive (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut u32) -> * mut Result_ok_String_err_Option_u32 { ferment :: boxed (Result_ok_String_err_Option_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_u32_destroy (ffi : * mut Result_ok_String_err_Option_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_platform_value_Value_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value } impl ferment :: FFIConversionFrom < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_platform_value_Value_platform_value_Value) -> Vec < (platform_value :: Value , platform_value :: Value) > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < (platform_value :: Value , platform_value :: Value) > > for Vec_Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < (platform_value :: Value , platform_value :: Value) >) -> * const Vec_Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_Value_platform_value_Value) -> * mut Vec_Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Vec_Tuple_platform_value_Value_platform_value_Value { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_Value_platform_value_Value_destroy (ffi : * mut Vec_Tuple_platform_value_Value_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > > for std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > > for std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > >) -> * const std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (std :: sync :: RwLock :: new (obj . read () . expect ("Poisoned") . clone ())) }) } } impl Drop for std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Vec < u8 > > > for std_collections_HashSet_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Vec_u8) -> std :: collections :: HashSet < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Vec < u8 > > > for std_collections_HashSet_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Vec < u8 > >) -> * const std_collections_HashSet_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_HashSet_Vec_u8 { ferment :: boxed (std_collections_HashSet_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Vec_u8_destroy (ffi : * mut std_collections_HashSet_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < u32 > > for std_cell_RefCell_u32 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_u32) -> std :: cell :: RefCell < u32 > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < u32 > > for std_cell_RefCell_u32 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < u32 >) -> * const std_cell_RefCell_u32 { ferment :: boxed (Self { obj : obj . into_inner () }) } } impl Drop for std_cell_RefCell_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_ctor (obj : u32) -> * mut std_cell_RefCell_u32 { ferment :: boxed (std_cell_RefCell_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_u32_destroy (ffi : * mut std_cell_RefCell_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_20 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_from_const (ffi : * const Arr_u8_20) -> [u8 ; 20] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 20] > for Arr_u8_20 { unsafe fn ffi_to_const (obj : [u8 ; 20]) -> * const Arr_u8_20 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_20 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_20 { ferment :: boxed (Arr_u8_20 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_20_destroy (ffi : * mut Arr_u8_20) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Tuple_String_dpp_balances_credits_Credits { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_from_const (ffi : * const Tuple_String_dpp_balances_credits_Credits) -> (String , dpp :: balances :: credits :: Credits) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < (String , dpp :: balances :: credits :: Credits) > for Tuple_String_dpp_balances_credits_Credits { unsafe fn ffi_to_const (obj : (String , dpp :: balances :: credits :: Credits)) -> * const Tuple_String_dpp_balances_credits_Credits { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Tuple_String_dpp_balances_credits_Credits { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Tuple_String_dpp_balances_credits_Credits_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_Credits) -> * mut Tuple_String_dpp_balances_credits_Credits { ferment :: boxed (Tuple_String_dpp_balances_credits_Credits { o_0 , o_1 }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Tuple_String_dpp_balances_credits_Credits_destroy (ffi : * mut Tuple_String_dpp_balances_credits_Credits) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_String) -> std :: collections :: BTreeMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , String > > for std_collections_Map_keys_String_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , String >) -> * const std_collections_Map_keys_String_values_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_String_values_String { ferment :: boxed (std_collections_Map_keys_String_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_String_destroy (ffi : * mut std_collections_Map_keys_String_values_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > for std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > for std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > >) -> * const std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < u32 > > for std_collections_BTreeSet_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_u32) -> std :: collections :: BTreeSet < u32 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < u32 > > for std_collections_BTreeSet_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < u32 >) -> * const std_collections_BTreeSet_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_ctor (count : usize , values : * mut u32) -> * mut std_collections_BTreeSet_u32 { ferment :: boxed (std_collections_BTreeSet_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_u32_destroy (ffi : * mut std_collections_BTreeSet_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName as ferment :: FFIConversionFrom < dpp :: data_contract :: DefinitionName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DefinitionName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DefinitionName , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DefinitionName_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , String > > for std_collections_Map_keys_u32_values_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_String) -> std :: collections :: BTreeMap < u32 , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , String > > for std_collections_Map_keys_u32_values_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , String >) -> * const std_collections_Map_keys_u32_values_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_String { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_u32_values_String { ferment :: boxed (std_collections_Map_keys_u32_values_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < String > > for std_collections_HashSet_String { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_String) -> std :: collections :: HashSet < String > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < String > > for std_collections_HashSet_String { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < String >) -> * const std_collections_HashSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_HashSet_String { ferment :: boxed (std_collections_HashSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_String_destroy (ffi : * mut std_collections_HashSet_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_Vec_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > > for std_collections_Map_keys_u32_values_Option_Vec_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_u32) -> std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_u32 as ferment :: FFIConversionFrom < Vec < u32 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > > > for std_collections_Map_keys_u32_values_Option_Vec_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < Vec < u32 > > >) -> * const std_collections_Map_keys_u32_values_Option_Vec_u32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_opt_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_Option_Vec_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_u32) -> * mut std_collections_Map_keys_u32_values_Option_Vec_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_Option_Vec_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_String_Arr_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_String_Arr_u8_32) -> Vec < (String , [u8 ; 32]) > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < (String , [u8 ; 32]) > > for Vec_Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : Vec < (String , [u8 ; 32]) >) -> * const Vec_Tuple_String_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_String_Arr_u8_32) -> * mut Vec_Tuple_String_Arr_u8_32 { ferment :: boxed (Vec_Tuple_String_Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_Arr_u8_32_destroy (ffi : * mut Vec_Tuple_String_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_document_Document { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } impl ferment :: FFIConversionFrom < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const Vec_dpp_document_Document) -> Vec < dpp :: document :: Document > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: document :: Document > > for Vec_dpp_document_Document { unsafe fn ffi_to_const (obj : Vec < dpp :: document :: Document >) -> * const Vec_dpp_document_Document { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut Vec_dpp_document_Document { ferment :: boxed (Vec_dpp_document_Document { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_document_Document_destroy (ffi : * mut Vec_dpp_document_Document) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexMap_String_String { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < indexmap :: IndexMap < String , String > > for indexmap_IndexMap_String_String { unsafe fn ffi_from_const (ffi : * const indexmap_IndexMap_String_String) -> indexmap :: IndexMap < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexMap < String , String > > for indexmap_IndexMap_String_String { unsafe fn ffi_to_const (obj : indexmap :: IndexMap < String , String >) -> * const indexmap_IndexMap_String_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for indexmap_IndexMap_String_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut std :: os :: raw :: c_char) -> * mut indexmap_IndexMap_String_String { ferment :: boxed (indexmap_IndexMap_String_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_String_destroy (ffi : * mut indexmap_IndexMap_String_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_platform_value_Value { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_platform_value_Value) -> std :: collections :: BTreeMap < String , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , platform_value :: Value > > for std_collections_Map_keys_String_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , platform_value :: Value >) -> * const std_collections_Map_keys_String_values_platform_value_Value { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_String_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_String_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_String_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < u32 > > for std_sync_RwLock_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_u32) -> std :: sync :: RwLock < u32 > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < u32 > > for std_sync_RwLock_u32 { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < u32 >) -> * const std_sync_RwLock_u32 { ferment :: boxed (Self { obj : obj . into_inner () . expect ("Err") }) } } impl Drop for std_sync_RwLock_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_ctor (obj : u32) -> * mut std_sync_RwLock_u32 { ferment :: boxed (std_sync_RwLock_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_u32_destroy (ffi : * mut std_sync_RwLock_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_36 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_from_const (ffi : * const Arr_u8_36) -> [u8 ; 36] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 36] > for Arr_u8_36 { unsafe fn ffi_to_const (obj : [u8 ; 36]) -> * const Arr_u8_36 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_36 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_36 { ferment :: boxed (Arr_u8_36 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_36_destroy (ffi : * mut Arr_u8_36) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > > for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID) -> std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID > > for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < dpp :: identity :: identity_public_key :: KeyID >) -> * const std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { ferment :: boxed (std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID_destroy (ffi : * mut std_collections_BTreeSet_dpp_identity_identity_public_key_KeyID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Option < String > > > for std_sync_Arc_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Option_String) -> std :: sync :: Arc < Option < String > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Option < String > > > for std_sync_Arc_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Option < String > >) -> * const std_sync_Arc_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_Arc_Option_String { ferment :: boxed (std_sync_Arc_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_String_destroy (ffi : * mut std_sync_Arc_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < String > > > for std_cell_RefCell_Option_String { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Option_String) -> std :: cell :: RefCell < Option < String > > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Option < String > > > for std_cell_RefCell_Option_String { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Option < String > >) -> * const std_cell_RefCell_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_cell_RefCell_Option_String { ferment :: boxed (std_cell_RefCell_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_String_destroy (ffi : * mut std_cell_RefCell_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_String { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < String , Option < String > > > for Result_ok_String_err_Option_String { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_String) -> Result < String , Option < String > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < String > > > for Result_ok_String_err_Option_String { unsafe fn ffi_to_const (obj : Result < String , Option < String > >) -> * const Result_ok_String_err_Option_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to_opt (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_String_err_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_Option_String { ferment :: boxed (Result_ok_String_err_Option_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_String_destroy (ffi : * mut Result_ok_String_err_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txin_TxIn { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txin_TxIn) -> Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txin :: TxIn > > for Vec_dashcore_blockdata_transaction_txin_TxIn { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txin :: TxIn >) -> * const Vec_dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txin_TxIn { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txin :: dashcore_blockdata_transaction_txin_TxIn) -> * mut Vec_dashcore_blockdata_transaction_txin_TxIn { ferment :: boxed (Vec_dashcore_blockdata_transaction_txin_TxIn { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txin_TxIn_destroy (ffi : * mut Vec_dashcore_blockdata_transaction_txin_TxIn) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < Vec < u32 > > for Vec_u32 { unsafe fn ffi_from_const (ffi : * const Vec_u32) -> Vec < u32 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u32 > > for Vec_u32 { unsafe fn ffi_to_const (obj : Vec < u32 >) -> * const Vec_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u32_ctor (count : usize , values : * mut u32) -> * mut Vec_u32 { ferment :: boxed (Vec_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u32_destroy (ffi : * mut Vec_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo > > for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: contender_structs :: FinalizedResourceVoteChoicesWithVoterInfo >) -> * const Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: voting :: contender_structs :: dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) -> * mut Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { ferment :: boxed (Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo_destroy (ffi : * mut Vec_dpp_voting_contender_structs_FinalizedResourceVoteChoicesWithVoterInfo) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Vec < u8 > > > for std_sync_RwLock_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Vec_u8) -> std :: sync :: RwLock < Vec < u8 > > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Vec < u8 > > > for std_sync_RwLock_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Vec < u8 > >) -> * const std_sync_RwLock_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_RwLock_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_RwLock_Vec_u8 { ferment :: boxed (std_sync_RwLock_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Vec_u8_destroy (ffi : * mut std_sync_RwLock_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_outpoint_OutPoint { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > > for Vec_dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_outpoint_OutPoint) -> Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint > > for Vec_dashcore_blockdata_transaction_outpoint_OutPoint { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: outpoint :: OutPoint >) -> * const Vec_dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dashcore_blockdata_transaction_outpoint_OutPoint { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_outpoint_OutPoint_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: outpoint :: dashcore_blockdata_transaction_outpoint_OutPoint) -> * mut Vec_dashcore_blockdata_transaction_outpoint_OutPoint { ferment :: boxed (Vec_dashcore_blockdata_transaction_outpoint_OutPoint { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_outpoint_OutPoint_destroy (ffi : * mut Vec_dashcore_blockdata_transaction_outpoint_OutPoint) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif , pub o_2 : * mut crate :: fermented :: generics :: Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_2)) } } impl < 'a > ferment :: FFIConversionTo < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32])) -> * const Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) , o_2 : ferment :: FFIConversionTo :: ffi_to (obj . 2) }) } } impl Drop for Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif , o_2 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_example_simple_nested_HashID { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > > for std_collections_Map_keys_String_values_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_example_simple_nested_HashID) -> std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID as ferment :: FFIConversionFrom < example_simple :: nested :: HashID >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_simple :: nested :: HashID > > for std_collections_Map_keys_String_values_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , example_simple :: nested :: HashID >) -> * const std_collections_Map_keys_String_values_example_simple_nested_HashID { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut std_collections_Map_keys_String_values_example_simple_nested_HashID { ferment :: boxed (std_collections_Map_keys_String_values_example_simple_nested_HashID { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_simple_nested_HashID_destroy (ffi : * mut std_collections_Map_keys_String_values_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Option_Vec_u8 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Result < String , Option < Vec < u8 > > > > for Result_ok_String_err_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Option_Vec_u8) -> Result < String , Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < String , Option < Vec < u8 > > > > for Result_ok_String_err_Option_Vec_u8 { unsafe fn ffi_to_const (obj : Result < String , Option < Vec < u8 > > >) -> * const Result_ok_String_err_Option_Vec_u8 { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to_opt (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_String_err_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Option_Vec_u8 { ferment :: boxed (Result_ok_String_err_Option_Vec_u8 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Option_Vec_u8_destroy (ffi : * mut Result_ok_String_err_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } impl FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32 , o_1 : [u8 ; 32]) -> Option < String > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } unsafe impl Send for FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { } unsafe impl Sync for FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { } # [no_mangle] pub unsafe extern "C" fn FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { ferment :: boxed (FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String_destroy (ffi : * mut FnMut_ARGS_u32_Arr_u8_32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_nested_gen_dict_CacheExample { pub obj : * mut example_nested :: gen :: dict :: CacheExample } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > > for std_sync_Arc_example_nested_gen_dict_CacheExample { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_nested_gen_dict_CacheExample) -> std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > { let ffi_ref = & * ffi ; std :: sync :: Arc :: from_raw (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample > > for std_sync_Arc_example_nested_gen_dict_CacheExample { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_nested :: gen :: dict :: CacheExample >) -> * const std_sync_Arc_example_nested_gen_dict_CacheExample { ferment :: boxed (Self { obj : std :: sync :: Arc :: into_raw (obj) . cast_mut () }) } } impl Drop for std_sync_Arc_example_nested_gen_dict_CacheExample { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_gen_dict_CacheExample_ctor (obj : * mut example_nested :: gen :: dict :: CacheExample) -> * mut std_sync_Arc_example_nested_gen_dict_CacheExample { ferment :: boxed (std_sync_Arc_example_nested_gen_dict_CacheExample { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_gen_dict_CacheExample_destroy (ffi : * mut std_sync_Arc_example_nested_gen_dict_CacheExample) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Vec_u8) -> Vec < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Vec < u8 > > > for Vec_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Vec < u8 > >) -> * const Vec_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Vec_u8 { ferment :: boxed (Vec_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Vec_u8_destroy (ffi : * mut Vec_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < std :: sync :: RwLock < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (std :: sync :: RwLock :: new (obj . read () . expect ("Poisoned") . clone ())) }) } } impl Drop for std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_std_sync_RwLock_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: platform_value :: platform_value_Value as ferment :: FFIConversionFrom < platform_value :: Value >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , platform_value :: Value >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_blockdata_transaction_txout_TxOut { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut } impl ferment :: FFIConversionFrom < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_blockdata_transaction_txout_TxOut) -> Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dashcore :: blockdata :: transaction :: txout :: TxOut > > for Vec_dashcore_blockdata_transaction_txout_TxOut { unsafe fn ffi_to_const (obj : Vec < dashcore :: blockdata :: transaction :: txout :: TxOut >) -> * const Vec_dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dashcore_blockdata_transaction_txout_TxOut { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: blockdata :: transaction :: txout :: dashcore_blockdata_transaction_txout_TxOut) -> * mut Vec_dashcore_blockdata_transaction_txout_TxOut { ferment :: boxed (Vec_dashcore_blockdata_transaction_txout_TxOut { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_blockdata_transaction_txout_TxOut_destroy (ffi : * mut Vec_dashcore_blockdata_transaction_txout_TxOut) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Vec < u8 > > > for std_sync_Mutex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Vec_u8) -> std :: sync :: Mutex < Vec < u8 > > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Vec < u8 > > > for std_sync_Mutex_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Vec < u8 > >) -> * const std_sync_Mutex_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_Mutex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_Mutex_Vec_u8 { ferment :: boxed (std_sync_Mutex_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Vec_u8_destroy (ffi : * mut std_sync_Mutex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 } impl ferment :: FFIConversionFrom < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_from_const (ffi : * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 > > for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { unsafe fn ffi_to_const (obj : Vec < dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: ContestedDocumentVotePollStoredInfoVoteEventV0 >) -> * const Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: voting :: vote_info_storage :: contested_document_vote_poll_stored_info :: v0 :: dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) -> * mut Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { ferment :: boxed (Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0_destroy (ffi : * mut Vec_dpp_voting_vote_info_storage_contested_document_vote_poll_stored_info_v0_ContestedDocumentVotePollStoredInfoVoteEventV0) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition , pub error : * mut crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: protocol_error :: ProtocolError > > for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError) -> Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition as ferment :: FFIConversionFrom < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < dpp :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: protocol_error :: ProtocolError > > for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: DataContractUpdateTransition , dpp :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: contract :: data_contract_update_transition :: dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition , error : * mut crate :: fermented :: types :: dpp :: errors :: protocol_error :: dpp_errors_protocol_error_ProtocolError) -> * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_dpp_state_transition_state_transitions_contract_data_contract_update_transition_DataContractUpdateTransition_err_dpp_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { pub o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , pub o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash } impl ferment :: FFIConversionFrom < (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash) > for Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { unsafe fn ffi_from_const (ffi : * const Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash) -> (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash) > for Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { unsafe fn ffi_to_const (obj : (dashcore :: hash_types :: BlockHash , dashcore :: hash_types :: BlockHash)) -> * const Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash_ctor (o_0 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash , o_1 : * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { ferment :: boxed (Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash_destroy (ffi : * mut Tuple_dashcore_hash_types_BlockHash_dashcore_hash_types_BlockHash) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { pub count : usize , pub keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: ProTxHash >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry as ferment :: FFIConversionFrom < dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry > > for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: ProTxHash , dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: QualifiedMasternodeListEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_ctor (count : usize , keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_ProTxHash , values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: masternode_list_entry :: qualified_masternode_list_entry :: dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) -> * mut std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { ferment :: boxed (std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_hash_types_ProTxHash_values_dashcore_sml_masternode_list_entry_qualified_masternode_list_entry_QualifiedMasternodeListEntry) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_Vec_u8 { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Result < String , Vec < u8 > > > for Result_ok_String_err_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_Vec_u8) -> Result < String , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < String , Vec < u8 > > > for Result_ok_String_err_Vec_u8 { unsafe fn ffi_to_const (obj : Result < String , Vec < u8 > >) -> * const Result_ok_String_err_Vec_u8 { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_String_err_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Result_ok_String_err_Vec_u8 { ferment :: boxed (Result_ok_String_err_Vec_u8 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_Vec_u8_destroy (ffi : * mut Result_ok_String_err_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { pub ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot > > for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot) -> Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot > > for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : Result < example_nested :: model :: snapshot :: LLMQSnapshot , example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot_ctor (ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_platform_value_types_identifier_Identifier_u8 { pub o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub o_1 : u8 } impl ferment :: FFIConversionFrom < (platform_value :: types :: identifier :: Identifier , u8) > for Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_platform_value_types_identifier_Identifier_u8) -> (platform_value :: types :: identifier :: Identifier , u8) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (platform_value :: types :: identifier :: Identifier , u8) > for Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : (platform_value :: types :: identifier :: Identifier , u8)) -> * const Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : obj . 1 }) } } impl Drop for Tuple_platform_value_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_types_identifier_Identifier_u8_ctor (o_0 : * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , o_1 : u8) -> * mut Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Tuple_platform_value_types_identifier_Identifier_u8 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_types_identifier_Identifier_u8_destroy (ffi : * mut Tuple_platform_value_types_identifier_Identifier_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_dashcore_bls_sig_utils_BLSSignature_4 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature } impl ferment :: FFIConversionFrom < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_from_const (ffi : * const Arr_dashcore_bls_sig_utils_BLSSignature_4) -> [dashcore :: bls_sig_utils :: BLSSignature ; 4] { let ffi_ref = & * ffi ; let vec : Vec < dashcore :: bls_sig_utils :: BLSSignature > = ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [dashcore :: bls_sig_utils :: BLSSignature ; 4] > for Arr_dashcore_bls_sig_utils_BLSSignature_4 { unsafe fn ffi_to_const (obj : [dashcore :: bls_sig_utils :: BLSSignature ; 4]) -> * const Arr_dashcore_bls_sig_utils_BLSSignature_4 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Arr_dashcore_bls_sig_utils_BLSSignature_4 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dashcore :: bls_sig_utils :: dashcore_bls_sig_utils_BLSSignature) -> * mut Arr_dashcore_bls_sig_utils_BLSSignature_4 { ferment :: boxed (Arr_dashcore_bls_sig_utils_BLSSignature_4 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_dashcore_bls_sig_utils_BLSSignature_4_destroy (ffi : * mut Arr_dashcore_bls_sig_utils_BLSSignature_4) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_Vec_u8_values_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > > for std_collections_Map_keys_Vec_u8_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_Vec_u8_values_Vec_u8) -> std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > > > for std_collections_Map_keys_Vec_u8_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < Vec < u8 > , Vec < u8 > >) -> * const std_collections_Map_keys_Vec_u8_values_Vec_u8 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_Vec_u8_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_Vec_u8_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_Vec_u8_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Vec_u8_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_Vec_u8_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut u64 , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u64 , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_ctor (count : usize , keys : * mut u64 , values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { ferment :: boxed (std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount_destroy (ffi : * mut std_collections_Map_keys_u64_values_dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Arr_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_u32_RTRN_Arr_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> [u8 ; 32] { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_Arr_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Arr_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Arr_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Arr_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Arr_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_example_nested_model_Quorum_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum } impl ferment :: FFIConversionFrom < [example_nested :: model :: Quorum ; 32] > for Arr_example_nested_model_Quorum_32 { unsafe fn ffi_from_const (ffi : * const Arr_example_nested_model_Quorum_32) -> [example_nested :: model :: Quorum ; 32] { let ffi_ref = & * ffi ; let vec : Vec < example_nested :: model :: Quorum > = ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [example_nested :: model :: Quorum ; 32] > for Arr_example_nested_model_Quorum_32 { unsafe fn ffi_to_const (obj : [example_nested :: model :: Quorum ; 32]) -> * const Arr_example_nested_model_Quorum_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Arr_example_nested_model_Quorum_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: example_nested_model_Quorum) -> * mut Arr_example_nested_model_Quorum_32 { ferment :: boxed (Arr_example_nested_model_Quorum_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_example_nested_model_Quorum_32_destroy (ffi : * mut Arr_example_nested_model_Quorum_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < Vec < u8 > > > > for std_collections_HashSet_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_Vec_u8) -> std :: collections :: HashSet < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < Vec < u8 > > > > for std_collections_HashSet_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < Vec < u8 > > >) -> * const std_collections_HashSet_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_HashSet_Option_Vec_u8 { ferment :: boxed (std_collections_HashSet_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_Vec_u8_destroy (ffi : * mut std_collections_HashSet_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_platform_value_Value_platform_value_Value { pub o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , pub o_1 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Tuple_platform_value_Value_platform_value_Value) -> (platform_value :: Value , platform_value :: Value) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (platform_value :: Value , platform_value :: Value) > for Tuple_platform_value_Value_platform_value_Value { unsafe fn ffi_to_const (obj : (platform_value :: Value , platform_value :: Value)) -> * const Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_platform_value_Value_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_Value_platform_value_Value_ctor (o_0 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value , o_1 : * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut Tuple_platform_value_Value_platform_value_Value { ferment :: boxed (Tuple_platform_value_Value_platform_value_Value { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_platform_value_Value_platform_value_Value_destroy (ffi : * mut Tuple_platform_value_Value_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) -> std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName as ferment :: FFIConversionFrom < dpp :: data_contract :: DocumentName >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: DocumentType >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType > > for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: DocumentName , dpp :: data_contract :: document_type :: DocumentType >) -> * const std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_DocumentName , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: dpp_data_contract_document_type_DocumentType) -> * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_DocumentName_values_dpp_data_contract_document_type_DocumentType) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_platform_value_Value { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value } impl ferment :: FFIConversionFrom < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_from_const (ffi : * const Vec_platform_value_Value) -> Vec < platform_value :: Value > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < platform_value :: Value > > for Vec_platform_value_Value { unsafe fn ffi_to_const (obj : Vec < platform_value :: Value >) -> * const Vec_platform_value_Value { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_platform_value_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: platform_value :: platform_value_Value) -> * mut Vec_platform_value_Value { ferment :: boxed (Vec_platform_value_Value { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_platform_value_Value_destroy (ffi : * mut Vec_platform_value_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) -> Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < example_nested :: model :: snapshot :: LLMQSnapshot , Option < example_simple :: errors :: protocol_error :: ProtocolError > >) -> * const Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to_opt (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_example_nested_model_snapshot_LLMQSnapshot_err_Option_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_String { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < (String , String) > for Tuple_String_String { unsafe fn ffi_from_const (ffi : * const Tuple_String_String) -> (String , String) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , String) > for Tuple_String_String { unsafe fn ffi_to_const (obj : (String , String)) -> * const Tuple_String_String { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_String_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut std :: os :: raw :: c_char) -> * mut Tuple_String_String { ferment :: boxed (Tuple_String_String { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_String_destroy (ffi : * mut Tuple_String_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_Arr_u8_32 { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Tuple_String_Arr_u8_32) -> (String , [u8 ; 32]) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , [u8 ; 32]) > for Tuple_String_Arr_u8_32 { unsafe fn ffi_to_const (obj : (String , [u8 ; 32])) -> * const Tuple_String_Arr_u8_32 { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Arr_u8_32_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Tuple_String_Arr_u8_32 { ferment :: boxed (Tuple_String_Arr_u8_32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Arr_u8_32_destroy (ffi : * mut Tuple_String_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { pub o_0 : u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , pub o_2 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot) -> (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1) , ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >) > for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : (u32 , example_simple :: nested :: HashID , Option < example_nested :: model :: snapshot :: LLMQSnapshot >)) -> * const Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) , o_2 : ferment :: FFIConversionTo :: ffi_to_opt (obj . 2) }) } } impl Drop for Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any_opt (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot_ctor (o_0 : u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID , o_2 : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut Tuple_u32_example_simple_nested_HashID_Option_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < Vec < u8 > > > > for std_collections_BTreeSet_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_Vec_u8) -> std :: collections :: BTreeSet < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < Vec < u8 > > > > for std_collections_BTreeSet_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < Vec < u8 > > >) -> * const std_collections_BTreeSet_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_BTreeSet_Option_Vec_u8 { ferment :: boxed (std_collections_BTreeSet_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_Vec_u8_destroy (ffi : * mut std_collections_BTreeSet_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char) } impl Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { pub unsafe fn call (& self , o_0 : u32 , o_1 : [u8 ; 32]) -> Option < String > { let ffi_result = (self . caller) (o_0 , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; if ffi_result . is_null () { None } else { let result = < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } } unsafe impl Send for Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { } unsafe impl Sync for Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String_ctor (caller : unsafe extern "C" fn (u32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut std :: os :: raw :: c_char , destructor : unsafe extern "C" fn (* mut std :: os :: raw :: c_char)) -> * mut Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { ferment :: boxed (Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String_destroy (ffi : * mut Fn_ARGS_u32_Arr_u8_32_RTRN_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot) -> std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: rc :: Rc < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_rc_Rc_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_Vec_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > > for std_collections_Map_keys_u32_values_Option_Vec_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_Vec_String) -> std :: collections :: BTreeMap < u32 , Option < Vec < String > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_String as ferment :: FFIConversionFrom < Vec < String > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < Vec < String > > > > for std_collections_Map_keys_u32_values_Option_Vec_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < Vec < String > > >) -> * const std_collections_Map_keys_u32_values_Option_Vec_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_opt_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_Option_Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_String) -> * mut std_collections_Map_keys_u32_values_Option_Vec_String { ferment :: boxed (std_collections_Map_keys_u32_values_Option_Vec_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_Vec_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_Vec_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_bool { pub count : usize , pub values : * mut bool } impl ferment :: FFIConversionFrom < Vec < bool > > for Vec_bool { unsafe fn ffi_from_const (ffi : * const Vec_bool) -> Vec < bool > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < bool > > for Vec_bool { unsafe fn ffi_to_const (obj : Vec < bool >) -> * const Vec_bool { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_bool { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_bool_ctor (count : usize , values : * mut bool) -> * mut Vec_bool { ferment :: boxed (Vec_bool { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_bool_destroy (ffi : * mut Vec_bool) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) } impl Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub unsafe fn call (& self , o_0 : [u8 ; 32] , o_1 : [u8 ; 32]) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0) , < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_1)) ; let result = < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32 , * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError)) -> * mut Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_Arr_u8_32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Vec < u8 > > > for std_cell_RefCell_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Vec_u8) -> std :: cell :: RefCell < Vec < u8 > > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Vec < u8 > > > for std_cell_RefCell_Vec_u8 { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Vec < u8 > >) -> * const std_cell_RefCell_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_cell_RefCell_Vec_u8 { ferment :: boxed (std_cell_RefCell_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Vec_u8_destroy (ffi : * mut std_cell_RefCell_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to_opt (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: generics :: std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < Option < String > > > for Vec_Option_String { unsafe fn ffi_from_const (ffi : * const Vec_Option_String) -> Vec < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Option < String > > > for Vec_Option_String { unsafe fn ffi_to_const (obj : Vec < Option < String > >) -> * const Vec_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Vec_Option_String { ferment :: boxed (Vec_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_String_destroy (ffi : * mut Vec_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > > for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_security_level_SecurityLevel) -> Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel > > for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: security_level :: SecurityLevel >) -> * const Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_security_level_SecurityLevel_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: security_level :: dpp_identity_identity_public_key_security_level_SecurityLevel) -> * mut Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { ferment :: boxed (Vec_dpp_identity_identity_public_key_security_level_SecurityLevel { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_security_level_SecurityLevel_destroy (ffi : * mut Vec_dpp_identity_identity_public_key_security_level_SecurityLevel) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: document :: dpp_document_Document as ferment :: FFIConversionFrom < dpp :: document :: Document >> :: ffi_from_opt (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , Option < dpp :: document :: Document > >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_opt_complex_group (obj . values () . cloned ()) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: document :: dpp_document_Document) -> * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { ferment :: boxed (std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document { count , keys , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document_destroy (ffi : * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_Option_dpp_document_Document) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Vec < u8 > > > for std_sync_Arc_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Vec_u8) -> std :: sync :: Arc < Vec < u8 > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Vec < u8 > > > for std_sync_Arc_Vec_u8 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Vec < u8 > >) -> * const std_sync_Arc_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_sync_Arc_Vec_u8 { ferment :: boxed (std_sync_Arc_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Vec_u8_destroy (ffi : * mut std_sync_Arc_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : [u8 ; 32]) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (< crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionTo < [u8 ; 32] >> :: ffi_to (o_0)) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_Arr_u8_32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Vec < String > > for Vec_String { unsafe fn ffi_from_const (ffi : * const Vec_String) -> Vec < String > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < String > > for Vec_String { unsafe fn ffi_to_const (obj : Vec < String >) -> * const Vec_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Vec_String { ferment :: boxed (Vec_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_String_destroy (ffi : * mut Vec_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: GroupMemberPower >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: data_contract :: group :: GroupMemberPower >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_GroupMemberPower) -> * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { ferment :: boxed (std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower_destroy (ffi : * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_data_contract_group_GroupMemberPower) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel) } impl Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { pub unsafe fn call (& self , o_0 : u32) -> example_nested :: entry :: SomeModel { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel as ferment :: FFIConversionFrom < example_nested :: entry :: SomeModel >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { } unsafe impl Sync for Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel , destructor : unsafe extern "C" fn (* mut crate :: fermented :: types :: example_nested :: entry :: example_nested_entry_SomeModel)) -> * mut Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { ferment :: boxed (Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel_destroy (ffi : * mut Fn_ARGS_u32_RTRN_example_nested_entry_SomeModel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) -> std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: GroupContractPosition >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group as ferment :: FFIConversionFrom < dpp :: data_contract :: group :: Group >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group > > for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: GroupContractPosition , dpp :: data_contract :: group :: Group >) -> * const std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_GroupContractPosition , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: group :: dpp_data_contract_group_Group) -> * mut std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_GroupContractPosition_values_dpp_data_contract_group_Group) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut u32 , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: destroy_opt_primitive (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut u32 , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_u32 { pub count : usize , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < u32 > > for std_collections_HashSet_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_u32) -> std :: collections :: HashSet < u32 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < u32 > > for std_collections_HashSet_u32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < u32 >) -> * const std_collections_HashSet_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_ctor (count : usize , values : * mut u32) -> * mut std_collections_HashSet_u32 { ferment :: boxed (std_collections_HashSet_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_u32_destroy (ffi : * mut std_collections_HashSet_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_purpose_Purpose { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > > for Vec_dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_purpose_Purpose) -> Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose > > for Vec_dpp_identity_identity_public_key_purpose_Purpose { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: purpose :: Purpose >) -> * const Vec_dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_identity_identity_public_key_purpose_Purpose { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_purpose_Purpose_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: purpose :: dpp_identity_identity_public_key_purpose_Purpose) -> * mut Vec_dpp_identity_identity_public_key_purpose_Purpose { ferment :: boxed (Vec_dpp_identity_identity_public_key_purpose_Purpose { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_purpose_Purpose_destroy (ffi : * mut Vec_dpp_identity_identity_public_key_purpose_Purpose) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty } impl ferment :: FFIConversionFrom < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_from_const (ffi : * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) -> indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: property :: DocumentProperty >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty > > for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { unsafe fn ffi_to_const (obj : indexmap :: IndexMap < String , dpp :: data_contract :: document_type :: property :: DocumentProperty >) -> * const indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: dpp_data_contract_document_type_property_DocumentProperty) -> * mut indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { ferment :: boxed (indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty_destroy (ffi : * mut indexmap_IndexMap_String_dpp_data_contract_document_type_property_DocumentProperty) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_platform_value_types_identifier_Identifier_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_types_identifier_Identifier_u8 } impl ferment :: FFIConversionFrom < Vec < (platform_value :: types :: identifier :: Identifier , u8) > > for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_platform_value_types_identifier_Identifier_u8) -> Vec < (platform_value :: types :: identifier :: Identifier , u8) > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < (platform_value :: types :: identifier :: Identifier , u8) > > for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { unsafe fn ffi_to_const (obj : Vec < (platform_value :: types :: identifier :: Identifier , u8) >) -> * const Vec_Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Tuple_platform_value_types_identifier_Identifier_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_types_identifier_Identifier_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_platform_value_types_identifier_Identifier_u8) -> * mut Vec_Tuple_platform_value_types_identifier_Identifier_u8 { ferment :: boxed (Vec_Tuple_platform_value_types_identifier_Identifier_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_platform_value_types_identifier_Identifier_u8_destroy (ffi : * mut Vec_Tuple_platform_value_types_identifier_Identifier_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_String_Vec_String { pub o_0 : * mut std :: os :: raw :: c_char , pub o_1 : * mut crate :: fermented :: generics :: Vec_String } impl ferment :: FFIConversionFrom < (String , Vec < String >) > for Tuple_String_Vec_String { unsafe fn ffi_from_const (ffi : * const Tuple_String_Vec_String) -> (String , Vec < String >) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (String , Vec < String >) > for Tuple_String_Vec_String { unsafe fn ffi_to_const (obj : (String , Vec < String >)) -> * const Tuple_String_Vec_String { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_String_Vec_String { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Vec_String_ctor (o_0 : * mut std :: os :: raw :: c_char , o_1 : * mut crate :: fermented :: generics :: Vec_String) -> * mut Tuple_String_Vec_String { ferment :: boxed (Tuple_String_Vec_String { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_String_Vec_String_destroy (ffi : * mut Tuple_String_Vec_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Mutex_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_example_simple_nested_HashID { pub o_0 : u32 , pub o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID } impl ferment :: FFIConversionFrom < (u32 , example_simple :: nested :: HashID) > for Tuple_u32_example_simple_nested_HashID { unsafe fn ffi_from_const (ffi : * const Tuple_u32_example_simple_nested_HashID) -> (u32 , example_simple :: nested :: HashID) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (u32 , example_simple :: nested :: HashID) > for Tuple_u32_example_simple_nested_HashID { unsafe fn ffi_to_const (obj : (u32 , example_simple :: nested :: HashID)) -> * const Tuple_u32_example_simple_nested_HashID { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_u32_example_simple_nested_HashID { fn drop (& mut self) { unsafe { ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_ctor (o_0 : u32 , o_1 : * mut crate :: fermented :: types :: example_simple :: nested :: example_simple_nested_HashID) -> * mut Tuple_u32_example_simple_nested_HashID { ferment :: boxed (Tuple_u32_example_simple_nested_HashID { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_example_simple_nested_HashID_destroy (ffi : * mut Tuple_u32_example_simple_nested_HashID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_versioned_feature_core_FeatureVersion { pub count : usize , pub values : * mut * mut example_nested :: versioned_feature_core_FeatureVersion } impl ferment :: FFIConversionFrom < Vec < versioned_feature_core :: FeatureVersion > > for Vec_versioned_feature_core_FeatureVersion { unsafe fn ffi_from_const (ffi : * const Vec_versioned_feature_core_FeatureVersion) -> Vec < versioned_feature_core :: FeatureVersion > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < versioned_feature_core :: FeatureVersion > > for Vec_versioned_feature_core_FeatureVersion { unsafe fn ffi_to_const (obj : Vec < versioned_feature_core :: FeatureVersion >) -> * const Vec_versioned_feature_core_FeatureVersion { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_versioned_feature_core_FeatureVersion { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_versioned_feature_core_FeatureVersion_ctor (count : usize , values : * mut * mut example_nested :: versioned_feature_core_FeatureVersion) -> * mut Vec_versioned_feature_core_FeatureVersion { ferment :: boxed (Vec_versioned_feature_core_FeatureVersion { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_versioned_feature_core_FeatureVersion_destroy (ffi : * mut Vec_versioned_feature_core_FeatureVersion) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_2 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_from_const (ffi : * const Arr_u8_2) -> [u8 ; 2] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 2] > for Arr_u8_2 { unsafe fn ffi_to_const (obj : [u8 ; 2]) -> * const Arr_u8_2 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_2 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_2 { ferment :: boxed (Arr_u8_2 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_2_destroy (ffi : * mut Arr_u8_2) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , pub values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) -> std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier as ferment :: FFIConversionFrom < platform_value :: types :: identifier :: Identifier >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount as ferment :: FFIConversionFrom < dpp :: balances :: credits :: TokenAmount >> :: ffi_from (o)) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount > > for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < platform_value :: types :: identifier :: Identifier , dpp :: balances :: credits :: TokenAmount >) -> * const std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: platform_value :: types :: identifier :: platform_value_types_identifier_Identifier , values : * mut * mut crate :: fermented :: types :: dpp :: balances :: credits :: dpp_balances_credits_TokenAmount) -> * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { ferment :: boxed (std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount { count , keys , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount_destroy (ffi : * mut std_collections_Map_keys_platform_value_types_identifier_Identifier_values_dpp_balances_credits_TokenAmount) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Mutex_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) -> std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > > > for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < example_simple :: errors :: protocol_error :: ProtocolError > >) -> * const std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut std_collections_HashSet_Option_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot) -> std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_cell_RefCell_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_std_time_Duration { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut example_simple :: std_time_Duration } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , std :: time :: Duration > > for std_collections_Map_keys_String_values_std_time_Duration { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_std_time_Duration) -> std :: collections :: BTreeMap < String , std :: time :: Duration > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < example_simple :: std_time_Duration as ferment :: FFIConversionFrom < std :: time :: Duration >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , std :: time :: Duration > > for std_collections_Map_keys_String_values_std_time_Duration { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , std :: time :: Duration >) -> * const std_collections_Map_keys_String_values_std_time_Duration { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_std_time_Duration { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut example_simple :: std_time_Duration) -> * mut std_collections_Map_keys_String_values_std_time_Duration { ferment :: boxed (std_collections_Map_keys_String_values_std_time_Duration { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_std_time_Duration_destroy (ffi : * mut std_collections_Map_keys_String_values_std_time_Duration) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Vec_u8 { pub obj : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Vec < u8 > > > for std_rc_Rc_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Vec_u8) -> std :: rc :: Rc < Vec < u8 > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Vec < u8 > > > for std_rc_Rc_Vec_u8 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Vec < u8 > >) -> * const std_rc_Rc_Vec_u8 { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Vec_u8_ctor (obj : * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_rc_Rc_Vec_u8 { ferment :: boxed (std_rc_Rc_Vec_u8 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Vec_u8_destroy (ffi : * mut std_rc_Rc_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif } impl < 'a > ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > > for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) -> std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif as ferment :: FFIConversionFrom < example_nested :: ExampleEnumLif < 'a > >> :: ffi_from (o)) } } impl < 'a > ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > > > for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , example_nested :: ExampleEnumLif < 'a > >) -> * const std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) -> * mut std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { ferment :: boxed (std_collections_Map_keys_String_values_example_nested_ExampleEnumLif { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_example_nested_ExampleEnumLif_destroy (ffi : * mut std_collections_Map_keys_String_values_example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: DocumentTransition >) -> * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: document_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) -> * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { ferment :: boxed (Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition { count , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition_destroy (ffi : * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_document_transition_DocumentTransition) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_index_IndexProperty { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_index_IndexProperty) -> Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: index :: IndexProperty > > for Vec_dpp_data_contract_document_type_index_IndexProperty { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: index :: IndexProperty >) -> * const Vec_dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_data_contract_document_type_index_IndexProperty { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_IndexProperty) -> * mut Vec_dpp_data_contract_document_type_index_IndexProperty { ferment :: boxed (Vec_dpp_data_contract_document_type_index_IndexProperty { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_index_IndexProperty_destroy (ffi : * mut Vec_dpp_data_contract_document_type_index_IndexProperty) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Vec_u8 { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Vec < u8 > > > for std_collections_Map_keys_u32_values_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Vec_u8) -> std :: collections :: BTreeMap < u32 , Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Vec < u8 > > > for std_collections_Map_keys_u32_values_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Vec < u8 > >) -> * const std_collections_Map_keys_u32_values_Vec_u8 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_u32_values_Vec_u8 { ferment :: boxed (std_collections_Map_keys_u32_values_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_u32_values_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) } impl Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { pub unsafe fn call (& self , o_0 : u32) -> Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < Result < u32 , example_simple :: errors :: protocol_error :: ProtocolError > >> :: ffi_from (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError)) -> * mut Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Result_ok_u32_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization > > for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: associated_token :: token_configuration_localization :: TokenConfigurationLocalization >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: associated_token :: token_configuration_localization :: dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_associated_token_token_configuration_localization_TokenConfigurationLocalization) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_std_time_Duration_std_time_Duration { pub o_0 : * mut example_simple :: std_time_Duration , pub o_1 : * mut example_simple :: std_time_Duration } impl ferment :: FFIConversionFrom < (std :: time :: Duration , std :: time :: Duration) > for Tuple_std_time_Duration_std_time_Duration { unsafe fn ffi_from_const (ffi : * const Tuple_std_time_Duration_std_time_Duration) -> (std :: time :: Duration , std :: time :: Duration) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1)) } } impl ferment :: FFIConversionTo < (std :: time :: Duration , std :: time :: Duration) > for Tuple_std_time_Duration_std_time_Duration { unsafe fn ffi_to_const (obj : (std :: time :: Duration , std :: time :: Duration)) -> * const Tuple_std_time_Duration_std_time_Duration { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) }) } } impl Drop for Tuple_std_time_Duration_std_time_Duration { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_std_time_Duration_std_time_Duration_ctor (o_0 : * mut example_simple :: std_time_Duration , o_1 : * mut example_simple :: std_time_Duration) -> * mut Tuple_std_time_Duration_std_time_Duration { ferment :: boxed (Tuple_std_time_Duration_std_time_Duration { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_std_time_Duration_std_time_Duration_destroy (ffi : * mut Tuple_std_time_Duration_std_time_Duration) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct indexmap_IndexSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < indexmap :: IndexSet < String > > for indexmap_IndexSet_String { unsafe fn ffi_from_const (ffi : * const indexmap_IndexSet_String) -> indexmap :: IndexSet < String > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < indexmap :: IndexSet < String > > for indexmap_IndexSet_String { unsafe fn ffi_to_const (obj : indexmap :: IndexSet < String >) -> * const indexmap_IndexSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for indexmap_IndexSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut indexmap_IndexSet_String { ferment :: boxed (indexmap_IndexSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn indexmap_IndexSet_String_destroy (ffi : * mut indexmap_IndexSet_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) -> (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >) > for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: SenderKeyIndex , dpp :: prelude :: RecipientKeyIndex , Vec < u8 >)) -> * const Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) , o_2 : ferment :: FFIConversionTo :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8_ctor (o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_SenderKeyIndex , o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RecipientKeyIndex , o_2 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { ferment :: boxed (Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8_destroy (ffi : * mut Tuple_dpp_prelude_SenderKeyIndex_dpp_prelude_RecipientKeyIndex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > > for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 as ferment :: FFIConversionFrom < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > >> :: ffi_from (o)) } } impl < 'a > ferment :: FFIConversionTo < std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > > for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : std :: collections :: HashMap < String , Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > >) -> * const std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: generics :: Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> * mut std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut std_collections_Map_keys_String_values_Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: Index >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: Index >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_Index) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_Index) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_example_nested_ExampleEnumLif { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif } impl < 'a > ferment :: FFIConversionFrom < Vec < example_nested :: ExampleEnumLif < 'a > > > for Vec_example_nested_ExampleEnumLif { unsafe fn ffi_from_const (ffi : * const Vec_example_nested_ExampleEnumLif) -> Vec < example_nested :: ExampleEnumLif < 'a > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl < 'a > ferment :: FFIConversionTo < Vec < example_nested :: ExampleEnumLif < 'a > > > for Vec_example_nested_ExampleEnumLif { unsafe fn ffi_to_const (obj : Vec < example_nested :: ExampleEnumLif < 'a > >) -> * const Vec_example_nested_ExampleEnumLif { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_example_nested_ExampleEnumLif { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: example_nested_ExampleEnumLif) -> * mut Vec_example_nested_ExampleEnumLif { ferment :: boxed (Vec_example_nested_ExampleEnumLif { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_ExampleEnumLif_destroy (ffi : * mut Vec_example_nested_ExampleEnumLif) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Option < String > > > for std_collections_BTreeSet_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Option_String) -> std :: collections :: BTreeSet < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Option < String > > > for std_collections_BTreeSet_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Option < String > >) -> * const std_collections_BTreeSet_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_BTreeSet_Option_String { ferment :: boxed (std_collections_BTreeSet_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Option_String_destroy (ffi : * mut std_collections_BTreeSet_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_data_contract_document_type_property_array_ArrayItemType { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType } impl ferment :: FFIConversionFrom < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_from_const (ffi : * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType) -> Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType > > for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { unsafe fn ffi_to_const (obj : Vec < dpp :: data_contract :: document_type :: property :: array :: ArrayItemType >) -> * const Vec_dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_data_contract_document_type_property_array_ArrayItemType { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: property :: array :: dpp_data_contract_document_type_property_array_ArrayItemType) -> * mut Vec_dpp_data_contract_document_type_property_array_ArrayItemType { ferment :: boxed (Vec_dpp_data_contract_document_type_property_array_ArrayItemType { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_data_contract_document_type_property_array_ArrayItemType_destroy (ffi : * mut Vec_dpp_data_contract_document_type_property_array_ArrayItemType) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index_level :: IndexLevel >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index_level :: IndexLevel >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index_level :: dpp_data_contract_document_type_index_level_IndexLevel) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_level_IndexLevel) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Arc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Arc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , pub values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash as ferment :: FFIConversionFrom < dashcore :: hash_types :: QuorumHash >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry >) -> * const std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor (count : usize , keys : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_QuorumHash , values : * mut * mut crate :: fermented :: types :: dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > >> :: ffi_from_opt (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to_opt (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: generics :: Vec_example_nested_model_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_Vec_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_u32_err_u32 { pub ok : * mut u32 , pub error : * mut u32 } impl ferment :: FFIConversionFrom < Result < u32 , u32 > > for Result_ok_u32_err_u32 { unsafe fn ffi_from_const (ffi : * const Result_ok_u32_err_u32) -> Result < u32 , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | * o , ffi_ref . error , | o | * o) } } impl ferment :: FFIConversionTo < Result < u32 , u32 > > for Result_ok_u32_err_u32 { unsafe fn ffi_to_const (obj : Result < u32 , u32 >) -> * const Result_ok_u32_err_u32 { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: boxed (o) , | o | ferment :: boxed (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_u32_err_u32 { fn drop (& mut self) { unsafe { ferment :: destroy_opt_primitive (self . ok) ; ferment :: destroy_opt_primitive (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_ctor (ok : * mut u32 , error : * mut u32) -> * mut Result_ok_u32_err_u32 { ferment :: boxed (Result_ok_u32_err_u32 { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_u32_err_u32_destroy (ffi : * mut Result_ok_u32_err_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_32 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Arr_u8_32) -> [u8 ; 32] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 32] > for Arr_u8_32 { unsafe fn ffi_to_const (obj : [u8 ; 32]) -> * const Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_32 { ferment :: boxed (Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_32_destroy (ffi : * mut Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_Option_String { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , Option < String > > > for std_collections_Map_keys_u32_values_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_Option_String) -> std :: collections :: BTreeMap < u32 , Option < String > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , Option < String > > > for std_collections_Map_keys_u32_values_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , Option < String > >) -> * const std_collections_Map_keys_u32_values_Option_String { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_opt_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_ctor (count : usize , keys : * mut u32 , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_Map_keys_u32_values_Option_String { ferment :: boxed (std_collections_Map_keys_u32_values_Option_String { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_Option_String_destroy (ffi : * mut std_collections_Map_keys_u32_values_Option_String) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition > > for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: BatchedTransition >) -> * const Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: document :: batch_transition :: batched_transition :: dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) -> * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { ferment :: boxed (Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition { count , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition_destroy (ffi : * mut Vec_dpp_state_transition_state_transitions_document_batch_transition_batched_transition_BatchedTransition) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < String > > > for std_sync_Mutex_Option_String { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Option_String) -> std :: sync :: Mutex < Option < String > > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Option < String > > > for std_sync_Mutex_Option_String { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Option < String > >) -> * const std_sync_Mutex_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_Mutex_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_sync_Mutex_Option_String { ferment :: boxed (std_sync_Mutex_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_String_destroy (ffi : * mut std_sync_Mutex_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { pub count : usize , pub keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > > for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) -> std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o) , | o | < crate :: fermented :: generics :: Vec_u8 as ferment :: FFIConversionFrom < Vec < u8 > >> :: ffi_from_opt (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > > > for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < Option < Vec < u8 > > , Option < Vec < u8 > > >) -> * const std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_opt_complex_group (obj . keys () . cloned ()) , values : ferment :: to_opt_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_ctor (count : usize , keys : * mut * mut crate :: fermented :: generics :: Vec_u8 , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { ferment :: boxed (std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8_destroy (ffi : * mut std_collections_Map_keys_Option_Vec_u8_values_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Arc_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: sync :: Arc < u32 > > for std_sync_Arc_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Arc_u32) -> std :: sync :: Arc < u32 > { let ffi_ref = & * ffi ; std :: sync :: Arc :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Arc < u32 > > for std_sync_Arc_u32 { unsafe fn ffi_to_const (obj : std :: sync :: Arc < u32 >) -> * const std_sync_Arc_u32 { ferment :: boxed (Self { obj : * obj }) } } impl Drop for std_sync_Arc_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_u32_ctor (obj : u32) -> * mut std_sync_Arc_u32 { ferment :: boxed (std_sync_Arc_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Arc_u32_destroy (ffi : * mut std_sync_Arc_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_String) -> std :: collections :: BTreeSet < String > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < String > > for std_collections_BTreeSet_String { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < String >) -> * const std_collections_BTreeSet_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_BTreeSet_String { ferment :: boxed (std_collections_BTreeSet_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_String_destroy (ffi : * mut std_collections_BTreeSet_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_RwLock_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dashcore_hash_types_BlockHash { pub count : usize , pub values : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash } impl ferment :: FFIConversionFrom < Vec < dashcore :: hash_types :: BlockHash > > for Vec_dashcore_hash_types_BlockHash { unsafe fn ffi_from_const (ffi : * const Vec_dashcore_hash_types_BlockHash) -> Vec < dashcore :: hash_types :: BlockHash > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dashcore :: hash_types :: BlockHash > > for Vec_dashcore_hash_types_BlockHash { unsafe fn ffi_to_const (obj : Vec < dashcore :: hash_types :: BlockHash >) -> * const Vec_dashcore_hash_types_BlockHash { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dashcore_hash_types_BlockHash { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_hash_types_BlockHash_ctor (count : usize , values : * mut * mut example_nested :: custom :: dashcore :: dashcore_hash_types_BlockHash) -> * mut Vec_dashcore_hash_types_BlockHash { ferment :: boxed (Vec_dashcore_hash_types_BlockHash { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dashcore_hash_types_BlockHash_destroy (ffi : * mut Vec_dashcore_hash_types_BlockHash) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < u32 > > > for std_collections_HashSet_Option_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_u32) -> std :: collections :: HashSet < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_opt_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < u32 > > > for std_collections_HashSet_Option_u32 { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < u32 > >) -> * const std_collections_HashSet_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_primitive_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut std_collections_HashSet_Option_u32 { ferment :: boxed (std_collections_HashSet_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_u32_destroy (ffi : * mut std_collections_HashSet_Option_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_BTreeSet_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeSet < Vec < u8 > > > for std_collections_BTreeSet_Vec_u8 { unsafe fn ffi_from_const (ffi : * const std_collections_BTreeSet_Vec_u8) -> std :: collections :: BTreeSet < Vec < u8 > > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeSet < Vec < u8 > > > for std_collections_BTreeSet_Vec_u8 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeSet < Vec < u8 > >) -> * const std_collections_BTreeSet_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_BTreeSet_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut std_collections_BTreeSet_Vec_u8 { ferment :: boxed (std_collections_BTreeSet_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_BTreeSet_Vec_u8_destroy (ffi : * mut std_collections_BTreeSet_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_example_nested_model_snapshot_LLMQSnapshot { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > for Vec_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const Vec_example_nested_model_snapshot_LLMQSnapshot) -> Vec < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < example_nested :: model :: snapshot :: LLMQSnapshot > > for Vec_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : Vec < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const Vec_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshot_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut Vec_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Vec_example_nested_model_snapshot_LLMQSnapshot { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut Vec_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_errors_consensus_consensus_error_ConsensusError { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError } impl ferment :: FFIConversionFrom < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > > for Vec_dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_from_const (ffi : * const Vec_dpp_errors_consensus_consensus_error_ConsensusError) -> Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError > > for Vec_dpp_errors_consensus_consensus_error_ConsensusError { unsafe fn ffi_to_const (obj : Vec < dpp :: errors :: consensus :: consensus_error :: ConsensusError >) -> * const Vec_dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_errors_consensus_consensus_error_ConsensusError { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_errors_consensus_consensus_error_ConsensusError_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: errors :: consensus :: consensus_error :: dpp_errors_consensus_consensus_error_ConsensusError) -> * mut Vec_dpp_errors_consensus_consensus_error_ConsensusError { ferment :: boxed (Vec_dpp_errors_consensus_consensus_error_ConsensusError { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_errors_consensus_consensus_error_ConsensusError_destroy (ffi : * mut Vec_dpp_errors_consensus_consensus_error_ConsensusError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_i32 { pub count : usize , pub values : * mut i32 } impl ferment :: FFIConversionFrom < Vec < i32 > > for Vec_i32 { unsafe fn ffi_from_const (ffi : * const Vec_i32) -> Vec < i32 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < i32 > > for Vec_i32 { unsafe fn ffi_to_const (obj : Vec < i32 >) -> * const Vec_i32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_i32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_i32_ctor (count : usize , values : * mut i32) -> * mut Vec_i32 { ferment :: boxed (Vec_i32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_i32_destroy (ffi : * mut Vec_i32) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "state-transitions")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "state-transitions")))] pub struct Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionFrom < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > > for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_from_const (ffi : * const Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl ferment :: FFIConversionTo < Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation > > for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { unsafe fn ffi_to_const (obj : Vec < dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: IdentityPublicKeyInCreation >) -> * const Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } # [cfg (any (any (feature = "state-transitions")))] # [cfg (any (any (feature = "state-transitions")))] impl Drop for Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: state_transition :: state_transitions :: identity :: public_key_in_creation :: dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) -> * mut Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { ferment :: boxed (Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation { count , values }) } # [cfg (any (any (feature = "state-transitions")))] # [no_mangle] pub unsafe extern "C" fn Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation_destroy (ffi : * mut Vec_dpp_state_transition_state_transitions_identity_public_key_in_creation_IdentityPublicKeyInCreation) { ferment :: unbox_any (ffi) ; } # [cfg (any (any (feature = "json-schema-validation")))] # [repr (C)] # [derive (Clone)] # [cfg (any (any (feature = "json-schema-validation")))] pub struct serde_json_Map_String_serde_json_Value { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut example_nested :: serde_json_Value } # [cfg (any (any (feature = "json-schema-validation")))] # [cfg (any (any (feature = "json-schema-validation")))] impl ferment :: FFIConversionFrom < serde_json :: Map < String , serde_json :: Value > > for serde_json_Map_String_serde_json_Value { unsafe fn ffi_from_const (ffi : * const serde_json_Map_String_serde_json_Value) -> serde_json :: Map < String , serde_json :: Value > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < example_nested :: serde_json_Value as ferment :: FFIConversionFrom < serde_json :: Value >> :: ffi_from (o)) } } # [cfg (any (any (feature = "json-schema-validation")))] # [cfg (any (any (feature = "json-schema-validation")))] impl ferment :: FFIConversionTo < serde_json :: Map < String , serde_json :: Value > > for serde_json_Map_String_serde_json_Value { unsafe fn ffi_to_const (obj : serde_json :: Map < String , serde_json :: Value >) -> * const serde_json_Map_String_serde_json_Value { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } # [cfg (any (any (feature = "json-schema-validation")))] # [cfg (any (any (feature = "json-schema-validation")))] impl Drop for serde_json_Map_String_serde_json_Value { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [cfg (any (any (feature = "json-schema-validation")))] # [no_mangle] pub unsafe extern "C" fn serde_json_Map_String_serde_json_Value_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut example_nested :: serde_json_Value) -> * mut serde_json_Map_String_serde_json_Value { ferment :: boxed (serde_json_Map_String_serde_json_Value { count , keys , values }) } # [cfg (any (any (feature = "json-schema-validation")))] # [no_mangle] pub unsafe extern "C" fn serde_json_Map_String_serde_json_Value_destroy (ffi : * mut serde_json_Map_String_serde_json_Value) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 } impl < 'a > ferment :: FFIConversionFrom < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl < 'a > ferment :: FFIConversionTo < Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) > > for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { unsafe fn ffi_to_const (obj : Vec < (String , example_nested :: ExampleEnumLif < 'a > , [u8 ; 32]) >) -> * const Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) -> * mut Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { ferment :: boxed (Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32_destroy (ffi : * mut Vec_Tuple_String_example_nested_ExampleEnumLif_Arr_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { pub count : usize , pub keys : * mut * mut std :: os :: raw :: c_char , pub values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch as ferment :: FFIConversionFrom < dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch > > for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < String , dpp :: data_contract :: document_type :: index :: ContestedIndexFieldMatch >) -> * const std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . keys , self . count , ferment :: unbox_string) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_ctor (count : usize , keys : * mut * mut std :: os :: raw :: c_char , values : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: document_type :: index :: dpp_data_contract_document_type_index_ContestedIndexFieldMatch) -> * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { ferment :: boxed (std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch_destroy (ffi : * mut std_collections_Map_keys_String_values_dpp_data_contract_document_type_index_ContestedIndexFieldMatch) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_u32 { pub count : usize , pub keys : * mut u32 , pub values : * mut u32 } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , u32 > > for std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_u32) -> std :: collections :: BTreeMap < u32 , u32 > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | o) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , u32 > > for std_collections_Map_keys_u32_values_u32 { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , u32 >) -> * const std_collections_Map_keys_u32_values_u32 { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_primitive_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_ctor (count : usize , keys : * mut u32 , values : * mut u32) -> * mut std_collections_Map_keys_u32_values_u32 { ferment :: boxed (std_collections_Map_keys_u32_values_u32 { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_u32_destroy (ffi : * mut std_collections_Map_keys_u32_values_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: cell :: RefCell :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: cell :: RefCell < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner ()) }) } } impl Drop for std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_cell_RefCell_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_HashSet_Option_String { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: collections :: HashSet < Option < String > > > for std_collections_HashSet_Option_String { unsafe fn ffi_from_const (ffi : * const std_collections_HashSet_Option_String) -> std :: collections :: HashSet < Option < String > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < std :: collections :: HashSet < Option < String > > > for std_collections_HashSet_Option_String { unsafe fn ffi_to_const (obj : std :: collections :: HashSet < Option < String > >) -> * const std_collections_HashSet_Option_String { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for std_collections_HashSet_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut std_collections_HashSet_Option_String { ferment :: boxed (std_collections_HashSet_Option_String { count , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_HashSet_Option_String_destroy (ffi : * mut std_collections_HashSet_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { pub ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , pub error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError } impl ferment :: FFIConversionFrom < Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_from_const (ffi : * const Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) -> Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from_opt (o) , ffi_ref . error , | o | < crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError as ferment :: FFIConversionFrom < example_simple :: errors :: protocol_error :: ProtocolError >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError > > for Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { unsafe fn ffi_to_const (obj : Result < Option < example_nested :: model :: snapshot :: LLMQSnapshot > , example_simple :: errors :: protocol_error :: ProtocolError >) -> * const Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to_opt (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_ctor (ok : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot , error : * mut crate :: fermented :: types :: example_simple :: errors :: protocol_error :: example_simple_errors_protocol_error_ProtocolError) -> * mut Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ferment :: boxed (Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError_destroy (ffi : * mut Result_ok_Option_example_nested_model_snapshot_LLMQSnapshot_err_example_simple_errors_protocol_error_ProtocolError) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_Vec_u8 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < Vec < Option < Vec < u8 > > > > for Vec_Option_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_Option_Vec_u8) -> Vec < Option < Vec < u8 > > > { let ffi_ref = & * ffi ; ferment :: from_opt_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Option < Vec < u8 > > > > for Vec_Option_Vec_u8 { unsafe fn ffi_to_const (obj : Vec < Option < Vec < u8 > > >) -> * const Vec_Option_Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_Option_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Vec_u8) -> * mut Vec_Option_Vec_u8 { ferment :: boxed (Vec_Option_Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_Vec_u8_destroy (ffi : * mut Vec_Option_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_96 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_from_const (ffi : * const Arr_u8_96) -> [u8 ; 96] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 96] > for Arr_u8_96 { unsafe fn ffi_to_const (obj : [u8 ; 96]) -> * const Arr_u8_96 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_96 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_96 { ferment :: boxed (Arr_u8_96 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_96_destroy (ffi : * mut Arr_u8_96) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj) . map (Box :: new)) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < Option < Box < example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_Mutex_Option_Box_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_Option_u32 { pub count : usize , pub values : * mut * mut u32 } impl ferment :: FFIConversionFrom < Vec < Option < u32 > > > for Vec_Option_u32 { unsafe fn ffi_from_const (ffi : * const Vec_Option_u32) -> Vec < Option < u32 > > { let ffi_ref = & * ffi ; ferment :: from_opt_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < Option < u32 > > > for Vec_Option_u32 { unsafe fn ffi_to_const (obj : Vec < Option < u32 > >) -> * const Vec_Option_u32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_opt_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_Option_u32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_ctor (count : usize , values : * mut * mut u32) -> * mut Vec_Option_u32 { ferment :: boxed (Vec_Option_u32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_Option_u32_destroy (ffi : * mut Vec_Option_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot) -> std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; std :: sync :: RwLock :: new (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot > > for std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: sync :: RwLock < example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to (obj . into_inner () . expect ("Err")) }) } } impl Drop for std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_sync_RwLock_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_String_32 { pub count : usize , pub values : * mut * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < [String ; 32] > for Arr_String_32 { unsafe fn ffi_from_const (ffi : * const Arr_String_32) -> [String ; 32] { let ffi_ref = & * ffi ; let vec : Vec < String > = ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [String ; 32] > for Arr_String_32 { unsafe fn ffi_to_const (obj : [String ; 32]) -> * const Arr_String_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Arr_String_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr_composer (self . values , self . count , ferment :: unbox_string) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_ctor (count : usize , values : * mut * mut std :: os :: raw :: c_char) -> * mut Arr_String_32 { ferment :: boxed (Arr_String_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_String_32_destroy (ffi : * mut Arr_String_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_sync_Mutex_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: sync :: Mutex < u32 > > for std_sync_Mutex_u32 { unsafe fn ffi_from_const (ffi : * const std_sync_Mutex_u32) -> std :: sync :: Mutex < u32 > { let ffi_ref = & * ffi ; std :: sync :: Mutex :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: sync :: Mutex < u32 > > for std_sync_Mutex_u32 { unsafe fn ffi_to_const (obj : std :: sync :: Mutex < u32 >) -> * const std_sync_Mutex_u32 { ferment :: boxed (Self { obj : obj . into_inner () . expect ("Err") }) } } impl Drop for std_sync_Mutex_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_ctor (obj : u32) -> * mut std_sync_Mutex_u32 { ferment :: boxed (std_sync_Mutex_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_sync_Mutex_u32_destroy (ffi : * mut std_sync_Mutex_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_u32 { pub obj : u32 } impl ferment :: FFIConversionFrom < std :: rc :: Rc < u32 > > for std_rc_Rc_u32 { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_u32) -> std :: rc :: Rc < u32 > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ffi_ref . obj) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < u32 > > for std_rc_Rc_u32 { unsafe fn ffi_to_const (obj : std :: rc :: Rc < u32 >) -> * const std_rc_Rc_u32 { ferment :: boxed (Self { obj : * obj }) } } impl Drop for std_rc_Rc_u32 { fn drop (& mut self) { unsafe { ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_u32_ctor (obj : u32) -> * mut std_rc_Rc_u32 { ferment :: boxed (std_rc_Rc_u32 { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_u32_destroy (ffi : * mut std_rc_Rc_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Slice_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Slice_u8 { unsafe fn ffi_from_const (ffi : * const Slice_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Slice_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Slice_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Slice_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Slice_u8_ctor (count : usize , values : * mut u8) -> * mut Slice_u8 { ferment :: boxed (Slice_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Slice_u8_destroy (ffi : * mut Slice_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , pub values : * mut * mut example_nested :: custom :: dpp :: TokenConfigurationFFI } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration) -> std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition as ferment :: FFIConversionFrom < dpp :: data_contract :: TokenContractPosition >> :: ffi_from (o) , | o | < example_nested :: custom :: dpp :: TokenConfigurationFFI as ferment :: FFIConversionFrom < dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration > > for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: data_contract :: TokenContractPosition , dpp :: data_contract :: associated_token :: token_configuration :: TokenConfiguration >) -> * const std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: data_contract :: dpp_data_contract_TokenContractPosition , values : * mut * mut example_nested :: custom :: dpp :: TokenConfigurationFFI) -> * mut std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { ferment :: boxed (std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration_destroy (ffi : * mut std_collections_Map_keys_dpp_data_contract_TokenContractPosition_values_dpp_data_contract_associated_token_token_configuration_TokenConfiguration) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_dpp_identity_identity_public_key_KeyID { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID } impl ferment :: FFIConversionFrom < Vec < dpp :: identity :: identity_public_key :: KeyID > > for Vec_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_from_const (ffi : * const Vec_dpp_identity_identity_public_key_KeyID) -> Vec < dpp :: identity :: identity_public_key :: KeyID > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < dpp :: identity :: identity_public_key :: KeyID > > for Vec_dpp_identity_identity_public_key_KeyID { unsafe fn ffi_to_const (obj : Vec < dpp :: identity :: identity_public_key :: KeyID >) -> * const Vec_dpp_identity_identity_public_key_KeyID { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_dpp_identity_identity_public_key_KeyID { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_KeyID_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID) -> * mut Vec_dpp_identity_identity_public_key_KeyID { ferment :: boxed (Vec_dpp_identity_identity_public_key_KeyID { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_dpp_identity_identity_public_key_KeyID_destroy (ffi : * mut Vec_dpp_identity_identity_public_key_KeyID) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Option_String { pub obj : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Option < String > > > for std_rc_Rc_Option_String { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Option_String) -> std :: rc :: Rc < Option < String > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Option < String > > > for std_rc_Rc_Option_String { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Option < String > >) -> * const std_rc_Rc_Option_String { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Option_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_String_ctor (obj : * mut std :: os :: raw :: c_char) -> * mut std_rc_Rc_Option_String { ferment :: boxed (std_rc_Rc_Option_String { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_String_destroy (ffi : * mut std_rc_Rc_Option_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Result_ok_String_err_String { pub ok : * mut std :: os :: raw :: c_char , pub error : * mut std :: os :: raw :: c_char } impl ferment :: FFIConversionFrom < Result < String , String > > for Result_ok_String_err_String { unsafe fn ffi_from_const (ffi : * const Result_ok_String_err_String) -> Result < String , String > { let ffi_ref = & * ffi ; ferment :: fold_to_result (ffi_ref . ok , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o) , ffi_ref . error , | o | < std :: os :: raw :: c_char as ferment :: FFIConversionFrom < String >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < Result < String , String > > for Result_ok_String_err_String { unsafe fn ffi_to_const (obj : Result < String , String >) -> * const Result_ok_String_err_String { ferment :: boxed ({ let (ok , error) = ferment :: to_result (obj , | o | ferment :: FFIConversionTo :: ffi_to (o) , | o | ferment :: FFIConversionTo :: ffi_to (o)) ; Self { ok , error } }) } } impl Drop for Result_ok_String_err_String { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . ok) ; ferment :: unbox_any_opt (self . error) ; } } } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_ctor (ok : * mut std :: os :: raw :: c_char , error : * mut std :: os :: raw :: c_char) -> * mut Result_ok_String_err_String { ferment :: boxed (Result_ok_String_err_String { ok , error }) } # [no_mangle] pub unsafe extern "C" fn Result_ok_String_err_String_destroy (ffi : * mut Result_ok_String_err_String) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { pub o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex , pub o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex , pub o_2 : * mut crate :: fermented :: generics :: Vec_u8 } impl ferment :: FFIConversionFrom < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_from_const (ffi : * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) -> (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) { let ffi_ref = & * ffi ; (ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_0) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_1) , ferment :: FFIConversionFrom :: ffi_from (ffi_ref . o_2)) } } impl ferment :: FFIConversionTo < (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,) > for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { unsafe fn ffi_to_const (obj : (dpp :: prelude :: RootEncryptionKeyIndex , dpp :: prelude :: DerivationEncryptionKeyIndex , Vec < u8 > ,)) -> * const Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { ferment :: boxed (Self { o_0 : ferment :: FFIConversionTo :: ffi_to (obj . 0) , o_1 : ferment :: FFIConversionTo :: ffi_to (obj . 1) , o_2 : ferment :: FFIConversionTo :: ffi_to (obj . 2) }) } } impl Drop for Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_any (self . o_0) ; ferment :: unbox_any (self . o_1) ; ferment :: unbox_any (self . o_2) ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8_ctor (o_0 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_RootEncryptionKeyIndex , o_1 : * mut crate :: fermented :: types :: dpp :: prelude :: dpp_prelude_DerivationEncryptionKeyIndex , o_2 : * mut crate :: fermented :: generics :: Vec_u8) -> * mut Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { ferment :: boxed (Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8 { o_0 , o_1 , o_2 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8_destroy (ffi : * mut Tuple_dpp_prelude_RootEncryptionKeyIndex_dpp_prelude_DerivationEncryptionKeyIndex_Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Arr_u8_48 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_from_const (ffi : * const Arr_u8_48) -> [u8 ; 48] { let ffi_ref = & * ffi ; let vec : Vec < u8 > = ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) ; vec . try_into () . unwrap () } } impl ferment :: FFIConversionTo < [u8 ; 48] > for Arr_u8_48 { unsafe fn ffi_to_const (obj : [u8 ; 48]) -> * const Arr_u8_48 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Arr_u8_48 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_ctor (count : usize , values : * mut u8) -> * mut Arr_u8_48 { ferment :: boxed (Arr_u8_48 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Arr_u8_48_destroy (ffi : * mut Arr_u8_48) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8_32 { pub count : usize , pub values : * mut * mut crate :: fermented :: generics :: Arr_u8_32 } impl ferment :: FFIConversionFrom < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_from_const (ffi : * const Vec_u8_32) -> Vec < [u8 ; 32] > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < [u8 ; 32] > > for Vec_u8_32 { unsafe fn ffi_to_const (obj : Vec < [u8 ; 32] >) -> * const Vec_u8_32 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_u8_32 { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_ctor (count : usize , values : * mut * mut crate :: fermented :: generics :: Arr_u8_32) -> * mut Vec_u8_32 { ferment :: boxed (Vec_u8_32 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_32_destroy (ffi : * mut Vec_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode } impl ferment :: FFIConversionFrom < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > > for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_from_const (ffi : * const Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) -> Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > { let ffi_ref = & * ffi ; ferment :: from_complex_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode > > for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { unsafe fn ffi_to_const (obj : Vec < example_nested :: model :: snapshot :: LLMQSnapshotSkipMode >) -> * const Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_complex_group (obj . into_iter ()) }) } } impl Drop for Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_ctor (count : usize , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshotSkipMode) -> * mut Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { ferment :: boxed (Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode_destroy (ffi : * mut Vec_example_nested_model_snapshot_LLMQSnapshotSkipMode) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Tuple_u32_u32 { pub o_0 : u32 , pub o_1 : u32 } impl ferment :: FFIConversionFrom < (u32 , u32) > for Tuple_u32_u32 { unsafe fn ffi_from_const (ffi : * const Tuple_u32_u32) -> (u32 , u32) { let ffi_ref = & * ffi ; (ffi_ref . o_0 , ffi_ref . o_1) } } impl ferment :: FFIConversionTo < (u32 , u32) > for Tuple_u32_u32 { unsafe fn ffi_to_const (obj : (u32 , u32)) -> * const Tuple_u32_u32 { ferment :: boxed (Self { o_0 : obj . 0 , o_1 : obj . 1 }) } } impl Drop for Tuple_u32_u32 { fn drop (& mut self) { unsafe { ; ; } } } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_u32_ctor (o_0 : u32 , o_1 : u32) -> * mut Tuple_u32_u32 { ferment :: boxed (Tuple_u32_u32 { o_0 , o_1 }) } # [no_mangle] pub unsafe extern "C" fn Tuple_u32_u32_destroy (ffi : * mut Tuple_u32_u32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , pub values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType as ferment :: FFIConversionFrom < dashcore :: sml :: llmq_type :: LLMQType >> :: ffi_from (o) , | o | < crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry as ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > > > for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dashcore :: sml :: llmq_type :: LLMQType , std :: collections :: BTreeMap < dashcore :: hash_types :: QuorumHash , dashcore :: sml :: quorum_entry :: qualified_quorum_entry :: QualifiedQuorumEntry > >) -> * const std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dashcore :: sml :: llmq_type :: dashcore_sml_llmq_type_LLMQType , values : * mut * mut crate :: fermented :: generics :: std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) -> * mut std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { ferment :: boxed (std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry_destroy (ffi : * mut std_collections_Map_keys_dashcore_sml_llmq_type_LLMQType_values_std_collections_Map_keys_dashcore_hash_types_QuorumHash_values_dashcore_sml_quorum_entry_qualified_quorum_entry_QualifiedQuorumEntry) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Vec_u8 { pub count : usize , pub values : * mut u8 } impl ferment :: FFIConversionFrom < Vec < u8 > > for Vec_u8 { unsafe fn ffi_from_const (ffi : * const Vec_u8) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment :: from_primitive_group (ffi_ref . values , ffi_ref . count) } } impl ferment :: FFIConversionTo < Vec < u8 > > for Vec_u8 { unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8 { ferment :: boxed (Self { count : obj . len () , values : ferment :: to_primitive_group (obj . into_iter ()) }) } } impl Drop for Vec_u8 { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn Vec_u8_ctor (count : usize , values : * mut u8) -> * mut Vec_u8 { ferment :: boxed (Vec_u8 { count , values }) } # [no_mangle] pub unsafe extern "C" fn Vec_u8_destroy (ffi : * mut Vec_u8) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > { let ffi_ref = & * ffi ; std :: rc :: Rc :: new (ferment :: FFIConversionFrom :: ffi_from_opt (ffi_ref . obj)) } } impl ferment :: FFIConversionTo < std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > > > for std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: rc :: Rc < Option < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > >) -> * const std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { obj : ferment :: FFIConversionTo :: ffi_to_opt ((* obj) . clone ()) }) } } impl Drop for std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_any_opt (self . obj) ; } } } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (obj : * mut crate :: fermented :: generics :: std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> * mut std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { obj }) } # [no_mangle] pub unsafe extern "C" fn std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_rc_Rc_Option_std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct Fn_ARGS_u32_RTRN_Option_u8_32 { caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32) } impl Fn_ARGS_u32_RTRN_Option_u8_32 { pub unsafe fn call (& self , o_0 : u32) -> Option < [u8 ; 32] > { let ffi_result = (self . caller) (o_0) ; let result = < crate :: fermented :: generics :: Arr_u8_32 as ferment :: FFIConversionFrom < [u8 ; 32] >> :: ffi_from_opt (ffi_result) ; (self . destructor) (ffi_result) ; result } } unsafe impl Send for Fn_ARGS_u32_RTRN_Option_u8_32 { } unsafe impl Sync for Fn_ARGS_u32_RTRN_Option_u8_32 { } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_u8_32_ctor (caller : unsafe extern "C" fn (u32) -> * mut crate :: fermented :: generics :: Arr_u8_32 , destructor : unsafe extern "C" fn (* mut crate :: fermented :: generics :: Arr_u8_32)) -> * mut Fn_ARGS_u32_RTRN_Option_u8_32 { ferment :: boxed (Fn_ARGS_u32_RTRN_Option_u8_32 { caller , destructor }) } # [no_mangle] pub unsafe extern "C" fn Fn_ARGS_u32_RTRN_Option_u8_32_destroy (ffi : * mut Fn_ARGS_u32_RTRN_Option_u8_32) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { pub count : usize , pub keys : * mut u32 , pub values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > for std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) -> std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | o , | o | < crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot as ferment :: FFIConversionFrom < example_nested :: model :: snapshot :: LLMQSnapshot >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot > > for std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < u32 , example_nested :: model :: snapshot :: LLMQSnapshot >) -> * const std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_primitive_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { fn drop (& mut self) { unsafe { ferment :: unbox_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_ctor (count : usize , keys : * mut u32 , values : * mut * mut crate :: fermented :: types :: example_nested :: model :: snapshot :: example_nested_model_snapshot_LLMQSnapshot) -> * mut std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { ferment :: boxed (std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot_destroy (ffi : * mut std_collections_Map_keys_u32_values_example_nested_model_snapshot_LLMQSnapshot) { ferment :: unbox_any (ffi) ; } # [repr (C)] # [derive (Clone)] pub struct std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , pub values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey } impl ferment :: FFIConversionFrom < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > > for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey) -> std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > { let ffi_ref = & * ffi ; ferment :: fold_to_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: KeyID >> :: ffi_from (o) , | o | < crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey as ferment :: FFIConversionFrom < dpp :: identity :: identity_public_key :: IdentityPublicKey >> :: ffi_from (o)) } } impl ferment :: FFIConversionTo < std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey > > for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < dpp :: identity :: identity_public_key :: KeyID , dpp :: identity :: identity_public_key :: IdentityPublicKey >) -> * const std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (Self { count : obj . len () , keys : ferment :: to_complex_group (obj . keys () . cloned ()) , values : ferment :: to_complex_group (obj . values () . cloned ()) }) } } impl Drop for std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { fn drop (& mut self) { unsafe { ferment :: unbox_any_vec_ptr (self . keys , self . count) ; ferment :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey_ctor (count : usize , keys : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_KeyID , values : * mut * mut crate :: fermented :: types :: dpp :: identity :: identity_public_key :: dpp_identity_identity_public_key_IdentityPublicKey) -> * mut std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { ferment :: boxed (std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey { count , keys , values }) } # [no_mangle] pub unsafe extern "C" fn std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey_destroy (ffi : * mut std_collections_Map_keys_dpp_identity_identity_public_key_KeyID_values_dpp_identity_identity_public_key_IdentityPublicKey) { ferment :: unbox_any (ffi) ; } }